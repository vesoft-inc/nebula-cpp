/**
 * Autogenerated by Thrift for common.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "common_types.h"
#include "common_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "common_data.h"


namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::cpp2::NullType>::size;
folly::Range<::nebula::cpp2::NullType const*> const TEnumTraits<::nebula::cpp2::NullType>::values = folly::range(TEnumDataStorage<::nebula::cpp2::NullType>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::cpp2::NullType>::names = folly::range(TEnumDataStorage<::nebula::cpp2::NullType>::names);

char const* TEnumTraits<::nebula::cpp2::NullType>::findName(type value) {
  using factory = ::nebula::cpp2::_NullType_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::cpp2::NullType>::findValue(char const* name, type* out) {
  using factory = ::nebula::cpp2::_NullType_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _NullType_EnumMapFactory::ValuesToNamesMapType _NullType_VALUES_TO_NAMES = _NullType_EnumMapFactory::makeValuesToNamesMap();
const _NullType_EnumMapFactory::NamesToValuesMapType _NullType_NAMES_TO_VALUES = _NullType_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // nebula::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::cpp2::PropertyType>::size;
folly::Range<::nebula::cpp2::PropertyType const*> const TEnumTraits<::nebula::cpp2::PropertyType>::values = folly::range(TEnumDataStorage<::nebula::cpp2::PropertyType>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::cpp2::PropertyType>::names = folly::range(TEnumDataStorage<::nebula::cpp2::PropertyType>::names);

char const* TEnumTraits<::nebula::cpp2::PropertyType>::findName(type value) {
  using factory = ::nebula::cpp2::_PropertyType_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::cpp2::PropertyType>::findValue(char const* name, type* out) {
  using factory = ::nebula::cpp2::_PropertyType_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _PropertyType_EnumMapFactory::ValuesToNamesMapType _PropertyType_VALUES_TO_NAMES = _PropertyType_EnumMapFactory::makeValuesToNamesMap();
const _PropertyType_EnumMapFactory::NamesToValuesMapType _PropertyType_NAMES_TO_VALUES = _PropertyType_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // nebula::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::cpp2::ErrorCode>::size;
folly::Range<::nebula::cpp2::ErrorCode const*> const TEnumTraits<::nebula::cpp2::ErrorCode>::values = folly::range(TEnumDataStorage<::nebula::cpp2::ErrorCode>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::cpp2::ErrorCode>::names = folly::range(TEnumDataStorage<::nebula::cpp2::ErrorCode>::names);

char const* TEnumTraits<::nebula::cpp2::ErrorCode>::findName(type value) {
  using factory = ::nebula::cpp2::_ErrorCode_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::cpp2::ErrorCode>::findValue(char const* name, type* out) {
  using factory = ::nebula::cpp2::_ErrorCode_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _ErrorCode_EnumMapFactory::ValuesToNamesMapType _ErrorCode_VALUES_TO_NAMES = _ErrorCode_EnumMapFactory::makeValuesToNamesMap();
const _ErrorCode_EnumMapFactory::NamesToValuesMapType _ErrorCode_NAMES_TO_VALUES = _ErrorCode_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::SchemaID>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::SchemaID>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::cpp2::SchemaID::Type>::size;
folly::Range<::nebula::cpp2::SchemaID::Type const*> const TEnumTraits<::nebula::cpp2::SchemaID::Type>::values = folly::range(TEnumDataStorage<::nebula::cpp2::SchemaID::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::cpp2::SchemaID::Type>::names = folly::range(TEnumDataStorage<::nebula::cpp2::SchemaID::Type>::names);

char const* TEnumTraits<::nebula::cpp2::SchemaID::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::nebula::cpp2::SchemaID::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::cpp2::SchemaID::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::nebula::cpp2::SchemaID::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace nebula { namespace cpp2 {

void SchemaID::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::tag_id:
      destruct(value_.tag_id);
      break;
    case Type::edge_type:
      destruct(value_.edge_type);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool SchemaID::operator==(const SchemaID& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::tag_id:
      return value_.tag_id == rhs.value_.tag_id;
    case Type::edge_type:
      return value_.edge_type == rhs.value_.edge_type;
    default:
      return true;
  }
}

bool SchemaID::operator<(const SchemaID& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::tag_id:
      return lhs.value_.tag_id < rhs.value_.tag_id;
    case Type::edge_type:
      return lhs.value_.edge_type < rhs.value_.edge_type;
    default:
      return false;
  }
}

void swap(SchemaID& a, SchemaID& b) {
  SchemaID temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void SchemaID::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t SchemaID::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t SchemaID::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t SchemaID::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void SchemaID::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t SchemaID::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t SchemaID::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t SchemaID::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::Date>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::Date>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Date::Date(apache::thrift::FragileConstructor, int16_t year__arg, int8_t month__arg, int8_t day__arg) :
    year(std::move(year__arg)),
    month(std::move(month__arg)),
    day(std::move(day__arg)) {
  __isset.year = true;
  __isset.month = true;
  __isset.day = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Date::__clear() {
  // clear all fields
  year = 0;
  month = 0;
  day = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool Date::operator==(const Date& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.year == rhs.year)) {
    return false;
  }
  if (!(lhs.month == rhs.month)) {
    return false;
  }
  if (!(lhs.day == rhs.day)) {
    return false;
  }
  return true;
}

bool Date::operator<(const Date& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.year == rhs.year)) {
    return lhs.year < rhs.year;
  }
  if (!(lhs.month == rhs.month)) {
    return lhs.month < rhs.month;
  }
  if (!(lhs.day == rhs.day)) {
    return lhs.day < rhs.day;
  }
  return false;
}


void swap(Date& a, Date& b) {
  using ::std::swap;
  swap(a.year_ref().value(), b.year_ref().value());
  swap(a.month_ref().value(), b.month_ref().value());
  swap(a.day_ref().value(), b.day_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void Date::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Date::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Date::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Date::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Date::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Date::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Date::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Date::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::Time>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::Time>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Time::Time(apache::thrift::FragileConstructor, int8_t hour__arg, int8_t minute__arg, int8_t sec__arg, int32_t microsec__arg) :
    hour(std::move(hour__arg)),
    minute(std::move(minute__arg)),
    sec(std::move(sec__arg)),
    microsec(std::move(microsec__arg)) {
  __isset.hour = true;
  __isset.minute = true;
  __isset.sec = true;
  __isset.microsec = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Time::__clear() {
  // clear all fields
  hour = 0;
  minute = 0;
  sec = 0;
  microsec = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool Time::operator==(const Time& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.hour == rhs.hour)) {
    return false;
  }
  if (!(lhs.minute == rhs.minute)) {
    return false;
  }
  if (!(lhs.sec == rhs.sec)) {
    return false;
  }
  if (!(lhs.microsec == rhs.microsec)) {
    return false;
  }
  return true;
}

bool Time::operator<(const Time& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.hour == rhs.hour)) {
    return lhs.hour < rhs.hour;
  }
  if (!(lhs.minute == rhs.minute)) {
    return lhs.minute < rhs.minute;
  }
  if (!(lhs.sec == rhs.sec)) {
    return lhs.sec < rhs.sec;
  }
  if (!(lhs.microsec == rhs.microsec)) {
    return lhs.microsec < rhs.microsec;
  }
  return false;
}


void swap(Time& a, Time& b) {
  using ::std::swap;
  swap(a.hour_ref().value(), b.hour_ref().value());
  swap(a.minute_ref().value(), b.minute_ref().value());
  swap(a.sec_ref().value(), b.sec_ref().value());
  swap(a.microsec_ref().value(), b.microsec_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void Time::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Time::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Time::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Time::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Time::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Time::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Time::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Time::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::DateTime>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::DateTime>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DateTime::DateTime(apache::thrift::FragileConstructor, int16_t year__arg, int8_t month__arg, int8_t day__arg, int8_t hour__arg, int8_t minute__arg, int8_t sec__arg, int32_t microsec__arg) :
    year(std::move(year__arg)),
    month(std::move(month__arg)),
    day(std::move(day__arg)),
    hour(std::move(hour__arg)),
    minute(std::move(minute__arg)),
    sec(std::move(sec__arg)),
    microsec(std::move(microsec__arg)) {
  __isset.year = true;
  __isset.month = true;
  __isset.day = true;
  __isset.hour = true;
  __isset.minute = true;
  __isset.sec = true;
  __isset.microsec = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void DateTime::__clear() {
  // clear all fields
  year = 0;
  month = 0;
  day = 0;
  hour = 0;
  minute = 0;
  sec = 0;
  microsec = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DateTime::operator==(const DateTime& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.year == rhs.year)) {
    return false;
  }
  if (!(lhs.month == rhs.month)) {
    return false;
  }
  if (!(lhs.day == rhs.day)) {
    return false;
  }
  if (!(lhs.hour == rhs.hour)) {
    return false;
  }
  if (!(lhs.minute == rhs.minute)) {
    return false;
  }
  if (!(lhs.sec == rhs.sec)) {
    return false;
  }
  if (!(lhs.microsec == rhs.microsec)) {
    return false;
  }
  return true;
}

bool DateTime::operator<(const DateTime& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.year == rhs.year)) {
    return lhs.year < rhs.year;
  }
  if (!(lhs.month == rhs.month)) {
    return lhs.month < rhs.month;
  }
  if (!(lhs.day == rhs.day)) {
    return lhs.day < rhs.day;
  }
  if (!(lhs.hour == rhs.hour)) {
    return lhs.hour < rhs.hour;
  }
  if (!(lhs.minute == rhs.minute)) {
    return lhs.minute < rhs.minute;
  }
  if (!(lhs.sec == rhs.sec)) {
    return lhs.sec < rhs.sec;
  }
  if (!(lhs.microsec == rhs.microsec)) {
    return lhs.microsec < rhs.microsec;
  }
  return false;
}


void swap(DateTime& a, DateTime& b) {
  using ::std::swap;
  swap(a.year_ref().value(), b.year_ref().value());
  swap(a.month_ref().value(), b.month_ref().value());
  swap(a.day_ref().value(), b.day_ref().value());
  swap(a.hour_ref().value(), b.hour_ref().value());
  swap(a.minute_ref().value(), b.minute_ref().value());
  swap(a.sec_ref().value(), b.sec_ref().value());
  swap(a.microsec_ref().value(), b.microsec_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DateTime::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DateTime::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DateTime::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DateTime::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DateTime::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DateTime::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DateTime::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DateTime::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::Value>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::Value>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::cpp2::Value::Type>::size;
folly::Range<::nebula::cpp2::Value::Type const*> const TEnumTraits<::nebula::cpp2::Value::Type>::values = folly::range(TEnumDataStorage<::nebula::cpp2::Value::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::cpp2::Value::Type>::names = folly::range(TEnumDataStorage<::nebula::cpp2::Value::Type>::names);

char const* TEnumTraits<::nebula::cpp2::Value::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::nebula::cpp2::Value::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::cpp2::Value::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::nebula::cpp2::Value::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace nebula { namespace cpp2 {

void Value::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::nVal:
      destruct(value_.nVal);
      break;
    case Type::bVal:
      destruct(value_.bVal);
      break;
    case Type::iVal:
      destruct(value_.iVal);
      break;
    case Type::fVal:
      destruct(value_.fVal);
      break;
    case Type::sVal:
      destruct(value_.sVal);
      break;
    case Type::dVal:
      destruct(value_.dVal);
      break;
    case Type::tVal:
      destruct(value_.tVal);
      break;
    case Type::dtVal:
      destruct(value_.dtVal);
      break;
    case Type::vVal:
      destruct(value_.vVal);
      break;
    case Type::eVal:
      destruct(value_.eVal);
      break;
    case Type::pVal:
      destruct(value_.pVal);
      break;
    case Type::lVal:
      destruct(value_.lVal);
      break;
    case Type::mVal:
      destruct(value_.mVal);
      break;
    case Type::uVal:
      destruct(value_.uVal);
      break;
    case Type::gVal:
      destruct(value_.gVal);
      break;
    case Type::ggVal:
      destruct(value_.ggVal);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool Value::operator==(const Value& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::nVal:
      return value_.nVal == rhs.value_.nVal;
    case Type::bVal:
      return value_.bVal == rhs.value_.bVal;
    case Type::iVal:
      return value_.iVal == rhs.value_.iVal;
    case Type::fVal:
      return value_.fVal == rhs.value_.fVal;
    case Type::sVal:
      return apache::thrift::StringTraits<std::string>::isEqual(
          value_.sVal,
          rhs.value_.sVal);
    case Type::dVal:
      return value_.dVal == rhs.value_.dVal;
    case Type::tVal:
      return value_.tVal == rhs.value_.tVal;
    case Type::dtVal:
      return value_.dtVal == rhs.value_.dtVal;
    case Type::vVal:
      return *value_.vVal == *rhs.value_.vVal;
    case Type::eVal:
      return *value_.eVal == *rhs.value_.eVal;
    case Type::pVal:
      return *value_.pVal == *rhs.value_.pVal;
    case Type::lVal:
      return *value_.lVal == *rhs.value_.lVal;
    case Type::mVal:
      return *value_.mVal == *rhs.value_.mVal;
    case Type::uVal:
      return *value_.uVal == *rhs.value_.uVal;
    case Type::gVal:
      return *value_.gVal == *rhs.value_.gVal;
    case Type::ggVal:
      return *value_.ggVal == *rhs.value_.ggVal;
    default:
      return true;
  }
}

std::unique_ptr<nebula::Vertex>& Value::set_vVal(nebula::Vertex const &t) {
  __clear();
  type_ = Type::vVal;
  ::new (std::addressof(value_.vVal)) std::unique_ptr<nebula::Vertex>(new std::unique_ptr<nebula::Vertex>::element_type(t));
  return value_.vVal;
}

std::unique_ptr<nebula::Vertex>& Value::set_vVal(nebula::Vertex&& t) {
  __clear();
  type_ = Type::vVal;
  ::new (std::addressof(value_.vVal)) std::unique_ptr<nebula::Vertex>(new std::unique_ptr<nebula::Vertex>::element_type(std::move(t)));
  return value_.vVal;
}

std::unique_ptr<nebula::Edge>& Value::set_eVal(nebula::Edge const &t) {
  __clear();
  type_ = Type::eVal;
  ::new (std::addressof(value_.eVal)) std::unique_ptr<nebula::Edge>(new std::unique_ptr<nebula::Edge>::element_type(t));
  return value_.eVal;
}

std::unique_ptr<nebula::Edge>& Value::set_eVal(nebula::Edge&& t) {
  __clear();
  type_ = Type::eVal;
  ::new (std::addressof(value_.eVal)) std::unique_ptr<nebula::Edge>(new std::unique_ptr<nebula::Edge>::element_type(std::move(t)));
  return value_.eVal;
}

std::unique_ptr<nebula::Path>& Value::set_pVal(nebula::Path const &t) {
  __clear();
  type_ = Type::pVal;
  ::new (std::addressof(value_.pVal)) std::unique_ptr<nebula::Path>(new std::unique_ptr<nebula::Path>::element_type(t));
  return value_.pVal;
}

std::unique_ptr<nebula::Path>& Value::set_pVal(nebula::Path&& t) {
  __clear();
  type_ = Type::pVal;
  ::new (std::addressof(value_.pVal)) std::unique_ptr<nebula::Path>(new std::unique_ptr<nebula::Path>::element_type(std::move(t)));
  return value_.pVal;
}

std::unique_ptr<nebula::List>& Value::set_lVal(nebula::List const &t) {
  __clear();
  type_ = Type::lVal;
  ::new (std::addressof(value_.lVal)) std::unique_ptr<nebula::List>(new std::unique_ptr<nebula::List>::element_type(t));
  return value_.lVal;
}

std::unique_ptr<nebula::List>& Value::set_lVal(nebula::List&& t) {
  __clear();
  type_ = Type::lVal;
  ::new (std::addressof(value_.lVal)) std::unique_ptr<nebula::List>(new std::unique_ptr<nebula::List>::element_type(std::move(t)));
  return value_.lVal;
}

std::unique_ptr<nebula::Map>& Value::set_mVal(nebula::Map const &t) {
  __clear();
  type_ = Type::mVal;
  ::new (std::addressof(value_.mVal)) std::unique_ptr<nebula::Map>(new std::unique_ptr<nebula::Map>::element_type(t));
  return value_.mVal;
}

std::unique_ptr<nebula::Map>& Value::set_mVal(nebula::Map&& t) {
  __clear();
  type_ = Type::mVal;
  ::new (std::addressof(value_.mVal)) std::unique_ptr<nebula::Map>(new std::unique_ptr<nebula::Map>::element_type(std::move(t)));
  return value_.mVal;
}

std::unique_ptr<nebula::Set>& Value::set_uVal(nebula::Set const &t) {
  __clear();
  type_ = Type::uVal;
  ::new (std::addressof(value_.uVal)) std::unique_ptr<nebula::Set>(new std::unique_ptr<nebula::Set>::element_type(t));
  return value_.uVal;
}

std::unique_ptr<nebula::Set>& Value::set_uVal(nebula::Set&& t) {
  __clear();
  type_ = Type::uVal;
  ::new (std::addressof(value_.uVal)) std::unique_ptr<nebula::Set>(new std::unique_ptr<nebula::Set>::element_type(std::move(t)));
  return value_.uVal;
}

std::unique_ptr<nebula::DataSet>& Value::set_gVal(nebula::DataSet const &t) {
  __clear();
  type_ = Type::gVal;
  ::new (std::addressof(value_.gVal)) std::unique_ptr<nebula::DataSet>(new std::unique_ptr<nebula::DataSet>::element_type(t));
  return value_.gVal;
}

std::unique_ptr<nebula::DataSet>& Value::set_gVal(nebula::DataSet&& t) {
  __clear();
  type_ = Type::gVal;
  ::new (std::addressof(value_.gVal)) std::unique_ptr<nebula::DataSet>(new std::unique_ptr<nebula::DataSet>::element_type(std::move(t)));
  return value_.gVal;
}

std::unique_ptr<nebula::Geography>& Value::set_ggVal(nebula::Geography const &t) {
  __clear();
  type_ = Type::ggVal;
  ::new (std::addressof(value_.ggVal)) std::unique_ptr<nebula::Geography>(new std::unique_ptr<nebula::Geography>::element_type(t));
  return value_.ggVal;
}

std::unique_ptr<nebula::Geography>& Value::set_ggVal(nebula::Geography&& t) {
  __clear();
  type_ = Type::ggVal;
  ::new (std::addressof(value_.ggVal)) std::unique_ptr<nebula::Geography>(new std::unique_ptr<nebula::Geography>::element_type(std::move(t)));
  return value_.ggVal;
}

void swap(Value& a, Value& b) {
  Value temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void Value::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Value::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Value::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Value::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Value::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Value::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Value::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Value::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::Date>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::Time>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::DateTime>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::Vertex>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::Edge>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::Path>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::List>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::Map>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::Set>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::DataSet>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Value,
        ::apache::thrift::type_class::variant,
        nebula::Geography>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::Date>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::Time>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::DateTime>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::Vertex>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::Edge>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::Path>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::List>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::Map>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::Set>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Value,
        ::apache::thrift::type_class::structure,
        nebula::DataSet>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Value,
        ::apache::thrift::type_class::variant,
        nebula::Geography>,
    "inconsistent use of nimble option");

}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::NList>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::NList>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
NList::NList(apache::thrift::FragileConstructor, ::std::vector<nebula::Value> values__arg) :
    values(std::move(values__arg)) {
  __isset.values = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void NList::__clear() {
  // clear all fields
  values.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool NList::operator==(const NList& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.values == rhs.values)) {
    return false;
  }
  return true;
}

const ::std::vector<nebula::Value>& NList::get_values() const& {
  return values;
}

::std::vector<nebula::Value> NList::get_values() && {
  return std::move(values);
}


void swap(NList& a, NList& b) {
  using ::std::swap;
  swap(a.values_ref().value(), b.values_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void NList::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t NList::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t NList::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t NList::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void NList::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t NList::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t NList::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t NList::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        NList,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>,
        ::std::vector<nebula::Value>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        NList,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>,
        ::std::vector<nebula::Value>>,
    "inconsistent use of nimble option");

}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::NMap>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::NMap>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
NMap::NMap(apache::thrift::FragileConstructor, std::unordered_map<::std::string, nebula::Value> kvs__arg) :
    kvs(std::move(kvs__arg)) {
  __isset.kvs = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void NMap::__clear() {
  // clear all fields
  kvs.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool NMap::operator==(const NMap& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.kvs == rhs.kvs)) {
    return false;
  }
  return true;
}

const std::unordered_map<::std::string, nebula::Value>& NMap::get_kvs() const& {
  return kvs;
}

std::unordered_map<::std::string, nebula::Value> NMap::get_kvs() && {
  return std::move(kvs);
}


void swap(NMap& a, NMap& b) {
  using ::std::swap;
  swap(a.kvs_ref().value(), b.kvs_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void NMap::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t NMap::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t NMap::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t NMap::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void NMap::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t NMap::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t NMap::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t NMap::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        NMap,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::binary, ::apache::thrift::type_class::variant>,
        std::unordered_map<::std::string, nebula::Value>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        NMap,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::binary, ::apache::thrift::type_class::variant>,
        std::unordered_map<::std::string, nebula::Value>>,
    "inconsistent use of nimble option");

}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::NSet>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::NSet>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
NSet::NSet(apache::thrift::FragileConstructor, std::unordered_set<nebula::Value> values__arg) :
    values(std::move(values__arg)) {
  __isset.values = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void NSet::__clear() {
  // clear all fields
  values.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool NSet::operator==(const NSet& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.values == rhs.values)) {
    return false;
  }
  return true;
}

const std::unordered_set<nebula::Value>& NSet::get_values() const& {
  return values;
}

std::unordered_set<nebula::Value> NSet::get_values() && {
  return std::move(values);
}


void swap(NSet& a, NSet& b) {
  using ::std::swap;
  swap(a.values_ref().value(), b.values_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void NSet::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t NSet::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t NSet::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t NSet::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void NSet::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t NSet::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t NSet::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t NSet::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        NSet,
        ::apache::thrift::type_class::set<::apache::thrift::type_class::variant>,
        std::unordered_set<nebula::Value>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        NSet,
        ::apache::thrift::type_class::set<::apache::thrift::type_class::variant>,
        std::unordered_set<nebula::Value>>,
    "inconsistent use of nimble option");

}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::Row>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::Row>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Row::Row(apache::thrift::FragileConstructor, ::std::vector<nebula::Value> values__arg) :
    values(std::move(values__arg)) {
  __isset.values = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Row::__clear() {
  // clear all fields
  values.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool Row::operator==(const Row& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.values == rhs.values)) {
    return false;
  }
  return true;
}

const ::std::vector<nebula::Value>& Row::get_values() const& {
  return values;
}

::std::vector<nebula::Value> Row::get_values() && {
  return std::move(values);
}


void swap(Row& a, Row& b) {
  using ::std::swap;
  swap(a.values_ref().value(), b.values_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void Row::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Row::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Row::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Row::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Row::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Row::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Row::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Row::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Row,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>,
        ::std::vector<nebula::Value>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Row,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>,
        ::std::vector<nebula::Value>>,
    "inconsistent use of nimble option");

}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::DataSet>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::DataSet>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DataSet::DataSet(apache::thrift::FragileConstructor, ::std::vector<::std::string> column_names__arg, ::std::vector<nebula::Row> rows__arg) :
    column_names(std::move(column_names__arg)),
    rows(std::move(rows__arg)) {
  __isset.column_names = true;
  __isset.rows = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void DataSet::__clear() {
  // clear all fields
  column_names.clear();
  rows.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DataSet::operator==(const DataSet& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.column_names == rhs.column_names)) {
    return false;
  }
  if (!(lhs.rows == rhs.rows)) {
    return false;
  }
  return true;
}

const ::std::vector<::std::string>& DataSet::get_column_names() const& {
  return column_names;
}

::std::vector<::std::string> DataSet::get_column_names() && {
  return std::move(column_names);
}

const ::std::vector<nebula::Row>& DataSet::get_rows() const& {
  return rows;
}

::std::vector<nebula::Row> DataSet::get_rows() && {
  return std::move(rows);
}


void swap(DataSet& a, DataSet& b) {
  using ::std::swap;
  swap(a.column_names_ref().value(), b.column_names_ref().value());
  swap(a.rows_ref().value(), b.rows_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DataSet::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DataSet::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DataSet::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DataSet::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DataSet::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DataSet::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DataSet::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DataSet::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        DataSet,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::Row>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        DataSet,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::Row>>,
    "inconsistent use of nimble option");

}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::Coordinate>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::Coordinate>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Coordinate::Coordinate(apache::thrift::FragileConstructor, double x__arg, double y__arg) :
    x(std::move(x__arg)),
    y(std::move(y__arg)) {
  __isset.x = true;
  __isset.y = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Coordinate::__clear() {
  // clear all fields
  x = 0;
  y = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool Coordinate::operator==(const Coordinate& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.x == rhs.x)) {
    return false;
  }
  if (!(lhs.y == rhs.y)) {
    return false;
  }
  return true;
}

bool Coordinate::operator<(const Coordinate& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.x == rhs.x)) {
    return lhs.x < rhs.x;
  }
  if (!(lhs.y == rhs.y)) {
    return lhs.y < rhs.y;
  }
  return false;
}


void swap(Coordinate& a, Coordinate& b) {
  using ::std::swap;
  swap(a.x_ref().value(), b.x_ref().value());
  swap(a.y_ref().value(), b.y_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void Coordinate::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Coordinate::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Coordinate::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Coordinate::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Coordinate::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Coordinate::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Coordinate::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Coordinate::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::Point>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::Point>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Point::Point(apache::thrift::FragileConstructor, nebula::Coordinate coord__arg) :
    coord(std::move(coord__arg)) {
  __isset.coord = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Point::__clear() {
  // clear all fields
  coord.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool Point::operator==(const Point& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.coord == rhs.coord)) {
    return false;
  }
  return true;
}

bool Point::operator<(const Point& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.coord == rhs.coord)) {
    return lhs.coord < rhs.coord;
  }
  return false;
}

const nebula::Coordinate& Point::get_coord() const& {
  return coord;
}

nebula::Coordinate Point::get_coord() && {
  return std::move(coord);
}


void swap(Point& a, Point& b) {
  using ::std::swap;
  swap(a.coord_ref().value(), b.coord_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void Point::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Point::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Point::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Point::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Point::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Point::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Point::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Point::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Point,
        ::apache::thrift::type_class::structure,
        nebula::Coordinate>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Point,
        ::apache::thrift::type_class::structure,
        nebula::Coordinate>,
    "inconsistent use of nimble option");

}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::LineString>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::LineString>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
LineString::LineString(apache::thrift::FragileConstructor, ::std::vector<nebula::Coordinate> coordList__arg) :
    coordList(std::move(coordList__arg)) {
  __isset.coordList = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void LineString::__clear() {
  // clear all fields
  coordList.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool LineString::operator==(const LineString& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.coordList == rhs.coordList)) {
    return false;
  }
  return true;
}

bool LineString::operator<(const LineString& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.coordList == rhs.coordList)) {
    return lhs.coordList < rhs.coordList;
  }
  return false;
}

const ::std::vector<nebula::Coordinate>& LineString::get_coordList() const& {
  return coordList;
}

::std::vector<nebula::Coordinate> LineString::get_coordList() && {
  return std::move(coordList);
}


void swap(LineString& a, LineString& b) {
  using ::std::swap;
  swap(a.coordList_ref().value(), b.coordList_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void LineString::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t LineString::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t LineString::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t LineString::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void LineString::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t LineString::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t LineString::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t LineString::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        LineString,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::Coordinate>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        LineString,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::Coordinate>>,
    "inconsistent use of nimble option");

}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::Polygon>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::Polygon>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Polygon::Polygon(apache::thrift::FragileConstructor, ::std::vector<::std::vector<nebula::Coordinate>> coordListList__arg) :
    coordListList(std::move(coordListList__arg)) {
  __isset.coordListList = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Polygon::__clear() {
  // clear all fields
  coordListList.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool Polygon::operator==(const Polygon& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.coordListList == rhs.coordListList)) {
    return false;
  }
  return true;
}

bool Polygon::operator<(const Polygon& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.coordListList == rhs.coordListList)) {
    return lhs.coordListList < rhs.coordListList;
  }
  return false;
}

const ::std::vector<::std::vector<nebula::Coordinate>>& Polygon::get_coordListList() const& {
  return coordListList;
}

::std::vector<::std::vector<nebula::Coordinate>> Polygon::get_coordListList() && {
  return std::move(coordListList);
}


void swap(Polygon& a, Polygon& b) {
  using ::std::swap;
  swap(a.coordListList_ref().value(), b.coordListList_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void Polygon::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Polygon::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Polygon::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Polygon::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Polygon::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Polygon::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Polygon::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Polygon::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Polygon,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        ::std::vector<::std::vector<nebula::Coordinate>>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Polygon,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        ::std::vector<::std::vector<nebula::Coordinate>>>,
    "inconsistent use of nimble option");

}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::Geography>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::Geography>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::cpp2::Geography::Type>::size;
folly::Range<::nebula::cpp2::Geography::Type const*> const TEnumTraits<::nebula::cpp2::Geography::Type>::values = folly::range(TEnumDataStorage<::nebula::cpp2::Geography::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::cpp2::Geography::Type>::names = folly::range(TEnumDataStorage<::nebula::cpp2::Geography::Type>::names);

char const* TEnumTraits<::nebula::cpp2::Geography::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::nebula::cpp2::Geography::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::cpp2::Geography::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::nebula::cpp2::Geography::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace nebula { namespace cpp2 {

void Geography::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::ptVal:
      destruct(value_.ptVal);
      break;
    case Type::lsVal:
      destruct(value_.lsVal);
      break;
    case Type::pgVal:
      destruct(value_.pgVal);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool Geography::operator==(const Geography& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::ptVal:
      return *value_.ptVal == *rhs.value_.ptVal;
    case Type::lsVal:
      return *value_.lsVal == *rhs.value_.lsVal;
    case Type::pgVal:
      return *value_.pgVal == *rhs.value_.pgVal;
    default:
      return true;
  }
}

bool Geography::operator<(const Geography& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::ptVal:
      return lhs.value_.ptVal < rhs.value_.ptVal;
    case Type::lsVal:
      return lhs.value_.lsVal < rhs.value_.lsVal;
    case Type::pgVal:
      return lhs.value_.pgVal < rhs.value_.pgVal;
    default:
      return false;
  }
}

std::unique_ptr<nebula::Point>& Geography::set_ptVal(nebula::Point const &t) {
  __clear();
  type_ = Type::ptVal;
  ::new (std::addressof(value_.ptVal)) std::unique_ptr<nebula::Point>(new std::unique_ptr<nebula::Point>::element_type(t));
  return value_.ptVal;
}

std::unique_ptr<nebula::Point>& Geography::set_ptVal(nebula::Point&& t) {
  __clear();
  type_ = Type::ptVal;
  ::new (std::addressof(value_.ptVal)) std::unique_ptr<nebula::Point>(new std::unique_ptr<nebula::Point>::element_type(std::move(t)));
  return value_.ptVal;
}

std::unique_ptr<nebula::LineString>& Geography::set_lsVal(nebula::LineString const &t) {
  __clear();
  type_ = Type::lsVal;
  ::new (std::addressof(value_.lsVal)) std::unique_ptr<nebula::LineString>(new std::unique_ptr<nebula::LineString>::element_type(t));
  return value_.lsVal;
}

std::unique_ptr<nebula::LineString>& Geography::set_lsVal(nebula::LineString&& t) {
  __clear();
  type_ = Type::lsVal;
  ::new (std::addressof(value_.lsVal)) std::unique_ptr<nebula::LineString>(new std::unique_ptr<nebula::LineString>::element_type(std::move(t)));
  return value_.lsVal;
}

std::unique_ptr<nebula::Polygon>& Geography::set_pgVal(nebula::Polygon const &t) {
  __clear();
  type_ = Type::pgVal;
  ::new (std::addressof(value_.pgVal)) std::unique_ptr<nebula::Polygon>(new std::unique_ptr<nebula::Polygon>::element_type(t));
  return value_.pgVal;
}

std::unique_ptr<nebula::Polygon>& Geography::set_pgVal(nebula::Polygon&& t) {
  __clear();
  type_ = Type::pgVal;
  ::new (std::addressof(value_.pgVal)) std::unique_ptr<nebula::Polygon>(new std::unique_ptr<nebula::Polygon>::element_type(std::move(t)));
  return value_.pgVal;
}

void swap(Geography& a, Geography& b) {
  Geography temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void Geography::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Geography::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Geography::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Geography::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Geography::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Geography::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Geography::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Geography::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Geography,
        ::apache::thrift::type_class::structure,
        nebula::Point>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Geography,
        ::apache::thrift::type_class::structure,
        nebula::LineString>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Geography,
        ::apache::thrift::type_class::structure,
        nebula::Polygon>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Geography,
        ::apache::thrift::type_class::structure,
        nebula::Point>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Geography,
        ::apache::thrift::type_class::structure,
        nebula::LineString>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Geography,
        ::apache::thrift::type_class::structure,
        nebula::Polygon>,
    "inconsistent use of nimble option");

}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::Tag>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::Tag>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Tag::Tag(apache::thrift::FragileConstructor, ::std::string name__arg, std::unordered_map<::std::string, nebula::Value> props__arg) :
    name(std::move(name__arg)),
    props(std::move(props__arg)) {
  __isset.name = true;
  __isset.props = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Tag::__clear() {
  // clear all fields
  name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  props.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool Tag::operator==(const Tag& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return false;
  }
  if (!(lhs.props == rhs.props)) {
    return false;
  }
  return true;
}

const std::unordered_map<::std::string, nebula::Value>& Tag::get_props() const& {
  return props;
}

std::unordered_map<::std::string, nebula::Value> Tag::get_props() && {
  return std::move(props);
}


void swap(Tag& a, Tag& b) {
  using ::std::swap;
  swap(a.name_ref().value(), b.name_ref().value());
  swap(a.props_ref().value(), b.props_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void Tag::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Tag::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Tag::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Tag::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Tag::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Tag::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Tag::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Tag::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Tag,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::binary, ::apache::thrift::type_class::variant>,
        std::unordered_map<::std::string, nebula::Value>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Tag,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::binary, ::apache::thrift::type_class::variant>,
        std::unordered_map<::std::string, nebula::Value>>,
    "inconsistent use of nimble option");

}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::Vertex>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::Vertex>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Vertex::Vertex(apache::thrift::FragileConstructor, nebula::Value vid__arg, ::std::vector<nebula::Tag> tags__arg) :
    vid(std::move(vid__arg)),
    tags(std::move(tags__arg)) {
  __isset.vid = true;
  __isset.tags = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Vertex::__clear() {
  // clear all fields
  vid.__clear();
  tags.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool Vertex::operator==(const Vertex& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.vid == rhs.vid)) {
    return false;
  }
  if (!(lhs.tags == rhs.tags)) {
    return false;
  }
  return true;
}

const nebula::Value& Vertex::get_vid() const& {
  return vid;
}

nebula::Value Vertex::get_vid() && {
  return std::move(vid);
}

const ::std::vector<nebula::Tag>& Vertex::get_tags() const& {
  return tags;
}

::std::vector<nebula::Tag> Vertex::get_tags() && {
  return std::move(tags);
}


void swap(Vertex& a, Vertex& b) {
  using ::std::swap;
  swap(a.vid_ref().value(), b.vid_ref().value());
  swap(a.tags_ref().value(), b.tags_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void Vertex::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Vertex::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Vertex::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Vertex::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Vertex::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Vertex::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Vertex::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Vertex::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Vertex,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Vertex,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::Tag>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Vertex,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Vertex,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::Tag>>,
    "inconsistent use of nimble option");

}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::Edge>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::Edge>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Edge::Edge() :
      type(0),
      ranking(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


Edge::~Edge() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Edge::Edge(apache::thrift::FragileConstructor, nebula::Value src__arg, nebula::Value dst__arg,  ::nebula::cpp2::EdgeType type__arg, ::std::string name__arg,  ::nebula::cpp2::EdgeRanking ranking__arg, std::unordered_map<::std::string, nebula::Value> props__arg) :
    src(std::move(src__arg)),
    dst(std::move(dst__arg)),
    type(std::move(type__arg)),
    name(std::move(name__arg)),
    ranking(std::move(ranking__arg)),
    props(std::move(props__arg)) {
  __isset.src = true;
  __isset.dst = true;
  __isset.type = true;
  __isset.name = true;
  __isset.ranking = true;
  __isset.props = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Edge::__clear() {
  // clear all fields
  src.__clear();
  dst.__clear();
  type = 0;
  name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  ranking = 0;
  props.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool Edge::operator==(const Edge& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.src == rhs.src)) {
    return false;
  }
  if (!(lhs.dst == rhs.dst)) {
    return false;
  }
  if (!(lhs.type == rhs.type)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return false;
  }
  if (!(lhs.ranking == rhs.ranking)) {
    return false;
  }
  if (!(lhs.props == rhs.props)) {
    return false;
  }
  return true;
}

const nebula::Value& Edge::get_src() const& {
  return src;
}

nebula::Value Edge::get_src() && {
  return std::move(src);
}

const nebula::Value& Edge::get_dst() const& {
  return dst;
}

nebula::Value Edge::get_dst() && {
  return std::move(dst);
}

const std::unordered_map<::std::string, nebula::Value>& Edge::get_props() const& {
  return props;
}

std::unordered_map<::std::string, nebula::Value> Edge::get_props() && {
  return std::move(props);
}


void swap(Edge& a, Edge& b) {
  using ::std::swap;
  swap(a.src_ref().value(), b.src_ref().value());
  swap(a.dst_ref().value(), b.dst_ref().value());
  swap(a.type_ref().value(), b.type_ref().value());
  swap(a.name_ref().value(), b.name_ref().value());
  swap(a.ranking_ref().value(), b.ranking_ref().value());
  swap(a.props_ref().value(), b.props_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void Edge::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Edge::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Edge::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Edge::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Edge::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Edge::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Edge::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Edge::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Edge,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Edge,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Edge,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::binary, ::apache::thrift::type_class::variant>,
        std::unordered_map<::std::string, nebula::Value>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Edge,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Edge,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Edge,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::binary, ::apache::thrift::type_class::variant>,
        std::unordered_map<::std::string, nebula::Value>>,
    "inconsistent use of nimble option");

}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::Step>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::Step>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Step::Step() :
      type(0),
      ranking(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


Step::~Step() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Step::Step(apache::thrift::FragileConstructor, nebula::Vertex dst__arg,  ::nebula::cpp2::EdgeType type__arg, ::std::string name__arg,  ::nebula::cpp2::EdgeRanking ranking__arg, std::unordered_map<::std::string, nebula::Value> props__arg) :
    dst(std::move(dst__arg)),
    type(std::move(type__arg)),
    name(std::move(name__arg)),
    ranking(std::move(ranking__arg)),
    props(std::move(props__arg)) {
  __isset.dst = true;
  __isset.type = true;
  __isset.name = true;
  __isset.ranking = true;
  __isset.props = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Step::__clear() {
  // clear all fields
  dst.__clear();
  type = 0;
  name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  ranking = 0;
  props.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool Step::operator==(const Step& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.dst == rhs.dst)) {
    return false;
  }
  if (!(lhs.type == rhs.type)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return false;
  }
  if (!(lhs.ranking == rhs.ranking)) {
    return false;
  }
  if (!(lhs.props == rhs.props)) {
    return false;
  }
  return true;
}

const nebula::Vertex& Step::get_dst() const& {
  return dst;
}

nebula::Vertex Step::get_dst() && {
  return std::move(dst);
}

const std::unordered_map<::std::string, nebula::Value>& Step::get_props() const& {
  return props;
}

std::unordered_map<::std::string, nebula::Value> Step::get_props() && {
  return std::move(props);
}


void swap(Step& a, Step& b) {
  using ::std::swap;
  swap(a.dst_ref().value(), b.dst_ref().value());
  swap(a.type_ref().value(), b.type_ref().value());
  swap(a.name_ref().value(), b.name_ref().value());
  swap(a.ranking_ref().value(), b.ranking_ref().value());
  swap(a.props_ref().value(), b.props_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void Step::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Step::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Step::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Step::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Step::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Step::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Step::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Step::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Step,
        ::apache::thrift::type_class::structure,
        nebula::Vertex>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Step,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::binary, ::apache::thrift::type_class::variant>,
        std::unordered_map<::std::string, nebula::Value>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Step,
        ::apache::thrift::type_class::structure,
        nebula::Vertex>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Step,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::binary, ::apache::thrift::type_class::variant>,
        std::unordered_map<::std::string, nebula::Value>>,
    "inconsistent use of nimble option");

}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::Path>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::Path>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Path::Path(apache::thrift::FragileConstructor, nebula::Vertex src__arg, ::std::vector<nebula::Step> steps__arg) :
    src(std::move(src__arg)),
    steps(std::move(steps__arg)) {
  __isset.src = true;
  __isset.steps = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Path::__clear() {
  // clear all fields
  src.__clear();
  steps.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool Path::operator==(const Path& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.src == rhs.src)) {
    return false;
  }
  if (!(lhs.steps == rhs.steps)) {
    return false;
  }
  return true;
}

const nebula::Vertex& Path::get_src() const& {
  return src;
}

nebula::Vertex Path::get_src() && {
  return std::move(src);
}

const ::std::vector<nebula::Step>& Path::get_steps() const& {
  return steps;
}

::std::vector<nebula::Step> Path::get_steps() && {
  return std::move(steps);
}


void swap(Path& a, Path& b) {
  using ::std::swap;
  swap(a.src_ref().value(), b.src_ref().value());
  swap(a.steps_ref().value(), b.steps_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void Path::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Path::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Path::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Path::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Path::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Path::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Path::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Path::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Path,
        ::apache::thrift::type_class::structure,
        nebula::Vertex>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Path,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::Step>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Path,
        ::apache::thrift::type_class::structure,
        nebula::Vertex>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Path,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::Step>>,
    "inconsistent use of nimble option");

}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::HostAddr>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::HostAddr>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
HostAddr::HostAddr(apache::thrift::FragileConstructor, ::std::string host__arg,  ::nebula::cpp2::Port port__arg) :
    host(std::move(host__arg)),
    port(std::move(port__arg)) {
  __isset.host = true;
  __isset.port = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void HostAddr::__clear() {
  // clear all fields
  host = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  port = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool HostAddr::operator==(const HostAddr& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.host == rhs.host)) {
    return false;
  }
  if (!(lhs.port == rhs.port)) {
    return false;
  }
  return true;
}

bool HostAddr::operator<(const HostAddr& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.host == rhs.host)) {
    return lhs.host < rhs.host;
  }
  if (!(lhs.port == rhs.port)) {
    return lhs.port < rhs.port;
  }
  return false;
}


void swap(HostAddr& a, HostAddr& b) {
  using ::std::swap;
  swap(a.host_ref().value(), b.host_ref().value());
  swap(a.port_ref().value(), b.port_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void HostAddr::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t HostAddr::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t HostAddr::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t HostAddr::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void HostAddr::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t HostAddr::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t HostAddr::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t HostAddr::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::KeyValue>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::KeyValue>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
KeyValue::KeyValue(apache::thrift::FragileConstructor, ::std::string key__arg, ::std::string value__arg) :
    key(std::move(key__arg)),
    value(std::move(value__arg)) {
  __isset.key = true;
  __isset.value = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void KeyValue::__clear() {
  // clear all fields
  key = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  value = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool KeyValue::operator==(const KeyValue& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.key, rhs.key)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.value, rhs.value)) {
    return false;
  }
  return true;
}

bool KeyValue::operator<(const KeyValue& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.key, rhs.key)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.key, rhs.key);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.value, rhs.value)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.value, rhs.value);
  }
  return false;
}


void swap(KeyValue& a, KeyValue& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.value_ref().value(), b.value_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void KeyValue::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t KeyValue::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t KeyValue::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t KeyValue::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void KeyValue::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t KeyValue::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t KeyValue::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t KeyValue::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::LogInfo>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::LogInfo>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
LogInfo::LogInfo(apache::thrift::FragileConstructor,  ::nebula::cpp2::LogID log_id__arg,  ::nebula::cpp2::TermID term_id__arg) :
    log_id(std::move(log_id__arg)),
    term_id(std::move(term_id__arg)) {
  __isset.log_id = true;
  __isset.term_id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void LogInfo::__clear() {
  // clear all fields
  log_id = 0;
  term_id = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool LogInfo::operator==(const LogInfo& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.log_id == rhs.log_id)) {
    return false;
  }
  if (!(lhs.term_id == rhs.term_id)) {
    return false;
  }
  return true;
}

bool LogInfo::operator<(const LogInfo& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.log_id == rhs.log_id)) {
    return lhs.log_id < rhs.log_id;
  }
  if (!(lhs.term_id == rhs.term_id)) {
    return lhs.term_id < rhs.term_id;
  }
  return false;
}


void swap(LogInfo& a, LogInfo& b) {
  using ::std::swap;
  swap(a.log_id_ref().value(), b.log_id_ref().value());
  swap(a.term_id_ref().value(), b.term_id_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void LogInfo::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t LogInfo::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t LogInfo::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t LogInfo::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void LogInfo::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t LogInfo::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t LogInfo::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t LogInfo::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::DirInfo>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::DirInfo>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DirInfo::DirInfo(apache::thrift::FragileConstructor, ::std::string root__arg, ::std::vector<::std::string> data__arg) :
    root(std::move(root__arg)),
    data(std::move(data__arg)) {
  __isset.root = true;
  __isset.data = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void DirInfo::__clear() {
  // clear all fields
  root = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  data.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DirInfo::operator==(const DirInfo& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.root, rhs.root)) {
    return false;
  }
  if (!(lhs.data == rhs.data)) {
    return false;
  }
  return true;
}

bool DirInfo::operator<(const DirInfo& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.root, rhs.root)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.root, rhs.root);
  }
  if (!(lhs.data == rhs.data)) {
    return lhs.data < rhs.data;
  }
  return false;
}

const ::std::vector<::std::string>& DirInfo::get_data() const& {
  return data;
}

::std::vector<::std::string> DirInfo::get_data() && {
  return std::move(data);
}


void swap(DirInfo& a, DirInfo& b) {
  using ::std::swap;
  swap(a.root_ref().value(), b.root_ref().value());
  swap(a.data_ref().value(), b.data_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DirInfo::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DirInfo::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DirInfo::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DirInfo::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DirInfo::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DirInfo::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DirInfo::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DirInfo::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::NodeInfo>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::NodeInfo>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
NodeInfo::NodeInfo(apache::thrift::FragileConstructor, nebula::HostAddr host__arg,  ::nebula::cpp2::DirInfo dir__arg) :
    host(std::move(host__arg)),
    dir(std::move(dir__arg)) {
  __isset.host = true;
  __isset.dir = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void NodeInfo::__clear() {
  // clear all fields
  host.__clear();
  dir.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool NodeInfo::operator==(const NodeInfo& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.host == rhs.host)) {
    return false;
  }
  if (!(lhs.dir == rhs.dir)) {
    return false;
  }
  return true;
}

bool NodeInfo::operator<(const NodeInfo& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.host == rhs.host)) {
    return lhs.host < rhs.host;
  }
  if (!(lhs.dir == rhs.dir)) {
    return lhs.dir < rhs.dir;
  }
  return false;
}

const nebula::HostAddr& NodeInfo::get_host() const& {
  return host;
}

nebula::HostAddr NodeInfo::get_host() && {
  return std::move(host);
}

const  ::nebula::cpp2::DirInfo& NodeInfo::get_dir() const& {
  return dir;
}

 ::nebula::cpp2::DirInfo NodeInfo::get_dir() && {
  return std::move(dir);
}


void swap(NodeInfo& a, NodeInfo& b) {
  using ::std::swap;
  swap(a.host_ref().value(), b.host_ref().value());
  swap(a.dir_ref().value(), b.dir_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void NodeInfo::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t NodeInfo::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t NodeInfo::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t NodeInfo::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void NodeInfo::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t NodeInfo::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t NodeInfo::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t NodeInfo::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        NodeInfo,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        NodeInfo,
        ::apache::thrift::type_class::structure,
         ::nebula::cpp2::DirInfo>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        NodeInfo,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        NodeInfo,
        ::apache::thrift::type_class::structure,
         ::nebula::cpp2::DirInfo>,
    "inconsistent use of nimble option");

}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::PartitionBackupInfo>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::PartitionBackupInfo>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PartitionBackupInfo::PartitionBackupInfo(apache::thrift::FragileConstructor, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::cpp2::LogInfo> info__arg) :
    info(std::move(info__arg)) {
  __isset.info = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void PartitionBackupInfo::__clear() {
  // clear all fields
  info.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool PartitionBackupInfo::operator==(const PartitionBackupInfo& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.info == rhs.info)) {
    return false;
  }
  return true;
}

const std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::cpp2::LogInfo>& PartitionBackupInfo::get_info() const& {
  return info;
}

std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::cpp2::LogInfo> PartitionBackupInfo::get_info() && {
  return std::move(info);
}


void swap(PartitionBackupInfo& a, PartitionBackupInfo& b) {
  using ::std::swap;
  swap(a.info_ref().value(), b.info_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void PartitionBackupInfo::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PartitionBackupInfo::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PartitionBackupInfo::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PartitionBackupInfo::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PartitionBackupInfo::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PartitionBackupInfo::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PartitionBackupInfo::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PartitionBackupInfo::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PartitionBackupInfo,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::cpp2::LogInfo>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PartitionBackupInfo,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::cpp2::LogInfo>>,
    "inconsistent use of nimble option");

}} // nebula::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::cpp2::CheckpointInfo>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::cpp2::CheckpointInfo>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CheckpointInfo::CheckpointInfo(apache::thrift::FragileConstructor,  ::nebula::cpp2::PartitionBackupInfo partition_info__arg, ::std::string path__arg) :
    partition_info(std::move(partition_info__arg)),
    path(std::move(path__arg)) {
  __isset.partition_info = true;
  __isset.path = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CheckpointInfo::__clear() {
  // clear all fields
  partition_info.__clear();
  path = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CheckpointInfo::operator==(const CheckpointInfo& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.partition_info == rhs.partition_info)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.path, rhs.path)) {
    return false;
  }
  return true;
}

const  ::nebula::cpp2::PartitionBackupInfo& CheckpointInfo::get_partition_info() const& {
  return partition_info;
}

 ::nebula::cpp2::PartitionBackupInfo CheckpointInfo::get_partition_info() && {
  return std::move(partition_info);
}


void swap(CheckpointInfo& a, CheckpointInfo& b) {
  using ::std::swap;
  swap(a.partition_info_ref().value(), b.partition_info_ref().value());
  swap(a.path_ref().value(), b.path_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CheckpointInfo::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CheckpointInfo::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CheckpointInfo::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CheckpointInfo::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CheckpointInfo::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CheckpointInfo::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CheckpointInfo::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CheckpointInfo::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CheckpointInfo,
        ::apache::thrift::type_class::structure,
         ::nebula::cpp2::PartitionBackupInfo>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CheckpointInfo,
        ::apache::thrift::type_class::structure,
         ::nebula::cpp2::PartitionBackupInfo>,
    "inconsistent use of nimble option");

}} // nebula::cpp2
