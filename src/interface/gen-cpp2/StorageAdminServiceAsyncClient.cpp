/**
 * Autogenerated by Thrift for storage.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include "StorageAdminServiceAsyncClient.h"

#include <thrift/lib/cpp2/gen/client_cpp.h>

namespace nebula { namespace storage { namespace cpp2 {
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::TransLeaderReq*>> StorageAdminService_transLeader_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_transLeader_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AddPartReq*>> StorageAdminService_addPart_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_addPart_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AddLearnerReq*>> StorageAdminService_addLearner_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_addLearner_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RemovePartReq*>> StorageAdminService_removePart_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_removePart_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::MemberChangeReq*>> StorageAdminService_memberChange_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_memberChange_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::CatchUpDataReq*>> StorageAdminService_waitingForCatchUpData_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_waitingForCatchUpData_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::CreateCPRequest*>> StorageAdminService_createCheckpoint_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::CreateCPResp*>> StorageAdminService_createCheckpoint_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::DropCPRequest*>> StorageAdminService_dropCheckpoint_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_dropCheckpoint_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::BlockingSignRequest*>> StorageAdminService_blockingWrites_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_blockingWrites_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RebuildIndexRequest*>> StorageAdminService_rebuildTagIndex_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_rebuildTagIndex_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RebuildIndexRequest*>> StorageAdminService_rebuildEdgeIndex_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_rebuildEdgeIndex_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::GetLeaderReq*>> StorageAdminService_getLeaderParts_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::GetLeaderPartsResp*>> StorageAdminService_getLeaderParts_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::CheckPeersReq*>> StorageAdminService_checkPeers_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_checkPeers_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AddAdminTaskRequest*>> StorageAdminService_addAdminTask_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_addAdminTask_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::StopAdminTaskRequest*>> StorageAdminService_stopAdminTask_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_stopAdminTask_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ListClusterInfoReq*>> StorageAdminService_listClusterInfo_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ListClusterInfoResp*>> StorageAdminService_listClusterInfo_presult;

template <typename Protocol_>
void StorageAdminServiceAsyncClient::transLeaderT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::TransLeaderReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  StorageAdminService_transLeader_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::TransLeaderReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "transLeader";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void StorageAdminServiceAsyncClient::addPartT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::AddPartReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  StorageAdminService_addPart_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::AddPartReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "addPart";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void StorageAdminServiceAsyncClient::addLearnerT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::AddLearnerReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  StorageAdminService_addLearner_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::AddLearnerReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "addLearner";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void StorageAdminServiceAsyncClient::removePartT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::RemovePartReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  StorageAdminService_removePart_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::RemovePartReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "removePart";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void StorageAdminServiceAsyncClient::memberChangeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::MemberChangeReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  StorageAdminService_memberChange_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::MemberChangeReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "memberChange";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void StorageAdminServiceAsyncClient::waitingForCatchUpDataT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::CatchUpDataReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  StorageAdminService_waitingForCatchUpData_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::CatchUpDataReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "waitingForCatchUpData";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void StorageAdminServiceAsyncClient::createCheckpointT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::CreateCPRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  StorageAdminService_createCheckpoint_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::CreateCPRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "createCheckpoint";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void StorageAdminServiceAsyncClient::dropCheckpointT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::DropCPRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  StorageAdminService_dropCheckpoint_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::DropCPRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "dropCheckpoint";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void StorageAdminServiceAsyncClient::blockingWritesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::BlockingSignRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  StorageAdminService_blockingWrites_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::BlockingSignRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "blockingWrites";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void StorageAdminServiceAsyncClient::rebuildTagIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  StorageAdminService_rebuildTagIndex_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::RebuildIndexRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "rebuildTagIndex";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void StorageAdminServiceAsyncClient::rebuildEdgeIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  StorageAdminService_rebuildEdgeIndex_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::RebuildIndexRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "rebuildEdgeIndex";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void StorageAdminServiceAsyncClient::getLeaderPartsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::GetLeaderReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  StorageAdminService_getLeaderParts_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::GetLeaderReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "getLeaderParts";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void StorageAdminServiceAsyncClient::checkPeersT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::CheckPeersReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  StorageAdminService_checkPeers_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::CheckPeersReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "checkPeers";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void StorageAdminServiceAsyncClient::addAdminTaskT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::AddAdminTaskRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  StorageAdminService_addAdminTask_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::AddAdminTaskRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "addAdminTask";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void StorageAdminServiceAsyncClient::stopAdminTaskT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::StopAdminTaskRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  StorageAdminService_stopAdminTask_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::StopAdminTaskRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "stopAdminTask";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void StorageAdminServiceAsyncClient::listClusterInfoT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::ListClusterInfoReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  StorageAdminService_listClusterInfo_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::ListClusterInfoReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listClusterInfo";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}



void StorageAdminServiceAsyncClient::transLeader(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::TransLeaderReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  transLeader(rpcOptions, std::move(callback), p_req);
}

void StorageAdminServiceAsyncClient::transLeader(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::TransLeaderReq& p_req) {
  auto ctx = transLeaderCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  transLeaderImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void StorageAdminServiceAsyncClient::transLeaderImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::TransLeaderReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      transLeaderT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      transLeaderT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> StorageAdminServiceAsyncClient::transLeaderCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "StorageAdminService.transLeader");
}

void StorageAdminServiceAsyncClient::sync_transLeader( ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::TransLeaderReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_transLeader(rpcOptions, _return, p_req);
}

void StorageAdminServiceAsyncClient::sync_transLeader(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::TransLeaderReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = transLeaderCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  transLeaderImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_transLeader(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_transLeader(const  ::nebula::storage::cpp2::TransLeaderReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_transLeader(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_transLeader(const  ::nebula::storage::cpp2::TransLeaderReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_transLeader(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_transLeader(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::TransLeaderReq& p_req) {
  folly::Promise< ::nebula::storage::cpp2::AdminExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_transLeader, channel_);
  transLeader(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_transLeader(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::TransLeaderReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_transLeader, channel_);
  auto callback = std::move(callbackAndFuture.first);
  transLeader(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_future_transLeader(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::TransLeaderReq& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_transLeader, channel_);
  transLeader(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_semifuture_transLeader(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::TransLeaderReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_transLeader, channel_);
  auto callback = std::move(callbackAndFuture.first);
  transLeader(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void StorageAdminServiceAsyncClient::transLeader(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::TransLeaderReq& p_req) {
  transLeader(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper StorageAdminServiceAsyncClient::recv_wrapped_transLeader( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = StorageAdminService_transLeader_presult;
  constexpr auto const fname = "transLeader";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void StorageAdminServiceAsyncClient::recv_transLeader( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_transLeader(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void StorageAdminServiceAsyncClient::recv_instance_transLeader( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_transLeader(_return, state);
}

folly::exception_wrapper StorageAdminServiceAsyncClient::recv_instance_wrapped_transLeader( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_transLeader(_return, state);
}

void StorageAdminServiceAsyncClient::addPart(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::AddPartReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  addPart(rpcOptions, std::move(callback), p_req);
}

void StorageAdminServiceAsyncClient::addPart(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::AddPartReq& p_req) {
  auto ctx = addPartCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  addPartImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void StorageAdminServiceAsyncClient::addPartImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::AddPartReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      addPartT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      addPartT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> StorageAdminServiceAsyncClient::addPartCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "StorageAdminService.addPart");
}

void StorageAdminServiceAsyncClient::sync_addPart( ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::AddPartReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_addPart(rpcOptions, _return, p_req);
}

void StorageAdminServiceAsyncClient::sync_addPart(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::AddPartReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = addPartCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  addPartImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_addPart(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_addPart(const  ::nebula::storage::cpp2::AddPartReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_addPart(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_addPart(const  ::nebula::storage::cpp2::AddPartReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_addPart(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_addPart(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddPartReq& p_req) {
  folly::Promise< ::nebula::storage::cpp2::AdminExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_addPart, channel_);
  addPart(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_addPart(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddPartReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_addPart, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addPart(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_future_addPart(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddPartReq& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_addPart, channel_);
  addPart(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_semifuture_addPart(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddPartReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_addPart, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addPart(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void StorageAdminServiceAsyncClient::addPart(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::AddPartReq& p_req) {
  addPart(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper StorageAdminServiceAsyncClient::recv_wrapped_addPart( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = StorageAdminService_addPart_presult;
  constexpr auto const fname = "addPart";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void StorageAdminServiceAsyncClient::recv_addPart( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_addPart(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void StorageAdminServiceAsyncClient::recv_instance_addPart( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_addPart(_return, state);
}

folly::exception_wrapper StorageAdminServiceAsyncClient::recv_instance_wrapped_addPart( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_addPart(_return, state);
}

void StorageAdminServiceAsyncClient::addLearner(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::AddLearnerReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  addLearner(rpcOptions, std::move(callback), p_req);
}

void StorageAdminServiceAsyncClient::addLearner(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::AddLearnerReq& p_req) {
  auto ctx = addLearnerCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  addLearnerImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void StorageAdminServiceAsyncClient::addLearnerImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::AddLearnerReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      addLearnerT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      addLearnerT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> StorageAdminServiceAsyncClient::addLearnerCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "StorageAdminService.addLearner");
}

void StorageAdminServiceAsyncClient::sync_addLearner( ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::AddLearnerReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_addLearner(rpcOptions, _return, p_req);
}

void StorageAdminServiceAsyncClient::sync_addLearner(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::AddLearnerReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = addLearnerCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  addLearnerImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_addLearner(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_addLearner(const  ::nebula::storage::cpp2::AddLearnerReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_addLearner(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_addLearner(const  ::nebula::storage::cpp2::AddLearnerReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_addLearner(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_addLearner(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddLearnerReq& p_req) {
  folly::Promise< ::nebula::storage::cpp2::AdminExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_addLearner, channel_);
  addLearner(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_addLearner(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddLearnerReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_addLearner, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addLearner(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_future_addLearner(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddLearnerReq& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_addLearner, channel_);
  addLearner(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_semifuture_addLearner(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddLearnerReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_addLearner, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addLearner(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void StorageAdminServiceAsyncClient::addLearner(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::AddLearnerReq& p_req) {
  addLearner(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper StorageAdminServiceAsyncClient::recv_wrapped_addLearner( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = StorageAdminService_addLearner_presult;
  constexpr auto const fname = "addLearner";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void StorageAdminServiceAsyncClient::recv_addLearner( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_addLearner(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void StorageAdminServiceAsyncClient::recv_instance_addLearner( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_addLearner(_return, state);
}

folly::exception_wrapper StorageAdminServiceAsyncClient::recv_instance_wrapped_addLearner( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_addLearner(_return, state);
}

void StorageAdminServiceAsyncClient::removePart(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::RemovePartReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  removePart(rpcOptions, std::move(callback), p_req);
}

void StorageAdminServiceAsyncClient::removePart(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::RemovePartReq& p_req) {
  auto ctx = removePartCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  removePartImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void StorageAdminServiceAsyncClient::removePartImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::RemovePartReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      removePartT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      removePartT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> StorageAdminServiceAsyncClient::removePartCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "StorageAdminService.removePart");
}

void StorageAdminServiceAsyncClient::sync_removePart( ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::RemovePartReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_removePart(rpcOptions, _return, p_req);
}

void StorageAdminServiceAsyncClient::sync_removePart(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::RemovePartReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = removePartCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  removePartImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_removePart(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_removePart(const  ::nebula::storage::cpp2::RemovePartReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_removePart(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_removePart(const  ::nebula::storage::cpp2::RemovePartReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_removePart(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_removePart(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::RemovePartReq& p_req) {
  folly::Promise< ::nebula::storage::cpp2::AdminExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_removePart, channel_);
  removePart(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_removePart(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::RemovePartReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_removePart, channel_);
  auto callback = std::move(callbackAndFuture.first);
  removePart(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_future_removePart(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::RemovePartReq& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_removePart, channel_);
  removePart(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_semifuture_removePart(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::RemovePartReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_removePart, channel_);
  auto callback = std::move(callbackAndFuture.first);
  removePart(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void StorageAdminServiceAsyncClient::removePart(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::RemovePartReq& p_req) {
  removePart(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper StorageAdminServiceAsyncClient::recv_wrapped_removePart( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = StorageAdminService_removePart_presult;
  constexpr auto const fname = "removePart";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void StorageAdminServiceAsyncClient::recv_removePart( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_removePart(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void StorageAdminServiceAsyncClient::recv_instance_removePart( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_removePart(_return, state);
}

folly::exception_wrapper StorageAdminServiceAsyncClient::recv_instance_wrapped_removePart( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_removePart(_return, state);
}

void StorageAdminServiceAsyncClient::memberChange(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::MemberChangeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  memberChange(rpcOptions, std::move(callback), p_req);
}

void StorageAdminServiceAsyncClient::memberChange(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::MemberChangeReq& p_req) {
  auto ctx = memberChangeCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  memberChangeImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void StorageAdminServiceAsyncClient::memberChangeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::MemberChangeReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      memberChangeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      memberChangeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> StorageAdminServiceAsyncClient::memberChangeCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "StorageAdminService.memberChange");
}

void StorageAdminServiceAsyncClient::sync_memberChange( ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::MemberChangeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_memberChange(rpcOptions, _return, p_req);
}

void StorageAdminServiceAsyncClient::sync_memberChange(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::MemberChangeReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = memberChangeCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  memberChangeImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_memberChange(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_memberChange(const  ::nebula::storage::cpp2::MemberChangeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_memberChange(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_memberChange(const  ::nebula::storage::cpp2::MemberChangeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_memberChange(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_memberChange(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::MemberChangeReq& p_req) {
  folly::Promise< ::nebula::storage::cpp2::AdminExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_memberChange, channel_);
  memberChange(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_memberChange(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::MemberChangeReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_memberChange, channel_);
  auto callback = std::move(callbackAndFuture.first);
  memberChange(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_future_memberChange(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::MemberChangeReq& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_memberChange, channel_);
  memberChange(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_semifuture_memberChange(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::MemberChangeReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_memberChange, channel_);
  auto callback = std::move(callbackAndFuture.first);
  memberChange(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void StorageAdminServiceAsyncClient::memberChange(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::MemberChangeReq& p_req) {
  memberChange(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper StorageAdminServiceAsyncClient::recv_wrapped_memberChange( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = StorageAdminService_memberChange_presult;
  constexpr auto const fname = "memberChange";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void StorageAdminServiceAsyncClient::recv_memberChange( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_memberChange(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void StorageAdminServiceAsyncClient::recv_instance_memberChange( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_memberChange(_return, state);
}

folly::exception_wrapper StorageAdminServiceAsyncClient::recv_instance_wrapped_memberChange( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_memberChange(_return, state);
}

void StorageAdminServiceAsyncClient::waitingForCatchUpData(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::CatchUpDataReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  waitingForCatchUpData(rpcOptions, std::move(callback), p_req);
}

void StorageAdminServiceAsyncClient::waitingForCatchUpData(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::CatchUpDataReq& p_req) {
  auto ctx = waitingForCatchUpDataCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  waitingForCatchUpDataImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void StorageAdminServiceAsyncClient::waitingForCatchUpDataImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::CatchUpDataReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      waitingForCatchUpDataT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      waitingForCatchUpDataT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> StorageAdminServiceAsyncClient::waitingForCatchUpDataCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "StorageAdminService.waitingForCatchUpData");
}

void StorageAdminServiceAsyncClient::sync_waitingForCatchUpData( ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::CatchUpDataReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_waitingForCatchUpData(rpcOptions, _return, p_req);
}

void StorageAdminServiceAsyncClient::sync_waitingForCatchUpData(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::CatchUpDataReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = waitingForCatchUpDataCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  waitingForCatchUpDataImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_waitingForCatchUpData(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_waitingForCatchUpData(const  ::nebula::storage::cpp2::CatchUpDataReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_waitingForCatchUpData(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_waitingForCatchUpData(const  ::nebula::storage::cpp2::CatchUpDataReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_waitingForCatchUpData(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_waitingForCatchUpData(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::CatchUpDataReq& p_req) {
  folly::Promise< ::nebula::storage::cpp2::AdminExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_waitingForCatchUpData, channel_);
  waitingForCatchUpData(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_waitingForCatchUpData(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::CatchUpDataReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_waitingForCatchUpData, channel_);
  auto callback = std::move(callbackAndFuture.first);
  waitingForCatchUpData(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_future_waitingForCatchUpData(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::CatchUpDataReq& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_waitingForCatchUpData, channel_);
  waitingForCatchUpData(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_semifuture_waitingForCatchUpData(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::CatchUpDataReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_waitingForCatchUpData, channel_);
  auto callback = std::move(callbackAndFuture.first);
  waitingForCatchUpData(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void StorageAdminServiceAsyncClient::waitingForCatchUpData(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::CatchUpDataReq& p_req) {
  waitingForCatchUpData(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper StorageAdminServiceAsyncClient::recv_wrapped_waitingForCatchUpData( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = StorageAdminService_waitingForCatchUpData_presult;
  constexpr auto const fname = "waitingForCatchUpData";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void StorageAdminServiceAsyncClient::recv_waitingForCatchUpData( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_waitingForCatchUpData(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void StorageAdminServiceAsyncClient::recv_instance_waitingForCatchUpData( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_waitingForCatchUpData(_return, state);
}

folly::exception_wrapper StorageAdminServiceAsyncClient::recv_instance_wrapped_waitingForCatchUpData( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_waitingForCatchUpData(_return, state);
}

void StorageAdminServiceAsyncClient::createCheckpoint(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::CreateCPRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  createCheckpoint(rpcOptions, std::move(callback), p_req);
}

void StorageAdminServiceAsyncClient::createCheckpoint(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::CreateCPRequest& p_req) {
  auto ctx = createCheckpointCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  createCheckpointImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void StorageAdminServiceAsyncClient::createCheckpointImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::CreateCPRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      createCheckpointT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      createCheckpointT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> StorageAdminServiceAsyncClient::createCheckpointCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "StorageAdminService.createCheckpoint");
}

void StorageAdminServiceAsyncClient::sync_createCheckpoint( ::nebula::storage::cpp2::CreateCPResp& _return, const  ::nebula::storage::cpp2::CreateCPRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_createCheckpoint(rpcOptions, _return, p_req);
}

void StorageAdminServiceAsyncClient::sync_createCheckpoint(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::CreateCPResp& _return, const  ::nebula::storage::cpp2::CreateCPRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = createCheckpointCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  createCheckpointImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_createCheckpoint(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::CreateCPResp> StorageAdminServiceAsyncClient::future_createCheckpoint(const  ::nebula::storage::cpp2::CreateCPRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_createCheckpoint(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::CreateCPResp> StorageAdminServiceAsyncClient::semifuture_createCheckpoint(const  ::nebula::storage::cpp2::CreateCPRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_createCheckpoint(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::CreateCPResp> StorageAdminServiceAsyncClient::future_createCheckpoint(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::CreateCPRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::CreateCPResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::CreateCPResp>>(std::move(promise), recv_wrapped_createCheckpoint, channel_);
  createCheckpoint(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::CreateCPResp> StorageAdminServiceAsyncClient::semifuture_createCheckpoint(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::CreateCPRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_createCheckpoint, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createCheckpoint(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::CreateCPResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_future_createCheckpoint(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::CreateCPRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::CreateCPResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::CreateCPResp>>(std::move(promise), recv_wrapped_createCheckpoint, channel_);
  createCheckpoint(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::CreateCPResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_semifuture_createCheckpoint(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::CreateCPRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_createCheckpoint, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createCheckpoint(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void StorageAdminServiceAsyncClient::createCheckpoint(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::CreateCPRequest& p_req) {
  createCheckpoint(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper StorageAdminServiceAsyncClient::recv_wrapped_createCheckpoint( ::nebula::storage::cpp2::CreateCPResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = StorageAdminService_createCheckpoint_presult;
  constexpr auto const fname = "createCheckpoint";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void StorageAdminServiceAsyncClient::recv_createCheckpoint( ::nebula::storage::cpp2::CreateCPResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_createCheckpoint(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void StorageAdminServiceAsyncClient::recv_instance_createCheckpoint( ::nebula::storage::cpp2::CreateCPResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_createCheckpoint(_return, state);
}

folly::exception_wrapper StorageAdminServiceAsyncClient::recv_instance_wrapped_createCheckpoint( ::nebula::storage::cpp2::CreateCPResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_createCheckpoint(_return, state);
}

void StorageAdminServiceAsyncClient::dropCheckpoint(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::DropCPRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  dropCheckpoint(rpcOptions, std::move(callback), p_req);
}

void StorageAdminServiceAsyncClient::dropCheckpoint(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::DropCPRequest& p_req) {
  auto ctx = dropCheckpointCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  dropCheckpointImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void StorageAdminServiceAsyncClient::dropCheckpointImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::DropCPRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      dropCheckpointT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      dropCheckpointT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> StorageAdminServiceAsyncClient::dropCheckpointCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "StorageAdminService.dropCheckpoint");
}

void StorageAdminServiceAsyncClient::sync_dropCheckpoint( ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::DropCPRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_dropCheckpoint(rpcOptions, _return, p_req);
}

void StorageAdminServiceAsyncClient::sync_dropCheckpoint(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::DropCPRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = dropCheckpointCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  dropCheckpointImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_dropCheckpoint(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_dropCheckpoint(const  ::nebula::storage::cpp2::DropCPRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_dropCheckpoint(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_dropCheckpoint(const  ::nebula::storage::cpp2::DropCPRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_dropCheckpoint(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_dropCheckpoint(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DropCPRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::AdminExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_dropCheckpoint, channel_);
  dropCheckpoint(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_dropCheckpoint(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DropCPRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_dropCheckpoint, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropCheckpoint(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_future_dropCheckpoint(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DropCPRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_dropCheckpoint, channel_);
  dropCheckpoint(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_semifuture_dropCheckpoint(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DropCPRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_dropCheckpoint, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropCheckpoint(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void StorageAdminServiceAsyncClient::dropCheckpoint(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::DropCPRequest& p_req) {
  dropCheckpoint(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper StorageAdminServiceAsyncClient::recv_wrapped_dropCheckpoint( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = StorageAdminService_dropCheckpoint_presult;
  constexpr auto const fname = "dropCheckpoint";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void StorageAdminServiceAsyncClient::recv_dropCheckpoint( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_dropCheckpoint(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void StorageAdminServiceAsyncClient::recv_instance_dropCheckpoint( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_dropCheckpoint(_return, state);
}

folly::exception_wrapper StorageAdminServiceAsyncClient::recv_instance_wrapped_dropCheckpoint( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_dropCheckpoint(_return, state);
}

void StorageAdminServiceAsyncClient::blockingWrites(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::BlockingSignRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  blockingWrites(rpcOptions, std::move(callback), p_req);
}

void StorageAdminServiceAsyncClient::blockingWrites(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::BlockingSignRequest& p_req) {
  auto ctx = blockingWritesCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  blockingWritesImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void StorageAdminServiceAsyncClient::blockingWritesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::BlockingSignRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      blockingWritesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      blockingWritesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> StorageAdminServiceAsyncClient::blockingWritesCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "StorageAdminService.blockingWrites");
}

void StorageAdminServiceAsyncClient::sync_blockingWrites( ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::BlockingSignRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_blockingWrites(rpcOptions, _return, p_req);
}

void StorageAdminServiceAsyncClient::sync_blockingWrites(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::BlockingSignRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = blockingWritesCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  blockingWritesImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_blockingWrites(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_blockingWrites(const  ::nebula::storage::cpp2::BlockingSignRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_blockingWrites(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_blockingWrites(const  ::nebula::storage::cpp2::BlockingSignRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_blockingWrites(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_blockingWrites(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::BlockingSignRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::AdminExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_blockingWrites, channel_);
  blockingWrites(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_blockingWrites(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::BlockingSignRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_blockingWrites, channel_);
  auto callback = std::move(callbackAndFuture.first);
  blockingWrites(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_future_blockingWrites(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::BlockingSignRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_blockingWrites, channel_);
  blockingWrites(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_semifuture_blockingWrites(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::BlockingSignRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_blockingWrites, channel_);
  auto callback = std::move(callbackAndFuture.first);
  blockingWrites(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void StorageAdminServiceAsyncClient::blockingWrites(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::BlockingSignRequest& p_req) {
  blockingWrites(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper StorageAdminServiceAsyncClient::recv_wrapped_blockingWrites( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = StorageAdminService_blockingWrites_presult;
  constexpr auto const fname = "blockingWrites";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void StorageAdminServiceAsyncClient::recv_blockingWrites( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_blockingWrites(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void StorageAdminServiceAsyncClient::recv_instance_blockingWrites( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_blockingWrites(_return, state);
}

folly::exception_wrapper StorageAdminServiceAsyncClient::recv_instance_wrapped_blockingWrites( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_blockingWrites(_return, state);
}

void StorageAdminServiceAsyncClient::rebuildTagIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  rebuildTagIndex(rpcOptions, std::move(callback), p_req);
}

void StorageAdminServiceAsyncClient::rebuildTagIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  auto ctx = rebuildTagIndexCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  rebuildTagIndexImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void StorageAdminServiceAsyncClient::rebuildTagIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      rebuildTagIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      rebuildTagIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> StorageAdminServiceAsyncClient::rebuildTagIndexCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "StorageAdminService.rebuildTagIndex");
}

void StorageAdminServiceAsyncClient::sync_rebuildTagIndex( ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_rebuildTagIndex(rpcOptions, _return, p_req);
}

void StorageAdminServiceAsyncClient::sync_rebuildTagIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = rebuildTagIndexCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  rebuildTagIndexImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_rebuildTagIndex(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_rebuildTagIndex(const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_rebuildTagIndex(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_rebuildTagIndex(const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_rebuildTagIndex(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_rebuildTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::AdminExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_rebuildTagIndex, channel_);
  rebuildTagIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_rebuildTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_rebuildTagIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  rebuildTagIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_future_rebuildTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_rebuildTagIndex, channel_);
  rebuildTagIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_semifuture_rebuildTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_rebuildTagIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  rebuildTagIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void StorageAdminServiceAsyncClient::rebuildTagIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  rebuildTagIndex(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper StorageAdminServiceAsyncClient::recv_wrapped_rebuildTagIndex( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = StorageAdminService_rebuildTagIndex_presult;
  constexpr auto const fname = "rebuildTagIndex";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void StorageAdminServiceAsyncClient::recv_rebuildTagIndex( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_rebuildTagIndex(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void StorageAdminServiceAsyncClient::recv_instance_rebuildTagIndex( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_rebuildTagIndex(_return, state);
}

folly::exception_wrapper StorageAdminServiceAsyncClient::recv_instance_wrapped_rebuildTagIndex( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_rebuildTagIndex(_return, state);
}

void StorageAdminServiceAsyncClient::rebuildEdgeIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  rebuildEdgeIndex(rpcOptions, std::move(callback), p_req);
}

void StorageAdminServiceAsyncClient::rebuildEdgeIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  auto ctx = rebuildEdgeIndexCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  rebuildEdgeIndexImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void StorageAdminServiceAsyncClient::rebuildEdgeIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      rebuildEdgeIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      rebuildEdgeIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> StorageAdminServiceAsyncClient::rebuildEdgeIndexCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "StorageAdminService.rebuildEdgeIndex");
}

void StorageAdminServiceAsyncClient::sync_rebuildEdgeIndex( ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_rebuildEdgeIndex(rpcOptions, _return, p_req);
}

void StorageAdminServiceAsyncClient::sync_rebuildEdgeIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = rebuildEdgeIndexCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  rebuildEdgeIndexImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_rebuildEdgeIndex(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_rebuildEdgeIndex(const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_rebuildEdgeIndex(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_rebuildEdgeIndex(const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_rebuildEdgeIndex(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_rebuildEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::AdminExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_rebuildEdgeIndex, channel_);
  rebuildEdgeIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_rebuildEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_rebuildEdgeIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  rebuildEdgeIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_future_rebuildEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_rebuildEdgeIndex, channel_);
  rebuildEdgeIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_semifuture_rebuildEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_rebuildEdgeIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  rebuildEdgeIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void StorageAdminServiceAsyncClient::rebuildEdgeIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::RebuildIndexRequest& p_req) {
  rebuildEdgeIndex(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper StorageAdminServiceAsyncClient::recv_wrapped_rebuildEdgeIndex( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = StorageAdminService_rebuildEdgeIndex_presult;
  constexpr auto const fname = "rebuildEdgeIndex";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void StorageAdminServiceAsyncClient::recv_rebuildEdgeIndex( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_rebuildEdgeIndex(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void StorageAdminServiceAsyncClient::recv_instance_rebuildEdgeIndex( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_rebuildEdgeIndex(_return, state);
}

folly::exception_wrapper StorageAdminServiceAsyncClient::recv_instance_wrapped_rebuildEdgeIndex( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_rebuildEdgeIndex(_return, state);
}

void StorageAdminServiceAsyncClient::getLeaderParts(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::GetLeaderReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  getLeaderParts(rpcOptions, std::move(callback), p_req);
}

void StorageAdminServiceAsyncClient::getLeaderParts(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::GetLeaderReq& p_req) {
  auto ctx = getLeaderPartsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  getLeaderPartsImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void StorageAdminServiceAsyncClient::getLeaderPartsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::GetLeaderReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getLeaderPartsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getLeaderPartsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> StorageAdminServiceAsyncClient::getLeaderPartsCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "StorageAdminService.getLeaderParts");
}

void StorageAdminServiceAsyncClient::sync_getLeaderParts( ::nebula::storage::cpp2::GetLeaderPartsResp& _return, const  ::nebula::storage::cpp2::GetLeaderReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getLeaderParts(rpcOptions, _return, p_req);
}

void StorageAdminServiceAsyncClient::sync_getLeaderParts(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::GetLeaderPartsResp& _return, const  ::nebula::storage::cpp2::GetLeaderReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = getLeaderPartsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  getLeaderPartsImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_getLeaderParts(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::GetLeaderPartsResp> StorageAdminServiceAsyncClient::future_getLeaderParts(const  ::nebula::storage::cpp2::GetLeaderReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getLeaderParts(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::GetLeaderPartsResp> StorageAdminServiceAsyncClient::semifuture_getLeaderParts(const  ::nebula::storage::cpp2::GetLeaderReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getLeaderParts(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::GetLeaderPartsResp> StorageAdminServiceAsyncClient::future_getLeaderParts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetLeaderReq& p_req) {
  folly::Promise< ::nebula::storage::cpp2::GetLeaderPartsResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::GetLeaderPartsResp>>(std::move(promise), recv_wrapped_getLeaderParts, channel_);
  getLeaderParts(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::GetLeaderPartsResp> StorageAdminServiceAsyncClient::semifuture_getLeaderParts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetLeaderReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getLeaderParts, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getLeaderParts(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::GetLeaderPartsResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_future_getLeaderParts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetLeaderReq& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::GetLeaderPartsResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::GetLeaderPartsResp>>(std::move(promise), recv_wrapped_getLeaderParts, channel_);
  getLeaderParts(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::GetLeaderPartsResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_semifuture_getLeaderParts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetLeaderReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getLeaderParts, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getLeaderParts(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void StorageAdminServiceAsyncClient::getLeaderParts(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::GetLeaderReq& p_req) {
  getLeaderParts(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper StorageAdminServiceAsyncClient::recv_wrapped_getLeaderParts( ::nebula::storage::cpp2::GetLeaderPartsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = StorageAdminService_getLeaderParts_presult;
  constexpr auto const fname = "getLeaderParts";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void StorageAdminServiceAsyncClient::recv_getLeaderParts( ::nebula::storage::cpp2::GetLeaderPartsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getLeaderParts(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void StorageAdminServiceAsyncClient::recv_instance_getLeaderParts( ::nebula::storage::cpp2::GetLeaderPartsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getLeaderParts(_return, state);
}

folly::exception_wrapper StorageAdminServiceAsyncClient::recv_instance_wrapped_getLeaderParts( ::nebula::storage::cpp2::GetLeaderPartsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getLeaderParts(_return, state);
}

void StorageAdminServiceAsyncClient::checkPeers(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::CheckPeersReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  checkPeers(rpcOptions, std::move(callback), p_req);
}

void StorageAdminServiceAsyncClient::checkPeers(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::CheckPeersReq& p_req) {
  auto ctx = checkPeersCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  checkPeersImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void StorageAdminServiceAsyncClient::checkPeersImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::CheckPeersReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      checkPeersT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      checkPeersT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> StorageAdminServiceAsyncClient::checkPeersCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "StorageAdminService.checkPeers");
}

void StorageAdminServiceAsyncClient::sync_checkPeers( ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::CheckPeersReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_checkPeers(rpcOptions, _return, p_req);
}

void StorageAdminServiceAsyncClient::sync_checkPeers(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::CheckPeersReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = checkPeersCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  checkPeersImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_checkPeers(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_checkPeers(const  ::nebula::storage::cpp2::CheckPeersReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_checkPeers(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_checkPeers(const  ::nebula::storage::cpp2::CheckPeersReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_checkPeers(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_checkPeers(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::CheckPeersReq& p_req) {
  folly::Promise< ::nebula::storage::cpp2::AdminExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_checkPeers, channel_);
  checkPeers(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_checkPeers(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::CheckPeersReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_checkPeers, channel_);
  auto callback = std::move(callbackAndFuture.first);
  checkPeers(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_future_checkPeers(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::CheckPeersReq& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_checkPeers, channel_);
  checkPeers(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_semifuture_checkPeers(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::CheckPeersReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_checkPeers, channel_);
  auto callback = std::move(callbackAndFuture.first);
  checkPeers(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void StorageAdminServiceAsyncClient::checkPeers(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::CheckPeersReq& p_req) {
  checkPeers(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper StorageAdminServiceAsyncClient::recv_wrapped_checkPeers( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = StorageAdminService_checkPeers_presult;
  constexpr auto const fname = "checkPeers";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void StorageAdminServiceAsyncClient::recv_checkPeers( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_checkPeers(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void StorageAdminServiceAsyncClient::recv_instance_checkPeers( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_checkPeers(_return, state);
}

folly::exception_wrapper StorageAdminServiceAsyncClient::recv_instance_wrapped_checkPeers( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_checkPeers(_return, state);
}

void StorageAdminServiceAsyncClient::addAdminTask(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::AddAdminTaskRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  addAdminTask(rpcOptions, std::move(callback), p_req);
}

void StorageAdminServiceAsyncClient::addAdminTask(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::AddAdminTaskRequest& p_req) {
  auto ctx = addAdminTaskCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  addAdminTaskImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void StorageAdminServiceAsyncClient::addAdminTaskImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::AddAdminTaskRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      addAdminTaskT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      addAdminTaskT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> StorageAdminServiceAsyncClient::addAdminTaskCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "StorageAdminService.addAdminTask");
}

void StorageAdminServiceAsyncClient::sync_addAdminTask( ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::AddAdminTaskRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_addAdminTask(rpcOptions, _return, p_req);
}

void StorageAdminServiceAsyncClient::sync_addAdminTask(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::AddAdminTaskRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = addAdminTaskCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  addAdminTaskImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_addAdminTask(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_addAdminTask(const  ::nebula::storage::cpp2::AddAdminTaskRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_addAdminTask(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_addAdminTask(const  ::nebula::storage::cpp2::AddAdminTaskRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_addAdminTask(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_addAdminTask(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddAdminTaskRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::AdminExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_addAdminTask, channel_);
  addAdminTask(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_addAdminTask(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddAdminTaskRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_addAdminTask, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addAdminTask(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_future_addAdminTask(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddAdminTaskRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_addAdminTask, channel_);
  addAdminTask(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_semifuture_addAdminTask(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddAdminTaskRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_addAdminTask, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addAdminTask(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void StorageAdminServiceAsyncClient::addAdminTask(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::AddAdminTaskRequest& p_req) {
  addAdminTask(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper StorageAdminServiceAsyncClient::recv_wrapped_addAdminTask( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = StorageAdminService_addAdminTask_presult;
  constexpr auto const fname = "addAdminTask";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void StorageAdminServiceAsyncClient::recv_addAdminTask( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_addAdminTask(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void StorageAdminServiceAsyncClient::recv_instance_addAdminTask( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_addAdminTask(_return, state);
}

folly::exception_wrapper StorageAdminServiceAsyncClient::recv_instance_wrapped_addAdminTask( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_addAdminTask(_return, state);
}

void StorageAdminServiceAsyncClient::stopAdminTask(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::StopAdminTaskRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  stopAdminTask(rpcOptions, std::move(callback), p_req);
}

void StorageAdminServiceAsyncClient::stopAdminTask(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::StopAdminTaskRequest& p_req) {
  auto ctx = stopAdminTaskCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  stopAdminTaskImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void StorageAdminServiceAsyncClient::stopAdminTaskImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::StopAdminTaskRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      stopAdminTaskT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      stopAdminTaskT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> StorageAdminServiceAsyncClient::stopAdminTaskCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "StorageAdminService.stopAdminTask");
}

void StorageAdminServiceAsyncClient::sync_stopAdminTask( ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::StopAdminTaskRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_stopAdminTask(rpcOptions, _return, p_req);
}

void StorageAdminServiceAsyncClient::sync_stopAdminTask(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::AdminExecResp& _return, const  ::nebula::storage::cpp2::StopAdminTaskRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = stopAdminTaskCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  stopAdminTaskImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_stopAdminTask(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_stopAdminTask(const  ::nebula::storage::cpp2::StopAdminTaskRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_stopAdminTask(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_stopAdminTask(const  ::nebula::storage::cpp2::StopAdminTaskRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_stopAdminTask(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::future_stopAdminTask(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::StopAdminTaskRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::AdminExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_stopAdminTask, channel_);
  stopAdminTask(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::AdminExecResp> StorageAdminServiceAsyncClient::semifuture_stopAdminTask(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::StopAdminTaskRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_stopAdminTask, channel_);
  auto callback = std::move(callbackAndFuture.first);
  stopAdminTask(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_future_stopAdminTask(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::StopAdminTaskRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(promise), recv_wrapped_stopAdminTask, channel_);
  stopAdminTask(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::AdminExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_semifuture_stopAdminTask(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::StopAdminTaskRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_stopAdminTask, channel_);
  auto callback = std::move(callbackAndFuture.first);
  stopAdminTask(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void StorageAdminServiceAsyncClient::stopAdminTask(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::StopAdminTaskRequest& p_req) {
  stopAdminTask(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper StorageAdminServiceAsyncClient::recv_wrapped_stopAdminTask( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = StorageAdminService_stopAdminTask_presult;
  constexpr auto const fname = "stopAdminTask";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void StorageAdminServiceAsyncClient::recv_stopAdminTask( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_stopAdminTask(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void StorageAdminServiceAsyncClient::recv_instance_stopAdminTask( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_stopAdminTask(_return, state);
}

folly::exception_wrapper StorageAdminServiceAsyncClient::recv_instance_wrapped_stopAdminTask( ::nebula::storage::cpp2::AdminExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_stopAdminTask(_return, state);
}

void StorageAdminServiceAsyncClient::listClusterInfo(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::ListClusterInfoReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listClusterInfo(rpcOptions, std::move(callback), p_req);
}

void StorageAdminServiceAsyncClient::listClusterInfo(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::ListClusterInfoReq& p_req) {
  auto ctx = listClusterInfoCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listClusterInfoImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void StorageAdminServiceAsyncClient::listClusterInfoImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::ListClusterInfoReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listClusterInfoT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listClusterInfoT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> StorageAdminServiceAsyncClient::listClusterInfoCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "StorageAdminService.listClusterInfo");
}

void StorageAdminServiceAsyncClient::sync_listClusterInfo( ::nebula::storage::cpp2::ListClusterInfoResp& _return, const  ::nebula::storage::cpp2::ListClusterInfoReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listClusterInfo(rpcOptions, _return, p_req);
}

void StorageAdminServiceAsyncClient::sync_listClusterInfo(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ListClusterInfoResp& _return, const  ::nebula::storage::cpp2::ListClusterInfoReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listClusterInfoCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listClusterInfoImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listClusterInfo(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::ListClusterInfoResp> StorageAdminServiceAsyncClient::future_listClusterInfo(const  ::nebula::storage::cpp2::ListClusterInfoReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listClusterInfo(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::ListClusterInfoResp> StorageAdminServiceAsyncClient::semifuture_listClusterInfo(const  ::nebula::storage::cpp2::ListClusterInfoReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listClusterInfo(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::ListClusterInfoResp> StorageAdminServiceAsyncClient::future_listClusterInfo(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ListClusterInfoReq& p_req) {
  folly::Promise< ::nebula::storage::cpp2::ListClusterInfoResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::ListClusterInfoResp>>(std::move(promise), recv_wrapped_listClusterInfo, channel_);
  listClusterInfo(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::ListClusterInfoResp> StorageAdminServiceAsyncClient::semifuture_listClusterInfo(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ListClusterInfoReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listClusterInfo, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listClusterInfo(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::ListClusterInfoResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_future_listClusterInfo(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ListClusterInfoReq& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::ListClusterInfoResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::ListClusterInfoResp>>(std::move(promise), recv_wrapped_listClusterInfo, channel_);
  listClusterInfo(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ListClusterInfoResp, std::unique_ptr<apache::thrift::transport::THeader>>> StorageAdminServiceAsyncClient::header_semifuture_listClusterInfo(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ListClusterInfoReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listClusterInfo, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listClusterInfo(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void StorageAdminServiceAsyncClient::listClusterInfo(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::ListClusterInfoReq& p_req) {
  listClusterInfo(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper StorageAdminServiceAsyncClient::recv_wrapped_listClusterInfo( ::nebula::storage::cpp2::ListClusterInfoResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = StorageAdminService_listClusterInfo_presult;
  constexpr auto const fname = "listClusterInfo";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void StorageAdminServiceAsyncClient::recv_listClusterInfo( ::nebula::storage::cpp2::ListClusterInfoResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listClusterInfo(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void StorageAdminServiceAsyncClient::recv_instance_listClusterInfo( ::nebula::storage::cpp2::ListClusterInfoResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listClusterInfo(_return, state);
}

folly::exception_wrapper StorageAdminServiceAsyncClient::recv_instance_wrapped_listClusterInfo( ::nebula::storage::cpp2::ListClusterInfoResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listClusterInfo(_return, state);
}


}}} // nebula::storage::cpp2
