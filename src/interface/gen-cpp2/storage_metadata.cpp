/**
 * Autogenerated by Thrift for storage.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include <thrift/lib/cpp2/gen/module_metadata_cpp.h>
#include "storage_metadata.h"

namespace apache {
namespace thrift {
namespace detail {
namespace md {
using ThriftMetadata = ::apache::thrift::metadata::ThriftMetadata;
using ThriftPrimitiveType = ::apache::thrift::metadata::ThriftPrimitiveType;
using ThriftType = ::apache::thrift::metadata::ThriftType;
using ThriftService = ::apache::thrift::metadata::ThriftService;
using ThriftServiceContext = ::apache::thrift::metadata::ThriftServiceContext;
using ThriftFunctionGenerator = void (*)(ThriftMetadata&, ThriftService&);

void EnumMetadata<::nebula::storage::cpp2::StatType>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("storage.StatType", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "storage.StatType";
  using EnumTraits = TEnumTraits<::nebula::storage::cpp2::StatType>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::storage::cpp2::OrderDirection>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("storage.OrderDirection", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "storage.OrderDirection";
  using EnumTraits = TEnumTraits<::nebula::storage::cpp2::OrderDirection>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::storage::cpp2::EdgeDirection>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("storage.EdgeDirection", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "storage.EdgeDirection";
  using EnumTraits = TEnumTraits<::nebula::storage::cpp2::EdgeDirection>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::storage::cpp2::ScanType>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("storage.ScanType", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "storage.ScanType";
  using EnumTraits = TEnumTraits<::nebula::storage::cpp2::ScanType>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::storage::cpp2::EngineSignType>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("storage.EngineSignType", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "storage.EngineSignType";
  using EnumTraits = TEnumTraits<::nebula::storage::cpp2::EngineSignType>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}

const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::RequestCommon>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.RequestCommon", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_RequestCommon = res.first->second;
  storage_RequestCommon.name_ref() = "storage.RequestCommon";
  storage_RequestCommon.is_union_ref() = false;
  static const EncodedThriftField
  storage_RequestCommon_fields[] = {
    std::make_tuple(1, "session_id", true, std::make_unique<Typedef>("common.SessionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "plan_id", true, std::make_unique<Typedef>("common.ExecutionPlanID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "profile_detail", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_RequestCommon_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_RequestCommon.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::PartitionResult>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.PartitionResult", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_PartitionResult = res.first->second;
  storage_PartitionResult.name_ref() = "storage.PartitionResult";
  storage_PartitionResult.is_union_ref() = false;
  static const EncodedThriftField
  storage_PartitionResult_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "part_id", false, std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "leader", true, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_PartitionResult_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_PartitionResult.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::ResponseCommon>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.ResponseCommon", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_ResponseCommon = res.first->second;
  storage_ResponseCommon.name_ref() = "storage.ResponseCommon";
  storage_ResponseCommon.is_union_ref() = false;
  static const EncodedThriftField
  storage_ResponseCommon_fields[] = {
    std::make_tuple(1, "failed_parts", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::PartitionResult>>("storage.PartitionResult")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "latency_in_us", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "latency_detail_us", true, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_ResponseCommon_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_ResponseCommon.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::StatProp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.StatProp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_StatProp = res.first->second;
  storage_StatProp.name_ref() = "storage.StatProp";
  storage_StatProp.is_union_ref() = false;
  static const EncodedThriftField
  storage_StatProp_fields[] = {
    std::make_tuple(1, "alias", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "prop", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "stat", false, std::make_unique<Enum< ::nebula::storage::cpp2::StatType>>("storage.StatType"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_StatProp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_StatProp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::Expr>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.Expr", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_Expr = res.first->second;
  storage_Expr.name_ref() = "storage.Expr";
  storage_Expr.is_union_ref() = false;
  static const EncodedThriftField
  storage_Expr_fields[] = {
    std::make_tuple(1, "alias", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "expr", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_Expr_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_Expr.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::EdgeProp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.EdgeProp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_EdgeProp = res.first->second;
  storage_EdgeProp.name_ref() = "storage.EdgeProp";
  storage_EdgeProp.is_union_ref() = false;
  static const EncodedThriftField
  storage_EdgeProp_fields[] = {
    std::make_tuple(1, "type", false, std::make_unique<Typedef>("common.EdgeType", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "props", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_EdgeProp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_EdgeProp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::VertexProp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.VertexProp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_VertexProp = res.first->second;
  storage_VertexProp.name_ref() = "storage.VertexProp";
  storage_VertexProp.is_union_ref() = false;
  static const EncodedThriftField
  storage_VertexProp_fields[] = {
    std::make_tuple(1, "tag", false, std::make_unique<Typedef>("common.TagID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "props", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_VertexProp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_VertexProp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::OrderBy>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.OrderBy", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_OrderBy = res.first->second;
  storage_OrderBy.name_ref() = "storage.OrderBy";
  storage_OrderBy.is_union_ref() = false;
  static const EncodedThriftField
  storage_OrderBy_fields[] = {
    std::make_tuple(1, "prop", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "direction", false, std::make_unique<Enum< ::nebula::storage::cpp2::OrderDirection>>("storage.OrderDirection"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_OrderBy_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_OrderBy.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::TraverseSpec>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.TraverseSpec", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_TraverseSpec = res.first->second;
  storage_TraverseSpec.name_ref() = "storage.TraverseSpec";
  storage_TraverseSpec.is_union_ref() = false;
  static const EncodedThriftField
  storage_TraverseSpec_fields[] = {
    std::make_tuple(1, "edge_types", false, std::make_unique<List>(std::make_unique<Typedef>("common.EdgeType", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "edge_direction", false, std::make_unique<Enum< ::nebula::storage::cpp2::EdgeDirection>>("storage.EdgeDirection"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "dedup", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "stat_props", true, std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::StatProp>>("storage.StatProp")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "vertex_props", true, std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::VertexProp>>("storage.VertexProp")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "edge_props", true, std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::EdgeProp>>("storage.EdgeProp")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(7, "expressions", true, std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::Expr>>("storage.Expr")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(8, "order_by", true, std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::OrderBy>>("storage.OrderBy")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(9, "random", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(10, "limit", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(11, "filter", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_TraverseSpec_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_TraverseSpec.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::GetNeighborsRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.GetNeighborsRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_GetNeighborsRequest = res.first->second;
  storage_GetNeighborsRequest.name_ref() = "storage.GetNeighborsRequest";
  storage_GetNeighborsRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_GetNeighborsRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "column_names", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "parts", false, std::make_unique<Map>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::Row>>("common.Row"))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "traverse_spec", false, std::make_unique<Struct< ::nebula::storage::cpp2::TraverseSpec>>("storage.TraverseSpec"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "common", true, std::make_unique<Struct< ::nebula::storage::cpp2::RequestCommon>>("storage.RequestCommon"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_GetNeighborsRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_GetNeighborsRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::GetNeighborsResponse>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.GetNeighborsResponse", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_GetNeighborsResponse = res.first->second;
  storage_GetNeighborsResponse.name_ref() = "storage.GetNeighborsResponse";
  storage_GetNeighborsResponse.is_union_ref() = false;
  static const EncodedThriftField
  storage_GetNeighborsResponse_fields[] = {
    std::make_tuple(1, "result", false, std::make_unique<Struct< ::nebula::storage::cpp2::ResponseCommon>>("storage.ResponseCommon"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "vertices", true, std::make_unique<Struct< ::nebula::cpp2::DataSet>>("common.DataSet"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_GetNeighborsResponse_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_GetNeighborsResponse.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::ExecResponse>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.ExecResponse", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_ExecResponse = res.first->second;
  storage_ExecResponse.name_ref() = "storage.ExecResponse";
  storage_ExecResponse.is_union_ref() = false;
  static const EncodedThriftField
  storage_ExecResponse_fields[] = {
    std::make_tuple(1, "result", false, std::make_unique<Struct< ::nebula::storage::cpp2::ResponseCommon>>("storage.ResponseCommon"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_ExecResponse_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_ExecResponse.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::GetPropRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.GetPropRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_GetPropRequest = res.first->second;
  storage_GetPropRequest.name_ref() = "storage.GetPropRequest";
  storage_GetPropRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_GetPropRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "parts", false, std::make_unique<Map>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::Row>>("common.Row"))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "vertex_props", true, std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::VertexProp>>("storage.VertexProp")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "edge_props", true, std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::EdgeProp>>("storage.EdgeProp")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "expressions", true, std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::Expr>>("storage.Expr")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "dedup", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(7, "order_by", true, std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::OrderBy>>("storage.OrderBy")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(8, "limit", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(9, "filter", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(10, "common", true, std::make_unique<Struct< ::nebula::storage::cpp2::RequestCommon>>("storage.RequestCommon"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_GetPropRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_GetPropRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::GetPropResponse>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.GetPropResponse", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_GetPropResponse = res.first->second;
  storage_GetPropResponse.name_ref() = "storage.GetPropResponse";
  storage_GetPropResponse.is_union_ref() = false;
  static const EncodedThriftField
  storage_GetPropResponse_fields[] = {
    std::make_tuple(1, "result", false, std::make_unique<Struct< ::nebula::storage::cpp2::ResponseCommon>>("storage.ResponseCommon"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "props", true, std::make_unique<Struct< ::nebula::cpp2::DataSet>>("common.DataSet"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_GetPropResponse_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_GetPropResponse.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::NewTag>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.NewTag", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_NewTag = res.first->second;
  storage_NewTag.name_ref() = "storage.NewTag";
  storage_NewTag.is_union_ref() = false;
  static const EncodedThriftField
  storage_NewTag_fields[] = {
    std::make_tuple(1, "tag_id", false, std::make_unique<Typedef>("common.TagID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "props", false, std::make_unique<List>(std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_NewTag_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_NewTag.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::NewVertex>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.NewVertex", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_NewVertex = res.first->second;
  storage_NewVertex.name_ref() = "storage.NewVertex";
  storage_NewVertex.is_union_ref() = false;
  static const EncodedThriftField
  storage_NewVertex_fields[] = {
    std::make_tuple(1, "id", false, std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "tags", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::NewTag>>("storage.NewTag")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_NewVertex_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_NewVertex.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::EdgeKey>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.EdgeKey", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_EdgeKey = res.first->second;
  storage_EdgeKey.name_ref() = "storage.EdgeKey";
  storage_EdgeKey.is_union_ref() = false;
  static const EncodedThriftField
  storage_EdgeKey_fields[] = {
    std::make_tuple(1, "src", false, std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "edge_type", false, std::make_unique<Typedef>("common.EdgeType", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "ranking", false, std::make_unique<Typedef>("common.EdgeRanking", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "dst", false, std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_EdgeKey_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_EdgeKey.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::NewEdge>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.NewEdge", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_NewEdge = res.first->second;
  storage_NewEdge.name_ref() = "storage.NewEdge";
  storage_NewEdge.is_union_ref() = false;
  static const EncodedThriftField
  storage_NewEdge_fields[] = {
    std::make_tuple(1, "key", false, std::make_unique<Struct< ::nebula::storage::cpp2::EdgeKey>>("storage.EdgeKey"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "props", false, std::make_unique<List>(std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_NewEdge_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_NewEdge.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::AddVerticesRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.AddVerticesRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_AddVerticesRequest = res.first->second;
  storage_AddVerticesRequest.name_ref() = "storage.AddVerticesRequest";
  storage_AddVerticesRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_AddVerticesRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "parts", false, std::make_unique<Map>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::NewVertex>>("storage.NewVertex"))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "prop_names", false, std::make_unique<Map>(std::make_unique<Typedef>("common.TagID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "if_not_exists", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "common", true, std::make_unique<Struct< ::nebula::storage::cpp2::RequestCommon>>("storage.RequestCommon"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_AddVerticesRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_AddVerticesRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::AddEdgesRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.AddEdgesRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_AddEdgesRequest = res.first->second;
  storage_AddEdgesRequest.name_ref() = "storage.AddEdgesRequest";
  storage_AddEdgesRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_AddEdgesRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "parts", false, std::make_unique<Map>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::NewEdge>>("storage.NewEdge"))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "prop_names", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "if_not_exists", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "common", true, std::make_unique<Struct< ::nebula::storage::cpp2::RequestCommon>>("storage.RequestCommon"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_AddEdgesRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_AddEdgesRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::DeleteVerticesRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.DeleteVerticesRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_DeleteVerticesRequest = res.first->second;
  storage_DeleteVerticesRequest.name_ref() = "storage.DeleteVerticesRequest";
  storage_DeleteVerticesRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_DeleteVerticesRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "parts", false, std::make_unique<Map>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<List>(std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value"))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "common", true, std::make_unique<Struct< ::nebula::storage::cpp2::RequestCommon>>("storage.RequestCommon"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_DeleteVerticesRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_DeleteVerticesRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::DeleteEdgesRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.DeleteEdgesRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_DeleteEdgesRequest = res.first->second;
  storage_DeleteEdgesRequest.name_ref() = "storage.DeleteEdgesRequest";
  storage_DeleteEdgesRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_DeleteEdgesRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "parts", false, std::make_unique<Map>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::EdgeKey>>("storage.EdgeKey"))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "common", true, std::make_unique<Struct< ::nebula::storage::cpp2::RequestCommon>>("storage.RequestCommon"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_DeleteEdgesRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_DeleteEdgesRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::DelTags>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.DelTags", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_DelTags = res.first->second;
  storage_DelTags.name_ref() = "storage.DelTags";
  storage_DelTags.is_union_ref() = false;
  static const EncodedThriftField
  storage_DelTags_fields[] = {
    std::make_tuple(1, "id", false, std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "tags", false, std::make_unique<List>(std::make_unique<Typedef>("common.TagID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE))), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_DelTags_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_DelTags.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::DeleteTagsRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.DeleteTagsRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_DeleteTagsRequest = res.first->second;
  storage_DeleteTagsRequest.name_ref() = "storage.DeleteTagsRequest";
  storage_DeleteTagsRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_DeleteTagsRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "parts", false, std::make_unique<Map>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::DelTags>>("storage.DelTags"))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "common", true, std::make_unique<Struct< ::nebula::storage::cpp2::RequestCommon>>("storage.RequestCommon"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_DeleteTagsRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_DeleteTagsRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::UpdateResponse>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.UpdateResponse", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_UpdateResponse = res.first->second;
  storage_UpdateResponse.name_ref() = "storage.UpdateResponse";
  storage_UpdateResponse.is_union_ref() = false;
  static const EncodedThriftField
  storage_UpdateResponse_fields[] = {
    std::make_tuple(1, "result", false, std::make_unique<Struct< ::nebula::storage::cpp2::ResponseCommon>>("storage.ResponseCommon"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "props", true, std::make_unique<Struct< ::nebula::cpp2::DataSet>>("common.DataSet"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_UpdateResponse_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_UpdateResponse.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::UpdatedProp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.UpdatedProp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_UpdatedProp = res.first->second;
  storage_UpdatedProp.name_ref() = "storage.UpdatedProp";
  storage_UpdatedProp.is_union_ref() = false;
  static const EncodedThriftField
  storage_UpdatedProp_fields[] = {
    std::make_tuple(1, "name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "value", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_UpdatedProp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_UpdatedProp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::UpdateVertexRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.UpdateVertexRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_UpdateVertexRequest = res.first->second;
  storage_UpdateVertexRequest.name_ref() = "storage.UpdateVertexRequest";
  storage_UpdateVertexRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_UpdateVertexRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "part_id", false, std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "vertex_id", false, std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "tag_id", false, std::make_unique<Typedef>("common.TagID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "updated_props", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::UpdatedProp>>("storage.UpdatedProp")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "insertable", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(7, "return_props", true, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(8, "condition", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(9, "common", true, std::make_unique<Struct< ::nebula::storage::cpp2::RequestCommon>>("storage.RequestCommon"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_UpdateVertexRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_UpdateVertexRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::UpdateEdgeRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.UpdateEdgeRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_UpdateEdgeRequest = res.first->second;
  storage_UpdateEdgeRequest.name_ref() = "storage.UpdateEdgeRequest";
  storage_UpdateEdgeRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_UpdateEdgeRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "part_id", false, std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "edge_key", false, std::make_unique<Struct< ::nebula::storage::cpp2::EdgeKey>>("storage.EdgeKey"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "updated_props", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::UpdatedProp>>("storage.UpdatedProp")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "insertable", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "return_props", true, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(7, "condition", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(8, "common", true, std::make_unique<Struct< ::nebula::storage::cpp2::RequestCommon>>("storage.RequestCommon"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_UpdateEdgeRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_UpdateEdgeRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::GetUUIDReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.GetUUIDReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_GetUUIDReq = res.first->second;
  storage_GetUUIDReq.name_ref() = "storage.GetUUIDReq";
  storage_GetUUIDReq.is_union_ref() = false;
  static const EncodedThriftField
  storage_GetUUIDReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "part_id", false, std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "common", true, std::make_unique<Struct< ::nebula::storage::cpp2::RequestCommon>>("storage.RequestCommon"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_GetUUIDReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_GetUUIDReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::GetUUIDResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.GetUUIDResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_GetUUIDResp = res.first->second;
  storage_GetUUIDResp.name_ref() = "storage.GetUUIDResp";
  storage_GetUUIDResp.is_union_ref() = false;
  static const EncodedThriftField
  storage_GetUUIDResp_fields[] = {
    std::make_tuple(1, "result", false, std::make_unique<Struct< ::nebula::storage::cpp2::ResponseCommon>>("storage.ResponseCommon"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "id", false, std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_GetUUIDResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_GetUUIDResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::LookupIndexResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.LookupIndexResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_LookupIndexResp = res.first->second;
  storage_LookupIndexResp.name_ref() = "storage.LookupIndexResp";
  storage_LookupIndexResp.is_union_ref() = false;
  static const EncodedThriftField
  storage_LookupIndexResp_fields[] = {
    std::make_tuple(1, "result", false, std::make_unique<Struct< ::nebula::storage::cpp2::ResponseCommon>>("storage.ResponseCommon"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "data", true, std::make_unique<Struct< ::nebula::cpp2::DataSet>>("common.DataSet"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_LookupIndexResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_LookupIndexResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::IndexColumnHint>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.IndexColumnHint", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_IndexColumnHint = res.first->second;
  storage_IndexColumnHint.name_ref() = "storage.IndexColumnHint";
  storage_IndexColumnHint.is_union_ref() = false;
  static const EncodedThriftField
  storage_IndexColumnHint_fields[] = {
    std::make_tuple(1, "column_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "scan_type", false, std::make_unique<Enum< ::nebula::storage::cpp2::ScanType>>("storage.ScanType"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "begin_value", false, std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "end_value", false, std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_IndexColumnHint_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_IndexColumnHint.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::IndexQueryContext>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.IndexQueryContext", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_IndexQueryContext = res.first->second;
  storage_IndexQueryContext.name_ref() = "storage.IndexQueryContext";
  storage_IndexQueryContext.is_union_ref() = false;
  static const EncodedThriftField
  storage_IndexQueryContext_fields[] = {
    std::make_tuple(1, "index_id", false, std::make_unique<Typedef>("common.IndexID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "filter", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "column_hints", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::IndexColumnHint>>("storage.IndexColumnHint")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_IndexQueryContext_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_IndexQueryContext.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::IndexSpec>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.IndexSpec", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_IndexSpec = res.first->second;
  storage_IndexSpec.name_ref() = "storage.IndexSpec";
  storage_IndexSpec.is_union_ref() = false;
  static const EncodedThriftField
  storage_IndexSpec_fields[] = {
    std::make_tuple(1, "contexts", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::IndexQueryContext>>("storage.IndexQueryContext")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "schema_id", false, std::make_unique<Union< ::nebula::cpp2::SchemaID>>("common.SchemaID"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_IndexSpec_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_IndexSpec.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::LookupIndexRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.LookupIndexRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_LookupIndexRequest = res.first->second;
  storage_LookupIndexRequest.name_ref() = "storage.LookupIndexRequest";
  storage_LookupIndexRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_LookupIndexRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "parts", false, std::make_unique<List>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "indices", false, std::make_unique<Struct< ::nebula::storage::cpp2::IndexSpec>>("storage.IndexSpec"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "return_columns", true, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "common", true, std::make_unique<Struct< ::nebula::storage::cpp2::RequestCommon>>("storage.RequestCommon"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "limit", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_LookupIndexRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_LookupIndexRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::LookupAndTraverseRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.LookupAndTraverseRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_LookupAndTraverseRequest = res.first->second;
  storage_LookupAndTraverseRequest.name_ref() = "storage.LookupAndTraverseRequest";
  storage_LookupAndTraverseRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_LookupAndTraverseRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "parts", false, std::make_unique<List>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "indices", false, std::make_unique<Struct< ::nebula::storage::cpp2::IndexSpec>>("storage.IndexSpec"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "traverse_spec", false, std::make_unique<Struct< ::nebula::storage::cpp2::TraverseSpec>>("storage.TraverseSpec"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "common", true, std::make_unique<Struct< ::nebula::storage::cpp2::RequestCommon>>("storage.RequestCommon"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_LookupAndTraverseRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_LookupAndTraverseRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::ScanVertexRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.ScanVertexRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_ScanVertexRequest = res.first->second;
  storage_ScanVertexRequest.name_ref() = "storage.ScanVertexRequest";
  storage_ScanVertexRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_ScanVertexRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "part_id", false, std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "cursor", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "return_columns", false, std::make_unique<Struct< ::nebula::storage::cpp2::VertexProp>>("storage.VertexProp"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "limit", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "start_time", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(7, "end_time", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(8, "filter", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(9, "only_latest_version", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(10, "enable_read_from_follower", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(11, "common", true, std::make_unique<Struct< ::nebula::storage::cpp2::RequestCommon>>("storage.RequestCommon"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_ScanVertexRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_ScanVertexRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::ScanVertexResponse>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.ScanVertexResponse", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_ScanVertexResponse = res.first->second;
  storage_ScanVertexResponse.name_ref() = "storage.ScanVertexResponse";
  storage_ScanVertexResponse.is_union_ref() = false;
  static const EncodedThriftField
  storage_ScanVertexResponse_fields[] = {
    std::make_tuple(1, "result", false, std::make_unique<Struct< ::nebula::storage::cpp2::ResponseCommon>>("storage.ResponseCommon"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "vertex_data", false, std::make_unique<Struct< ::nebula::cpp2::DataSet>>("common.DataSet"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "has_next", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "next_cursor", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_ScanVertexResponse_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_ScanVertexResponse.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::ScanEdgeRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.ScanEdgeRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_ScanEdgeRequest = res.first->second;
  storage_ScanEdgeRequest.name_ref() = "storage.ScanEdgeRequest";
  storage_ScanEdgeRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_ScanEdgeRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "part_id", false, std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "cursor", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "return_columns", false, std::make_unique<Struct< ::nebula::storage::cpp2::EdgeProp>>("storage.EdgeProp"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "limit", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "start_time", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(7, "end_time", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(8, "filter", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(9, "only_latest_version", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(10, "enable_read_from_follower", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(11, "common", true, std::make_unique<Struct< ::nebula::storage::cpp2::RequestCommon>>("storage.RequestCommon"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_ScanEdgeRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_ScanEdgeRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::ScanEdgeResponse>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.ScanEdgeResponse", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_ScanEdgeResponse = res.first->second;
  storage_ScanEdgeResponse.name_ref() = "storage.ScanEdgeResponse";
  storage_ScanEdgeResponse.is_union_ref() = false;
  static const EncodedThriftField
  storage_ScanEdgeResponse_fields[] = {
    std::make_tuple(1, "result", false, std::make_unique<Struct< ::nebula::storage::cpp2::ResponseCommon>>("storage.ResponseCommon"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "edge_data", false, std::make_unique<Struct< ::nebula::cpp2::DataSet>>("common.DataSet"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "has_next", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "next_cursor", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_ScanEdgeResponse_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_ScanEdgeResponse.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::TaskPara>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.TaskPara", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_TaskPara = res.first->second;
  storage_TaskPara.name_ref() = "storage.TaskPara";
  storage_TaskPara.is_union_ref() = false;
  static const EncodedThriftField
  storage_TaskPara_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "parts", true, std::make_unique<List>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "task_specfic_paras", true, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_TaskPara_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_TaskPara.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::AddAdminTaskRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.AddAdminTaskRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_AddAdminTaskRequest = res.first->second;
  storage_AddAdminTaskRequest.name_ref() = "storage.AddAdminTaskRequest";
  storage_AddAdminTaskRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_AddAdminTaskRequest_fields[] = {
    std::make_tuple(1, "cmd", false, std::make_unique<Enum< ::nebula::meta::cpp2::AdminCmd>>("meta.AdminCmd"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "job_id", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "task_id", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "para", false, std::make_unique<Struct< ::nebula::storage::cpp2::TaskPara>>("storage.TaskPara"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "concurrency", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_AddAdminTaskRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_AddAdminTaskRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::StopAdminTaskRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.StopAdminTaskRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_StopAdminTaskRequest = res.first->second;
  storage_StopAdminTaskRequest.name_ref() = "storage.StopAdminTaskRequest";
  storage_StopAdminTaskRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_StopAdminTaskRequest_fields[] = {
    std::make_tuple(1, "job_id", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "task_id", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_StopAdminTaskRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_StopAdminTaskRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::AdminExecResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.AdminExecResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_AdminExecResp = res.first->second;
  storage_AdminExecResp.name_ref() = "storage.AdminExecResp";
  storage_AdminExecResp.is_union_ref() = false;
  static const EncodedThriftField
  storage_AdminExecResp_fields[] = {
    std::make_tuple(1, "result", false, std::make_unique<Struct< ::nebula::storage::cpp2::ResponseCommon>>("storage.ResponseCommon"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "stats", true, std::make_unique<Struct< ::nebula::meta::cpp2::StatsItem>>("meta.StatsItem"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_AdminExecResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_AdminExecResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::TransLeaderReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.TransLeaderReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_TransLeaderReq = res.first->second;
  storage_TransLeaderReq.name_ref() = "storage.TransLeaderReq";
  storage_TransLeaderReq.is_union_ref() = false;
  static const EncodedThriftField
  storage_TransLeaderReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "part_id", false, std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "new_leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_TransLeaderReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_TransLeaderReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::AddPartReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.AddPartReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_AddPartReq = res.first->second;
  storage_AddPartReq.name_ref() = "storage.AddPartReq";
  storage_AddPartReq.is_union_ref() = false;
  static const EncodedThriftField
  storage_AddPartReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "part_id", false, std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "as_learner", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "peers", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_AddPartReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_AddPartReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::AddLearnerReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.AddLearnerReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_AddLearnerReq = res.first->second;
  storage_AddLearnerReq.name_ref() = "storage.AddLearnerReq";
  storage_AddLearnerReq.is_union_ref() = false;
  static const EncodedThriftField
  storage_AddLearnerReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "part_id", false, std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "learner", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_AddLearnerReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_AddLearnerReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::RemovePartReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.RemovePartReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_RemovePartReq = res.first->second;
  storage_RemovePartReq.name_ref() = "storage.RemovePartReq";
  storage_RemovePartReq.is_union_ref() = false;
  static const EncodedThriftField
  storage_RemovePartReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "part_id", false, std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_RemovePartReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_RemovePartReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::MemberChangeReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.MemberChangeReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_MemberChangeReq = res.first->second;
  storage_MemberChangeReq.name_ref() = "storage.MemberChangeReq";
  storage_MemberChangeReq.is_union_ref() = false;
  static const EncodedThriftField
  storage_MemberChangeReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "part_id", false, std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "peer", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "add", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_MemberChangeReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_MemberChangeReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::CatchUpDataReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.CatchUpDataReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_CatchUpDataReq = res.first->second;
  storage_CatchUpDataReq.name_ref() = "storage.CatchUpDataReq";
  storage_CatchUpDataReq.is_union_ref() = false;
  static const EncodedThriftField
  storage_CatchUpDataReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "part_id", false, std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "target", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_CatchUpDataReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_CatchUpDataReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::GetLeaderReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.GetLeaderReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_GetLeaderReq = res.first->second;
  storage_GetLeaderReq.name_ref() = "storage.GetLeaderReq";
  storage_GetLeaderReq.is_union_ref() = false;
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::CreateCPRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.CreateCPRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_CreateCPRequest = res.first->second;
  storage_CreateCPRequest.name_ref() = "storage.CreateCPRequest";
  storage_CreateCPRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_CreateCPRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_CreateCPRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_CreateCPRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::DropCPRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.DropCPRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_DropCPRequest = res.first->second;
  storage_DropCPRequest.name_ref() = "storage.DropCPRequest";
  storage_DropCPRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_DropCPRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_DropCPRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_DropCPRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::BlockingSignRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.BlockingSignRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_BlockingSignRequest = res.first->second;
  storage_BlockingSignRequest.name_ref() = "storage.BlockingSignRequest";
  storage_BlockingSignRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_BlockingSignRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "sign", false, std::make_unique<Enum< ::nebula::storage::cpp2::EngineSignType>>("storage.EngineSignType"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_BlockingSignRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_BlockingSignRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::GetLeaderPartsResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.GetLeaderPartsResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_GetLeaderPartsResp = res.first->second;
  storage_GetLeaderPartsResp.name_ref() = "storage.GetLeaderPartsResp";
  storage_GetLeaderPartsResp.is_union_ref() = false;
  static const EncodedThriftField
  storage_GetLeaderPartsResp_fields[] = {
    std::make_tuple(1, "result", false, std::make_unique<Struct< ::nebula::storage::cpp2::ResponseCommon>>("storage.ResponseCommon"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader_parts", false, std::make_unique<Map>(std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<List>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)))), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_GetLeaderPartsResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_GetLeaderPartsResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::CheckPeersReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.CheckPeersReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_CheckPeersReq = res.first->second;
  storage_CheckPeersReq.name_ref() = "storage.CheckPeersReq";
  storage_CheckPeersReq.is_union_ref() = false;
  static const EncodedThriftField
  storage_CheckPeersReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "part_id", false, std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "peers", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_CheckPeersReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_CheckPeersReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::RebuildIndexRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.RebuildIndexRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_RebuildIndexRequest = res.first->second;
  storage_RebuildIndexRequest.name_ref() = "storage.RebuildIndexRequest";
  storage_RebuildIndexRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_RebuildIndexRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "parts", false, std::make_unique<List>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "index_id", false, std::make_unique<Typedef>("common.IndexID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_RebuildIndexRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_RebuildIndexRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::CreateCPResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.CreateCPResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_CreateCPResp = res.first->second;
  storage_CreateCPResp.name_ref() = "storage.CreateCPResp";
  storage_CreateCPResp.is_union_ref() = false;
  static const EncodedThriftField
  storage_CreateCPResp_fields[] = {
    std::make_tuple(1, "result", false, std::make_unique<Struct< ::nebula::storage::cpp2::ResponseCommon>>("storage.ResponseCommon"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "info", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::CheckpointInfo>>("common.CheckpointInfo")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_CreateCPResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_CreateCPResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::ListClusterInfoResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.ListClusterInfoResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_ListClusterInfoResp = res.first->second;
  storage_ListClusterInfoResp.name_ref() = "storage.ListClusterInfoResp";
  storage_ListClusterInfoResp.is_union_ref() = false;
  static const EncodedThriftField
  storage_ListClusterInfoResp_fields[] = {
    std::make_tuple(1, "result", false, std::make_unique<Struct< ::nebula::storage::cpp2::ResponseCommon>>("storage.ResponseCommon"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "dir", false, std::make_unique<Struct< ::nebula::cpp2::DirInfo>>("common.DirInfo"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_ListClusterInfoResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_ListClusterInfoResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::ListClusterInfoReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.ListClusterInfoReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_ListClusterInfoReq = res.first->second;
  storage_ListClusterInfoReq.name_ref() = "storage.ListClusterInfoReq";
  storage_ListClusterInfoReq.is_union_ref() = false;
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::KVGetRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.KVGetRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_KVGetRequest = res.first->second;
  storage_KVGetRequest.name_ref() = "storage.KVGetRequest";
  storage_KVGetRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_KVGetRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "parts", false, std::make_unique<Map>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "return_partly", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_KVGetRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_KVGetRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::KVGetResponse>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.KVGetResponse", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_KVGetResponse = res.first->second;
  storage_KVGetResponse.name_ref() = "storage.KVGetResponse";
  storage_KVGetResponse.is_union_ref() = false;
  static const EncodedThriftField
  storage_KVGetResponse_fields[] = {
    std::make_tuple(1, "result", false, std::make_unique<Struct< ::nebula::storage::cpp2::ResponseCommon>>("storage.ResponseCommon"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "key_values", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_KVGetResponse_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_KVGetResponse.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::KVPutRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.KVPutRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_KVPutRequest = res.first->second;
  storage_KVPutRequest.name_ref() = "storage.KVPutRequest";
  storage_KVPutRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_KVPutRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "parts", false, std::make_unique<Map>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::KeyValue>>("common.KeyValue"))), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_KVPutRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_KVPutRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::KVRemoveRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.KVRemoveRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_KVRemoveRequest = res.first->second;
  storage_KVRemoveRequest.name_ref() = "storage.KVRemoveRequest";
  storage_KVRemoveRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_KVRemoveRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "parts", false, std::make_unique<Map>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE))), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_KVRemoveRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_KVRemoveRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::InternalTxnRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.InternalTxnRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_InternalTxnRequest = res.first->second;
  storage_InternalTxnRequest.name_ref() = "storage.InternalTxnRequest";
  storage_InternalTxnRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_InternalTxnRequest_fields[] = {
    std::make_tuple(1, "txn_id", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "term_of_parts", false, std::make_unique<Map>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "add_edge_req", true, std::make_unique<Struct< ::nebula::storage::cpp2::AddEdgesRequest>>("storage.AddEdgesRequest"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "upd_edge_req", true, std::make_unique<Struct< ::nebula::storage::cpp2::UpdateEdgeRequest>>("storage.UpdateEdgeRequest"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "edge_ver", true, std::make_unique<Map>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE))), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_InternalTxnRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_InternalTxnRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::ChainAddEdgesRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.ChainAddEdgesRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_ChainAddEdgesRequest = res.first->second;
  storage_ChainAddEdgesRequest.name_ref() = "storage.ChainAddEdgesRequest";
  storage_ChainAddEdgesRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_ChainAddEdgesRequest_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "parts", false, std::make_unique<Map>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<List>(std::make_unique<Struct< ::nebula::storage::cpp2::NewEdge>>("storage.NewEdge"))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "prop_names", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "if_not_exists", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "term", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "edge_version", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_ChainAddEdgesRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_ChainAddEdgesRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::storage::cpp2::ChainUpdateEdgeRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("storage.ChainUpdateEdgeRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& storage_ChainUpdateEdgeRequest = res.first->second;
  storage_ChainUpdateEdgeRequest.name_ref() = "storage.ChainUpdateEdgeRequest";
  storage_ChainUpdateEdgeRequest.is_union_ref() = false;
  static const EncodedThriftField
  storage_ChainUpdateEdgeRequest_fields[] = {
    std::make_tuple(1, "update_edge_request", false, std::make_unique<Struct< ::nebula::storage::cpp2::UpdateEdgeRequest>>("storage.UpdateEdgeRequest"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "term", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "edge_version", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "parts", false, std::make_unique<List>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE))), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : storage_ChainUpdateEdgeRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    storage_ChainUpdateEdgeRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}

void ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_getNeighbors(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "getNeighbors";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::GetNeighborsResponse>>("storage.GetNeighborsResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_GraphStorageService_getNeighbors_req_1;
  storage_GraphStorageService_getNeighbors_req_1.id_ref() = 1;
  storage_GraphStorageService_getNeighbors_req_1.name_ref() = "req";
  storage_GraphStorageService_getNeighbors_req_1.is_optional_ref() = false;
  auto storage_GraphStorageService_getNeighbors_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::GetNeighborsRequest>>("storage.GetNeighborsRequest");
  storage_GraphStorageService_getNeighbors_req_1_type->writeAndGenType(*storage_GraphStorageService_getNeighbors_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_GraphStorageService_getNeighbors_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_getProps(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "getProps";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::GetPropResponse>>("storage.GetPropResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_GraphStorageService_getProps_req_1;
  storage_GraphStorageService_getProps_req_1.id_ref() = 1;
  storage_GraphStorageService_getProps_req_1.name_ref() = "req";
  storage_GraphStorageService_getProps_req_1.is_optional_ref() = false;
  auto storage_GraphStorageService_getProps_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::GetPropRequest>>("storage.GetPropRequest");
  storage_GraphStorageService_getProps_req_1_type->writeAndGenType(*storage_GraphStorageService_getProps_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_GraphStorageService_getProps_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_addVertices(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "addVertices";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::ExecResponse>>("storage.ExecResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_GraphStorageService_addVertices_req_1;
  storage_GraphStorageService_addVertices_req_1.id_ref() = 1;
  storage_GraphStorageService_addVertices_req_1.name_ref() = "req";
  storage_GraphStorageService_addVertices_req_1.is_optional_ref() = false;
  auto storage_GraphStorageService_addVertices_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::AddVerticesRequest>>("storage.AddVerticesRequest");
  storage_GraphStorageService_addVertices_req_1_type->writeAndGenType(*storage_GraphStorageService_addVertices_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_GraphStorageService_addVertices_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_addEdges(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "addEdges";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::ExecResponse>>("storage.ExecResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_GraphStorageService_addEdges_req_1;
  storage_GraphStorageService_addEdges_req_1.id_ref() = 1;
  storage_GraphStorageService_addEdges_req_1.name_ref() = "req";
  storage_GraphStorageService_addEdges_req_1.is_optional_ref() = false;
  auto storage_GraphStorageService_addEdges_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::AddEdgesRequest>>("storage.AddEdgesRequest");
  storage_GraphStorageService_addEdges_req_1_type->writeAndGenType(*storage_GraphStorageService_addEdges_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_GraphStorageService_addEdges_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_deleteEdges(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "deleteEdges";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::ExecResponse>>("storage.ExecResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_GraphStorageService_deleteEdges_req_1;
  storage_GraphStorageService_deleteEdges_req_1.id_ref() = 1;
  storage_GraphStorageService_deleteEdges_req_1.name_ref() = "req";
  storage_GraphStorageService_deleteEdges_req_1.is_optional_ref() = false;
  auto storage_GraphStorageService_deleteEdges_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::DeleteEdgesRequest>>("storage.DeleteEdgesRequest");
  storage_GraphStorageService_deleteEdges_req_1_type->writeAndGenType(*storage_GraphStorageService_deleteEdges_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_GraphStorageService_deleteEdges_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_deleteVertices(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "deleteVertices";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::ExecResponse>>("storage.ExecResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_GraphStorageService_deleteVertices_req_1;
  storage_GraphStorageService_deleteVertices_req_1.id_ref() = 1;
  storage_GraphStorageService_deleteVertices_req_1.name_ref() = "req";
  storage_GraphStorageService_deleteVertices_req_1.is_optional_ref() = false;
  auto storage_GraphStorageService_deleteVertices_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::DeleteVerticesRequest>>("storage.DeleteVerticesRequest");
  storage_GraphStorageService_deleteVertices_req_1_type->writeAndGenType(*storage_GraphStorageService_deleteVertices_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_GraphStorageService_deleteVertices_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_deleteTags(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "deleteTags";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::ExecResponse>>("storage.ExecResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_GraphStorageService_deleteTags_req_1;
  storage_GraphStorageService_deleteTags_req_1.id_ref() = 1;
  storage_GraphStorageService_deleteTags_req_1.name_ref() = "req";
  storage_GraphStorageService_deleteTags_req_1.is_optional_ref() = false;
  auto storage_GraphStorageService_deleteTags_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::DeleteTagsRequest>>("storage.DeleteTagsRequest");
  storage_GraphStorageService_deleteTags_req_1_type->writeAndGenType(*storage_GraphStorageService_deleteTags_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_GraphStorageService_deleteTags_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_updateVertex(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "updateVertex";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::UpdateResponse>>("storage.UpdateResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_GraphStorageService_updateVertex_req_1;
  storage_GraphStorageService_updateVertex_req_1.id_ref() = 1;
  storage_GraphStorageService_updateVertex_req_1.name_ref() = "req";
  storage_GraphStorageService_updateVertex_req_1.is_optional_ref() = false;
  auto storage_GraphStorageService_updateVertex_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::UpdateVertexRequest>>("storage.UpdateVertexRequest");
  storage_GraphStorageService_updateVertex_req_1_type->writeAndGenType(*storage_GraphStorageService_updateVertex_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_GraphStorageService_updateVertex_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_updateEdge(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "updateEdge";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::UpdateResponse>>("storage.UpdateResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_GraphStorageService_updateEdge_req_1;
  storage_GraphStorageService_updateEdge_req_1.id_ref() = 1;
  storage_GraphStorageService_updateEdge_req_1.name_ref() = "req";
  storage_GraphStorageService_updateEdge_req_1.is_optional_ref() = false;
  auto storage_GraphStorageService_updateEdge_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::UpdateEdgeRequest>>("storage.UpdateEdgeRequest");
  storage_GraphStorageService_updateEdge_req_1_type->writeAndGenType(*storage_GraphStorageService_updateEdge_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_GraphStorageService_updateEdge_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_scanVertex(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "scanVertex";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::ScanVertexResponse>>("storage.ScanVertexResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_GraphStorageService_scanVertex_req_1;
  storage_GraphStorageService_scanVertex_req_1.id_ref() = 1;
  storage_GraphStorageService_scanVertex_req_1.name_ref() = "req";
  storage_GraphStorageService_scanVertex_req_1.is_optional_ref() = false;
  auto storage_GraphStorageService_scanVertex_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::ScanVertexRequest>>("storage.ScanVertexRequest");
  storage_GraphStorageService_scanVertex_req_1_type->writeAndGenType(*storage_GraphStorageService_scanVertex_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_GraphStorageService_scanVertex_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_scanEdge(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "scanEdge";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::ScanEdgeResponse>>("storage.ScanEdgeResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_GraphStorageService_scanEdge_req_1;
  storage_GraphStorageService_scanEdge_req_1.id_ref() = 1;
  storage_GraphStorageService_scanEdge_req_1.name_ref() = "req";
  storage_GraphStorageService_scanEdge_req_1.is_optional_ref() = false;
  auto storage_GraphStorageService_scanEdge_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::ScanEdgeRequest>>("storage.ScanEdgeRequest");
  storage_GraphStorageService_scanEdge_req_1_type->writeAndGenType(*storage_GraphStorageService_scanEdge_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_GraphStorageService_scanEdge_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_getUUID(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "getUUID";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::GetUUIDResp>>("storage.GetUUIDResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_GraphStorageService_getUUID_req_1;
  storage_GraphStorageService_getUUID_req_1.id_ref() = 1;
  storage_GraphStorageService_getUUID_req_1.name_ref() = "req";
  storage_GraphStorageService_getUUID_req_1.is_optional_ref() = false;
  auto storage_GraphStorageService_getUUID_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::GetUUIDReq>>("storage.GetUUIDReq");
  storage_GraphStorageService_getUUID_req_1_type->writeAndGenType(*storage_GraphStorageService_getUUID_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_GraphStorageService_getUUID_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_lookupIndex(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "lookupIndex";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::LookupIndexResp>>("storage.LookupIndexResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_GraphStorageService_lookupIndex_req_1;
  storage_GraphStorageService_lookupIndex_req_1.id_ref() = 1;
  storage_GraphStorageService_lookupIndex_req_1.name_ref() = "req";
  storage_GraphStorageService_lookupIndex_req_1.is_optional_ref() = false;
  auto storage_GraphStorageService_lookupIndex_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::LookupIndexRequest>>("storage.LookupIndexRequest");
  storage_GraphStorageService_lookupIndex_req_1_type->writeAndGenType(*storage_GraphStorageService_lookupIndex_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_GraphStorageService_lookupIndex_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_lookupAndTraverse(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "lookupAndTraverse";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::GetNeighborsResponse>>("storage.GetNeighborsResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_GraphStorageService_lookupAndTraverse_req_1;
  storage_GraphStorageService_lookupAndTraverse_req_1.id_ref() = 1;
  storage_GraphStorageService_lookupAndTraverse_req_1.name_ref() = "req";
  storage_GraphStorageService_lookupAndTraverse_req_1.is_optional_ref() = false;
  auto storage_GraphStorageService_lookupAndTraverse_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::LookupAndTraverseRequest>>("storage.LookupAndTraverseRequest");
  storage_GraphStorageService_lookupAndTraverse_req_1_type->writeAndGenType(*storage_GraphStorageService_lookupAndTraverse_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_GraphStorageService_lookupAndTraverse_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_chainUpdateEdge(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "chainUpdateEdge";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::UpdateResponse>>("storage.UpdateResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_GraphStorageService_chainUpdateEdge_req_1;
  storage_GraphStorageService_chainUpdateEdge_req_1.id_ref() = 1;
  storage_GraphStorageService_chainUpdateEdge_req_1.name_ref() = "req";
  storage_GraphStorageService_chainUpdateEdge_req_1.is_optional_ref() = false;
  auto storage_GraphStorageService_chainUpdateEdge_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::UpdateEdgeRequest>>("storage.UpdateEdgeRequest");
  storage_GraphStorageService_chainUpdateEdge_req_1_type->writeAndGenType(*storage_GraphStorageService_chainUpdateEdge_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_GraphStorageService_chainUpdateEdge_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_chainAddEdges(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "chainAddEdges";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::ExecResponse>>("storage.ExecResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_GraphStorageService_chainAddEdges_req_1;
  storage_GraphStorageService_chainAddEdges_req_1.id_ref() = 1;
  storage_GraphStorageService_chainAddEdges_req_1.name_ref() = "req";
  storage_GraphStorageService_chainAddEdges_req_1.is_optional_ref() = false;
  auto storage_GraphStorageService_chainAddEdges_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::AddEdgesRequest>>("storage.AddEdgesRequest");
  storage_GraphStorageService_chainAddEdges_req_1_type->writeAndGenType(*storage_GraphStorageService_chainAddEdges_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_GraphStorageService_chainAddEdges_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}

void ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen(ThriftMetadata& metadata, ThriftServiceContext& context) {
  (void) metadata;
  ::apache::thrift::metadata::ThriftService storage_GraphStorageService;
  storage_GraphStorageService.name_ref() = "storage.GraphStorageService";
  static const ThriftFunctionGenerator functions[] = {
    ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_getNeighbors,
    ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_getProps,
    ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_addVertices,
    ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_addEdges,
    ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_deleteEdges,
    ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_deleteVertices,
    ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_deleteTags,
    ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_updateVertex,
    ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_updateEdge,
    ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_scanVertex,
    ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_scanEdge,
    ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_getUUID,
    ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_lookupIndex,
    ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_lookupAndTraverse,
    ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_chainUpdateEdge,
    ServiceMetadata<::nebula::storage::cpp2::GraphStorageServiceSvIf>::gen_chainAddEdges,
  };
  for (auto& function_gen : functions) {
    function_gen(metadata, storage_GraphStorageService);
  }
  context.service_info_ref() = std::move(storage_GraphStorageService);
  ::apache::thrift::metadata::ThriftModuleContext module;
  module.name_ref() = "storage";
  context.module_ref() = std::move(module);
}
void ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_transLeader(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "transLeader";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::AdminExecResp>>("storage.AdminExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_StorageAdminService_transLeader_req_1;
  storage_StorageAdminService_transLeader_req_1.id_ref() = 1;
  storage_StorageAdminService_transLeader_req_1.name_ref() = "req";
  storage_StorageAdminService_transLeader_req_1.is_optional_ref() = false;
  auto storage_StorageAdminService_transLeader_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::TransLeaderReq>>("storage.TransLeaderReq");
  storage_StorageAdminService_transLeader_req_1_type->writeAndGenType(*storage_StorageAdminService_transLeader_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_StorageAdminService_transLeader_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_addPart(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "addPart";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::AdminExecResp>>("storage.AdminExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_StorageAdminService_addPart_req_1;
  storage_StorageAdminService_addPart_req_1.id_ref() = 1;
  storage_StorageAdminService_addPart_req_1.name_ref() = "req";
  storage_StorageAdminService_addPart_req_1.is_optional_ref() = false;
  auto storage_StorageAdminService_addPart_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::AddPartReq>>("storage.AddPartReq");
  storage_StorageAdminService_addPart_req_1_type->writeAndGenType(*storage_StorageAdminService_addPart_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_StorageAdminService_addPart_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_addLearner(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "addLearner";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::AdminExecResp>>("storage.AdminExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_StorageAdminService_addLearner_req_1;
  storage_StorageAdminService_addLearner_req_1.id_ref() = 1;
  storage_StorageAdminService_addLearner_req_1.name_ref() = "req";
  storage_StorageAdminService_addLearner_req_1.is_optional_ref() = false;
  auto storage_StorageAdminService_addLearner_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::AddLearnerReq>>("storage.AddLearnerReq");
  storage_StorageAdminService_addLearner_req_1_type->writeAndGenType(*storage_StorageAdminService_addLearner_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_StorageAdminService_addLearner_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_removePart(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "removePart";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::AdminExecResp>>("storage.AdminExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_StorageAdminService_removePart_req_1;
  storage_StorageAdminService_removePart_req_1.id_ref() = 1;
  storage_StorageAdminService_removePart_req_1.name_ref() = "req";
  storage_StorageAdminService_removePart_req_1.is_optional_ref() = false;
  auto storage_StorageAdminService_removePart_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::RemovePartReq>>("storage.RemovePartReq");
  storage_StorageAdminService_removePart_req_1_type->writeAndGenType(*storage_StorageAdminService_removePart_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_StorageAdminService_removePart_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_memberChange(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "memberChange";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::AdminExecResp>>("storage.AdminExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_StorageAdminService_memberChange_req_1;
  storage_StorageAdminService_memberChange_req_1.id_ref() = 1;
  storage_StorageAdminService_memberChange_req_1.name_ref() = "req";
  storage_StorageAdminService_memberChange_req_1.is_optional_ref() = false;
  auto storage_StorageAdminService_memberChange_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::MemberChangeReq>>("storage.MemberChangeReq");
  storage_StorageAdminService_memberChange_req_1_type->writeAndGenType(*storage_StorageAdminService_memberChange_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_StorageAdminService_memberChange_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_waitingForCatchUpData(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "waitingForCatchUpData";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::AdminExecResp>>("storage.AdminExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_StorageAdminService_waitingForCatchUpData_req_1;
  storage_StorageAdminService_waitingForCatchUpData_req_1.id_ref() = 1;
  storage_StorageAdminService_waitingForCatchUpData_req_1.name_ref() = "req";
  storage_StorageAdminService_waitingForCatchUpData_req_1.is_optional_ref() = false;
  auto storage_StorageAdminService_waitingForCatchUpData_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::CatchUpDataReq>>("storage.CatchUpDataReq");
  storage_StorageAdminService_waitingForCatchUpData_req_1_type->writeAndGenType(*storage_StorageAdminService_waitingForCatchUpData_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_StorageAdminService_waitingForCatchUpData_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_createCheckpoint(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "createCheckpoint";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::CreateCPResp>>("storage.CreateCPResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_StorageAdminService_createCheckpoint_req_1;
  storage_StorageAdminService_createCheckpoint_req_1.id_ref() = 1;
  storage_StorageAdminService_createCheckpoint_req_1.name_ref() = "req";
  storage_StorageAdminService_createCheckpoint_req_1.is_optional_ref() = false;
  auto storage_StorageAdminService_createCheckpoint_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::CreateCPRequest>>("storage.CreateCPRequest");
  storage_StorageAdminService_createCheckpoint_req_1_type->writeAndGenType(*storage_StorageAdminService_createCheckpoint_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_StorageAdminService_createCheckpoint_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_dropCheckpoint(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "dropCheckpoint";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::AdminExecResp>>("storage.AdminExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_StorageAdminService_dropCheckpoint_req_1;
  storage_StorageAdminService_dropCheckpoint_req_1.id_ref() = 1;
  storage_StorageAdminService_dropCheckpoint_req_1.name_ref() = "req";
  storage_StorageAdminService_dropCheckpoint_req_1.is_optional_ref() = false;
  auto storage_StorageAdminService_dropCheckpoint_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::DropCPRequest>>("storage.DropCPRequest");
  storage_StorageAdminService_dropCheckpoint_req_1_type->writeAndGenType(*storage_StorageAdminService_dropCheckpoint_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_StorageAdminService_dropCheckpoint_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_blockingWrites(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "blockingWrites";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::AdminExecResp>>("storage.AdminExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_StorageAdminService_blockingWrites_req_1;
  storage_StorageAdminService_blockingWrites_req_1.id_ref() = 1;
  storage_StorageAdminService_blockingWrites_req_1.name_ref() = "req";
  storage_StorageAdminService_blockingWrites_req_1.is_optional_ref() = false;
  auto storage_StorageAdminService_blockingWrites_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::BlockingSignRequest>>("storage.BlockingSignRequest");
  storage_StorageAdminService_blockingWrites_req_1_type->writeAndGenType(*storage_StorageAdminService_blockingWrites_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_StorageAdminService_blockingWrites_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_rebuildTagIndex(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "rebuildTagIndex";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::AdminExecResp>>("storage.AdminExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_StorageAdminService_rebuildTagIndex_req_1;
  storage_StorageAdminService_rebuildTagIndex_req_1.id_ref() = 1;
  storage_StorageAdminService_rebuildTagIndex_req_1.name_ref() = "req";
  storage_StorageAdminService_rebuildTagIndex_req_1.is_optional_ref() = false;
  auto storage_StorageAdminService_rebuildTagIndex_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::RebuildIndexRequest>>("storage.RebuildIndexRequest");
  storage_StorageAdminService_rebuildTagIndex_req_1_type->writeAndGenType(*storage_StorageAdminService_rebuildTagIndex_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_StorageAdminService_rebuildTagIndex_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_rebuildEdgeIndex(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "rebuildEdgeIndex";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::AdminExecResp>>("storage.AdminExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_StorageAdminService_rebuildEdgeIndex_req_1;
  storage_StorageAdminService_rebuildEdgeIndex_req_1.id_ref() = 1;
  storage_StorageAdminService_rebuildEdgeIndex_req_1.name_ref() = "req";
  storage_StorageAdminService_rebuildEdgeIndex_req_1.is_optional_ref() = false;
  auto storage_StorageAdminService_rebuildEdgeIndex_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::RebuildIndexRequest>>("storage.RebuildIndexRequest");
  storage_StorageAdminService_rebuildEdgeIndex_req_1_type->writeAndGenType(*storage_StorageAdminService_rebuildEdgeIndex_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_StorageAdminService_rebuildEdgeIndex_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_getLeaderParts(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "getLeaderParts";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::GetLeaderPartsResp>>("storage.GetLeaderPartsResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_StorageAdminService_getLeaderParts_req_1;
  storage_StorageAdminService_getLeaderParts_req_1.id_ref() = 1;
  storage_StorageAdminService_getLeaderParts_req_1.name_ref() = "req";
  storage_StorageAdminService_getLeaderParts_req_1.is_optional_ref() = false;
  auto storage_StorageAdminService_getLeaderParts_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::GetLeaderReq>>("storage.GetLeaderReq");
  storage_StorageAdminService_getLeaderParts_req_1_type->writeAndGenType(*storage_StorageAdminService_getLeaderParts_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_StorageAdminService_getLeaderParts_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_checkPeers(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "checkPeers";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::AdminExecResp>>("storage.AdminExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_StorageAdminService_checkPeers_req_1;
  storage_StorageAdminService_checkPeers_req_1.id_ref() = 1;
  storage_StorageAdminService_checkPeers_req_1.name_ref() = "req";
  storage_StorageAdminService_checkPeers_req_1.is_optional_ref() = false;
  auto storage_StorageAdminService_checkPeers_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::CheckPeersReq>>("storage.CheckPeersReq");
  storage_StorageAdminService_checkPeers_req_1_type->writeAndGenType(*storage_StorageAdminService_checkPeers_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_StorageAdminService_checkPeers_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_addAdminTask(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "addAdminTask";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::AdminExecResp>>("storage.AdminExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_StorageAdminService_addAdminTask_req_1;
  storage_StorageAdminService_addAdminTask_req_1.id_ref() = 1;
  storage_StorageAdminService_addAdminTask_req_1.name_ref() = "req";
  storage_StorageAdminService_addAdminTask_req_1.is_optional_ref() = false;
  auto storage_StorageAdminService_addAdminTask_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::AddAdminTaskRequest>>("storage.AddAdminTaskRequest");
  storage_StorageAdminService_addAdminTask_req_1_type->writeAndGenType(*storage_StorageAdminService_addAdminTask_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_StorageAdminService_addAdminTask_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_stopAdminTask(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "stopAdminTask";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::AdminExecResp>>("storage.AdminExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_StorageAdminService_stopAdminTask_req_1;
  storage_StorageAdminService_stopAdminTask_req_1.id_ref() = 1;
  storage_StorageAdminService_stopAdminTask_req_1.name_ref() = "req";
  storage_StorageAdminService_stopAdminTask_req_1.is_optional_ref() = false;
  auto storage_StorageAdminService_stopAdminTask_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::StopAdminTaskRequest>>("storage.StopAdminTaskRequest");
  storage_StorageAdminService_stopAdminTask_req_1_type->writeAndGenType(*storage_StorageAdminService_stopAdminTask_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_StorageAdminService_stopAdminTask_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_listClusterInfo(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listClusterInfo";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::ListClusterInfoResp>>("storage.ListClusterInfoResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_StorageAdminService_listClusterInfo_req_1;
  storage_StorageAdminService_listClusterInfo_req_1.id_ref() = 1;
  storage_StorageAdminService_listClusterInfo_req_1.name_ref() = "req";
  storage_StorageAdminService_listClusterInfo_req_1.is_optional_ref() = false;
  auto storage_StorageAdminService_listClusterInfo_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::ListClusterInfoReq>>("storage.ListClusterInfoReq");
  storage_StorageAdminService_listClusterInfo_req_1_type->writeAndGenType(*storage_StorageAdminService_listClusterInfo_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_StorageAdminService_listClusterInfo_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}

void ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen(ThriftMetadata& metadata, ThriftServiceContext& context) {
  (void) metadata;
  ::apache::thrift::metadata::ThriftService storage_StorageAdminService;
  storage_StorageAdminService.name_ref() = "storage.StorageAdminService";
  static const ThriftFunctionGenerator functions[] = {
    ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_transLeader,
    ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_addPart,
    ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_addLearner,
    ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_removePart,
    ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_memberChange,
    ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_waitingForCatchUpData,
    ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_createCheckpoint,
    ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_dropCheckpoint,
    ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_blockingWrites,
    ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_rebuildTagIndex,
    ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_rebuildEdgeIndex,
    ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_getLeaderParts,
    ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_checkPeers,
    ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_addAdminTask,
    ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_stopAdminTask,
    ServiceMetadata<::nebula::storage::cpp2::StorageAdminServiceSvIf>::gen_listClusterInfo,
  };
  for (auto& function_gen : functions) {
    function_gen(metadata, storage_StorageAdminService);
  }
  context.service_info_ref() = std::move(storage_StorageAdminService);
  ::apache::thrift::metadata::ThriftModuleContext module;
  module.name_ref() = "storage";
  context.module_ref() = std::move(module);
}
void ServiceMetadata<::nebula::storage::cpp2::GeneralStorageServiceSvIf>::gen_get(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "get";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::KVGetResponse>>("storage.KVGetResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_GeneralStorageService_get_req_1;
  storage_GeneralStorageService_get_req_1.id_ref() = 1;
  storage_GeneralStorageService_get_req_1.name_ref() = "req";
  storage_GeneralStorageService_get_req_1.is_optional_ref() = false;
  auto storage_GeneralStorageService_get_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::KVGetRequest>>("storage.KVGetRequest");
  storage_GeneralStorageService_get_req_1_type->writeAndGenType(*storage_GeneralStorageService_get_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_GeneralStorageService_get_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::GeneralStorageServiceSvIf>::gen_put(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "put";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::ExecResponse>>("storage.ExecResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_GeneralStorageService_put_req_1;
  storage_GeneralStorageService_put_req_1.id_ref() = 1;
  storage_GeneralStorageService_put_req_1.name_ref() = "req";
  storage_GeneralStorageService_put_req_1.is_optional_ref() = false;
  auto storage_GeneralStorageService_put_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::KVPutRequest>>("storage.KVPutRequest");
  storage_GeneralStorageService_put_req_1_type->writeAndGenType(*storage_GeneralStorageService_put_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_GeneralStorageService_put_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::GeneralStorageServiceSvIf>::gen_remove(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "remove";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::ExecResponse>>("storage.ExecResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_GeneralStorageService_remove_req_1;
  storage_GeneralStorageService_remove_req_1.id_ref() = 1;
  storage_GeneralStorageService_remove_req_1.name_ref() = "req";
  storage_GeneralStorageService_remove_req_1.is_optional_ref() = false;
  auto storage_GeneralStorageService_remove_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::KVRemoveRequest>>("storage.KVRemoveRequest");
  storage_GeneralStorageService_remove_req_1_type->writeAndGenType(*storage_GeneralStorageService_remove_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_GeneralStorageService_remove_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}

void ServiceMetadata<::nebula::storage::cpp2::GeneralStorageServiceSvIf>::gen(ThriftMetadata& metadata, ThriftServiceContext& context) {
  (void) metadata;
  ::apache::thrift::metadata::ThriftService storage_GeneralStorageService;
  storage_GeneralStorageService.name_ref() = "storage.GeneralStorageService";
  static const ThriftFunctionGenerator functions[] = {
    ServiceMetadata<::nebula::storage::cpp2::GeneralStorageServiceSvIf>::gen_get,
    ServiceMetadata<::nebula::storage::cpp2::GeneralStorageServiceSvIf>::gen_put,
    ServiceMetadata<::nebula::storage::cpp2::GeneralStorageServiceSvIf>::gen_remove,
  };
  for (auto& function_gen : functions) {
    function_gen(metadata, storage_GeneralStorageService);
  }
  context.service_info_ref() = std::move(storage_GeneralStorageService);
  ::apache::thrift::metadata::ThriftModuleContext module;
  module.name_ref() = "storage";
  context.module_ref() = std::move(module);
}
void ServiceMetadata<::nebula::storage::cpp2::InternalStorageServiceSvIf>::gen_chainAddEdges(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "chainAddEdges";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::ExecResponse>>("storage.ExecResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_InternalStorageService_chainAddEdges_req_1;
  storage_InternalStorageService_chainAddEdges_req_1.id_ref() = 1;
  storage_InternalStorageService_chainAddEdges_req_1.name_ref() = "req";
  storage_InternalStorageService_chainAddEdges_req_1.is_optional_ref() = false;
  auto storage_InternalStorageService_chainAddEdges_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::ChainAddEdgesRequest>>("storage.ChainAddEdgesRequest");
  storage_InternalStorageService_chainAddEdges_req_1_type->writeAndGenType(*storage_InternalStorageService_chainAddEdges_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_InternalStorageService_chainAddEdges_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::storage::cpp2::InternalStorageServiceSvIf>::gen_chainUpdateEdge(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "chainUpdateEdge";
  auto func_ret_type = std::make_unique<Struct< ::nebula::storage::cpp2::UpdateResponse>>("storage.UpdateResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField storage_InternalStorageService_chainUpdateEdge_req_1;
  storage_InternalStorageService_chainUpdateEdge_req_1.id_ref() = 1;
  storage_InternalStorageService_chainUpdateEdge_req_1.name_ref() = "req";
  storage_InternalStorageService_chainUpdateEdge_req_1.is_optional_ref() = false;
  auto storage_InternalStorageService_chainUpdateEdge_req_1_type = std::make_unique<Struct< ::nebula::storage::cpp2::ChainUpdateEdgeRequest>>("storage.ChainUpdateEdgeRequest");
  storage_InternalStorageService_chainUpdateEdge_req_1_type->writeAndGenType(*storage_InternalStorageService_chainUpdateEdge_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(storage_InternalStorageService_chainUpdateEdge_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}

void ServiceMetadata<::nebula::storage::cpp2::InternalStorageServiceSvIf>::gen(ThriftMetadata& metadata, ThriftServiceContext& context) {
  (void) metadata;
  ::apache::thrift::metadata::ThriftService storage_InternalStorageService;
  storage_InternalStorageService.name_ref() = "storage.InternalStorageService";
  static const ThriftFunctionGenerator functions[] = {
    ServiceMetadata<::nebula::storage::cpp2::InternalStorageServiceSvIf>::gen_chainAddEdges,
    ServiceMetadata<::nebula::storage::cpp2::InternalStorageServiceSvIf>::gen_chainUpdateEdge,
  };
  for (auto& function_gen : functions) {
    function_gen(metadata, storage_InternalStorageService);
  }
  context.service_info_ref() = std::move(storage_InternalStorageService);
  ::apache::thrift::metadata::ThriftModuleContext module;
  module.name_ref() = "storage";
  context.module_ref() = std::move(module);
}
} // namespace md
} // namespace detail
} // namespace thrift
} // namespace apache
