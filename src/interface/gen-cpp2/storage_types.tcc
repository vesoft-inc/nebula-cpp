/**
 * Autogenerated by Thrift for storage.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include "storage_types.h"

#include <thrift/lib/cpp2/gen/module_types_tcc.h>

namespace nebula { namespace storage { namespace cpp2 {

}}} // nebula::storage::cpp2
namespace std {

} // std

namespace nebula { namespace storage { namespace cpp2 {

}}} // nebula::storage::cpp2
namespace std {

} // std

namespace nebula { namespace storage { namespace cpp2 {

}}} // nebula::storage::cpp2
namespace std {

} // std

namespace nebula { namespace storage { namespace cpp2 {

}}} // nebula::storage::cpp2
namespace std {

} // std

namespace nebula { namespace storage { namespace cpp2 {

}}} // nebula::storage::cpp2
namespace std {

} // std


namespace apache {
namespace thrift {
namespace detail {

template <>
struct TccStructTraits<::nebula::storage::cpp2::RequestCommon> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::PartitionResult> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::ResponseCommon> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::StatProp> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::Expr> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::EdgeProp> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::VertexProp> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::OrderBy> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::TraverseSpec> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::GetNeighborsRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::GetNeighborsResponse> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::ExecResponse> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::GetPropRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::GetPropResponse> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::NewTag> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::NewVertex> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::EdgeKey> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::NewEdge> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::AddVerticesRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::AddEdgesRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::DeleteVerticesRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::DeleteEdgesRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::DelTags> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::DeleteTagsRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::UpdateResponse> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::UpdatedProp> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::UpdateVertexRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::UpdateEdgeRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::GetUUIDReq> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::GetUUIDResp> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::LookupIndexResp> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::IndexColumnHint> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::IndexQueryContext> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::IndexSpec> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::LookupIndexRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::LookupAndTraverseRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::ScanCursor> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::ScanVertexRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::ScanEdgeRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::ScanResponse> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::TaskPara> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::KVGetRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::KVGetResponse> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::KVPutRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::KVRemoveRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::AdminExecResp> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::TransLeaderReq> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::AddPartReq> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::AddLearnerReq> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::RemovePartReq> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::MemberChangeReq> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::CatchUpDataReq> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::GetLeaderReq> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::CreateCPRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::DropCPRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::BlockingSignRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::GetLeaderPartsResp> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::CheckPeersReq> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::RebuildIndexRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::CreateCPResp> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::ListClusterInfoResp> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::ListClusterInfoReq> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::AddAdminTaskRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::StopAdminTaskRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::ChainAddEdgesRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::ChainUpdateEdgeRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};
template <>
struct TccStructTraits<::nebula::storage::cpp2::ChainDeleteEdgesRequest> {
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype) noexcept;
};

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void RequestCommon::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I64))) {
    goto _loop;
  }
_readField_session_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::SessionID>::readWithContext(*iprot, this->session_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.session_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I64))) {
    goto _loop;
  }
_readField_plan_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::ExecutionPlanID>::readWithContext(*iprot, this->plan_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.plan_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_profile_detail:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->profile_detail, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.profile_detail = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<RequestCommon>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I64))) {
        goto _readField_session_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I64))) {
        goto _readField_plan_id;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_profile_detail;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t RequestCommon::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("RequestCommon");
  if (this->session_id_ref().has_value()) {
    xfer += prot_->serializedFieldSize("session_id", apache::thrift::protocol::T_I64, 1);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::SessionID>::serializedSize<false>(*prot_, this->session_id);
  }
  if (this->plan_id_ref().has_value()) {
    xfer += prot_->serializedFieldSize("plan_id", apache::thrift::protocol::T_I64, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::ExecutionPlanID>::serializedSize<false>(*prot_, this->plan_id);
  }
  if (this->profile_detail_ref().has_value()) {
    xfer += prot_->serializedFieldSize("profile_detail", apache::thrift::protocol::T_BOOL, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->profile_detail);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t RequestCommon::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("RequestCommon");
  if (this->session_id_ref().has_value()) {
    xfer += prot_->serializedFieldSize("session_id", apache::thrift::protocol::T_I64, 1);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::SessionID>::serializedSize<false>(*prot_, this->session_id);
  }
  if (this->plan_id_ref().has_value()) {
    xfer += prot_->serializedFieldSize("plan_id", apache::thrift::protocol::T_I64, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::ExecutionPlanID>::serializedSize<false>(*prot_, this->plan_id);
  }
  if (this->profile_detail_ref().has_value()) {
    xfer += prot_->serializedFieldSize("profile_detail", apache::thrift::protocol::T_BOOL, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->profile_detail);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t RequestCommon::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("RequestCommon");
  if (this->session_id_ref().has_value()) {
    xfer += prot_->writeFieldBegin("session_id", apache::thrift::protocol::T_I64, 1);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::SessionID>::write(*prot_, this->session_id);
    xfer += prot_->writeFieldEnd();
  }
  if (this->plan_id_ref().has_value()) {
    xfer += prot_->writeFieldBegin("plan_id", apache::thrift::protocol::T_I64, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::ExecutionPlanID>::write(*prot_, this->plan_id);
    xfer += prot_->writeFieldEnd();
  }
  if (this->profile_detail_ref().has_value()) {
    xfer += prot_->writeFieldBegin("profile_detail", apache::thrift::protocol::T_BOOL, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->profile_detail);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void RequestCommon::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t RequestCommon::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t RequestCommon::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t RequestCommon::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void RequestCommon::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t RequestCommon::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t RequestCommon::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t RequestCommon::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void PartitionResult::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_code:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::cpp2::ErrorCode>::readWithContext(*iprot, this->code, _readState);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_part_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::readWithContext(*iprot, this->part_id, _readState);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_leader:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::readWithContext(*iprot, this->leader, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.leader = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<PartitionResult>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_code;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_part_id;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_leader;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t PartitionResult::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("PartitionResult");
  xfer += prot_->serializedFieldSize("code", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::cpp2::ErrorCode>::serializedSize<false>(*prot_, this->code);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  if (this->leader_ref().has_value()) {
    xfer += prot_->serializedFieldSize("leader", apache::thrift::protocol::T_STRUCT, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::serializedSize<false>(*prot_, this->leader);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t PartitionResult::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("PartitionResult");
  xfer += prot_->serializedFieldSize("code", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::cpp2::ErrorCode>::serializedSize<false>(*prot_, this->code);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  if (this->leader_ref().has_value()) {
    xfer += prot_->serializedFieldSize("leader", apache::thrift::protocol::T_STRUCT, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::serializedSize<true>(*prot_, this->leader);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t PartitionResult::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("PartitionResult");
  xfer += prot_->writeFieldBegin("code", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::cpp2::ErrorCode>::write(*prot_, this->code);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::write(*prot_, this->part_id);
  xfer += prot_->writeFieldEnd();
  if (this->leader_ref().has_value()) {
    xfer += prot_->writeFieldBegin("leader", apache::thrift::protocol::T_STRUCT, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::write(*prot_, this->leader);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void PartitionResult::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t PartitionResult::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t PartitionResult::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t PartitionResult::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void PartitionResult::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t PartitionResult::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t PartitionResult::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t PartitionResult::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void ResponseCommon::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_failed_parts:
  {
    _readState.beforeSubobject(iprot);
    this->failed_parts = ::std::vector< ::nebula::storage::cpp2::PartitionResult>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::PartitionResult>>::readWithContext(*iprot, this->failed_parts, _readState);
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I64))) {
    goto _loop;
  }
_readField_latency_in_us:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::readWithContext(*iprot, this->latency_in_us, _readState);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_MAP))) {
    goto _loop;
  }
_readField_latency_detail_us:
  {
    _readState.beforeSubobject(iprot);
    this->latency_detail_us = ::std::map<::std::string, int32_t>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::integral>, ::std::map<::std::string, int32_t>>::readWithContext(*iprot, this->latency_detail_us, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.latency_detail_us = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<ResponseCommon>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_failed_parts;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I64))) {
        goto _readField_latency_in_us;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_MAP))) {
        goto _readField_latency_detail_us;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t ResponseCommon::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ResponseCommon");
  xfer += prot_->serializedFieldSize("failed_parts", apache::thrift::protocol::T_LIST, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::PartitionResult>>::serializedSize<false>(*prot_, this->failed_parts);
  xfer += prot_->serializedFieldSize("latency_in_us", apache::thrift::protocol::T_I64, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->latency_in_us);
  if (this->latency_detail_us_ref().has_value()) {
    xfer += prot_->serializedFieldSize("latency_detail_us", apache::thrift::protocol::T_MAP, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::integral>, ::std::map<::std::string, int32_t>>::serializedSize<false>(*prot_, this->latency_detail_us);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ResponseCommon::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ResponseCommon");
  xfer += prot_->serializedFieldSize("failed_parts", apache::thrift::protocol::T_LIST, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::PartitionResult>>::serializedSize<false>(*prot_, this->failed_parts);
  xfer += prot_->serializedFieldSize("latency_in_us", apache::thrift::protocol::T_I64, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->latency_in_us);
  if (this->latency_detail_us_ref().has_value()) {
    xfer += prot_->serializedFieldSize("latency_detail_us", apache::thrift::protocol::T_MAP, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::integral>, ::std::map<::std::string, int32_t>>::serializedSize<false>(*prot_, this->latency_detail_us);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ResponseCommon::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("ResponseCommon");
  xfer += prot_->writeFieldBegin("failed_parts", apache::thrift::protocol::T_LIST, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::PartitionResult>>::write(*prot_, this->failed_parts);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("latency_in_us", apache::thrift::protocol::T_I64, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::write(*prot_, this->latency_in_us);
  xfer += prot_->writeFieldEnd();
  if (this->latency_detail_us_ref().has_value()) {
    xfer += prot_->writeFieldBegin("latency_detail_us", apache::thrift::protocol::T_MAP, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::integral>, ::std::map<::std::string, int32_t>>::write(*prot_, this->latency_detail_us);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void ResponseCommon::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t ResponseCommon::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t ResponseCommon::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t ResponseCommon::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void ResponseCommon::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t ResponseCommon::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t ResponseCommon::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t ResponseCommon::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void StatProp::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_alias:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->alias, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.alias = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_prop:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->prop, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.prop = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_stat:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::StatType>::readWithContext(*iprot, this->stat, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.stat = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<StatProp>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_alias;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_prop;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_stat;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t StatProp::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("StatProp");
  xfer += prot_->serializedFieldSize("alias", apache::thrift::protocol::T_STRING, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->alias);
  xfer += prot_->serializedFieldSize("prop", apache::thrift::protocol::T_STRING, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->prop);
  xfer += prot_->serializedFieldSize("stat", apache::thrift::protocol::T_I32, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::StatType>::serializedSize<false>(*prot_, this->stat);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t StatProp::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("StatProp");
  xfer += prot_->serializedFieldSize("alias", apache::thrift::protocol::T_STRING, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->alias);
  xfer += prot_->serializedFieldSize("prop", apache::thrift::protocol::T_STRING, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->prop);
  xfer += prot_->serializedFieldSize("stat", apache::thrift::protocol::T_I32, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::StatType>::serializedSize<false>(*prot_, this->stat);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t StatProp::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("StatProp");
  xfer += prot_->writeFieldBegin("alias", apache::thrift::protocol::T_STRING, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->alias);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("prop", apache::thrift::protocol::T_STRING, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->prop);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("stat", apache::thrift::protocol::T_I32, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::StatType>::write(*prot_, this->stat);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void StatProp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t StatProp::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t StatProp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t StatProp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void StatProp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t StatProp::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t StatProp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t StatProp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void Expr::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_alias:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->alias, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.alias = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_expr:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->expr, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.expr = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<Expr>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_alias;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_expr;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t Expr::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("Expr");
  xfer += prot_->serializedFieldSize("alias", apache::thrift::protocol::T_STRING, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->alias);
  xfer += prot_->serializedFieldSize("expr", apache::thrift::protocol::T_STRING, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->expr);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t Expr::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("Expr");
  xfer += prot_->serializedFieldSize("alias", apache::thrift::protocol::T_STRING, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->alias);
  xfer += prot_->serializedFieldSize("expr", apache::thrift::protocol::T_STRING, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->expr);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t Expr::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("Expr");
  xfer += prot_->writeFieldBegin("alias", apache::thrift::protocol::T_STRING, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->alias);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("expr", apache::thrift::protocol::T_STRING, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->expr);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void Expr::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t Expr::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t Expr::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t Expr::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void Expr::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t Expr::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t Expr::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t Expr::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void EdgeProp::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_type:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::EdgeType>::readWithContext(*iprot, this->type, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.type = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_props:
  {
    _readState.beforeSubobject(iprot);
    this->props = ::std::vector<::std::string>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::readWithContext(*iprot, this->props, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.props = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<EdgeProp>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_type;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_props;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t EdgeProp::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("EdgeProp");
  xfer += prot_->serializedFieldSize("type", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::EdgeType>::serializedSize<false>(*prot_, this->type);
  xfer += prot_->serializedFieldSize("props", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::serializedSize<false>(*prot_, this->props);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t EdgeProp::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("EdgeProp");
  xfer += prot_->serializedFieldSize("type", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::EdgeType>::serializedSize<false>(*prot_, this->type);
  xfer += prot_->serializedFieldSize("props", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::serializedSize<false>(*prot_, this->props);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t EdgeProp::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("EdgeProp");
  xfer += prot_->writeFieldBegin("type", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::EdgeType>::write(*prot_, this->type);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("props", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::write(*prot_, this->props);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void EdgeProp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t EdgeProp::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t EdgeProp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t EdgeProp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void EdgeProp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t EdgeProp::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t EdgeProp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t EdgeProp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void VertexProp::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_tag:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::TagID>::readWithContext(*iprot, this->tag, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.tag = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_props:
  {
    _readState.beforeSubobject(iprot);
    this->props = ::std::vector<::std::string>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::readWithContext(*iprot, this->props, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.props = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<VertexProp>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_tag;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_props;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t VertexProp::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("VertexProp");
  xfer += prot_->serializedFieldSize("tag", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::TagID>::serializedSize<false>(*prot_, this->tag);
  xfer += prot_->serializedFieldSize("props", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::serializedSize<false>(*prot_, this->props);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t VertexProp::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("VertexProp");
  xfer += prot_->serializedFieldSize("tag", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::TagID>::serializedSize<false>(*prot_, this->tag);
  xfer += prot_->serializedFieldSize("props", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::serializedSize<false>(*prot_, this->props);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t VertexProp::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("VertexProp");
  xfer += prot_->writeFieldBegin("tag", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::TagID>::write(*prot_, this->tag);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("props", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::write(*prot_, this->props);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void VertexProp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t VertexProp::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t VertexProp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t VertexProp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void VertexProp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t VertexProp::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t VertexProp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t VertexProp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void OrderBy::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_prop:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->prop, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.prop = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_direction:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::OrderDirection>::readWithContext(*iprot, this->direction, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.direction = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<OrderBy>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_prop;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_direction;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t OrderBy::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("OrderBy");
  xfer += prot_->serializedFieldSize("prop", apache::thrift::protocol::T_STRING, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->prop);
  xfer += prot_->serializedFieldSize("direction", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::OrderDirection>::serializedSize<false>(*prot_, this->direction);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t OrderBy::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("OrderBy");
  xfer += prot_->serializedFieldSize("prop", apache::thrift::protocol::T_STRING, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->prop);
  xfer += prot_->serializedFieldSize("direction", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::OrderDirection>::serializedSize<false>(*prot_, this->direction);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t OrderBy::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("OrderBy");
  xfer += prot_->writeFieldBegin("prop", apache::thrift::protocol::T_STRING, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->prop);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("direction", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::OrderDirection>::write(*prot_, this->direction);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void OrderBy::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t OrderBy::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t OrderBy::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t OrderBy::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void OrderBy::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t OrderBy::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t OrderBy::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t OrderBy::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void TraverseSpec::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_edge_types:
  {
    _readState.beforeSubobject(iprot);
    this->edge_types = ::std::vector< ::nebula::cpp2::EdgeType>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::EdgeType>>::readWithContext(*iprot, this->edge_types, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.edge_types = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_edge_direction:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::EdgeDirection>::readWithContext(*iprot, this->edge_direction, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.edge_direction = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_dedup:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->dedup, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.dedup = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_stat_props:
  {
    _readState.beforeSubobject(iprot);
    this->stat_props = ::std::vector< ::nebula::storage::cpp2::StatProp>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::StatProp>>::readWithContext(*iprot, this->stat_props, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.stat_props = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          5,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_vertex_props:
  {
    _readState.beforeSubobject(iprot);
    this->vertex_props = ::std::vector< ::nebula::storage::cpp2::VertexProp>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::VertexProp>>::readWithContext(*iprot, this->vertex_props, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.vertex_props = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          5,
          6,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_edge_props:
  {
    _readState.beforeSubobject(iprot);
    this->edge_props = ::std::vector< ::nebula::storage::cpp2::EdgeProp>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::EdgeProp>>::readWithContext(*iprot, this->edge_props, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.edge_props = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          6,
          7,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_expressions:
  {
    _readState.beforeSubobject(iprot);
    this->expressions = ::std::vector< ::nebula::storage::cpp2::Expr>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::Expr>>::readWithContext(*iprot, this->expressions, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.expressions = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          7,
          8,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_order_by:
  {
    _readState.beforeSubobject(iprot);
    this->order_by = ::std::vector< ::nebula::storage::cpp2::OrderBy>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::OrderBy>>::readWithContext(*iprot, this->order_by, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.order_by = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          8,
          9,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_random:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->random, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.random = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          9,
          10,
          apache::thrift::protocol::T_I64))) {
    goto _loop;
  }
_readField_limit:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::readWithContext(*iprot, this->limit, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.limit = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          10,
          11,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_filter:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->filter, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.filter = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          11,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<TraverseSpec>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_edge_types;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_edge_direction;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_dedup;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_stat_props;
      } else {
        goto _skip;
      }
    }
    case 5:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_vertex_props;
      } else {
        goto _skip;
      }
    }
    case 6:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_edge_props;
      } else {
        goto _skip;
      }
    }
    case 7:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_expressions;
      } else {
        goto _skip;
      }
    }
    case 8:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_order_by;
      } else {
        goto _skip;
      }
    }
    case 9:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_random;
      } else {
        goto _skip;
      }
    }
    case 10:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I64))) {
        goto _readField_limit;
      } else {
        goto _skip;
      }
    }
    case 11:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_filter;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t TraverseSpec::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("TraverseSpec");
  xfer += prot_->serializedFieldSize("edge_types", apache::thrift::protocol::T_LIST, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::EdgeType>>::serializedSize<false>(*prot_, this->edge_types);
  xfer += prot_->serializedFieldSize("edge_direction", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::EdgeDirection>::serializedSize<false>(*prot_, this->edge_direction);
  xfer += prot_->serializedFieldSize("dedup", apache::thrift::protocol::T_BOOL, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->dedup);
  if (this->stat_props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("stat_props", apache::thrift::protocol::T_LIST, 4);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::StatProp>>::serializedSize<false>(*prot_, this->stat_props);
  }
  if (this->vertex_props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("vertex_props", apache::thrift::protocol::T_LIST, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::VertexProp>>::serializedSize<false>(*prot_, this->vertex_props);
  }
  if (this->edge_props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("edge_props", apache::thrift::protocol::T_LIST, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::EdgeProp>>::serializedSize<false>(*prot_, this->edge_props);
  }
  if (this->expressions_ref().has_value()) {
    xfer += prot_->serializedFieldSize("expressions", apache::thrift::protocol::T_LIST, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::Expr>>::serializedSize<false>(*prot_, this->expressions);
  }
  if (this->order_by_ref().has_value()) {
    xfer += prot_->serializedFieldSize("order_by", apache::thrift::protocol::T_LIST, 8);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::OrderBy>>::serializedSize<false>(*prot_, this->order_by);
  }
  if (this->random_ref().has_value()) {
    xfer += prot_->serializedFieldSize("random", apache::thrift::protocol::T_BOOL, 9);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->random);
  }
  if (this->limit_ref().has_value()) {
    xfer += prot_->serializedFieldSize("limit", apache::thrift::protocol::T_I64, 10);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->limit);
  }
  if (this->filter_ref().has_value()) {
    xfer += prot_->serializedFieldSize("filter", apache::thrift::protocol::T_STRING, 11);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->filter);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t TraverseSpec::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("TraverseSpec");
  xfer += prot_->serializedFieldSize("edge_types", apache::thrift::protocol::T_LIST, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::EdgeType>>::serializedSize<false>(*prot_, this->edge_types);
  xfer += prot_->serializedFieldSize("edge_direction", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::EdgeDirection>::serializedSize<false>(*prot_, this->edge_direction);
  xfer += prot_->serializedFieldSize("dedup", apache::thrift::protocol::T_BOOL, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->dedup);
  if (this->stat_props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("stat_props", apache::thrift::protocol::T_LIST, 4);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::StatProp>>::serializedSize<false>(*prot_, this->stat_props);
  }
  if (this->vertex_props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("vertex_props", apache::thrift::protocol::T_LIST, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::VertexProp>>::serializedSize<false>(*prot_, this->vertex_props);
  }
  if (this->edge_props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("edge_props", apache::thrift::protocol::T_LIST, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::EdgeProp>>::serializedSize<false>(*prot_, this->edge_props);
  }
  if (this->expressions_ref().has_value()) {
    xfer += prot_->serializedFieldSize("expressions", apache::thrift::protocol::T_LIST, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::Expr>>::serializedSize<false>(*prot_, this->expressions);
  }
  if (this->order_by_ref().has_value()) {
    xfer += prot_->serializedFieldSize("order_by", apache::thrift::protocol::T_LIST, 8);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::OrderBy>>::serializedSize<false>(*prot_, this->order_by);
  }
  if (this->random_ref().has_value()) {
    xfer += prot_->serializedFieldSize("random", apache::thrift::protocol::T_BOOL, 9);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->random);
  }
  if (this->limit_ref().has_value()) {
    xfer += prot_->serializedFieldSize("limit", apache::thrift::protocol::T_I64, 10);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->limit);
  }
  if (this->filter_ref().has_value()) {
    xfer += prot_->serializedFieldSize("filter", apache::thrift::protocol::T_STRING, 11);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->filter);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t TraverseSpec::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("TraverseSpec");
  xfer += prot_->writeFieldBegin("edge_types", apache::thrift::protocol::T_LIST, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::EdgeType>>::write(*prot_, this->edge_types);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("edge_direction", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::EdgeDirection>::write(*prot_, this->edge_direction);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("dedup", apache::thrift::protocol::T_BOOL, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->dedup);
  xfer += prot_->writeFieldEnd();
  if (this->stat_props_ref().has_value()) {
    xfer += prot_->writeFieldBegin("stat_props", apache::thrift::protocol::T_LIST, 4);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::StatProp>>::write(*prot_, this->stat_props);
    xfer += prot_->writeFieldEnd();
  }
  if (this->vertex_props_ref().has_value()) {
    xfer += prot_->writeFieldBegin("vertex_props", apache::thrift::protocol::T_LIST, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::VertexProp>>::write(*prot_, this->vertex_props);
    xfer += prot_->writeFieldEnd();
  }
  if (this->edge_props_ref().has_value()) {
    xfer += prot_->writeFieldBegin("edge_props", apache::thrift::protocol::T_LIST, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::EdgeProp>>::write(*prot_, this->edge_props);
    xfer += prot_->writeFieldEnd();
  }
  if (this->expressions_ref().has_value()) {
    xfer += prot_->writeFieldBegin("expressions", apache::thrift::protocol::T_LIST, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::Expr>>::write(*prot_, this->expressions);
    xfer += prot_->writeFieldEnd();
  }
  if (this->order_by_ref().has_value()) {
    xfer += prot_->writeFieldBegin("order_by", apache::thrift::protocol::T_LIST, 8);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::OrderBy>>::write(*prot_, this->order_by);
    xfer += prot_->writeFieldEnd();
  }
  if (this->random_ref().has_value()) {
    xfer += prot_->writeFieldBegin("random", apache::thrift::protocol::T_BOOL, 9);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->random);
    xfer += prot_->writeFieldEnd();
  }
  if (this->limit_ref().has_value()) {
    xfer += prot_->writeFieldBegin("limit", apache::thrift::protocol::T_I64, 10);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::write(*prot_, this->limit);
    xfer += prot_->writeFieldEnd();
  }
  if (this->filter_ref().has_value()) {
    xfer += prot_->writeFieldBegin("filter", apache::thrift::protocol::T_STRING, 11);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->filter);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void TraverseSpec::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t TraverseSpec::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t TraverseSpec::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t TraverseSpec::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void TraverseSpec::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t TraverseSpec::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t TraverseSpec::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t TraverseSpec::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void GetNeighborsRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_column_names:
  {
    _readState.beforeSubobject(iprot);
    this->column_names = ::std::vector<::std::string>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::readWithContext(*iprot, this->column_names, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.column_names = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_MAP))) {
    goto _loop;
  }
_readField_parts:
  {
    _readState.beforeSubobject(iprot);
    this->parts = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>::readWithContext(*iprot, this->parts, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.parts = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_traverse_spec:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::TraverseSpec>::readWithContext(*iprot, this->traverse_spec, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.traverse_spec = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          5,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_common:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::readWithContext(*iprot, this->common, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.common = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          5,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<GetNeighborsRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_column_names;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_MAP))) {
        goto _readField_parts;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_traverse_spec;
      } else {
        goto _skip;
      }
    }
    case 5:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_common;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t GetNeighborsRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("GetNeighborsRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("column_names", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::serializedSize<false>(*prot_, this->column_names);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("traverse_spec", apache::thrift::protocol::T_STRUCT, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::TraverseSpec>::serializedSize<false>(*prot_, this->traverse_spec);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<false>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t GetNeighborsRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("GetNeighborsRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("column_names", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::serializedSize<false>(*prot_, this->column_names);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("traverse_spec", apache::thrift::protocol::T_STRUCT, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::TraverseSpec>::serializedSize<true>(*prot_, this->traverse_spec);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<true>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t GetNeighborsRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("GetNeighborsRequest");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("column_names", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::write(*prot_, this->column_names);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("parts", apache::thrift::protocol::T_MAP, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>::write(*prot_, this->parts);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("traverse_spec", apache::thrift::protocol::T_STRUCT, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::TraverseSpec>::write(*prot_, this->traverse_spec);
  xfer += prot_->writeFieldEnd();
  if (this->common_ref().has_value()) {
    xfer += prot_->writeFieldBegin("common", apache::thrift::protocol::T_STRUCT, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::write(*prot_, this->common);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void GetNeighborsRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t GetNeighborsRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t GetNeighborsRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t GetNeighborsRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void GetNeighborsRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t GetNeighborsRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t GetNeighborsRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t GetNeighborsRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void GetNeighborsResponse::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_result:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::readWithContext(*iprot, this->result, _readState);
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_vertices:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::readWithContext(*iprot, this->vertices, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.vertices = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<GetNeighborsResponse>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_result;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_vertices;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t GetNeighborsResponse::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("GetNeighborsResponse");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<false>(*prot_, this->result);
  if (this->vertices_ref().has_value()) {
    xfer += prot_->serializedFieldSize("vertices", apache::thrift::protocol::T_STRUCT, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::serializedSize<false>(*prot_, this->vertices);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t GetNeighborsResponse::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("GetNeighborsResponse");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<true>(*prot_, this->result);
  if (this->vertices_ref().has_value()) {
    xfer += prot_->serializedFieldSize("vertices", apache::thrift::protocol::T_STRUCT, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::serializedSize<true>(*prot_, this->vertices);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t GetNeighborsResponse::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("GetNeighborsResponse");
  xfer += prot_->writeFieldBegin("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::write(*prot_, this->result);
  xfer += prot_->writeFieldEnd();
  if (this->vertices_ref().has_value()) {
    xfer += prot_->writeFieldBegin("vertices", apache::thrift::protocol::T_STRUCT, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::write(*prot_, this->vertices);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void GetNeighborsResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t GetNeighborsResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t GetNeighborsResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t GetNeighborsResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void GetNeighborsResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t GetNeighborsResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t GetNeighborsResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t GetNeighborsResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void ExecResponse::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_result:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::readWithContext(*iprot, this->result, _readState);
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<ExecResponse>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_result;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t ExecResponse::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ExecResponse");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<false>(*prot_, this->result);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ExecResponse::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ExecResponse");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<true>(*prot_, this->result);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ExecResponse::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("ExecResponse");
  xfer += prot_->writeFieldBegin("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::write(*prot_, this->result);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void ExecResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t ExecResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t ExecResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t ExecResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void ExecResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t ExecResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t ExecResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t ExecResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void GetPropRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_MAP))) {
    goto _loop;
  }
_readField_parts:
  {
    _readState.beforeSubobject(iprot);
    this->parts = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>::readWithContext(*iprot, this->parts, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.parts = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_vertex_props:
  {
    _readState.beforeSubobject(iprot);
    this->vertex_props = ::std::vector< ::nebula::storage::cpp2::VertexProp>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::VertexProp>>::readWithContext(*iprot, this->vertex_props, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.vertex_props = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_edge_props:
  {
    _readState.beforeSubobject(iprot);
    this->edge_props = ::std::vector< ::nebula::storage::cpp2::EdgeProp>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::EdgeProp>>::readWithContext(*iprot, this->edge_props, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.edge_props = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          5,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_expressions:
  {
    _readState.beforeSubobject(iprot);
    this->expressions = ::std::vector< ::nebula::storage::cpp2::Expr>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::Expr>>::readWithContext(*iprot, this->expressions, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.expressions = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          5,
          6,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_dedup:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->dedup, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.dedup = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          6,
          7,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_order_by:
  {
    _readState.beforeSubobject(iprot);
    this->order_by = ::std::vector< ::nebula::storage::cpp2::OrderBy>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::OrderBy>>::readWithContext(*iprot, this->order_by, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.order_by = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          7,
          8,
          apache::thrift::protocol::T_I64))) {
    goto _loop;
  }
_readField_limit:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::readWithContext(*iprot, this->limit, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.limit = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          8,
          9,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_filter:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->filter, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.filter = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          9,
          10,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_common:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::readWithContext(*iprot, this->common, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.common = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          10,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<GetPropRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_MAP))) {
        goto _readField_parts;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_vertex_props;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_edge_props;
      } else {
        goto _skip;
      }
    }
    case 5:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_expressions;
      } else {
        goto _skip;
      }
    }
    case 6:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_dedup;
      } else {
        goto _skip;
      }
    }
    case 7:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_order_by;
      } else {
        goto _skip;
      }
    }
    case 8:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I64))) {
        goto _readField_limit;
      } else {
        goto _skip;
      }
    }
    case 9:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_filter;
      } else {
        goto _skip;
      }
    }
    case 10:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_common;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t GetPropRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("GetPropRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>::serializedSize<false>(*prot_, this->parts);
  if (this->vertex_props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("vertex_props", apache::thrift::protocol::T_LIST, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::VertexProp>>::serializedSize<false>(*prot_, this->vertex_props);
  }
  if (this->edge_props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("edge_props", apache::thrift::protocol::T_LIST, 4);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::EdgeProp>>::serializedSize<false>(*prot_, this->edge_props);
  }
  if (this->expressions_ref().has_value()) {
    xfer += prot_->serializedFieldSize("expressions", apache::thrift::protocol::T_LIST, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::Expr>>::serializedSize<false>(*prot_, this->expressions);
  }
  xfer += prot_->serializedFieldSize("dedup", apache::thrift::protocol::T_BOOL, 6);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->dedup);
  if (this->order_by_ref().has_value()) {
    xfer += prot_->serializedFieldSize("order_by", apache::thrift::protocol::T_LIST, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::OrderBy>>::serializedSize<false>(*prot_, this->order_by);
  }
  if (this->limit_ref().has_value()) {
    xfer += prot_->serializedFieldSize("limit", apache::thrift::protocol::T_I64, 8);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->limit);
  }
  if (this->filter_ref().has_value()) {
    xfer += prot_->serializedFieldSize("filter", apache::thrift::protocol::T_STRING, 9);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->filter);
  }
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 10);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<false>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t GetPropRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("GetPropRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>::serializedSize<false>(*prot_, this->parts);
  if (this->vertex_props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("vertex_props", apache::thrift::protocol::T_LIST, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::VertexProp>>::serializedSize<false>(*prot_, this->vertex_props);
  }
  if (this->edge_props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("edge_props", apache::thrift::protocol::T_LIST, 4);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::EdgeProp>>::serializedSize<false>(*prot_, this->edge_props);
  }
  if (this->expressions_ref().has_value()) {
    xfer += prot_->serializedFieldSize("expressions", apache::thrift::protocol::T_LIST, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::Expr>>::serializedSize<false>(*prot_, this->expressions);
  }
  xfer += prot_->serializedFieldSize("dedup", apache::thrift::protocol::T_BOOL, 6);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->dedup);
  if (this->order_by_ref().has_value()) {
    xfer += prot_->serializedFieldSize("order_by", apache::thrift::protocol::T_LIST, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::OrderBy>>::serializedSize<false>(*prot_, this->order_by);
  }
  if (this->limit_ref().has_value()) {
    xfer += prot_->serializedFieldSize("limit", apache::thrift::protocol::T_I64, 8);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->limit);
  }
  if (this->filter_ref().has_value()) {
    xfer += prot_->serializedFieldSize("filter", apache::thrift::protocol::T_STRING, 9);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->filter);
  }
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 10);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<true>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t GetPropRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("GetPropRequest");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>::write(*prot_, this->parts);
  xfer += prot_->writeFieldEnd();
  if (this->vertex_props_ref().has_value()) {
    xfer += prot_->writeFieldBegin("vertex_props", apache::thrift::protocol::T_LIST, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::VertexProp>>::write(*prot_, this->vertex_props);
    xfer += prot_->writeFieldEnd();
  }
  if (this->edge_props_ref().has_value()) {
    xfer += prot_->writeFieldBegin("edge_props", apache::thrift::protocol::T_LIST, 4);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::EdgeProp>>::write(*prot_, this->edge_props);
    xfer += prot_->writeFieldEnd();
  }
  if (this->expressions_ref().has_value()) {
    xfer += prot_->writeFieldBegin("expressions", apache::thrift::protocol::T_LIST, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::Expr>>::write(*prot_, this->expressions);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldBegin("dedup", apache::thrift::protocol::T_BOOL, 6);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->dedup);
  xfer += prot_->writeFieldEnd();
  if (this->order_by_ref().has_value()) {
    xfer += prot_->writeFieldBegin("order_by", apache::thrift::protocol::T_LIST, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::OrderBy>>::write(*prot_, this->order_by);
    xfer += prot_->writeFieldEnd();
  }
  if (this->limit_ref().has_value()) {
    xfer += prot_->writeFieldBegin("limit", apache::thrift::protocol::T_I64, 8);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::write(*prot_, this->limit);
    xfer += prot_->writeFieldEnd();
  }
  if (this->filter_ref().has_value()) {
    xfer += prot_->writeFieldBegin("filter", apache::thrift::protocol::T_STRING, 9);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->filter);
    xfer += prot_->writeFieldEnd();
  }
  if (this->common_ref().has_value()) {
    xfer += prot_->writeFieldBegin("common", apache::thrift::protocol::T_STRUCT, 10);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::write(*prot_, this->common);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void GetPropRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t GetPropRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t GetPropRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t GetPropRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void GetPropRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t GetPropRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t GetPropRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t GetPropRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void GetPropResponse::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_result:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::readWithContext(*iprot, this->result, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.result = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_props:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::readWithContext(*iprot, this->props, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.props = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<GetPropResponse>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_result;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_props;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t GetPropResponse::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("GetPropResponse");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<false>(*prot_, this->result);
  if (this->props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("props", apache::thrift::protocol::T_STRUCT, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::serializedSize<false>(*prot_, this->props);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t GetPropResponse::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("GetPropResponse");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<true>(*prot_, this->result);
  if (this->props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("props", apache::thrift::protocol::T_STRUCT, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::serializedSize<true>(*prot_, this->props);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t GetPropResponse::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("GetPropResponse");
  xfer += prot_->writeFieldBegin("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::write(*prot_, this->result);
  xfer += prot_->writeFieldEnd();
  if (this->props_ref().has_value()) {
    xfer += prot_->writeFieldBegin("props", apache::thrift::protocol::T_STRUCT, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::write(*prot_, this->props);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void GetPropResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t GetPropResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t GetPropResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t GetPropResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void GetPropResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t GetPropResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t GetPropResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t GetPropResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void NewTag::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_tag_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::TagID>::readWithContext(*iprot, this->tag_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.tag_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_props:
  {
    _readState.beforeSubobject(iprot);
    this->props = ::std::vector<nebula::Value>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>, ::std::vector<nebula::Value>>::readWithContext(*iprot, this->props, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.props = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<NewTag>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_tag_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_props;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t NewTag::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("NewTag");
  xfer += prot_->serializedFieldSize("tag_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::TagID>::serializedSize<false>(*prot_, this->tag_id);
  xfer += prot_->serializedFieldSize("props", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>, ::std::vector<nebula::Value>>::serializedSize<false>(*prot_, this->props);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t NewTag::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("NewTag");
  xfer += prot_->serializedFieldSize("tag_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::TagID>::serializedSize<false>(*prot_, this->tag_id);
  xfer += prot_->serializedFieldSize("props", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>, ::std::vector<nebula::Value>>::serializedSize<false>(*prot_, this->props);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t NewTag::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("NewTag");
  xfer += prot_->writeFieldBegin("tag_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::TagID>::write(*prot_, this->tag_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("props", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>, ::std::vector<nebula::Value>>::write(*prot_, this->props);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void NewTag::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t NewTag::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t NewTag::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t NewTag::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void NewTag::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t NewTag::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t NewTag::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t NewTag::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void NewVertex::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_id:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::readWithContext(*iprot, this->id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_tags:
  {
    _readState.beforeSubobject(iprot);
    this->tags = ::std::vector< ::nebula::storage::cpp2::NewTag>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::NewTag>>::readWithContext(*iprot, this->tags, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.tags = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<NewVertex>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_tags;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t NewVertex::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("NewVertex");
  xfer += prot_->serializedFieldSize("id", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::serializedSize<false>(*prot_, this->id);
  xfer += prot_->serializedFieldSize("tags", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::NewTag>>::serializedSize<false>(*prot_, this->tags);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t NewVertex::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("NewVertex");
  xfer += prot_->serializedFieldSize("id", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::serializedSize<true>(*prot_, this->id);
  xfer += prot_->serializedFieldSize("tags", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::NewTag>>::serializedSize<false>(*prot_, this->tags);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t NewVertex::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("NewVertex");
  xfer += prot_->writeFieldBegin("id", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::write(*prot_, this->id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("tags", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::NewTag>>::write(*prot_, this->tags);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void NewVertex::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t NewVertex::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t NewVertex::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t NewVertex::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void NewVertex::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t NewVertex::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t NewVertex::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t NewVertex::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void EdgeKey::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_src:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::readWithContext(*iprot, this->src, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.src = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_edge_type:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::EdgeType>::readWithContext(*iprot, this->edge_type, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.edge_type = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_I64))) {
    goto _loop;
  }
_readField_ranking:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::EdgeRanking>::readWithContext(*iprot, this->ranking, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.ranking = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_dst:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::readWithContext(*iprot, this->dst, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.dst = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<EdgeKey>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_src;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_edge_type;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I64))) {
        goto _readField_ranking;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_dst;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t EdgeKey::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("EdgeKey");
  xfer += prot_->serializedFieldSize("src", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::serializedSize<false>(*prot_, this->src);
  xfer += prot_->serializedFieldSize("edge_type", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::EdgeType>::serializedSize<false>(*prot_, this->edge_type);
  xfer += prot_->serializedFieldSize("ranking", apache::thrift::protocol::T_I64, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::EdgeRanking>::serializedSize<false>(*prot_, this->ranking);
  xfer += prot_->serializedFieldSize("dst", apache::thrift::protocol::T_STRUCT, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::serializedSize<false>(*prot_, this->dst);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t EdgeKey::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("EdgeKey");
  xfer += prot_->serializedFieldSize("src", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::serializedSize<true>(*prot_, this->src);
  xfer += prot_->serializedFieldSize("edge_type", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::EdgeType>::serializedSize<false>(*prot_, this->edge_type);
  xfer += prot_->serializedFieldSize("ranking", apache::thrift::protocol::T_I64, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::EdgeRanking>::serializedSize<false>(*prot_, this->ranking);
  xfer += prot_->serializedFieldSize("dst", apache::thrift::protocol::T_STRUCT, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::serializedSize<true>(*prot_, this->dst);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t EdgeKey::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("EdgeKey");
  xfer += prot_->writeFieldBegin("src", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::write(*prot_, this->src);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("edge_type", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::EdgeType>::write(*prot_, this->edge_type);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("ranking", apache::thrift::protocol::T_I64, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::EdgeRanking>::write(*prot_, this->ranking);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("dst", apache::thrift::protocol::T_STRUCT, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::write(*prot_, this->dst);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void EdgeKey::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t EdgeKey::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t EdgeKey::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t EdgeKey::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void EdgeKey::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t EdgeKey::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t EdgeKey::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t EdgeKey::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void NewEdge::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_key:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::EdgeKey>::readWithContext(*iprot, this->key, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.key = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_props:
  {
    _readState.beforeSubobject(iprot);
    this->props = ::std::vector<nebula::Value>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>, ::std::vector<nebula::Value>>::readWithContext(*iprot, this->props, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.props = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<NewEdge>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_key;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_props;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t NewEdge::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("NewEdge");
  xfer += prot_->serializedFieldSize("key", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::EdgeKey>::serializedSize<false>(*prot_, this->key);
  xfer += prot_->serializedFieldSize("props", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>, ::std::vector<nebula::Value>>::serializedSize<false>(*prot_, this->props);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t NewEdge::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("NewEdge");
  xfer += prot_->serializedFieldSize("key", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::EdgeKey>::serializedSize<true>(*prot_, this->key);
  xfer += prot_->serializedFieldSize("props", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>, ::std::vector<nebula::Value>>::serializedSize<false>(*prot_, this->props);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t NewEdge::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("NewEdge");
  xfer += prot_->writeFieldBegin("key", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::EdgeKey>::write(*prot_, this->key);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("props", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>, ::std::vector<nebula::Value>>::write(*prot_, this->props);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void NewEdge::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t NewEdge::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t NewEdge::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t NewEdge::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void NewEdge::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t NewEdge::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t NewEdge::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t NewEdge::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void AddVerticesRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_MAP))) {
    goto _loop;
  }
_readField_parts:
  {
    _readState.beforeSubobject(iprot);
    this->parts = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>>>::readWithContext(*iprot, this->parts, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.parts = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_MAP))) {
    goto _loop;
  }
_readField_prop_names:
  {
    _readState.beforeSubobject(iprot);
    this->prop_names = std::unordered_map< ::nebula::cpp2::TagID, ::std::vector<::std::string>>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>>, std::unordered_map< ::nebula::cpp2::TagID, ::std::vector<::std::string>>>::readWithContext(*iprot, this->prop_names, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.prop_names = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_if_not_exists:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->if_not_exists, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.if_not_exists = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          5,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_ignore_existed_index:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->ignore_existed_index, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.ignore_existed_index = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          5,
          6,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_common:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::readWithContext(*iprot, this->common, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.common = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          6,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<AddVerticesRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_MAP))) {
        goto _readField_parts;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_MAP))) {
        goto _readField_prop_names;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_if_not_exists;
      } else {
        goto _skip;
      }
    }
    case 5:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_ignore_existed_index;
      } else {
        goto _skip;
      }
    }
    case 6:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_common;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t AddVerticesRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("AddVerticesRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("prop_names", apache::thrift::protocol::T_MAP, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>>, std::unordered_map< ::nebula::cpp2::TagID, ::std::vector<::std::string>>>::serializedSize<false>(*prot_, this->prop_names);
  xfer += prot_->serializedFieldSize("if_not_exists", apache::thrift::protocol::T_BOOL, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->if_not_exists);
  xfer += prot_->serializedFieldSize("ignore_existed_index", apache::thrift::protocol::T_BOOL, 5);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->ignore_existed_index);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<false>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t AddVerticesRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("AddVerticesRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("prop_names", apache::thrift::protocol::T_MAP, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>>, std::unordered_map< ::nebula::cpp2::TagID, ::std::vector<::std::string>>>::serializedSize<false>(*prot_, this->prop_names);
  xfer += prot_->serializedFieldSize("if_not_exists", apache::thrift::protocol::T_BOOL, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->if_not_exists);
  xfer += prot_->serializedFieldSize("ignore_existed_index", apache::thrift::protocol::T_BOOL, 5);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->ignore_existed_index);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<true>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t AddVerticesRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("AddVerticesRequest");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>>>::write(*prot_, this->parts);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("prop_names", apache::thrift::protocol::T_MAP, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>>, std::unordered_map< ::nebula::cpp2::TagID, ::std::vector<::std::string>>>::write(*prot_, this->prop_names);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("if_not_exists", apache::thrift::protocol::T_BOOL, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->if_not_exists);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("ignore_existed_index", apache::thrift::protocol::T_BOOL, 5);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->ignore_existed_index);
  xfer += prot_->writeFieldEnd();
  if (this->common_ref().has_value()) {
    xfer += prot_->writeFieldBegin("common", apache::thrift::protocol::T_STRUCT, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::write(*prot_, this->common);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void AddVerticesRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t AddVerticesRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t AddVerticesRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t AddVerticesRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void AddVerticesRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t AddVerticesRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t AddVerticesRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t AddVerticesRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void AddEdgesRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_MAP))) {
    goto _loop;
  }
_readField_parts:
  {
    _readState.beforeSubobject(iprot);
    this->parts = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>::readWithContext(*iprot, this->parts, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.parts = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_prop_names:
  {
    _readState.beforeSubobject(iprot);
    this->prop_names = ::std::vector<::std::string>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::readWithContext(*iprot, this->prop_names, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.prop_names = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_if_not_exists:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->if_not_exists, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.if_not_exists = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          5,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_ignore_existed_index:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->ignore_existed_index, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.ignore_existed_index = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          5,
          6,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_common:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::readWithContext(*iprot, this->common, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.common = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          6,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<AddEdgesRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_MAP))) {
        goto _readField_parts;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_prop_names;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_if_not_exists;
      } else {
        goto _skip;
      }
    }
    case 5:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_ignore_existed_index;
      } else {
        goto _skip;
      }
    }
    case 6:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_common;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t AddEdgesRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("AddEdgesRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("prop_names", apache::thrift::protocol::T_LIST, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::serializedSize<false>(*prot_, this->prop_names);
  xfer += prot_->serializedFieldSize("if_not_exists", apache::thrift::protocol::T_BOOL, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->if_not_exists);
  xfer += prot_->serializedFieldSize("ignore_existed_index", apache::thrift::protocol::T_BOOL, 5);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->ignore_existed_index);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<false>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t AddEdgesRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("AddEdgesRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("prop_names", apache::thrift::protocol::T_LIST, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::serializedSize<false>(*prot_, this->prop_names);
  xfer += prot_->serializedFieldSize("if_not_exists", apache::thrift::protocol::T_BOOL, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->if_not_exists);
  xfer += prot_->serializedFieldSize("ignore_existed_index", apache::thrift::protocol::T_BOOL, 5);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->ignore_existed_index);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<true>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t AddEdgesRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("AddEdgesRequest");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>::write(*prot_, this->parts);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("prop_names", apache::thrift::protocol::T_LIST, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::write(*prot_, this->prop_names);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("if_not_exists", apache::thrift::protocol::T_BOOL, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->if_not_exists);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("ignore_existed_index", apache::thrift::protocol::T_BOOL, 5);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->ignore_existed_index);
  xfer += prot_->writeFieldEnd();
  if (this->common_ref().has_value()) {
    xfer += prot_->writeFieldBegin("common", apache::thrift::protocol::T_STRUCT, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::write(*prot_, this->common);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void AddEdgesRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t AddEdgesRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t AddEdgesRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t AddEdgesRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void AddEdgesRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t AddEdgesRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t AddEdgesRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t AddEdgesRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void DeleteVerticesRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_MAP))) {
    goto _loop;
  }
_readField_parts:
  {
    _readState.beforeSubobject(iprot);
    this->parts = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>>::readWithContext(*iprot, this->parts, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.parts = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_common:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::readWithContext(*iprot, this->common, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.common = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<DeleteVerticesRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_MAP))) {
        goto _readField_parts;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_common;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t DeleteVerticesRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("DeleteVerticesRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>>::serializedSize<false>(*prot_, this->parts);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<false>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t DeleteVerticesRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("DeleteVerticesRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>>::serializedSize<false>(*prot_, this->parts);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<true>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t DeleteVerticesRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("DeleteVerticesRequest");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>>::write(*prot_, this->parts);
  xfer += prot_->writeFieldEnd();
  if (this->common_ref().has_value()) {
    xfer += prot_->writeFieldBegin("common", apache::thrift::protocol::T_STRUCT, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::write(*prot_, this->common);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void DeleteVerticesRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t DeleteVerticesRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t DeleteVerticesRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t DeleteVerticesRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void DeleteVerticesRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t DeleteVerticesRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t DeleteVerticesRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t DeleteVerticesRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void DeleteEdgesRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_MAP))) {
    goto _loop;
  }
_readField_parts:
  {
    _readState.beforeSubobject(iprot);
    this->parts = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>::readWithContext(*iprot, this->parts, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.parts = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_common:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::readWithContext(*iprot, this->common, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.common = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<DeleteEdgesRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_MAP))) {
        goto _readField_parts;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_common;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t DeleteEdgesRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("DeleteEdgesRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>::serializedSize<false>(*prot_, this->parts);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<false>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t DeleteEdgesRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("DeleteEdgesRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>::serializedSize<false>(*prot_, this->parts);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<true>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t DeleteEdgesRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("DeleteEdgesRequest");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>::write(*prot_, this->parts);
  xfer += prot_->writeFieldEnd();
  if (this->common_ref().has_value()) {
    xfer += prot_->writeFieldBegin("common", apache::thrift::protocol::T_STRUCT, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::write(*prot_, this->common);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void DeleteEdgesRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t DeleteEdgesRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t DeleteEdgesRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t DeleteEdgesRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void DeleteEdgesRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t DeleteEdgesRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t DeleteEdgesRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t DeleteEdgesRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void DelTags::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_id:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::readWithContext(*iprot, this->id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_tags:
  {
    _readState.beforeSubobject(iprot);
    this->tags = ::std::vector< ::nebula::cpp2::TagID>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::TagID>>::readWithContext(*iprot, this->tags, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.tags = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<DelTags>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_tags;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t DelTags::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("DelTags");
  xfer += prot_->serializedFieldSize("id", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::serializedSize<false>(*prot_, this->id);
  xfer += prot_->serializedFieldSize("tags", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::TagID>>::serializedSize<false>(*prot_, this->tags);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t DelTags::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("DelTags");
  xfer += prot_->serializedFieldSize("id", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::serializedSize<true>(*prot_, this->id);
  xfer += prot_->serializedFieldSize("tags", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::TagID>>::serializedSize<false>(*prot_, this->tags);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t DelTags::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("DelTags");
  xfer += prot_->writeFieldBegin("id", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::write(*prot_, this->id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("tags", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::TagID>>::write(*prot_, this->tags);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void DelTags::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t DelTags::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t DelTags::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t DelTags::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void DelTags::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t DelTags::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t DelTags::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t DelTags::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void DeleteTagsRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_MAP))) {
    goto _loop;
  }
_readField_parts:
  {
    _readState.beforeSubobject(iprot);
    this->parts = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>>>::readWithContext(*iprot, this->parts, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.parts = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_common:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::readWithContext(*iprot, this->common, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.common = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<DeleteTagsRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_MAP))) {
        goto _readField_parts;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_common;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t DeleteTagsRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("DeleteTagsRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>>>::serializedSize<false>(*prot_, this->parts);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<false>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t DeleteTagsRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("DeleteTagsRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>>>::serializedSize<false>(*prot_, this->parts);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<true>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t DeleteTagsRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("DeleteTagsRequest");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>>>::write(*prot_, this->parts);
  xfer += prot_->writeFieldEnd();
  if (this->common_ref().has_value()) {
    xfer += prot_->writeFieldBegin("common", apache::thrift::protocol::T_STRUCT, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::write(*prot_, this->common);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void DeleteTagsRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t DeleteTagsRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t DeleteTagsRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t DeleteTagsRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void DeleteTagsRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t DeleteTagsRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t DeleteTagsRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t DeleteTagsRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void UpdateResponse::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_result:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::readWithContext(*iprot, this->result, _readState);
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_props:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::readWithContext(*iprot, this->props, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.props = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<UpdateResponse>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_result;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_props;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t UpdateResponse::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("UpdateResponse");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<false>(*prot_, this->result);
  if (this->props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("props", apache::thrift::protocol::T_STRUCT, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::serializedSize<false>(*prot_, this->props);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t UpdateResponse::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("UpdateResponse");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<true>(*prot_, this->result);
  if (this->props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("props", apache::thrift::protocol::T_STRUCT, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::serializedSize<true>(*prot_, this->props);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t UpdateResponse::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("UpdateResponse");
  xfer += prot_->writeFieldBegin("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::write(*prot_, this->result);
  xfer += prot_->writeFieldEnd();
  if (this->props_ref().has_value()) {
    xfer += prot_->writeFieldBegin("props", apache::thrift::protocol::T_STRUCT, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::write(*prot_, this->props);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void UpdateResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t UpdateResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t UpdateResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t UpdateResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void UpdateResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t UpdateResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t UpdateResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t UpdateResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void UpdatedProp::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_name:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->name, _readState);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_value:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->value, _readState);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<UpdatedProp>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_name;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_value;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t UpdatedProp::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("UpdatedProp");
  xfer += prot_->serializedFieldSize("name", apache::thrift::protocol::T_STRING, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->name);
  xfer += prot_->serializedFieldSize("value", apache::thrift::protocol::T_STRING, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->value);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t UpdatedProp::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("UpdatedProp");
  xfer += prot_->serializedFieldSize("name", apache::thrift::protocol::T_STRING, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->name);
  xfer += prot_->serializedFieldSize("value", apache::thrift::protocol::T_STRING, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->value);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t UpdatedProp::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("UpdatedProp");
  xfer += prot_->writeFieldBegin("name", apache::thrift::protocol::T_STRING, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->name);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("value", apache::thrift::protocol::T_STRING, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->value);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void UpdatedProp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t UpdatedProp::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t UpdatedProp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t UpdatedProp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void UpdatedProp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t UpdatedProp::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t UpdatedProp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t UpdatedProp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void UpdateVertexRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_part_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::readWithContext(*iprot, this->part_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.part_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_vertex_id:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::readWithContext(*iprot, this->vertex_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.vertex_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_tag_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::TagID>::readWithContext(*iprot, this->tag_id, _readState);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          5,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_updated_props:
  {
    _readState.beforeSubobject(iprot);
    this->updated_props = ::std::vector< ::nebula::storage::cpp2::UpdatedProp>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>::readWithContext(*iprot, this->updated_props, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.updated_props = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          5,
          6,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_insertable:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->insertable, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.insertable = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          6,
          7,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_return_props:
  {
    _readState.beforeSubobject(iprot);
    this->return_props = ::std::vector<::std::string>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::readWithContext(*iprot, this->return_props, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.return_props = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          7,
          8,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_condition:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->condition, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.condition = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          8,
          9,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_common:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::readWithContext(*iprot, this->common, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.common = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          9,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<UpdateVertexRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_part_id;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_vertex_id;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_tag_id;
      } else {
        goto _skip;
      }
    }
    case 5:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_updated_props;
      } else {
        goto _skip;
      }
    }
    case 6:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_insertable;
      } else {
        goto _skip;
      }
    }
    case 7:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_return_props;
      } else {
        goto _skip;
      }
    }
    case 8:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_condition;
      } else {
        goto _skip;
      }
    }
    case 9:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_common;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t UpdateVertexRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("UpdateVertexRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedFieldSize("vertex_id", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::serializedSize<false>(*prot_, this->vertex_id);
  xfer += prot_->serializedFieldSize("tag_id", apache::thrift::protocol::T_I32, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::TagID>::serializedSize<false>(*prot_, this->tag_id);
  xfer += prot_->serializedFieldSize("updated_props", apache::thrift::protocol::T_LIST, 5);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>::serializedSize<false>(*prot_, this->updated_props);
  if (this->insertable_ref().has_value()) {
    xfer += prot_->serializedFieldSize("insertable", apache::thrift::protocol::T_BOOL, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->insertable);
  }
  if (this->return_props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("return_props", apache::thrift::protocol::T_LIST, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::serializedSize<false>(*prot_, this->return_props);
  }
  if (this->condition_ref().has_value()) {
    xfer += prot_->serializedFieldSize("condition", apache::thrift::protocol::T_STRING, 8);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->condition);
  }
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 9);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<false>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t UpdateVertexRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("UpdateVertexRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedFieldSize("vertex_id", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::serializedSize<true>(*prot_, this->vertex_id);
  xfer += prot_->serializedFieldSize("tag_id", apache::thrift::protocol::T_I32, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::TagID>::serializedSize<false>(*prot_, this->tag_id);
  xfer += prot_->serializedFieldSize("updated_props", apache::thrift::protocol::T_LIST, 5);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>::serializedSize<false>(*prot_, this->updated_props);
  if (this->insertable_ref().has_value()) {
    xfer += prot_->serializedFieldSize("insertable", apache::thrift::protocol::T_BOOL, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->insertable);
  }
  if (this->return_props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("return_props", apache::thrift::protocol::T_LIST, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::serializedSize<false>(*prot_, this->return_props);
  }
  if (this->condition_ref().has_value()) {
    xfer += prot_->serializedFieldSize("condition", apache::thrift::protocol::T_STRING, 8);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->condition);
  }
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 9);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<true>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t UpdateVertexRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("UpdateVertexRequest");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::write(*prot_, this->part_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("vertex_id", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::write(*prot_, this->vertex_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("tag_id", apache::thrift::protocol::T_I32, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::TagID>::write(*prot_, this->tag_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("updated_props", apache::thrift::protocol::T_LIST, 5);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>::write(*prot_, this->updated_props);
  xfer += prot_->writeFieldEnd();
  if (this->insertable_ref().has_value()) {
    xfer += prot_->writeFieldBegin("insertable", apache::thrift::protocol::T_BOOL, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->insertable);
    xfer += prot_->writeFieldEnd();
  }
  if (this->return_props_ref().has_value()) {
    xfer += prot_->writeFieldBegin("return_props", apache::thrift::protocol::T_LIST, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::write(*prot_, this->return_props);
    xfer += prot_->writeFieldEnd();
  }
  if (this->condition_ref().has_value()) {
    xfer += prot_->writeFieldBegin("condition", apache::thrift::protocol::T_STRING, 8);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->condition);
    xfer += prot_->writeFieldEnd();
  }
  if (this->common_ref().has_value()) {
    xfer += prot_->writeFieldBegin("common", apache::thrift::protocol::T_STRUCT, 9);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::write(*prot_, this->common);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void UpdateVertexRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t UpdateVertexRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t UpdateVertexRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t UpdateVertexRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void UpdateVertexRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t UpdateVertexRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t UpdateVertexRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t UpdateVertexRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void UpdateEdgeRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_part_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::readWithContext(*iprot, this->part_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.part_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_edge_key:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::EdgeKey>::readWithContext(*iprot, this->edge_key, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.edge_key = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_updated_props:
  {
    _readState.beforeSubobject(iprot);
    this->updated_props = ::std::vector< ::nebula::storage::cpp2::UpdatedProp>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>::readWithContext(*iprot, this->updated_props, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.updated_props = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          5,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_insertable:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->insertable, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.insertable = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          5,
          6,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_return_props:
  {
    _readState.beforeSubobject(iprot);
    this->return_props = ::std::vector<::std::string>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::readWithContext(*iprot, this->return_props, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.return_props = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          6,
          7,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_condition:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->condition, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.condition = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          7,
          8,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_common:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::readWithContext(*iprot, this->common, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.common = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          8,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<UpdateEdgeRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_part_id;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_edge_key;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_updated_props;
      } else {
        goto _skip;
      }
    }
    case 5:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_insertable;
      } else {
        goto _skip;
      }
    }
    case 6:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_return_props;
      } else {
        goto _skip;
      }
    }
    case 7:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_condition;
      } else {
        goto _skip;
      }
    }
    case 8:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_common;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t UpdateEdgeRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("UpdateEdgeRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedFieldSize("edge_key", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::EdgeKey>::serializedSize<false>(*prot_, this->edge_key);
  xfer += prot_->serializedFieldSize("updated_props", apache::thrift::protocol::T_LIST, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>::serializedSize<false>(*prot_, this->updated_props);
  if (this->insertable_ref().has_value()) {
    xfer += prot_->serializedFieldSize("insertable", apache::thrift::protocol::T_BOOL, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->insertable);
  }
  if (this->return_props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("return_props", apache::thrift::protocol::T_LIST, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::serializedSize<false>(*prot_, this->return_props);
  }
  if (this->condition_ref().has_value()) {
    xfer += prot_->serializedFieldSize("condition", apache::thrift::protocol::T_STRING, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->condition);
  }
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 8);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<false>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t UpdateEdgeRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("UpdateEdgeRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedFieldSize("edge_key", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::EdgeKey>::serializedSize<true>(*prot_, this->edge_key);
  xfer += prot_->serializedFieldSize("updated_props", apache::thrift::protocol::T_LIST, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>::serializedSize<false>(*prot_, this->updated_props);
  if (this->insertable_ref().has_value()) {
    xfer += prot_->serializedFieldSize("insertable", apache::thrift::protocol::T_BOOL, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->insertable);
  }
  if (this->return_props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("return_props", apache::thrift::protocol::T_LIST, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::serializedSize<false>(*prot_, this->return_props);
  }
  if (this->condition_ref().has_value()) {
    xfer += prot_->serializedFieldSize("condition", apache::thrift::protocol::T_STRING, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->condition);
  }
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 8);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<true>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t UpdateEdgeRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("UpdateEdgeRequest");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::write(*prot_, this->part_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("edge_key", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::EdgeKey>::write(*prot_, this->edge_key);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("updated_props", apache::thrift::protocol::T_LIST, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>::write(*prot_, this->updated_props);
  xfer += prot_->writeFieldEnd();
  if (this->insertable_ref().has_value()) {
    xfer += prot_->writeFieldBegin("insertable", apache::thrift::protocol::T_BOOL, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->insertable);
    xfer += prot_->writeFieldEnd();
  }
  if (this->return_props_ref().has_value()) {
    xfer += prot_->writeFieldBegin("return_props", apache::thrift::protocol::T_LIST, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::write(*prot_, this->return_props);
    xfer += prot_->writeFieldEnd();
  }
  if (this->condition_ref().has_value()) {
    xfer += prot_->writeFieldBegin("condition", apache::thrift::protocol::T_STRING, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->condition);
    xfer += prot_->writeFieldEnd();
  }
  if (this->common_ref().has_value()) {
    xfer += prot_->writeFieldBegin("common", apache::thrift::protocol::T_STRUCT, 8);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::write(*prot_, this->common);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void UpdateEdgeRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t UpdateEdgeRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t UpdateEdgeRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t UpdateEdgeRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void UpdateEdgeRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t UpdateEdgeRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t UpdateEdgeRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t UpdateEdgeRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void GetUUIDReq::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_part_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::readWithContext(*iprot, this->part_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.part_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_name:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->name, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.name = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_common:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::readWithContext(*iprot, this->common, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.common = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<GetUUIDReq>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_part_id;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_name;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_common;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t GetUUIDReq::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("GetUUIDReq");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedFieldSize("name", apache::thrift::protocol::T_STRING, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->name);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 4);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<false>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t GetUUIDReq::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("GetUUIDReq");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedFieldSize("name", apache::thrift::protocol::T_STRING, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->name);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 4);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<true>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t GetUUIDReq::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("GetUUIDReq");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::write(*prot_, this->part_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("name", apache::thrift::protocol::T_STRING, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->name);
  xfer += prot_->writeFieldEnd();
  if (this->common_ref().has_value()) {
    xfer += prot_->writeFieldBegin("common", apache::thrift::protocol::T_STRUCT, 4);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::write(*prot_, this->common);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void GetUUIDReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t GetUUIDReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t GetUUIDReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t GetUUIDReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void GetUUIDReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t GetUUIDReq::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t GetUUIDReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t GetUUIDReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void GetUUIDResp::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_result:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::readWithContext(*iprot, this->result, _readState);
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_id:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::readWithContext(*iprot, this->id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<GetUUIDResp>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_result;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_id;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t GetUUIDResp::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("GetUUIDResp");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<false>(*prot_, this->result);
  xfer += prot_->serializedFieldSize("id", apache::thrift::protocol::T_STRUCT, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::serializedSize<false>(*prot_, this->id);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t GetUUIDResp::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("GetUUIDResp");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<true>(*prot_, this->result);
  xfer += prot_->serializedFieldSize("id", apache::thrift::protocol::T_STRUCT, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::serializedSize<true>(*prot_, this->id);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t GetUUIDResp::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("GetUUIDResp");
  xfer += prot_->writeFieldBegin("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::write(*prot_, this->result);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("id", apache::thrift::protocol::T_STRUCT, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::write(*prot_, this->id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void GetUUIDResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t GetUUIDResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t GetUUIDResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t GetUUIDResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void GetUUIDResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t GetUUIDResp::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t GetUUIDResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t GetUUIDResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void LookupIndexResp::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_result:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::readWithContext(*iprot, this->result, _readState);
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_data:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::readWithContext(*iprot, this->data, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.data = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_stat_data:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::readWithContext(*iprot, this->stat_data, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.stat_data = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<LookupIndexResp>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_result;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_data;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_stat_data;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t LookupIndexResp::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("LookupIndexResp");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<false>(*prot_, this->result);
  if (this->data_ref().has_value()) {
    xfer += prot_->serializedFieldSize("data", apache::thrift::protocol::T_STRUCT, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::serializedSize<false>(*prot_, this->data);
  }
  if (this->stat_data_ref().has_value()) {
    xfer += prot_->serializedFieldSize("stat_data", apache::thrift::protocol::T_STRUCT, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::serializedSize<false>(*prot_, this->stat_data);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t LookupIndexResp::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("LookupIndexResp");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<true>(*prot_, this->result);
  if (this->data_ref().has_value()) {
    xfer += prot_->serializedFieldSize("data", apache::thrift::protocol::T_STRUCT, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::serializedSize<true>(*prot_, this->data);
  }
  if (this->stat_data_ref().has_value()) {
    xfer += prot_->serializedFieldSize("stat_data", apache::thrift::protocol::T_STRUCT, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::serializedSize<true>(*prot_, this->stat_data);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t LookupIndexResp::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("LookupIndexResp");
  xfer += prot_->writeFieldBegin("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::write(*prot_, this->result);
  xfer += prot_->writeFieldEnd();
  if (this->data_ref().has_value()) {
    xfer += prot_->writeFieldBegin("data", apache::thrift::protocol::T_STRUCT, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::write(*prot_, this->data);
    xfer += prot_->writeFieldEnd();
  }
  if (this->stat_data_ref().has_value()) {
    xfer += prot_->writeFieldBegin("stat_data", apache::thrift::protocol::T_STRUCT, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::write(*prot_, this->stat_data);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void LookupIndexResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t LookupIndexResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t LookupIndexResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t LookupIndexResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void LookupIndexResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t LookupIndexResp::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t LookupIndexResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t LookupIndexResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void IndexColumnHint::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_column_name:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->column_name, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.column_name = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_scan_type:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::ScanType>::readWithContext(*iprot, this->scan_type, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.scan_type = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_begin_value:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::readWithContext(*iprot, this->begin_value, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.begin_value = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_end_value:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::readWithContext(*iprot, this->end_value, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.end_value = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          5,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_include_begin:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->include_begin, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.include_begin = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          5,
          6,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_include_end:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->include_end, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.include_end = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          6,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<IndexColumnHint>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_column_name;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_scan_type;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_begin_value;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_end_value;
      } else {
        goto _skip;
      }
    }
    case 5:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_include_begin;
      } else {
        goto _skip;
      }
    }
    case 6:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_include_end;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t IndexColumnHint::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("IndexColumnHint");
  xfer += prot_->serializedFieldSize("column_name", apache::thrift::protocol::T_STRING, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->column_name);
  xfer += prot_->serializedFieldSize("scan_type", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::ScanType>::serializedSize<false>(*prot_, this->scan_type);
  xfer += prot_->serializedFieldSize("begin_value", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::serializedSize<false>(*prot_, this->begin_value);
  xfer += prot_->serializedFieldSize("end_value", apache::thrift::protocol::T_STRUCT, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::serializedSize<false>(*prot_, this->end_value);
  xfer += prot_->serializedFieldSize("include_begin", apache::thrift::protocol::T_BOOL, 5);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->include_begin);
  xfer += prot_->serializedFieldSize("include_end", apache::thrift::protocol::T_BOOL, 6);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->include_end);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t IndexColumnHint::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("IndexColumnHint");
  xfer += prot_->serializedFieldSize("column_name", apache::thrift::protocol::T_STRING, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->column_name);
  xfer += prot_->serializedFieldSize("scan_type", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::ScanType>::serializedSize<false>(*prot_, this->scan_type);
  xfer += prot_->serializedFieldSize("begin_value", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::serializedSize<true>(*prot_, this->begin_value);
  xfer += prot_->serializedFieldSize("end_value", apache::thrift::protocol::T_STRUCT, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::serializedSize<true>(*prot_, this->end_value);
  xfer += prot_->serializedFieldSize("include_begin", apache::thrift::protocol::T_BOOL, 5);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->include_begin);
  xfer += prot_->serializedFieldSize("include_end", apache::thrift::protocol::T_BOOL, 6);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->include_end);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t IndexColumnHint::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("IndexColumnHint");
  xfer += prot_->writeFieldBegin("column_name", apache::thrift::protocol::T_STRING, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->column_name);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("scan_type", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::ScanType>::write(*prot_, this->scan_type);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("begin_value", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::write(*prot_, this->begin_value);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("end_value", apache::thrift::protocol::T_STRUCT, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant, nebula::Value>::write(*prot_, this->end_value);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("include_begin", apache::thrift::protocol::T_BOOL, 5);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->include_begin);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("include_end", apache::thrift::protocol::T_BOOL, 6);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->include_end);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void IndexColumnHint::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t IndexColumnHint::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t IndexColumnHint::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t IndexColumnHint::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void IndexColumnHint::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t IndexColumnHint::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t IndexColumnHint::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t IndexColumnHint::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void IndexQueryContext::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_index_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::IndexID>::readWithContext(*iprot, this->index_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.index_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_filter:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->filter, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.filter = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_column_hints:
  {
    _readState.beforeSubobject(iprot);
    this->column_hints = ::std::vector< ::nebula::storage::cpp2::IndexColumnHint>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::IndexColumnHint>>::readWithContext(*iprot, this->column_hints, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.column_hints = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<IndexQueryContext>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_index_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_filter;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_column_hints;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t IndexQueryContext::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("IndexQueryContext");
  xfer += prot_->serializedFieldSize("index_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::IndexID>::serializedSize<false>(*prot_, this->index_id);
  xfer += prot_->serializedFieldSize("filter", apache::thrift::protocol::T_STRING, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->filter);
  xfer += prot_->serializedFieldSize("column_hints", apache::thrift::protocol::T_LIST, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::IndexColumnHint>>::serializedSize<false>(*prot_, this->column_hints);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t IndexQueryContext::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("IndexQueryContext");
  xfer += prot_->serializedFieldSize("index_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::IndexID>::serializedSize<false>(*prot_, this->index_id);
  xfer += prot_->serializedFieldSize("filter", apache::thrift::protocol::T_STRING, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->filter);
  xfer += prot_->serializedFieldSize("column_hints", apache::thrift::protocol::T_LIST, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::IndexColumnHint>>::serializedSize<false>(*prot_, this->column_hints);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t IndexQueryContext::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("IndexQueryContext");
  xfer += prot_->writeFieldBegin("index_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::IndexID>::write(*prot_, this->index_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("filter", apache::thrift::protocol::T_STRING, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->filter);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("column_hints", apache::thrift::protocol::T_LIST, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::IndexColumnHint>>::write(*prot_, this->column_hints);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void IndexQueryContext::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t IndexQueryContext::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t IndexQueryContext::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t IndexQueryContext::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void IndexQueryContext::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t IndexQueryContext::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t IndexQueryContext::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t IndexQueryContext::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void IndexSpec::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_contexts:
  {
    _readState.beforeSubobject(iprot);
    this->contexts = ::std::vector< ::nebula::storage::cpp2::IndexQueryContext>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::IndexQueryContext>>::readWithContext(*iprot, this->contexts, _readState);
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_schema_id:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant,  ::nebula::cpp2::SchemaID>::readWithContext(*iprot, this->schema_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.schema_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<IndexSpec>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_contexts;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_schema_id;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t IndexSpec::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("IndexSpec");
  xfer += prot_->serializedFieldSize("contexts", apache::thrift::protocol::T_LIST, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::IndexQueryContext>>::serializedSize<false>(*prot_, this->contexts);
  xfer += prot_->serializedFieldSize("schema_id", apache::thrift::protocol::T_STRUCT, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant,  ::nebula::cpp2::SchemaID>::serializedSize<false>(*prot_, this->schema_id);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t IndexSpec::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("IndexSpec");
  xfer += prot_->serializedFieldSize("contexts", apache::thrift::protocol::T_LIST, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::IndexQueryContext>>::serializedSize<false>(*prot_, this->contexts);
  xfer += prot_->serializedFieldSize("schema_id", apache::thrift::protocol::T_STRUCT, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant,  ::nebula::cpp2::SchemaID>::serializedSize<true>(*prot_, this->schema_id);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t IndexSpec::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("IndexSpec");
  xfer += prot_->writeFieldBegin("contexts", apache::thrift::protocol::T_LIST, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::IndexQueryContext>>::write(*prot_, this->contexts);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("schema_id", apache::thrift::protocol::T_STRUCT, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::variant,  ::nebula::cpp2::SchemaID>::write(*prot_, this->schema_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void IndexSpec::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t IndexSpec::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t IndexSpec::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t IndexSpec::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void IndexSpec::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t IndexSpec::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t IndexSpec::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t IndexSpec::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void LookupIndexRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_parts:
  {
    _readState.beforeSubobject(iprot);
    this->parts = ::std::vector< ::nebula::cpp2::PartitionID>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::readWithContext(*iprot, this->parts, _readState);
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_indices:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::IndexSpec>::readWithContext(*iprot, this->indices, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.indices = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_return_columns:
  {
    _readState.beforeSubobject(iprot);
    this->return_columns = ::std::vector<::std::string>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::readWithContext(*iprot, this->return_columns, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.return_columns = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          5,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_common:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::readWithContext(*iprot, this->common, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.common = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          5,
          6,
          apache::thrift::protocol::T_I64))) {
    goto _loop;
  }
_readField_limit:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::readWithContext(*iprot, this->limit, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.limit = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          6,
          7,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_order_by:
  {
    _readState.beforeSubobject(iprot);
    this->order_by = ::std::vector< ::nebula::storage::cpp2::OrderBy>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::OrderBy>>::readWithContext(*iprot, this->order_by, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.order_by = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          7,
          8,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_stat_columns:
  {
    _readState.beforeSubobject(iprot);
    this->stat_columns = ::std::vector< ::nebula::storage::cpp2::StatProp>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::StatProp>>::readWithContext(*iprot, this->stat_columns, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.stat_columns = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          8,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<LookupIndexRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_parts;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_indices;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_return_columns;
      } else {
        goto _skip;
      }
    }
    case 5:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_common;
      } else {
        goto _skip;
      }
    }
    case 6:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I64))) {
        goto _readField_limit;
      } else {
        goto _skip;
      }
    }
    case 7:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_order_by;
      } else {
        goto _skip;
      }
    }
    case 8:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_stat_columns;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t LookupIndexRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("LookupIndexRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("indices", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::IndexSpec>::serializedSize<false>(*prot_, this->indices);
  if (this->return_columns_ref().has_value()) {
    xfer += prot_->serializedFieldSize("return_columns", apache::thrift::protocol::T_LIST, 4);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::serializedSize<false>(*prot_, this->return_columns);
  }
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<false>(*prot_, this->common);
  }
  if (this->limit_ref().has_value()) {
    xfer += prot_->serializedFieldSize("limit", apache::thrift::protocol::T_I64, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->limit);
  }
  if (this->order_by_ref().has_value()) {
    xfer += prot_->serializedFieldSize("order_by", apache::thrift::protocol::T_LIST, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::OrderBy>>::serializedSize<false>(*prot_, this->order_by);
  }
  if (this->stat_columns_ref().has_value()) {
    xfer += prot_->serializedFieldSize("stat_columns", apache::thrift::protocol::T_LIST, 8);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::StatProp>>::serializedSize<false>(*prot_, this->stat_columns);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t LookupIndexRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("LookupIndexRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("indices", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::IndexSpec>::serializedSize<true>(*prot_, this->indices);
  if (this->return_columns_ref().has_value()) {
    xfer += prot_->serializedFieldSize("return_columns", apache::thrift::protocol::T_LIST, 4);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::serializedSize<false>(*prot_, this->return_columns);
  }
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<true>(*prot_, this->common);
  }
  if (this->limit_ref().has_value()) {
    xfer += prot_->serializedFieldSize("limit", apache::thrift::protocol::T_I64, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->limit);
  }
  if (this->order_by_ref().has_value()) {
    xfer += prot_->serializedFieldSize("order_by", apache::thrift::protocol::T_LIST, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::OrderBy>>::serializedSize<false>(*prot_, this->order_by);
  }
  if (this->stat_columns_ref().has_value()) {
    xfer += prot_->serializedFieldSize("stat_columns", apache::thrift::protocol::T_LIST, 8);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::StatProp>>::serializedSize<false>(*prot_, this->stat_columns);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t LookupIndexRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("LookupIndexRequest");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("parts", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::write(*prot_, this->parts);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("indices", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::IndexSpec>::write(*prot_, this->indices);
  xfer += prot_->writeFieldEnd();
  if (this->return_columns_ref().has_value()) {
    xfer += prot_->writeFieldBegin("return_columns", apache::thrift::protocol::T_LIST, 4);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::write(*prot_, this->return_columns);
    xfer += prot_->writeFieldEnd();
  }
  if (this->common_ref().has_value()) {
    xfer += prot_->writeFieldBegin("common", apache::thrift::protocol::T_STRUCT, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::write(*prot_, this->common);
    xfer += prot_->writeFieldEnd();
  }
  if (this->limit_ref().has_value()) {
    xfer += prot_->writeFieldBegin("limit", apache::thrift::protocol::T_I64, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::write(*prot_, this->limit);
    xfer += prot_->writeFieldEnd();
  }
  if (this->order_by_ref().has_value()) {
    xfer += prot_->writeFieldBegin("order_by", apache::thrift::protocol::T_LIST, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::OrderBy>>::write(*prot_, this->order_by);
    xfer += prot_->writeFieldEnd();
  }
  if (this->stat_columns_ref().has_value()) {
    xfer += prot_->writeFieldBegin("stat_columns", apache::thrift::protocol::T_LIST, 8);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::StatProp>>::write(*prot_, this->stat_columns);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void LookupIndexRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t LookupIndexRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t LookupIndexRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t LookupIndexRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void LookupIndexRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t LookupIndexRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t LookupIndexRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t LookupIndexRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void LookupAndTraverseRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_parts:
  {
    _readState.beforeSubobject(iprot);
    this->parts = ::std::vector< ::nebula::cpp2::PartitionID>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::readWithContext(*iprot, this->parts, _readState);
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_indices:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::IndexSpec>::readWithContext(*iprot, this->indices, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.indices = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_traverse_spec:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::TraverseSpec>::readWithContext(*iprot, this->traverse_spec, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.traverse_spec = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          5,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_common:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::readWithContext(*iprot, this->common, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.common = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          5,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<LookupAndTraverseRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_parts;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_indices;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_traverse_spec;
      } else {
        goto _skip;
      }
    }
    case 5:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_common;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t LookupAndTraverseRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("LookupAndTraverseRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("indices", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::IndexSpec>::serializedSize<false>(*prot_, this->indices);
  xfer += prot_->serializedFieldSize("traverse_spec", apache::thrift::protocol::T_STRUCT, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::TraverseSpec>::serializedSize<false>(*prot_, this->traverse_spec);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<false>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t LookupAndTraverseRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("LookupAndTraverseRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("indices", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::IndexSpec>::serializedSize<true>(*prot_, this->indices);
  xfer += prot_->serializedFieldSize("traverse_spec", apache::thrift::protocol::T_STRUCT, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::TraverseSpec>::serializedSize<true>(*prot_, this->traverse_spec);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<true>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t LookupAndTraverseRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("LookupAndTraverseRequest");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("parts", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::write(*prot_, this->parts);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("indices", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::IndexSpec>::write(*prot_, this->indices);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("traverse_spec", apache::thrift::protocol::T_STRUCT, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::TraverseSpec>::write(*prot_, this->traverse_spec);
  xfer += prot_->writeFieldEnd();
  if (this->common_ref().has_value()) {
    xfer += prot_->writeFieldBegin("common", apache::thrift::protocol::T_STRUCT, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::write(*prot_, this->common);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void LookupAndTraverseRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t LookupAndTraverseRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t LookupAndTraverseRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t LookupAndTraverseRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void LookupAndTraverseRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t LookupAndTraverseRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t LookupAndTraverseRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t LookupAndTraverseRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void ScanCursor::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_next_cursor:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->next_cursor, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.next_cursor = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<ScanCursor>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_next_cursor;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t ScanCursor::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ScanCursor");
  if (this->next_cursor_ref().has_value()) {
    xfer += prot_->serializedFieldSize("next_cursor", apache::thrift::protocol::T_STRING, 1);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->next_cursor);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ScanCursor::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ScanCursor");
  if (this->next_cursor_ref().has_value()) {
    xfer += prot_->serializedFieldSize("next_cursor", apache::thrift::protocol::T_STRING, 1);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->next_cursor);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ScanCursor::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("ScanCursor");
  if (this->next_cursor_ref().has_value()) {
    xfer += prot_->writeFieldBegin("next_cursor", apache::thrift::protocol::T_STRING, 1);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->next_cursor);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void ScanCursor::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t ScanCursor::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t ScanCursor::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t ScanCursor::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void ScanCursor::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t ScanCursor::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t ScanCursor::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t ScanCursor::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void ScanVertexRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_MAP))) {
    goto _loop;
  }
_readField_parts:
  {
    _readState.beforeSubobject(iprot);
    this->parts = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>::readWithContext(*iprot, this->parts, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.parts = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_return_columns:
  {
    _readState.beforeSubobject(iprot);
    this->return_columns = ::std::vector< ::nebula::storage::cpp2::VertexProp>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::VertexProp>>::readWithContext(*iprot, this->return_columns, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.return_columns = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_I64))) {
    goto _loop;
  }
_readField_limit:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::readWithContext(*iprot, this->limit, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.limit = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          5,
          apache::thrift::protocol::T_I64))) {
    goto _loop;
  }
_readField_start_time:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::readWithContext(*iprot, this->start_time, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.start_time = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          5,
          6,
          apache::thrift::protocol::T_I64))) {
    goto _loop;
  }
_readField_end_time:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::readWithContext(*iprot, this->end_time, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.end_time = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          6,
          7,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_filter:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->filter, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.filter = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          7,
          8,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_only_latest_version:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->only_latest_version, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.only_latest_version = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          8,
          9,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_enable_read_from_follower:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->enable_read_from_follower, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.enable_read_from_follower = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          9,
          10,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_common:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::readWithContext(*iprot, this->common, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.common = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          10,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<ScanVertexRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_MAP))) {
        goto _readField_parts;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_return_columns;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I64))) {
        goto _readField_limit;
      } else {
        goto _skip;
      }
    }
    case 5:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I64))) {
        goto _readField_start_time;
      } else {
        goto _skip;
      }
    }
    case 6:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I64))) {
        goto _readField_end_time;
      } else {
        goto _skip;
      }
    }
    case 7:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_filter;
      } else {
        goto _skip;
      }
    }
    case 8:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_only_latest_version;
      } else {
        goto _skip;
      }
    }
    case 9:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_enable_read_from_follower;
      } else {
        goto _skip;
      }
    }
    case 10:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_common;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t ScanVertexRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ScanVertexRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("return_columns", apache::thrift::protocol::T_LIST, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::VertexProp>>::serializedSize<false>(*prot_, this->return_columns);
  xfer += prot_->serializedFieldSize("limit", apache::thrift::protocol::T_I64, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->limit);
  if (this->start_time_ref().has_value()) {
    xfer += prot_->serializedFieldSize("start_time", apache::thrift::protocol::T_I64, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->start_time);
  }
  if (this->end_time_ref().has_value()) {
    xfer += prot_->serializedFieldSize("end_time", apache::thrift::protocol::T_I64, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->end_time);
  }
  if (this->filter_ref().has_value()) {
    xfer += prot_->serializedFieldSize("filter", apache::thrift::protocol::T_STRING, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->filter);
  }
  xfer += prot_->serializedFieldSize("only_latest_version", apache::thrift::protocol::T_BOOL, 8);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->only_latest_version);
  xfer += prot_->serializedFieldSize("enable_read_from_follower", apache::thrift::protocol::T_BOOL, 9);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->enable_read_from_follower);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 10);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<false>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ScanVertexRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ScanVertexRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("return_columns", apache::thrift::protocol::T_LIST, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::VertexProp>>::serializedSize<false>(*prot_, this->return_columns);
  xfer += prot_->serializedFieldSize("limit", apache::thrift::protocol::T_I64, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->limit);
  if (this->start_time_ref().has_value()) {
    xfer += prot_->serializedFieldSize("start_time", apache::thrift::protocol::T_I64, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->start_time);
  }
  if (this->end_time_ref().has_value()) {
    xfer += prot_->serializedFieldSize("end_time", apache::thrift::protocol::T_I64, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->end_time);
  }
  if (this->filter_ref().has_value()) {
    xfer += prot_->serializedFieldSize("filter", apache::thrift::protocol::T_STRING, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->filter);
  }
  xfer += prot_->serializedFieldSize("only_latest_version", apache::thrift::protocol::T_BOOL, 8);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->only_latest_version);
  xfer += prot_->serializedFieldSize("enable_read_from_follower", apache::thrift::protocol::T_BOOL, 9);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->enable_read_from_follower);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 10);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<true>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ScanVertexRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("ScanVertexRequest");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>::write(*prot_, this->parts);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("return_columns", apache::thrift::protocol::T_LIST, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::VertexProp>>::write(*prot_, this->return_columns);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("limit", apache::thrift::protocol::T_I64, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::write(*prot_, this->limit);
  xfer += prot_->writeFieldEnd();
  if (this->start_time_ref().has_value()) {
    xfer += prot_->writeFieldBegin("start_time", apache::thrift::protocol::T_I64, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::write(*prot_, this->start_time);
    xfer += prot_->writeFieldEnd();
  }
  if (this->end_time_ref().has_value()) {
    xfer += prot_->writeFieldBegin("end_time", apache::thrift::protocol::T_I64, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::write(*prot_, this->end_time);
    xfer += prot_->writeFieldEnd();
  }
  if (this->filter_ref().has_value()) {
    xfer += prot_->writeFieldBegin("filter", apache::thrift::protocol::T_STRING, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->filter);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldBegin("only_latest_version", apache::thrift::protocol::T_BOOL, 8);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->only_latest_version);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("enable_read_from_follower", apache::thrift::protocol::T_BOOL, 9);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->enable_read_from_follower);
  xfer += prot_->writeFieldEnd();
  if (this->common_ref().has_value()) {
    xfer += prot_->writeFieldBegin("common", apache::thrift::protocol::T_STRUCT, 10);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::write(*prot_, this->common);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void ScanVertexRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t ScanVertexRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t ScanVertexRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t ScanVertexRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void ScanVertexRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t ScanVertexRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t ScanVertexRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t ScanVertexRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void ScanEdgeRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_MAP))) {
    goto _loop;
  }
_readField_parts:
  {
    _readState.beforeSubobject(iprot);
    this->parts = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>::readWithContext(*iprot, this->parts, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.parts = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_return_columns:
  {
    _readState.beforeSubobject(iprot);
    this->return_columns = ::std::vector< ::nebula::storage::cpp2::EdgeProp>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::EdgeProp>>::readWithContext(*iprot, this->return_columns, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.return_columns = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_I64))) {
    goto _loop;
  }
_readField_limit:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::readWithContext(*iprot, this->limit, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.limit = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          5,
          apache::thrift::protocol::T_I64))) {
    goto _loop;
  }
_readField_start_time:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::readWithContext(*iprot, this->start_time, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.start_time = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          5,
          6,
          apache::thrift::protocol::T_I64))) {
    goto _loop;
  }
_readField_end_time:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::readWithContext(*iprot, this->end_time, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.end_time = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          6,
          7,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_filter:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->filter, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.filter = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          7,
          8,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_only_latest_version:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->only_latest_version, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.only_latest_version = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          8,
          9,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_enable_read_from_follower:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->enable_read_from_follower, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.enable_read_from_follower = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          9,
          10,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_common:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::readWithContext(*iprot, this->common, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.common = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          10,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<ScanEdgeRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_MAP))) {
        goto _readField_parts;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_return_columns;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I64))) {
        goto _readField_limit;
      } else {
        goto _skip;
      }
    }
    case 5:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I64))) {
        goto _readField_start_time;
      } else {
        goto _skip;
      }
    }
    case 6:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I64))) {
        goto _readField_end_time;
      } else {
        goto _skip;
      }
    }
    case 7:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_filter;
      } else {
        goto _skip;
      }
    }
    case 8:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_only_latest_version;
      } else {
        goto _skip;
      }
    }
    case 9:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_enable_read_from_follower;
      } else {
        goto _skip;
      }
    }
    case 10:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_common;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t ScanEdgeRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ScanEdgeRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("return_columns", apache::thrift::protocol::T_LIST, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::EdgeProp>>::serializedSize<false>(*prot_, this->return_columns);
  xfer += prot_->serializedFieldSize("limit", apache::thrift::protocol::T_I64, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->limit);
  if (this->start_time_ref().has_value()) {
    xfer += prot_->serializedFieldSize("start_time", apache::thrift::protocol::T_I64, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->start_time);
  }
  if (this->end_time_ref().has_value()) {
    xfer += prot_->serializedFieldSize("end_time", apache::thrift::protocol::T_I64, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->end_time);
  }
  if (this->filter_ref().has_value()) {
    xfer += prot_->serializedFieldSize("filter", apache::thrift::protocol::T_STRING, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->filter);
  }
  xfer += prot_->serializedFieldSize("only_latest_version", apache::thrift::protocol::T_BOOL, 8);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->only_latest_version);
  xfer += prot_->serializedFieldSize("enable_read_from_follower", apache::thrift::protocol::T_BOOL, 9);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->enable_read_from_follower);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 10);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<false>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ScanEdgeRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ScanEdgeRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("return_columns", apache::thrift::protocol::T_LIST, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::EdgeProp>>::serializedSize<false>(*prot_, this->return_columns);
  xfer += prot_->serializedFieldSize("limit", apache::thrift::protocol::T_I64, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->limit);
  if (this->start_time_ref().has_value()) {
    xfer += prot_->serializedFieldSize("start_time", apache::thrift::protocol::T_I64, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->start_time);
  }
  if (this->end_time_ref().has_value()) {
    xfer += prot_->serializedFieldSize("end_time", apache::thrift::protocol::T_I64, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->end_time);
  }
  if (this->filter_ref().has_value()) {
    xfer += prot_->serializedFieldSize("filter", apache::thrift::protocol::T_STRING, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->filter);
  }
  xfer += prot_->serializedFieldSize("only_latest_version", apache::thrift::protocol::T_BOOL, 8);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->only_latest_version);
  xfer += prot_->serializedFieldSize("enable_read_from_follower", apache::thrift::protocol::T_BOOL, 9);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->enable_read_from_follower);
  if (this->common_ref().has_value()) {
    xfer += prot_->serializedFieldSize("common", apache::thrift::protocol::T_STRUCT, 10);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::serializedSize<true>(*prot_, this->common);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ScanEdgeRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("ScanEdgeRequest");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>::write(*prot_, this->parts);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("return_columns", apache::thrift::protocol::T_LIST, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::storage::cpp2::EdgeProp>>::write(*prot_, this->return_columns);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("limit", apache::thrift::protocol::T_I64, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::write(*prot_, this->limit);
  xfer += prot_->writeFieldEnd();
  if (this->start_time_ref().has_value()) {
    xfer += prot_->writeFieldBegin("start_time", apache::thrift::protocol::T_I64, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::write(*prot_, this->start_time);
    xfer += prot_->writeFieldEnd();
  }
  if (this->end_time_ref().has_value()) {
    xfer += prot_->writeFieldBegin("end_time", apache::thrift::protocol::T_I64, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::write(*prot_, this->end_time);
    xfer += prot_->writeFieldEnd();
  }
  if (this->filter_ref().has_value()) {
    xfer += prot_->writeFieldBegin("filter", apache::thrift::protocol::T_STRING, 7);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->filter);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldBegin("only_latest_version", apache::thrift::protocol::T_BOOL, 8);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->only_latest_version);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("enable_read_from_follower", apache::thrift::protocol::T_BOOL, 9);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->enable_read_from_follower);
  xfer += prot_->writeFieldEnd();
  if (this->common_ref().has_value()) {
    xfer += prot_->writeFieldBegin("common", apache::thrift::protocol::T_STRUCT, 10);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RequestCommon>::write(*prot_, this->common);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void ScanEdgeRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t ScanEdgeRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t ScanEdgeRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t ScanEdgeRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void ScanEdgeRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t ScanEdgeRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t ScanEdgeRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t ScanEdgeRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void ScanResponse::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_result:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::readWithContext(*iprot, this->result, _readState);
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_props:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::readWithContext(*iprot, this->props, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.props = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_MAP))) {
    goto _loop;
  }
_readField_cursors:
  {
    _readState.beforeSubobject(iprot);
    this->cursors = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>::readWithContext(*iprot, this->cursors, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.cursors = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<ScanResponse>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_result;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_props;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_MAP))) {
        goto _readField_cursors;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t ScanResponse::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ScanResponse");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<false>(*prot_, this->result);
  if (this->props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("props", apache::thrift::protocol::T_STRUCT, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::serializedSize<false>(*prot_, this->props);
  }
  xfer += prot_->serializedFieldSize("cursors", apache::thrift::protocol::T_MAP, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>::serializedSize<false>(*prot_, this->cursors);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ScanResponse::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ScanResponse");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<true>(*prot_, this->result);
  if (this->props_ref().has_value()) {
    xfer += prot_->serializedFieldSize("props", apache::thrift::protocol::T_STRUCT, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::serializedSize<true>(*prot_, this->props);
  }
  xfer += prot_->serializedFieldSize("cursors", apache::thrift::protocol::T_MAP, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>::serializedSize<false>(*prot_, this->cursors);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ScanResponse::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("ScanResponse");
  xfer += prot_->writeFieldBegin("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::write(*prot_, this->result);
  xfer += prot_->writeFieldEnd();
  if (this->props_ref().has_value()) {
    xfer += prot_->writeFieldBegin("props", apache::thrift::protocol::T_STRUCT, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::DataSet>::write(*prot_, this->props);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldBegin("cursors", apache::thrift::protocol::T_MAP, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>::write(*prot_, this->cursors);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void ScanResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t ScanResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t ScanResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t ScanResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void ScanResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t ScanResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t ScanResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t ScanResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void TaskPara::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_parts:
  {
    _readState.beforeSubobject(iprot);
    this->parts = ::std::vector< ::nebula::cpp2::PartitionID>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::readWithContext(*iprot, this->parts, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.parts = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_task_specific_paras:
  {
    _readState.beforeSubobject(iprot);
    this->task_specific_paras = ::std::vector<::std::string>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::readWithContext(*iprot, this->task_specific_paras, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.task_specific_paras = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<TaskPara>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_parts;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_task_specific_paras;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t TaskPara::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("TaskPara");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  if (this->parts_ref().has_value()) {
    xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_LIST, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::serializedSize<false>(*prot_, this->parts);
  }
  if (this->task_specific_paras_ref().has_value()) {
    xfer += prot_->serializedFieldSize("task_specific_paras", apache::thrift::protocol::T_LIST, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::serializedSize<false>(*prot_, this->task_specific_paras);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t TaskPara::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("TaskPara");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  if (this->parts_ref().has_value()) {
    xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_LIST, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::serializedSize<false>(*prot_, this->parts);
  }
  if (this->task_specific_paras_ref().has_value()) {
    xfer += prot_->serializedFieldSize("task_specific_paras", apache::thrift::protocol::T_LIST, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::serializedSize<false>(*prot_, this->task_specific_paras);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t TaskPara::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("TaskPara");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  if (this->parts_ref().has_value()) {
    xfer += prot_->writeFieldBegin("parts", apache::thrift::protocol::T_LIST, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::write(*prot_, this->parts);
    xfer += prot_->writeFieldEnd();
  }
  if (this->task_specific_paras_ref().has_value()) {
    xfer += prot_->writeFieldBegin("task_specific_paras", apache::thrift::protocol::T_LIST, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::write(*prot_, this->task_specific_paras);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void TaskPara::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t TaskPara::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t TaskPara::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t TaskPara::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void TaskPara::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t TaskPara::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t TaskPara::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t TaskPara::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void KVGetRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_MAP))) {
    goto _loop;
  }
_readField_parts:
  {
    _readState.beforeSubobject(iprot);
    this->parts = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>>::readWithContext(*iprot, this->parts, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.parts = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_return_partly:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->return_partly, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.return_partly = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<KVGetRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_MAP))) {
        goto _readField_parts;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_return_partly;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t KVGetRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("KVGetRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("return_partly", apache::thrift::protocol::T_BOOL, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->return_partly);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t KVGetRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("KVGetRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("return_partly", apache::thrift::protocol::T_BOOL, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->return_partly);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t KVGetRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("KVGetRequest");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>>::write(*prot_, this->parts);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("return_partly", apache::thrift::protocol::T_BOOL, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->return_partly);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void KVGetRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t KVGetRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t KVGetRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t KVGetRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void KVGetRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t KVGetRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t KVGetRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t KVGetRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void KVGetResponse::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_result:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::readWithContext(*iprot, this->result, _readState);
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_MAP))) {
    goto _loop;
  }
_readField_key_values:
  {
    _readState.beforeSubobject(iprot);
    this->key_values = std::unordered_map<::std::string, ::std::string>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::binary, ::apache::thrift::type_class::binary>, std::unordered_map<::std::string, ::std::string>>::readWithContext(*iprot, this->key_values, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.key_values = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<KVGetResponse>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_result;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_MAP))) {
        goto _readField_key_values;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t KVGetResponse::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("KVGetResponse");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<false>(*prot_, this->result);
  xfer += prot_->serializedFieldSize("key_values", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::binary, ::apache::thrift::type_class::binary>, std::unordered_map<::std::string, ::std::string>>::serializedSize<false>(*prot_, this->key_values);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t KVGetResponse::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("KVGetResponse");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<true>(*prot_, this->result);
  xfer += prot_->serializedFieldSize("key_values", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::binary, ::apache::thrift::type_class::binary>, std::unordered_map<::std::string, ::std::string>>::serializedSize<false>(*prot_, this->key_values);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t KVGetResponse::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("KVGetResponse");
  xfer += prot_->writeFieldBegin("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::write(*prot_, this->result);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("key_values", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::binary, ::apache::thrift::type_class::binary>, std::unordered_map<::std::string, ::std::string>>::write(*prot_, this->key_values);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void KVGetResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t KVGetResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t KVGetResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t KVGetResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void KVGetResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t KVGetResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t KVGetResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t KVGetResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void KVPutRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_MAP))) {
    goto _loop;
  }
_readField_parts:
  {
    _readState.beforeSubobject(iprot);
    this->parts = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>>>::readWithContext(*iprot, this->parts, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.parts = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<KVPutRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_MAP))) {
        goto _readField_parts;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t KVPutRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("KVPutRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t KVPutRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("KVPutRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t KVPutRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("KVPutRequest");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>>>::write(*prot_, this->parts);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void KVPutRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t KVPutRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t KVPutRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t KVPutRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void KVPutRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t KVPutRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t KVPutRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t KVPutRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void KVRemoveRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_MAP))) {
    goto _loop;
  }
_readField_parts:
  {
    _readState.beforeSubobject(iprot);
    this->parts = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>>::readWithContext(*iprot, this->parts, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.parts = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<KVRemoveRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_MAP))) {
        goto _readField_parts;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t KVRemoveRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("KVRemoveRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t KVRemoveRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("KVRemoveRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t KVRemoveRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("KVRemoveRequest");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>>::write(*prot_, this->parts);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void KVRemoveRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t KVRemoveRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t KVRemoveRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t KVRemoveRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void KVRemoveRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t KVRemoveRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t KVRemoveRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t KVRemoveRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void AdminExecResp::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_result:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::readWithContext(*iprot, this->result, _readState);
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_stats:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::StatsItem>::readWithContext(*iprot, this->stats, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.stats = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<AdminExecResp>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_result;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_stats;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t AdminExecResp::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("AdminExecResp");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<false>(*prot_, this->result);
  if (this->stats_ref().has_value()) {
    xfer += prot_->serializedFieldSize("stats", apache::thrift::protocol::T_STRUCT, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::StatsItem>::serializedSize<false>(*prot_, this->stats);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t AdminExecResp::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("AdminExecResp");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<true>(*prot_, this->result);
  if (this->stats_ref().has_value()) {
    xfer += prot_->serializedFieldSize("stats", apache::thrift::protocol::T_STRUCT, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::StatsItem>::serializedSize<true>(*prot_, this->stats);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t AdminExecResp::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("AdminExecResp");
  xfer += prot_->writeFieldBegin("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::write(*prot_, this->result);
  xfer += prot_->writeFieldEnd();
  if (this->stats_ref().has_value()) {
    xfer += prot_->writeFieldBegin("stats", apache::thrift::protocol::T_STRUCT, 2);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::StatsItem>::write(*prot_, this->stats);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void AdminExecResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t AdminExecResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t AdminExecResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t AdminExecResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void AdminExecResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t AdminExecResp::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t AdminExecResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t AdminExecResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void TransLeaderReq::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_part_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::readWithContext(*iprot, this->part_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.part_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_new_leader:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::readWithContext(*iprot, this->new_leader, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.new_leader = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<TransLeaderReq>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_part_id;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_new_leader;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t TransLeaderReq::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("TransLeaderReq");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedFieldSize("new_leader", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::serializedSize<false>(*prot_, this->new_leader);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t TransLeaderReq::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("TransLeaderReq");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedFieldSize("new_leader", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::serializedSize<true>(*prot_, this->new_leader);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t TransLeaderReq::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("TransLeaderReq");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::write(*prot_, this->part_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("new_leader", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::write(*prot_, this->new_leader);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void TransLeaderReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t TransLeaderReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t TransLeaderReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t TransLeaderReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void TransLeaderReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t TransLeaderReq::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t TransLeaderReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t TransLeaderReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void AddPartReq::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_part_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::readWithContext(*iprot, this->part_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.part_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_as_learner:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->as_learner, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.as_learner = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_peers:
  {
    _readState.beforeSubobject(iprot);
    this->peers = ::std::vector<nebula::HostAddr>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector<nebula::HostAddr>>::readWithContext(*iprot, this->peers, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.peers = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<AddPartReq>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_part_id;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_as_learner;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_peers;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t AddPartReq::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("AddPartReq");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedFieldSize("as_learner", apache::thrift::protocol::T_BOOL, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->as_learner);
  xfer += prot_->serializedFieldSize("peers", apache::thrift::protocol::T_LIST, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector<nebula::HostAddr>>::serializedSize<false>(*prot_, this->peers);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t AddPartReq::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("AddPartReq");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedFieldSize("as_learner", apache::thrift::protocol::T_BOOL, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->as_learner);
  xfer += prot_->serializedFieldSize("peers", apache::thrift::protocol::T_LIST, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector<nebula::HostAddr>>::serializedSize<false>(*prot_, this->peers);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t AddPartReq::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("AddPartReq");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::write(*prot_, this->part_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("as_learner", apache::thrift::protocol::T_BOOL, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->as_learner);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("peers", apache::thrift::protocol::T_LIST, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector<nebula::HostAddr>>::write(*prot_, this->peers);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void AddPartReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t AddPartReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t AddPartReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t AddPartReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void AddPartReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t AddPartReq::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t AddPartReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t AddPartReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void AddLearnerReq::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_part_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::readWithContext(*iprot, this->part_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.part_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_learner:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::readWithContext(*iprot, this->learner, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.learner = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<AddLearnerReq>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_part_id;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_learner;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t AddLearnerReq::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("AddLearnerReq");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedFieldSize("learner", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::serializedSize<false>(*prot_, this->learner);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t AddLearnerReq::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("AddLearnerReq");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedFieldSize("learner", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::serializedSize<true>(*prot_, this->learner);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t AddLearnerReq::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("AddLearnerReq");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::write(*prot_, this->part_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("learner", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::write(*prot_, this->learner);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void AddLearnerReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t AddLearnerReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t AddLearnerReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t AddLearnerReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void AddLearnerReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t AddLearnerReq::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t AddLearnerReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t AddLearnerReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void RemovePartReq::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_part_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::readWithContext(*iprot, this->part_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.part_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<RemovePartReq>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_part_id;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t RemovePartReq::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("RemovePartReq");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t RemovePartReq::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("RemovePartReq");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t RemovePartReq::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("RemovePartReq");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::write(*prot_, this->part_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void RemovePartReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t RemovePartReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t RemovePartReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t RemovePartReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void RemovePartReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t RemovePartReq::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t RemovePartReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t RemovePartReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void MemberChangeReq::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_part_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::readWithContext(*iprot, this->part_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.part_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_peer:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::readWithContext(*iprot, this->peer, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.peer = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_add:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->add, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.add = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<MemberChangeReq>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_part_id;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_peer;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_add;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t MemberChangeReq::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("MemberChangeReq");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedFieldSize("peer", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::serializedSize<false>(*prot_, this->peer);
  xfer += prot_->serializedFieldSize("add", apache::thrift::protocol::T_BOOL, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->add);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t MemberChangeReq::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("MemberChangeReq");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedFieldSize("peer", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::serializedSize<true>(*prot_, this->peer);
  xfer += prot_->serializedFieldSize("add", apache::thrift::protocol::T_BOOL, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->add);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t MemberChangeReq::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("MemberChangeReq");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::write(*prot_, this->part_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("peer", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::write(*prot_, this->peer);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("add", apache::thrift::protocol::T_BOOL, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->add);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void MemberChangeReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t MemberChangeReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t MemberChangeReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t MemberChangeReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void MemberChangeReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t MemberChangeReq::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t MemberChangeReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t MemberChangeReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void CatchUpDataReq::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_part_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::readWithContext(*iprot, this->part_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.part_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_target:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::readWithContext(*iprot, this->target, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.target = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<CatchUpDataReq>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_part_id;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_target;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t CatchUpDataReq::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("CatchUpDataReq");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedFieldSize("target", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::serializedSize<false>(*prot_, this->target);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t CatchUpDataReq::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("CatchUpDataReq");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedFieldSize("target", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::serializedSize<true>(*prot_, this->target);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t CatchUpDataReq::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("CatchUpDataReq");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::write(*prot_, this->part_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("target", apache::thrift::protocol::T_STRUCT, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure, nebula::HostAddr>::write(*prot_, this->target);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void CatchUpDataReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t CatchUpDataReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t CatchUpDataReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t CatchUpDataReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void CatchUpDataReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t CatchUpDataReq::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t CatchUpDataReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t CatchUpDataReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void GetLeaderReq::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<GetLeaderReq>>();
  }

  switch (_readState.fieldId) {
    default:
    {
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t GetLeaderReq::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("GetLeaderReq");
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t GetLeaderReq::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("GetLeaderReq");
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t GetLeaderReq::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("GetLeaderReq");
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void GetLeaderReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t GetLeaderReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t GetLeaderReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t GetLeaderReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void GetLeaderReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t GetLeaderReq::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t GetLeaderReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t GetLeaderReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void CreateCPRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_space_ids:
  {
    _readState.beforeSubobject(iprot);
    this->space_ids = ::std::vector< ::nebula::cpp2::GraphSpaceID>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::GraphSpaceID>>::readWithContext(*iprot, this->space_ids, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_ids = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_name:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->name, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.name = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<CreateCPRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_space_ids;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_name;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t CreateCPRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("CreateCPRequest");
  xfer += prot_->serializedFieldSize("space_ids", apache::thrift::protocol::T_LIST, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::GraphSpaceID>>::serializedSize<false>(*prot_, this->space_ids);
  xfer += prot_->serializedFieldSize("name", apache::thrift::protocol::T_STRING, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->name);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t CreateCPRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("CreateCPRequest");
  xfer += prot_->serializedFieldSize("space_ids", apache::thrift::protocol::T_LIST, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::GraphSpaceID>>::serializedSize<false>(*prot_, this->space_ids);
  xfer += prot_->serializedFieldSize("name", apache::thrift::protocol::T_STRING, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->name);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t CreateCPRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("CreateCPRequest");
  xfer += prot_->writeFieldBegin("space_ids", apache::thrift::protocol::T_LIST, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::GraphSpaceID>>::write(*prot_, this->space_ids);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("name", apache::thrift::protocol::T_STRING, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->name);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void CreateCPRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t CreateCPRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t CreateCPRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t CreateCPRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void CreateCPRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t CreateCPRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t CreateCPRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t CreateCPRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void DropCPRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_space_ids:
  {
    _readState.beforeSubobject(iprot);
    this->space_ids = ::std::vector< ::nebula::cpp2::GraphSpaceID>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::GraphSpaceID>>::readWithContext(*iprot, this->space_ids, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_ids = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_name:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->name, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.name = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<DropCPRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_space_ids;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_name;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t DropCPRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("DropCPRequest");
  xfer += prot_->serializedFieldSize("space_ids", apache::thrift::protocol::T_LIST, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::GraphSpaceID>>::serializedSize<false>(*prot_, this->space_ids);
  xfer += prot_->serializedFieldSize("name", apache::thrift::protocol::T_STRING, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->name);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t DropCPRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("DropCPRequest");
  xfer += prot_->serializedFieldSize("space_ids", apache::thrift::protocol::T_LIST, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::GraphSpaceID>>::serializedSize<false>(*prot_, this->space_ids);
  xfer += prot_->serializedFieldSize("name", apache::thrift::protocol::T_STRING, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->name);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t DropCPRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("DropCPRequest");
  xfer += prot_->writeFieldBegin("space_ids", apache::thrift::protocol::T_LIST, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::GraphSpaceID>>::write(*prot_, this->space_ids);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("name", apache::thrift::protocol::T_STRING, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->name);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void DropCPRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t DropCPRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t DropCPRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t DropCPRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void DropCPRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t DropCPRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t DropCPRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t DropCPRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void BlockingSignRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_space_ids:
  {
    _readState.beforeSubobject(iprot);
    this->space_ids = ::std::vector< ::nebula::cpp2::GraphSpaceID>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::GraphSpaceID>>::readWithContext(*iprot, this->space_ids, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_ids = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_sign:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::EngineSignType>::readWithContext(*iprot, this->sign, _readState);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<BlockingSignRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_space_ids;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_sign;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t BlockingSignRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("BlockingSignRequest");
  xfer += prot_->serializedFieldSize("space_ids", apache::thrift::protocol::T_LIST, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::GraphSpaceID>>::serializedSize<false>(*prot_, this->space_ids);
  xfer += prot_->serializedFieldSize("sign", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::EngineSignType>::serializedSize<false>(*prot_, this->sign);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t BlockingSignRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("BlockingSignRequest");
  xfer += prot_->serializedFieldSize("space_ids", apache::thrift::protocol::T_LIST, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::GraphSpaceID>>::serializedSize<false>(*prot_, this->space_ids);
  xfer += prot_->serializedFieldSize("sign", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::EngineSignType>::serializedSize<false>(*prot_, this->sign);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t BlockingSignRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("BlockingSignRequest");
  xfer += prot_->writeFieldBegin("space_ids", apache::thrift::protocol::T_LIST, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::GraphSpaceID>>::write(*prot_, this->space_ids);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("sign", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::storage::cpp2::EngineSignType>::write(*prot_, this->sign);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void BlockingSignRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t BlockingSignRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t BlockingSignRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t BlockingSignRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void BlockingSignRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t BlockingSignRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t BlockingSignRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t BlockingSignRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void GetLeaderPartsResp::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_result:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::readWithContext(*iprot, this->result, _readState);
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_MAP))) {
    goto _loop;
  }
_readField_leader_parts:
  {
    _readState.beforeSubobject(iprot);
    this->leader_parts = std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::cpp2::PartitionID>>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>>, std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::cpp2::PartitionID>>>::readWithContext(*iprot, this->leader_parts, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.leader_parts = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<GetLeaderPartsResp>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_result;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_MAP))) {
        goto _readField_leader_parts;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t GetLeaderPartsResp::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("GetLeaderPartsResp");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<false>(*prot_, this->result);
  xfer += prot_->serializedFieldSize("leader_parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>>, std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::cpp2::PartitionID>>>::serializedSize<false>(*prot_, this->leader_parts);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t GetLeaderPartsResp::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("GetLeaderPartsResp");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<true>(*prot_, this->result);
  xfer += prot_->serializedFieldSize("leader_parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>>, std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::cpp2::PartitionID>>>::serializedSize<false>(*prot_, this->leader_parts);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t GetLeaderPartsResp::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("GetLeaderPartsResp");
  xfer += prot_->writeFieldBegin("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::write(*prot_, this->result);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("leader_parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>>, std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::cpp2::PartitionID>>>::write(*prot_, this->leader_parts);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void GetLeaderPartsResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t GetLeaderPartsResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t GetLeaderPartsResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t GetLeaderPartsResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void GetLeaderPartsResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t GetLeaderPartsResp::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t GetLeaderPartsResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t GetLeaderPartsResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void CheckPeersReq::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_part_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::readWithContext(*iprot, this->part_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.part_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_peers:
  {
    _readState.beforeSubobject(iprot);
    this->peers = ::std::vector<nebula::HostAddr>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector<nebula::HostAddr>>::readWithContext(*iprot, this->peers, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.peers = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<CheckPeersReq>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_part_id;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_peers;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t CheckPeersReq::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("CheckPeersReq");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedFieldSize("peers", apache::thrift::protocol::T_LIST, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector<nebula::HostAddr>>::serializedSize<false>(*prot_, this->peers);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t CheckPeersReq::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("CheckPeersReq");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::serializedSize<false>(*prot_, this->part_id);
  xfer += prot_->serializedFieldSize("peers", apache::thrift::protocol::T_LIST, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector<nebula::HostAddr>>::serializedSize<false>(*prot_, this->peers);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t CheckPeersReq::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("CheckPeersReq");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("part_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::PartitionID>::write(*prot_, this->part_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("peers", apache::thrift::protocol::T_LIST, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector<nebula::HostAddr>>::write(*prot_, this->peers);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void CheckPeersReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t CheckPeersReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t CheckPeersReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t CheckPeersReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void CheckPeersReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t CheckPeersReq::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t CheckPeersReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t CheckPeersReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void RebuildIndexRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_parts:
  {
    _readState.beforeSubobject(iprot);
    this->parts = ::std::vector< ::nebula::cpp2::PartitionID>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::readWithContext(*iprot, this->parts, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.parts = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_index_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::IndexID>::readWithContext(*iprot, this->index_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.index_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<RebuildIndexRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_parts;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_index_id;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t RebuildIndexRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("RebuildIndexRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("index_id", apache::thrift::protocol::T_I32, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::IndexID>::serializedSize<false>(*prot_, this->index_id);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t RebuildIndexRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("RebuildIndexRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("index_id", apache::thrift::protocol::T_I32, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::IndexID>::serializedSize<false>(*prot_, this->index_id);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t RebuildIndexRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("RebuildIndexRequest");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("parts", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::write(*prot_, this->parts);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("index_id", apache::thrift::protocol::T_I32, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::IndexID>::write(*prot_, this->index_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void RebuildIndexRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t RebuildIndexRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t RebuildIndexRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t RebuildIndexRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void RebuildIndexRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t RebuildIndexRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t RebuildIndexRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t RebuildIndexRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void CreateCPResp::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_result:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::readWithContext(*iprot, this->result, _readState);
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_info:
  {
    _readState.beforeSubobject(iprot);
    this->info = ::std::vector< ::nebula::cpp2::CheckpointInfo>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::cpp2::CheckpointInfo>>::readWithContext(*iprot, this->info, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.info = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<CreateCPResp>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_result;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_info;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t CreateCPResp::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("CreateCPResp");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<false>(*prot_, this->result);
  xfer += prot_->serializedFieldSize("info", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::cpp2::CheckpointInfo>>::serializedSize<false>(*prot_, this->info);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t CreateCPResp::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("CreateCPResp");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<true>(*prot_, this->result);
  xfer += prot_->serializedFieldSize("info", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::cpp2::CheckpointInfo>>::serializedSize<false>(*prot_, this->info);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t CreateCPResp::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("CreateCPResp");
  xfer += prot_->writeFieldBegin("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::write(*prot_, this->result);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("info", apache::thrift::protocol::T_LIST, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector< ::nebula::cpp2::CheckpointInfo>>::write(*prot_, this->info);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void CreateCPResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t CreateCPResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t CreateCPResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t CreateCPResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void CreateCPResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t CreateCPResp::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t CreateCPResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t CreateCPResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void ListClusterInfoResp::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_result:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::readWithContext(*iprot, this->result, _readState);
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_dir:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::cpp2::DirInfo>::readWithContext(*iprot, this->dir, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.dir = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<ListClusterInfoResp>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_result;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_dir;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t ListClusterInfoResp::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ListClusterInfoResp");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<false>(*prot_, this->result);
  xfer += prot_->serializedFieldSize("dir", apache::thrift::protocol::T_STRUCT, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::cpp2::DirInfo>::serializedSize<false>(*prot_, this->dir);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ListClusterInfoResp::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ListClusterInfoResp");
  xfer += prot_->serializedFieldSize("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::serializedSize<true>(*prot_, this->result);
  xfer += prot_->serializedFieldSize("dir", apache::thrift::protocol::T_STRUCT, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::cpp2::DirInfo>::serializedSize<true>(*prot_, this->dir);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ListClusterInfoResp::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("ListClusterInfoResp");
  xfer += prot_->writeFieldBegin("result", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ResponseCommon>::write(*prot_, this->result);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("dir", apache::thrift::protocol::T_STRUCT, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::cpp2::DirInfo>::write(*prot_, this->dir);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void ListClusterInfoResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t ListClusterInfoResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t ListClusterInfoResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t ListClusterInfoResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void ListClusterInfoResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t ListClusterInfoResp::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t ListClusterInfoResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t ListClusterInfoResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void ListClusterInfoReq::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<ListClusterInfoReq>>();
  }

  switch (_readState.fieldId) {
    default:
    {
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t ListClusterInfoReq::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ListClusterInfoReq");
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ListClusterInfoReq::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ListClusterInfoReq");
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ListClusterInfoReq::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("ListClusterInfoReq");
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void ListClusterInfoReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t ListClusterInfoReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t ListClusterInfoReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t ListClusterInfoReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void ListClusterInfoReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t ListClusterInfoReq::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t ListClusterInfoReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t ListClusterInfoReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void AddAdminTaskRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_cmd:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::meta::cpp2::AdminCmd>::readWithContext(*iprot, this->cmd, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.cmd = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_job_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::readWithContext(*iprot, this->job_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.job_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_task_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::readWithContext(*iprot, this->task_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.task_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_para:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::TaskPara>::readWithContext(*iprot, this->para, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.para = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          5,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_concurrency:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::readWithContext(*iprot, this->concurrency, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.concurrency = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          5,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<AddAdminTaskRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_cmd;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_job_id;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_task_id;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_para;
      } else {
        goto _skip;
      }
    }
    case 5:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_concurrency;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t AddAdminTaskRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("AddAdminTaskRequest");
  xfer += prot_->serializedFieldSize("cmd", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::meta::cpp2::AdminCmd>::serializedSize<false>(*prot_, this->cmd);
  xfer += prot_->serializedFieldSize("job_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::serializedSize<false>(*prot_, this->job_id);
  xfer += prot_->serializedFieldSize("task_id", apache::thrift::protocol::T_I32, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::serializedSize<false>(*prot_, this->task_id);
  xfer += prot_->serializedFieldSize("para", apache::thrift::protocol::T_STRUCT, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::TaskPara>::serializedSize<false>(*prot_, this->para);
  if (this->concurrency_ref().has_value()) {
    xfer += prot_->serializedFieldSize("concurrency", apache::thrift::protocol::T_I32, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::serializedSize<false>(*prot_, this->concurrency);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t AddAdminTaskRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("AddAdminTaskRequest");
  xfer += prot_->serializedFieldSize("cmd", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::meta::cpp2::AdminCmd>::serializedSize<false>(*prot_, this->cmd);
  xfer += prot_->serializedFieldSize("job_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::serializedSize<false>(*prot_, this->job_id);
  xfer += prot_->serializedFieldSize("task_id", apache::thrift::protocol::T_I32, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::serializedSize<false>(*prot_, this->task_id);
  xfer += prot_->serializedFieldSize("para", apache::thrift::protocol::T_STRUCT, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::TaskPara>::serializedSize<true>(*prot_, this->para);
  if (this->concurrency_ref().has_value()) {
    xfer += prot_->serializedFieldSize("concurrency", apache::thrift::protocol::T_I32, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::serializedSize<false>(*prot_, this->concurrency);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t AddAdminTaskRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("AddAdminTaskRequest");
  xfer += prot_->writeFieldBegin("cmd", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::enumeration,  ::nebula::meta::cpp2::AdminCmd>::write(*prot_, this->cmd);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("job_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::write(*prot_, this->job_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("task_id", apache::thrift::protocol::T_I32, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::write(*prot_, this->task_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("para", apache::thrift::protocol::T_STRUCT, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::TaskPara>::write(*prot_, this->para);
  xfer += prot_->writeFieldEnd();
  if (this->concurrency_ref().has_value()) {
    xfer += prot_->writeFieldBegin("concurrency", apache::thrift::protocol::T_I32, 5);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::write(*prot_, this->concurrency);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void AddAdminTaskRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t AddAdminTaskRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t AddAdminTaskRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t AddAdminTaskRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void AddAdminTaskRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t AddAdminTaskRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t AddAdminTaskRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t AddAdminTaskRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void StopAdminTaskRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_job_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::readWithContext(*iprot, this->job_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.job_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_task_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::readWithContext(*iprot, this->task_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.task_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<StopAdminTaskRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_job_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_task_id;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t StopAdminTaskRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("StopAdminTaskRequest");
  xfer += prot_->serializedFieldSize("job_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::serializedSize<false>(*prot_, this->job_id);
  xfer += prot_->serializedFieldSize("task_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::serializedSize<false>(*prot_, this->task_id);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t StopAdminTaskRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("StopAdminTaskRequest");
  xfer += prot_->serializedFieldSize("job_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::serializedSize<false>(*prot_, this->job_id);
  xfer += prot_->serializedFieldSize("task_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::serializedSize<false>(*prot_, this->task_id);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t StopAdminTaskRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("StopAdminTaskRequest");
  xfer += prot_->writeFieldBegin("job_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::write(*prot_, this->job_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("task_id", apache::thrift::protocol::T_I32, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int32_t>::write(*prot_, this->task_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void StopAdminTaskRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t StopAdminTaskRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t StopAdminTaskRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t StopAdminTaskRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void StopAdminTaskRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t StopAdminTaskRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t StopAdminTaskRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t StopAdminTaskRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void ChainAddEdgesRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_MAP))) {
    goto _loop;
  }
_readField_parts:
  {
    _readState.beforeSubobject(iprot);
    this->parts = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>::readWithContext(*iprot, this->parts, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.parts = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_prop_names:
  {
    _readState.beforeSubobject(iprot);
    this->prop_names = ::std::vector<::std::string>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::readWithContext(*iprot, this->prop_names, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.prop_names = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_BOOL))) {
    goto _loop;
  }
_readField_if_not_exists:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::readWithContext(*iprot, this->if_not_exists, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.if_not_exists = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          5,
          apache::thrift::protocol::T_I64))) {
    goto _loop;
  }
_readField_term:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::readWithContext(*iprot, this->term, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.term = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          5,
          6,
          apache::thrift::protocol::T_I64))) {
    goto _loop;
  }
_readField_edge_version:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::readWithContext(*iprot, this->edge_version, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.edge_version = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          6,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<ChainAddEdgesRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_MAP))) {
        goto _readField_parts;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_prop_names;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_BOOL))) {
        goto _readField_if_not_exists;
      } else {
        goto _skip;
      }
    }
    case 5:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I64))) {
        goto _readField_term;
      } else {
        goto _skip;
      }
    }
    case 6:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I64))) {
        goto _readField_edge_version;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t ChainAddEdgesRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ChainAddEdgesRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("prop_names", apache::thrift::protocol::T_LIST, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::serializedSize<false>(*prot_, this->prop_names);
  xfer += prot_->serializedFieldSize("if_not_exists", apache::thrift::protocol::T_BOOL, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->if_not_exists);
  xfer += prot_->serializedFieldSize("term", apache::thrift::protocol::T_I64, 5);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->term);
  if (this->edge_version_ref().has_value()) {
    xfer += prot_->serializedFieldSize("edge_version", apache::thrift::protocol::T_I64, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->edge_version);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ChainAddEdgesRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ChainAddEdgesRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("prop_names", apache::thrift::protocol::T_LIST, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::serializedSize<false>(*prot_, this->prop_names);
  xfer += prot_->serializedFieldSize("if_not_exists", apache::thrift::protocol::T_BOOL, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::serializedSize<false>(*prot_, this->if_not_exists);
  xfer += prot_->serializedFieldSize("term", apache::thrift::protocol::T_I64, 5);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->term);
  if (this->edge_version_ref().has_value()) {
    xfer += prot_->serializedFieldSize("edge_version", apache::thrift::protocol::T_I64, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->edge_version);
  }
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ChainAddEdgesRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("ChainAddEdgesRequest");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>::write(*prot_, this->parts);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("prop_names", apache::thrift::protocol::T_LIST, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>>::write(*prot_, this->prop_names);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("if_not_exists", apache::thrift::protocol::T_BOOL, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, bool>::write(*prot_, this->if_not_exists);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("term", apache::thrift::protocol::T_I64, 5);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::write(*prot_, this->term);
  xfer += prot_->writeFieldEnd();
  if (this->edge_version_ref().has_value()) {
    xfer += prot_->writeFieldBegin("edge_version", apache::thrift::protocol::T_I64, 6);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::write(*prot_, this->edge_version);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void ChainAddEdgesRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t ChainAddEdgesRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t ChainAddEdgesRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t ChainAddEdgesRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void ChainAddEdgesRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t ChainAddEdgesRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t ChainAddEdgesRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t ChainAddEdgesRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void ChainUpdateEdgeRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_STRUCT))) {
    goto _loop;
  }
_readField_update_edge_request:
  {
    _readState.beforeSubobject(iprot);
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::UpdateEdgeRequest>::readWithContext(*iprot, this->update_edge_request, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.update_edge_request = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_I64))) {
    goto _loop;
  }
_readField_term:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::readWithContext(*iprot, this->term, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.term = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_I64))) {
    goto _loop;
  }
_readField_edge_version:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::readWithContext(*iprot, this->edge_version, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.edge_version = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          5,
          apache::thrift::protocol::T_LIST))) {
    goto _loop;
  }
_readField_parts:
  {
    _readState.beforeSubobject(iprot);
    this->parts = ::std::vector< ::nebula::cpp2::PartitionID>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::readWithContext(*iprot, this->parts, _readState);
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          5,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<ChainUpdateEdgeRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRUCT))) {
        goto _readField_update_edge_request;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I64))) {
        goto _readField_term;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I64))) {
        goto _readField_edge_version;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 5:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_LIST))) {
        goto _readField_parts;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t ChainUpdateEdgeRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ChainUpdateEdgeRequest");
  xfer += prot_->serializedFieldSize("update_edge_request", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::UpdateEdgeRequest>::serializedSize<false>(*prot_, this->update_edge_request);
  xfer += prot_->serializedFieldSize("term", apache::thrift::protocol::T_I64, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->term);
  if (this->edge_version_ref().has_value()) {
    xfer += prot_->serializedFieldSize("edge_version", apache::thrift::protocol::T_I64, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->edge_version);
  }
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_LIST, 5);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ChainUpdateEdgeRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ChainUpdateEdgeRequest");
  xfer += prot_->serializedFieldSize("update_edge_request", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::UpdateEdgeRequest>::serializedSize<true>(*prot_, this->update_edge_request);
  xfer += prot_->serializedFieldSize("term", apache::thrift::protocol::T_I64, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->term);
  if (this->edge_version_ref().has_value()) {
    xfer += prot_->serializedFieldSize("edge_version", apache::thrift::protocol::T_I64, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->edge_version);
  }
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_LIST, 5);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ChainUpdateEdgeRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("ChainUpdateEdgeRequest");
  xfer += prot_->writeFieldBegin("update_edge_request", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::UpdateEdgeRequest>::write(*prot_, this->update_edge_request);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("term", apache::thrift::protocol::T_I64, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::write(*prot_, this->term);
  xfer += prot_->writeFieldEnd();
  if (this->edge_version_ref().has_value()) {
    xfer += prot_->writeFieldBegin("edge_version", apache::thrift::protocol::T_I64, 3);
    xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::write(*prot_, this->edge_version);
    xfer += prot_->writeFieldEnd();
  }
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("parts", apache::thrift::protocol::T_LIST, 5);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector< ::nebula::cpp2::PartitionID>>::write(*prot_, this->parts);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void ChainUpdateEdgeRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t ChainUpdateEdgeRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t ChainUpdateEdgeRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t ChainUpdateEdgeRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void ChainUpdateEdgeRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t ChainUpdateEdgeRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t ChainUpdateEdgeRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t ChainUpdateEdgeRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {

template <class Protocol_>
void ChainDeleteEdgesRequest::readNoXfer(Protocol_* iprot) {
  apache::thrift::detail::ProtocolReaderStructReadState<Protocol_> _readState;

  _readState.readStructBegin(iprot);

  using apache::thrift::TProtocolException;


  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          0,
          1,
          apache::thrift::protocol::T_I32))) {
    goto _loop;
  }
_readField_space_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::readWithContext(*iprot, this->space_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.space_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          1,
          2,
          apache::thrift::protocol::T_MAP))) {
    goto _loop;
  }
_readField_parts:
  {
    _readState.beforeSubobject(iprot);
    this->parts = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>();
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>::readWithContext(*iprot, this->parts, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.parts = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
    _readState.afterSubobject(iprot);
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          2,
          3,
          apache::thrift::protocol::T_STRING))) {
    goto _loop;
  }
_readField_txn_id:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::readWithContext(*iprot, this->txn_id, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.txn_id = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          3,
          4,
          apache::thrift::protocol::T_I64))) {
    goto _loop;
  }
_readField_term:
  {
    ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::readWithContext(*iprot, this->term, _readState);
    THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    this->__isset.term = true;
    THRIFT_IGNORE_ISSET_USE_WARNING_END
  }

  if (UNLIKELY(!_readState.advanceToNextField(
          iprot,
          4,
          0,
          apache::thrift::protocol::T_STOP))) {
    goto _loop;
  }

_end:
  _readState.readStructEnd(iprot);

  return;

_loop:
  _readState.afterAdvanceFailure(iprot);
  if (_readState.atStop()) {
    goto _end;
  }
  if (iprot->kUsesFieldNames()) {
    _readState.template fillFieldTraitsFromName<apache::thrift::detail::TccStructTraits<ChainDeleteEdgesRequest>>();
  }

  switch (_readState.fieldId) {
    case 1:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I32))) {
        goto _readField_space_id;
      } else {
        goto _skip;
      }
    }
    case 2:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_MAP))) {
        goto _readField_parts;
      } else {
        goto _skip;
      }
    }
    case 3:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_STRING))) {
        goto _readField_txn_id;
      } else {
        goto _skip;
      }
    }
    case 4:
    {
      if (LIKELY(_readState.isCompatibleWithType(iprot, apache::thrift::protocol::T_I64))) {
        goto _readField_term;
      } else {
        goto _skip;
      }
    }
    default:
    {
_skip:
      _readState.skip(iprot);
      _readState.readFieldEnd(iprot);
      _readState.readFieldBeginNoInline(iprot);
      goto _loop;
    }
  }
}

template <class Protocol_>
uint32_t ChainDeleteEdgesRequest::serializedSize(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ChainDeleteEdgesRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("txn_id", apache::thrift::protocol::T_STRING, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<false>(*prot_, this->txn_id);
  xfer += prot_->serializedFieldSize("term", apache::thrift::protocol::T_I64, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->term);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ChainDeleteEdgesRequest::serializedSizeZC(Protocol_ const* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ChainDeleteEdgesRequest");
  xfer += prot_->serializedFieldSize("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::serializedSize<false>(*prot_, this->space_id);
  xfer += prot_->serializedFieldSize("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>::serializedSize<false>(*prot_, this->parts);
  xfer += prot_->serializedFieldSize("txn_id", apache::thrift::protocol::T_STRING, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::serializedSize<true>(*prot_, this->txn_id);
  xfer += prot_->serializedFieldSize("term", apache::thrift::protocol::T_I64, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::serializedSize<false>(*prot_, this->term);
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ChainDeleteEdgesRequest::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("ChainDeleteEdgesRequest");
  xfer += prot_->writeFieldBegin("space_id", apache::thrift::protocol::T_I32, 1);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral,  ::nebula::cpp2::GraphSpaceID>::write(*prot_, this->space_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("parts", apache::thrift::protocol::T_MAP, 2);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>::write(*prot_, this->parts);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("txn_id", apache::thrift::protocol::T_STRING, 3);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::binary, ::std::string>::write(*prot_, this->txn_id);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("term", apache::thrift::protocol::T_I64, 4);
  xfer += ::apache::thrift::detail::pm::protocol_methods< ::apache::thrift::type_class::integral, int64_t>::write(*prot_, this->term);
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

extern template void ChainDeleteEdgesRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t ChainDeleteEdgesRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t ChainDeleteEdgesRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t ChainDeleteEdgesRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void ChainDeleteEdgesRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t ChainDeleteEdgesRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t ChainDeleteEdgesRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t ChainDeleteEdgesRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // nebula::storage::cpp2
