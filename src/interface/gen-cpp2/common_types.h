/**
 * Autogenerated by Thrift for common.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>


#include "common/thrift/ThriftTypes.h"
#include "common/datatypes/DateOps-inl.h"
#include "common/datatypes/VertexOps-inl.h"
#include "common/datatypes/EdgeOps-inl.h"
#include "common/datatypes/PathOps-inl.h"
#include "common/datatypes/ValueOps-inl.h"
#include "common/datatypes/MapOps-inl.h"
#include "common/datatypes/ListOps-inl.h"
#include "common/datatypes/SetOps-inl.h"
#include "common/datatypes/DataSetOps-inl.h"
#include "common/datatypes/KeyValueOps-inl.h"
#include "common/datatypes/HostAddrOps-inl.h"
#include "common/datatypes/GeographyOps-inl.h"
#include "common/datatypes/DurationOps-inl.h"

namespace apache {
namespace thrift {
namespace tag {
struct tag_id;
struct edge_type;
struct year;
struct month;
struct day;
struct hour;
struct minute;
struct sec;
struct microsec;
struct year;
struct month;
struct day;
struct hour;
struct minute;
struct sec;
struct microsec;
struct nVal;
struct bVal;
struct iVal;
struct fVal;
struct sVal;
struct dVal;
struct tVal;
struct dtVal;
struct vVal;
struct eVal;
struct pVal;
struct lVal;
struct mVal;
struct uVal;
struct gVal;
struct ggVal;
struct duVal;
struct values;
struct kvs;
struct values;
struct values;
struct column_names;
struct rows;
struct x;
struct y;
struct coord;
struct coordList;
struct coordListList;
struct ptVal;
struct lsVal;
struct pgVal;
struct name;
struct props;
struct vid;
struct tags;
struct src;
struct dst;
struct type;
struct name;
struct ranking;
struct props;
struct dst;
struct type;
struct name;
struct ranking;
struct props;
struct src;
struct steps;
struct host;
struct port;
struct key;
struct value;
struct seconds;
struct microseconds;
struct months;
struct log_id;
struct term_id;
struct commit_log_id;
struct checkpoint_path;
struct root;
struct data;
struct space_id;
struct parts;
struct data_path;
struct cluster;
struct log_str;
} // namespace tag
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_tag_id
#define APACHE_THRIFT_ACCESSOR_tag_id
APACHE_THRIFT_DEFINE_ACCESSOR(tag_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edge_type
#define APACHE_THRIFT_ACCESSOR_edge_type
APACHE_THRIFT_DEFINE_ACCESSOR(edge_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_year
#define APACHE_THRIFT_ACCESSOR_year
APACHE_THRIFT_DEFINE_ACCESSOR(year);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_month
#define APACHE_THRIFT_ACCESSOR_month
APACHE_THRIFT_DEFINE_ACCESSOR(month);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_day
#define APACHE_THRIFT_ACCESSOR_day
APACHE_THRIFT_DEFINE_ACCESSOR(day);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_hour
#define APACHE_THRIFT_ACCESSOR_hour
APACHE_THRIFT_DEFINE_ACCESSOR(hour);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_minute
#define APACHE_THRIFT_ACCESSOR_minute
APACHE_THRIFT_DEFINE_ACCESSOR(minute);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_sec
#define APACHE_THRIFT_ACCESSOR_sec
APACHE_THRIFT_DEFINE_ACCESSOR(sec);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_microsec
#define APACHE_THRIFT_ACCESSOR_microsec
APACHE_THRIFT_DEFINE_ACCESSOR(microsec);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_year
#define APACHE_THRIFT_ACCESSOR_year
APACHE_THRIFT_DEFINE_ACCESSOR(year);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_month
#define APACHE_THRIFT_ACCESSOR_month
APACHE_THRIFT_DEFINE_ACCESSOR(month);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_day
#define APACHE_THRIFT_ACCESSOR_day
APACHE_THRIFT_DEFINE_ACCESSOR(day);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_hour
#define APACHE_THRIFT_ACCESSOR_hour
APACHE_THRIFT_DEFINE_ACCESSOR(hour);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_minute
#define APACHE_THRIFT_ACCESSOR_minute
APACHE_THRIFT_DEFINE_ACCESSOR(minute);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_sec
#define APACHE_THRIFT_ACCESSOR_sec
APACHE_THRIFT_DEFINE_ACCESSOR(sec);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_microsec
#define APACHE_THRIFT_ACCESSOR_microsec
APACHE_THRIFT_DEFINE_ACCESSOR(microsec);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_nVal
#define APACHE_THRIFT_ACCESSOR_nVal
APACHE_THRIFT_DEFINE_ACCESSOR(nVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_bVal
#define APACHE_THRIFT_ACCESSOR_bVal
APACHE_THRIFT_DEFINE_ACCESSOR(bVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_iVal
#define APACHE_THRIFT_ACCESSOR_iVal
APACHE_THRIFT_DEFINE_ACCESSOR(iVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fVal
#define APACHE_THRIFT_ACCESSOR_fVal
APACHE_THRIFT_DEFINE_ACCESSOR(fVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_sVal
#define APACHE_THRIFT_ACCESSOR_sVal
APACHE_THRIFT_DEFINE_ACCESSOR(sVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_dVal
#define APACHE_THRIFT_ACCESSOR_dVal
APACHE_THRIFT_DEFINE_ACCESSOR(dVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tVal
#define APACHE_THRIFT_ACCESSOR_tVal
APACHE_THRIFT_DEFINE_ACCESSOR(tVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_dtVal
#define APACHE_THRIFT_ACCESSOR_dtVal
APACHE_THRIFT_DEFINE_ACCESSOR(dtVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_vVal
#define APACHE_THRIFT_ACCESSOR_vVal
APACHE_THRIFT_DEFINE_ACCESSOR(vVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_eVal
#define APACHE_THRIFT_ACCESSOR_eVal
APACHE_THRIFT_DEFINE_ACCESSOR(eVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_pVal
#define APACHE_THRIFT_ACCESSOR_pVal
APACHE_THRIFT_DEFINE_ACCESSOR(pVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_lVal
#define APACHE_THRIFT_ACCESSOR_lVal
APACHE_THRIFT_DEFINE_ACCESSOR(lVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_mVal
#define APACHE_THRIFT_ACCESSOR_mVal
APACHE_THRIFT_DEFINE_ACCESSOR(mVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_uVal
#define APACHE_THRIFT_ACCESSOR_uVal
APACHE_THRIFT_DEFINE_ACCESSOR(uVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_gVal
#define APACHE_THRIFT_ACCESSOR_gVal
APACHE_THRIFT_DEFINE_ACCESSOR(gVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ggVal
#define APACHE_THRIFT_ACCESSOR_ggVal
APACHE_THRIFT_DEFINE_ACCESSOR(ggVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_duVal
#define APACHE_THRIFT_ACCESSOR_duVal
APACHE_THRIFT_DEFINE_ACCESSOR(duVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_values
#define APACHE_THRIFT_ACCESSOR_values
APACHE_THRIFT_DEFINE_ACCESSOR(values);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_kvs
#define APACHE_THRIFT_ACCESSOR_kvs
APACHE_THRIFT_DEFINE_ACCESSOR(kvs);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_values
#define APACHE_THRIFT_ACCESSOR_values
APACHE_THRIFT_DEFINE_ACCESSOR(values);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_values
#define APACHE_THRIFT_ACCESSOR_values
APACHE_THRIFT_DEFINE_ACCESSOR(values);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_column_names
#define APACHE_THRIFT_ACCESSOR_column_names
APACHE_THRIFT_DEFINE_ACCESSOR(column_names);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_rows
#define APACHE_THRIFT_ACCESSOR_rows
APACHE_THRIFT_DEFINE_ACCESSOR(rows);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_x
#define APACHE_THRIFT_ACCESSOR_x
APACHE_THRIFT_DEFINE_ACCESSOR(x);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_y
#define APACHE_THRIFT_ACCESSOR_y
APACHE_THRIFT_DEFINE_ACCESSOR(y);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_coord
#define APACHE_THRIFT_ACCESSOR_coord
APACHE_THRIFT_DEFINE_ACCESSOR(coord);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_coordList
#define APACHE_THRIFT_ACCESSOR_coordList
APACHE_THRIFT_DEFINE_ACCESSOR(coordList);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_coordListList
#define APACHE_THRIFT_ACCESSOR_coordListList
APACHE_THRIFT_DEFINE_ACCESSOR(coordListList);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ptVal
#define APACHE_THRIFT_ACCESSOR_ptVal
APACHE_THRIFT_DEFINE_ACCESSOR(ptVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_lsVal
#define APACHE_THRIFT_ACCESSOR_lsVal
APACHE_THRIFT_DEFINE_ACCESSOR(lsVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_pgVal
#define APACHE_THRIFT_ACCESSOR_pgVal
APACHE_THRIFT_DEFINE_ACCESSOR(pgVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_props
#define APACHE_THRIFT_ACCESSOR_props
APACHE_THRIFT_DEFINE_ACCESSOR(props);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_vid
#define APACHE_THRIFT_ACCESSOR_vid
APACHE_THRIFT_DEFINE_ACCESSOR(vid);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tags
#define APACHE_THRIFT_ACCESSOR_tags
APACHE_THRIFT_DEFINE_ACCESSOR(tags);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_src
#define APACHE_THRIFT_ACCESSOR_src
APACHE_THRIFT_DEFINE_ACCESSOR(src);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_dst
#define APACHE_THRIFT_ACCESSOR_dst
APACHE_THRIFT_DEFINE_ACCESSOR(dst);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ranking
#define APACHE_THRIFT_ACCESSOR_ranking
APACHE_THRIFT_DEFINE_ACCESSOR(ranking);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_props
#define APACHE_THRIFT_ACCESSOR_props
APACHE_THRIFT_DEFINE_ACCESSOR(props);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_dst
#define APACHE_THRIFT_ACCESSOR_dst
APACHE_THRIFT_DEFINE_ACCESSOR(dst);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ranking
#define APACHE_THRIFT_ACCESSOR_ranking
APACHE_THRIFT_DEFINE_ACCESSOR(ranking);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_props
#define APACHE_THRIFT_ACCESSOR_props
APACHE_THRIFT_DEFINE_ACCESSOR(props);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_src
#define APACHE_THRIFT_ACCESSOR_src
APACHE_THRIFT_DEFINE_ACCESSOR(src);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_steps
#define APACHE_THRIFT_ACCESSOR_steps
APACHE_THRIFT_DEFINE_ACCESSOR(steps);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_host
#define APACHE_THRIFT_ACCESSOR_host
APACHE_THRIFT_DEFINE_ACCESSOR(host);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_port
#define APACHE_THRIFT_ACCESSOR_port
APACHE_THRIFT_DEFINE_ACCESSOR(port);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_key
#define APACHE_THRIFT_ACCESSOR_key
APACHE_THRIFT_DEFINE_ACCESSOR(key);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_value
#define APACHE_THRIFT_ACCESSOR_value
APACHE_THRIFT_DEFINE_ACCESSOR(value);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_seconds
#define APACHE_THRIFT_ACCESSOR_seconds
APACHE_THRIFT_DEFINE_ACCESSOR(seconds);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_microseconds
#define APACHE_THRIFT_ACCESSOR_microseconds
APACHE_THRIFT_DEFINE_ACCESSOR(microseconds);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_months
#define APACHE_THRIFT_ACCESSOR_months
APACHE_THRIFT_DEFINE_ACCESSOR(months);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_log_id
#define APACHE_THRIFT_ACCESSOR_log_id
APACHE_THRIFT_DEFINE_ACCESSOR(log_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_term_id
#define APACHE_THRIFT_ACCESSOR_term_id
APACHE_THRIFT_DEFINE_ACCESSOR(term_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_commit_log_id
#define APACHE_THRIFT_ACCESSOR_commit_log_id
APACHE_THRIFT_DEFINE_ACCESSOR(commit_log_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_checkpoint_path
#define APACHE_THRIFT_ACCESSOR_checkpoint_path
APACHE_THRIFT_DEFINE_ACCESSOR(checkpoint_path);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_root
#define APACHE_THRIFT_ACCESSOR_root
APACHE_THRIFT_DEFINE_ACCESSOR(root);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_data
#define APACHE_THRIFT_ACCESSOR_data
APACHE_THRIFT_DEFINE_ACCESSOR(data);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_data_path
#define APACHE_THRIFT_ACCESSOR_data_path
APACHE_THRIFT_DEFINE_ACCESSOR(data_path);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cluster
#define APACHE_THRIFT_ACCESSOR_cluster
APACHE_THRIFT_DEFINE_ACCESSOR(cluster);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_log_str
#define APACHE_THRIFT_ACCESSOR_log_str
APACHE_THRIFT_DEFINE_ACCESSOR(log_str);
#endif
} // namespace detail
} // namespace thrift
} // namespace apache

// BEGIN declare_enums
namespace nebula { namespace cpp2 {

enum class NullType {
  __NULL__ = 0,
  NaN = 1,
  BAD_DATA = 2,
  BAD_TYPE = 3,
  ERR_OVERFLOW = 4,
  UNKNOWN_PROP = 5,
  DIV_BY_ZERO = 6,
  OUT_OF_RANGE = 7,
};




enum class PropertyType {
  UNKNOWN = 0,
  BOOL = 1,
  INT64 = 2,
  VID = 3,
  FLOAT = 4,
  DOUBLE = 5,
  STRING = 6,
  FIXED_STRING = 7,
  INT8 = 8,
  INT16 = 9,
  INT32 = 10,
  TIMESTAMP = 21,
  DURATION = 23,
  DATE = 24,
  DATETIME = 25,
  TIME = 26,
  GEOGRAPHY = 31,
};




enum class ErrorCode {
  SUCCEEDED = 0,
  E_DISCONNECTED = -1,
  E_FAIL_TO_CONNECT = -2,
  E_RPC_FAILURE = -3,
  E_LEADER_CHANGED = -4,
  E_SPACE_NOT_FOUND = -5,
  E_TAG_NOT_FOUND = -6,
  E_EDGE_NOT_FOUND = -7,
  E_INDEX_NOT_FOUND = -8,
  E_EDGE_PROP_NOT_FOUND = -9,
  E_TAG_PROP_NOT_FOUND = -10,
  E_ROLE_NOT_FOUND = -11,
  E_CONFIG_NOT_FOUND = -12,
  E_MACHINE_NOT_FOUND = -13,
  E_ZONE_NOT_FOUND = -14,
  E_LISTENER_NOT_FOUND = -15,
  E_PART_NOT_FOUND = -16,
  E_KEY_NOT_FOUND = -17,
  E_USER_NOT_FOUND = -18,
  E_STATS_NOT_FOUND = -19,
  E_SERVICE_NOT_FOUND = -20,
  E_DRAINER_NOT_FOUND = -21,
  E_DRAINER_CLIENT_NOT_FOUND = -22,
  E_PART_STOPPED = -23,
  E_BACKUP_FAILED = -24,
  E_BACKUP_EMPTY_TABLE = -25,
  E_BACKUP_TABLE_FAILED = -26,
  E_PARTIAL_RESULT = -27,
  E_REBUILD_INDEX_FAILED = -28,
  E_INVALID_PASSWORD = -29,
  E_FAILED_GET_ABS_PATH = -30,
  E_LISTENER_PROGRESS_FAILED = -31,
  E_SYNC_LISTENER_NOT_FOUND = -32,
  E_DRAINER_PROGRESS_FAILED = -33,
  E_PART_DISABLED = -34,
  E_PART_ALREADY_STARTED = -35,
  E_PART_ALREADY_STOPPED = -36,
  E_BAD_USERNAME_PASSWORD = -1001,
  E_SESSION_INVALID = -1002,
  E_SESSION_TIMEOUT = -1003,
  E_SYNTAX_ERROR = -1004,
  E_EXECUTION_ERROR = -1005,
  E_STATEMENT_EMPTY = -1006,
  E_BAD_PERMISSION = -1008,
  E_SEMANTIC_ERROR = -1009,
  E_TOO_MANY_CONNECTIONS = -1010,
  E_PARTIAL_SUCCEEDED = -1011,
  E_NO_HOSTS = -2001,
  E_EXISTED = -2002,
  E_INVALID_HOST = -2003,
  E_UNSUPPORTED = -2004,
  E_NOT_DROP = -2005,
  E_BALANCER_RUNNING = -2006,
  E_CONFIG_IMMUTABLE = -2007,
  E_CONFLICT = -2008,
  E_INVALID_PARM = -2009,
  E_WRONGCLUSTER = -2010,
  E_ZONE_NOT_ENOUGH = -2011,
  E_ZONE_IS_EMPTY = -2012,
  E_LISTENER_CONFLICT = -2013,
  E_SCHEMA_NAME_EXISTS = -2014,
  E_RELATED_INDEX_EXISTS = -2015,
  E_RELATED_SPACE_EXISTS = -2016,
  E_RELATED_FULLTEXT_INDEX_EXISTS = -2017,
  E_HISTORY_CONFLICT = -2018,
  E_STORE_FAILURE = -2021,
  E_STORE_SEGMENT_ILLEGAL = -2022,
  E_BAD_BALANCE_PLAN = -2023,
  E_BALANCED = -2024,
  E_NO_RUNNING_BALANCE_PLAN = -2025,
  E_NO_VALID_HOST = -2026,
  E_CORRUPTED_BALANCE_PLAN = -2027,
  E_NO_INVALID_BALANCE_PLAN = -2028,
  E_NO_VALID_DRAINER = -2029,
  E_IMPROPER_ROLE = -2030,
  E_INVALID_PARTITION_NUM = -2031,
  E_INVALID_REPLICA_FACTOR = -2032,
  E_INVALID_CHARSET = -2033,
  E_INVALID_COLLATE = -2034,
  E_CHARSET_COLLATE_NOT_MATCH = -2035,
  E_PRIVILEGE_ALL_TAG_EDGE_SETTLED = -2036,
  E_PRIVILEGE_NOT_EXIST = -2037,
  E_PRIVILEGE_NEED_BASIC_ROLE = -2038,
  E_PRIVILEGE_ACTION_INVALID = -2039,
  E_STORAGE_ENABLE_AUTH = -2058,
  E_SNAPSHOT_FAILURE = -2040,
  E_SNAPSHOT_RUNNING_JOBS = -2056,
  E_SNAPSHOT_NOT_FOUND = -2057,
  E_BLOCK_WRITE_FAILURE = -2041,
  E_REBUILD_INDEX_FAILURE = -2042,
  E_INDEX_WITH_TTL = -2043,
  E_ADD_JOB_FAILURE = -2044,
  E_STOP_JOB_FAILURE = -2045,
  E_SAVE_JOB_FAILURE = -2046,
  E_BALANCER_FAILURE = -2047,
  E_JOB_NOT_FINISHED = -2048,
  E_TASK_REPORT_OUT_DATE = -2049,
  E_JOB_NOT_IN_SPACE = -2050,
  E_JOB_NEED_RECOVER = -2051,
  E_JOB_ALREADY_FINISH = -2052,
  E_JOB_SUBMITTED = -2053,
  E_JOB_NOT_STOPPABLE = -2054,
  E_JOB_HAS_NO_TARGET_STORAGE = -2055,
  E_INVALID_JOB = -2065,
  E_BACKUP_RUNNING_JOBS = -2066,
  E_BACKUP_SPACE_NOT_FOUND = -2067,
  E_RESTORE_FAILURE = -2068,
  E_SESSION_NOT_FOUND = -2069,
  E_LIST_CLUSTER_FAILURE = -2070,
  E_LIST_CLUSTER_GET_ABS_PATH_FAILURE = -2071,
  E_LIST_CLUSTER_NO_AGENT_FAILURE = -2072,
  E_QUERY_NOT_FOUND = -2073,
  E_AGENT_HB_FAILUE = -2074,
  E_INVALID_VARIABLE = -2080,
  E_VARIABLE_TYPE_VALUE_MISMATCH = -2081,
  E_HOST_CAN_NOT_BE_ADDED = -2082,
  E_ACCESS_ES_FAILURE = -2090,
  E_GRAPH_MEMORY_EXCEEDED = -2600,
  E_CONSENSUS_ERROR = -3001,
  E_KEY_HAS_EXISTS = -3002,
  E_DATA_TYPE_MISMATCH = -3003,
  E_INVALID_FIELD_VALUE = -3004,
  E_INVALID_OPERATION = -3005,
  E_NOT_NULLABLE = -3006,
  E_FIELD_UNSET = -3007,
  E_OUT_OF_RANGE = -3008,
  E_DATA_CONFLICT_ERROR = -3010,
  E_WRITE_STALLED = -3011,
  E_IMPROPER_DATA_TYPE = -3021,
  E_INVALID_SPACEVIDLEN = -3022,
  E_INVALID_FILTER = -3031,
  E_INVALID_UPDATER = -3032,
  E_INVALID_STORE = -3033,
  E_INVALID_PEER = -3034,
  E_RETRY_EXHAUSTED = -3035,
  E_TRANSFER_LEADER_FAILED = -3036,
  E_INVALID_STAT_TYPE = -3037,
  E_INVALID_VID = -3038,
  E_NO_TRANSFORMED = -3039,
  E_LOAD_META_FAILED = -3040,
  E_FAILED_TO_CHECKPOINT = -3041,
  E_CHECKPOINT_BLOCKED = -3042,
  E_FILTER_OUT = -3043,
  E_INVALID_DATA = -3044,
  E_MUTATE_EDGE_CONFLICT = -3045,
  E_MUTATE_TAG_CONFLICT = -3046,
  E_OUTDATED_LOCK = -3047,
  E_INVALID_TASK_PARA = -3051,
  E_USER_CANCEL = -3052,
  E_TASK_EXECUTION_FAILED = -3053,
  E_PLAN_IS_KILLED = -3060,
  E_NO_TERM = -3070,
  E_OUTDATED_TERM = -3071,
  E_OUTDATED_EDGE = -3072,
  E_WRITE_WRITE_CONFLICT = -3073,
  E_CLIENT_SERVER_INCOMPATIBLE = -3061,
  E_ID_FAILED = -3062,
  E_RAFT_UNKNOWN_PART = -3500,
  E_RAFT_LOG_GAP = -3501,
  E_RAFT_LOG_STALE = -3502,
  E_RAFT_TERM_OUT_OF_DATE = -3503,
  E_RAFT_UNKNOWN_APPEND_LOG = -3504,
  E_RAFT_WAITING_SNAPSHOT = -3511,
  E_RAFT_SENDING_SNAPSHOT = -3512,
  E_RAFT_INVALID_PEER = -3513,
  E_RAFT_NOT_READY = -3514,
  E_RAFT_STOPPED = -3515,
  E_RAFT_BAD_ROLE = -3516,
  E_RAFT_WAL_FAIL = -3521,
  E_RAFT_HOST_STOPPED = -3522,
  E_RAFT_TOO_MANY_REQUESTS = -3523,
  E_RAFT_PERSIST_SNAPSHOT_FAILED = -3524,
  E_RAFT_RPC_EXCEPTION = -3525,
  E_RAFT_NO_WAL_FOUND = -3526,
  E_RAFT_HOST_PAUSED = -3527,
  E_RAFT_WRITE_BLOCKED = -3528,
  E_RAFT_BUFFER_OVERFLOW = -3529,
  E_RAFT_ATOMIC_OP_FAILED = -3530,
  E_LEADER_LEASE_FAILED = -3531,
  E_RAFT_CAUGHT_UP = -3532,
  E_LOG_GAP = -4001,
  E_LOG_STALE = -4002,
  E_INVALID_DRAINER_STORE = -4003,
  E_SPACE_MISMATCH = -4004,
  E_PART_MISMATCH = -4005,
  E_DATA_CONFLICT = -4006,
  E_REQ_CONFLICT = -4007,
  E_DATA_ILLEGAL = -4008,
  E_CACHE_CONFIG_ERROR = -5001,
  E_NOT_ENOUGH_SPACE = -5002,
  E_CACHE_MISS = -5003,
  E_POOL_NOT_FOUND = -5004,
  E_CACHE_WRITE_FAILURE = -5005,
  E_NODE_NUMBER_EXCEED_LIMIT = -7001,
  E_PARSING_LICENSE_FAILURE = -7002,
  E_STORAGE_MEMORY_EXCEEDED = -3600,
  E_UNKNOWN = -8000,
};




}} // nebula::cpp2
namespace std {


template<> struct hash<typename ::nebula::cpp2::NullType> : public apache::thrift::detail::enum_hash<typename ::nebula::cpp2::NullType> {};
template<> struct equal_to<typename ::nebula::cpp2::NullType> : public apache::thrift::detail::enum_equal_to<typename ::nebula::cpp2::NullType> {};


template<> struct hash<typename ::nebula::cpp2::PropertyType> : public apache::thrift::detail::enum_hash<typename ::nebula::cpp2::PropertyType> {};
template<> struct equal_to<typename ::nebula::cpp2::PropertyType> : public apache::thrift::detail::enum_equal_to<typename ::nebula::cpp2::PropertyType> {};


template<> struct hash<typename ::nebula::cpp2::ErrorCode> : public apache::thrift::detail::enum_hash<typename ::nebula::cpp2::ErrorCode> {};
template<> struct equal_to<typename ::nebula::cpp2::ErrorCode> : public apache::thrift::detail::enum_equal_to<typename ::nebula::cpp2::ErrorCode> {};


} // std

namespace apache { namespace thrift {


template <> struct TEnumDataStorage<::nebula::cpp2::NullType>;

template <> struct TEnumTraits<::nebula::cpp2::NullType> {
  using type = ::nebula::cpp2::NullType;

  static constexpr std::size_t const size = 8;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::__NULL__; }
  static constexpr type max() { return type::OUT_OF_RANGE; }
};


template <> struct TEnumDataStorage<::nebula::cpp2::PropertyType>;

template <> struct TEnumTraits<::nebula::cpp2::PropertyType> {
  using type = ::nebula::cpp2::PropertyType;

  static constexpr std::size_t const size = 17;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::UNKNOWN; }
  static constexpr type max() { return type::GEOGRAPHY; }
};


template <> struct TEnumDataStorage<::nebula::cpp2::ErrorCode>;

template <> struct TEnumTraits<::nebula::cpp2::ErrorCode> {
  using type = ::nebula::cpp2::ErrorCode;

  static constexpr std::size_t const size = 197;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::E_UNKNOWN; }
  static constexpr type max() { return type::SUCCEEDED; }
};


}} // apache::thrift

namespace nebula { namespace cpp2 {

using _NullType_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<NullType>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _NullType_EnumMapFactory::ValuesToNamesMapType _NullType_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _NullType_EnumMapFactory::NamesToValuesMapType _NullType_NAMES_TO_VALUES;

using _PropertyType_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<PropertyType>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _PropertyType_EnumMapFactory::ValuesToNamesMapType _PropertyType_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _PropertyType_EnumMapFactory::NamesToValuesMapType _PropertyType_NAMES_TO_VALUES;

using _ErrorCode_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<ErrorCode>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _ErrorCode_EnumMapFactory::ValuesToNamesMapType _ErrorCode_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _ErrorCode_EnumMapFactory::NamesToValuesMapType _ErrorCode_NAMES_TO_VALUES;

}} // nebula::cpp2

// END declare_enums
// BEGIN forward_declare
namespace nebula { namespace cpp2 {
class SchemaID;
class Date;
class Time;
class DateTime;
class Value;
class NList;
class NMap;
class NSet;
class Row;
class DataSet;
class Coordinate;
class Point;
class LineString;
class Polygon;
class Geography;
class Tag;
class Vertex;
class Edge;
class Step;
class Path;
class HostAddr;
class KeyValue;
class Duration;
class LogInfo;
class DirInfo;
class CheckpointInfo;
class LogEntry;
}} // nebula::cpp2
// END forward_declare
// BEGIN typedefs
namespace nebula { namespace cpp2 {
typedef nebula::ClusterID ClusterID;
typedef nebula::GraphSpaceID GraphSpaceID;
typedef nebula::PartitionID PartitionID;
typedef nebula::TagID TagID;
typedef nebula::EdgeType EdgeType;
typedef nebula::EdgeRanking EdgeRanking;
typedef nebula::LogID LogID;
typedef nebula::TermID TermID;
typedef nebula::Timestamp Timestamp;
typedef nebula::IndexID IndexID;
typedef nebula::Port Port;
typedef nebula::SessionID SessionID;
typedef nebula::ExecutionPlanID ExecutionPlanID;

}} // nebula::cpp2
// END typedefs
// BEGIN hash_and_equal_to
// END hash_and_equal_to
namespace nebula { namespace cpp2 {
class SchemaID final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = SchemaID;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    tag_id = 1,
    edge_type = 2,
  } ;

  SchemaID()
      : type_(Type::__EMPTY__) {}

  SchemaID(SchemaID&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::tag_id:
      {
        set_tag_id(std::move(rhs.value_.tag_id));
        break;
      }
      case Type::edge_type:
      {
        set_edge_type(std::move(rhs.value_.edge_type));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  SchemaID(const SchemaID& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::tag_id:
      {
        set_tag_id(rhs.value_.tag_id);
        break;
      }
      case Type::edge_type:
      {
        set_edge_type(rhs.value_.edge_type);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  SchemaID& operator=(SchemaID&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::tag_id:
      {
        set_tag_id(std::move(rhs.value_.tag_id));
        break;
      }
      case Type::edge_type:
      {
        set_edge_type(std::move(rhs.value_.edge_type));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  SchemaID& operator=(const SchemaID& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::tag_id:
      {
        set_tag_id(rhs.value_.tag_id);
        break;
      }
      case Type::edge_type:
      {
        set_edge_type(rhs.value_.edge_type);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~SchemaID() {
    __clear();
  }
  union storage_type {
     ::nebula::cpp2::TagID tag_id;
     ::nebula::cpp2::EdgeType edge_type;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const SchemaID& rhs) const;
#ifndef SWIG
  friend bool operator!=(const SchemaID& __x, const SchemaID& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const SchemaID& rhs) const;
#ifndef SWIG
  friend bool operator>(const SchemaID& __x, const SchemaID& __y) {
    return __y < __x;
  }
  friend bool operator<=(const SchemaID& __x, const SchemaID& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const SchemaID& __x, const SchemaID& __y) {
    return !(__x < __y);
  }
#endif

   ::nebula::cpp2::TagID& set_tag_id( ::nebula::cpp2::TagID t =  ::nebula::cpp2::TagID()) {
    __clear();
    type_ = Type::tag_id;
    ::new (std::addressof(value_.tag_id))  ::nebula::cpp2::TagID(t);
    return value_.tag_id;
  }

   ::nebula::cpp2::EdgeType& set_edge_type( ::nebula::cpp2::EdgeType t =  ::nebula::cpp2::EdgeType()) {
    __clear();
    type_ = Type::edge_type;
    ::new (std::addressof(value_.edge_type))  ::nebula::cpp2::EdgeType(t);
    return value_.edge_type;
  }

   ::nebula::cpp2::TagID const & get_tag_id() const {
    assert(type_ == Type::tag_id);
    return value_.tag_id;
  }

   ::nebula::cpp2::EdgeType const & get_edge_type() const {
    assert(type_ == Type::edge_type);
    return value_.edge_type;
  }

   ::nebula::cpp2::TagID & mutable_tag_id() {
    assert(type_ == Type::tag_id);
    return value_.tag_id;
  }

   ::nebula::cpp2::EdgeType & mutable_edge_type() {
    assert(type_ == Type::edge_type);
    return value_.edge_type;
  }

   ::nebula::cpp2::TagID move_tag_id() {
    assert(type_ == Type::tag_id);
    return std::move(value_.tag_id);
  }

   ::nebula::cpp2::EdgeType move_edge_type() {
    assert(type_ == Type::edge_type);
    return std::move(value_.edge_type);
  }

  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> tag_id_ref() const& {
    return {value_.tag_id, type_, tag_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> tag_id_ref() const&& {
    return {std::move(value_.tag_id), type_, tag_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> tag_id_ref() & {
    return {value_.tag_id, type_, tag_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> tag_id_ref() && {
    return {std::move(value_.tag_id), type_, tag_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> edge_type_ref() const& {
    return {value_.edge_type, type_, edge_type, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> edge_type_ref() const&& {
    return {std::move(value_.edge_type), type_, edge_type, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> edge_type_ref() & {
    return {value_.edge_type, type_, edge_type, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> edge_type_ref() && {
    return {std::move(value_.edge_type), type_, edge_type, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< SchemaID >;
  friend void swap(SchemaID& a, SchemaID& b);
};

template <class Protocol_>
uint32_t SchemaID::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class Date final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Date;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  Date() :
      year(0),
      month(0),
      day(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Date(apache::thrift::FragileConstructor, int16_t year__arg, int8_t month__arg, int8_t day__arg);

  Date(Date&&) = default;

  Date(const Date&) = default;


  Date& operator=(Date&&) = default;

  Date& operator=(const Date&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  int16_t year;
 private:
  int8_t month;
 private:
  int8_t day;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool year;
    bool month;
    bool day;
  } __isset = {};
  bool operator==(const Date& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Date& __x, const Date& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Date& rhs) const;
#ifndef SWIG
  friend bool operator>(const Date& __x, const Date& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Date& __x, const Date& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Date& __x, const Date& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> year_ref() const& {
    return {this->year, __isset.year};
  }

  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> year_ref() const&& {
    return {std::move(this->year), __isset.year};
  }

  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> year_ref() & {
    return {this->year, __isset.year};
  }

  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> year_ref() && {
    return {std::move(this->year), __isset.year};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> month_ref() const& {
    return {this->month, __isset.month};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> month_ref() const&& {
    return {std::move(this->month), __isset.month};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> month_ref() & {
    return {this->month, __isset.month};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> month_ref() && {
    return {std::move(this->month), __isset.month};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> day_ref() const& {
    return {this->day, __isset.day};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> day_ref() const&& {
    return {std::move(this->day), __isset.day};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> day_ref() & {
    return {this->day, __isset.day};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> day_ref() && {
    return {std::move(this->day), __isset.day};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  int16_t get_year() const {
    return year;
  }

  int16_t& set_year(int16_t year_) {
    year = year_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.year = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return year;
  }

  int8_t get_month() const {
    return month;
  }

  int8_t& set_month(int8_t month_) {
    month = month_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.month = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return month;
  }

  int8_t get_day() const {
    return day;
  }

  int8_t& set_day(int8_t day_) {
    day = day_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.day = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return day;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Date >;
  friend void swap(Date& a, Date& b);
};

template <class Protocol_>
uint32_t Date::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class Time final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Time;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  Time() :
      hour(0),
      minute(0),
      sec(0),
      microsec(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Time(apache::thrift::FragileConstructor, int8_t hour__arg, int8_t minute__arg, int8_t sec__arg, int32_t microsec__arg);

  Time(Time&&) = default;

  Time(const Time&) = default;


  Time& operator=(Time&&) = default;

  Time& operator=(const Time&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  int8_t hour;
 private:
  int8_t minute;
 private:
  int8_t sec;
 private:
  int32_t microsec;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool hour;
    bool minute;
    bool sec;
    bool microsec;
  } __isset = {};
  bool operator==(const Time& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Time& __x, const Time& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Time& rhs) const;
#ifndef SWIG
  friend bool operator>(const Time& __x, const Time& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Time& __x, const Time& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Time& __x, const Time& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> hour_ref() const& {
    return {this->hour, __isset.hour};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> hour_ref() const&& {
    return {std::move(this->hour), __isset.hour};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> hour_ref() & {
    return {this->hour, __isset.hour};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> hour_ref() && {
    return {std::move(this->hour), __isset.hour};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> minute_ref() const& {
    return {this->minute, __isset.minute};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> minute_ref() const&& {
    return {std::move(this->minute), __isset.minute};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> minute_ref() & {
    return {this->minute, __isset.minute};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> minute_ref() && {
    return {std::move(this->minute), __isset.minute};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> sec_ref() const& {
    return {this->sec, __isset.sec};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> sec_ref() const&& {
    return {std::move(this->sec), __isset.sec};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> sec_ref() & {
    return {this->sec, __isset.sec};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> sec_ref() && {
    return {std::move(this->sec), __isset.sec};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> microsec_ref() const& {
    return {this->microsec, __isset.microsec};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> microsec_ref() const&& {
    return {std::move(this->microsec), __isset.microsec};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> microsec_ref() & {
    return {this->microsec, __isset.microsec};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> microsec_ref() && {
    return {std::move(this->microsec), __isset.microsec};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  int8_t get_hour() const {
    return hour;
  }

  int8_t& set_hour(int8_t hour_) {
    hour = hour_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.hour = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return hour;
  }

  int8_t get_minute() const {
    return minute;
  }

  int8_t& set_minute(int8_t minute_) {
    minute = minute_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.minute = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return minute;
  }

  int8_t get_sec() const {
    return sec;
  }

  int8_t& set_sec(int8_t sec_) {
    sec = sec_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.sec = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return sec;
  }

  int32_t get_microsec() const {
    return microsec;
  }

  int32_t& set_microsec(int32_t microsec_) {
    microsec = microsec_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.microsec = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return microsec;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Time >;
  friend void swap(Time& a, Time& b);
};

template <class Protocol_>
uint32_t Time::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class DateTime final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = DateTime;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  DateTime() :
      year(0),
      month(0),
      day(0),
      hour(0),
      minute(0),
      sec(0),
      microsec(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  DateTime(apache::thrift::FragileConstructor, int16_t year__arg, int8_t month__arg, int8_t day__arg, int8_t hour__arg, int8_t minute__arg, int8_t sec__arg, int32_t microsec__arg);

  DateTime(DateTime&&) = default;

  DateTime(const DateTime&) = default;


  DateTime& operator=(DateTime&&) = default;

  DateTime& operator=(const DateTime&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  int16_t year;
 private:
  int8_t month;
 private:
  int8_t day;
 private:
  int8_t hour;
 private:
  int8_t minute;
 private:
  int8_t sec;
 private:
  int32_t microsec;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool year;
    bool month;
    bool day;
    bool hour;
    bool minute;
    bool sec;
    bool microsec;
  } __isset = {};
  bool operator==(const DateTime& rhs) const;
#ifndef SWIG
  friend bool operator!=(const DateTime& __x, const DateTime& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const DateTime& rhs) const;
#ifndef SWIG
  friend bool operator>(const DateTime& __x, const DateTime& __y) {
    return __y < __x;
  }
  friend bool operator<=(const DateTime& __x, const DateTime& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const DateTime& __x, const DateTime& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> year_ref() const& {
    return {this->year, __isset.year};
  }

  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> year_ref() const&& {
    return {std::move(this->year), __isset.year};
  }

  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> year_ref() & {
    return {this->year, __isset.year};
  }

  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> year_ref() && {
    return {std::move(this->year), __isset.year};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> month_ref() const& {
    return {this->month, __isset.month};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> month_ref() const&& {
    return {std::move(this->month), __isset.month};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> month_ref() & {
    return {this->month, __isset.month};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> month_ref() && {
    return {std::move(this->month), __isset.month};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> day_ref() const& {
    return {this->day, __isset.day};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> day_ref() const&& {
    return {std::move(this->day), __isset.day};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> day_ref() & {
    return {this->day, __isset.day};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> day_ref() && {
    return {std::move(this->day), __isset.day};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> hour_ref() const& {
    return {this->hour, __isset.hour};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> hour_ref() const&& {
    return {std::move(this->hour), __isset.hour};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> hour_ref() & {
    return {this->hour, __isset.hour};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> hour_ref() && {
    return {std::move(this->hour), __isset.hour};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> minute_ref() const& {
    return {this->minute, __isset.minute};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> minute_ref() const&& {
    return {std::move(this->minute), __isset.minute};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> minute_ref() & {
    return {this->minute, __isset.minute};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> minute_ref() && {
    return {std::move(this->minute), __isset.minute};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> sec_ref() const& {
    return {this->sec, __isset.sec};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> sec_ref() const&& {
    return {std::move(this->sec), __isset.sec};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> sec_ref() & {
    return {this->sec, __isset.sec};
  }

  template <typename..., typename T = int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> sec_ref() && {
    return {std::move(this->sec), __isset.sec};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> microsec_ref() const& {
    return {this->microsec, __isset.microsec};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> microsec_ref() const&& {
    return {std::move(this->microsec), __isset.microsec};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> microsec_ref() & {
    return {this->microsec, __isset.microsec};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> microsec_ref() && {
    return {std::move(this->microsec), __isset.microsec};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  int16_t get_year() const {
    return year;
  }

  int16_t& set_year(int16_t year_) {
    year = year_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.year = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return year;
  }

  int8_t get_month() const {
    return month;
  }

  int8_t& set_month(int8_t month_) {
    month = month_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.month = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return month;
  }

  int8_t get_day() const {
    return day;
  }

  int8_t& set_day(int8_t day_) {
    day = day_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.day = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return day;
  }

  int8_t get_hour() const {
    return hour;
  }

  int8_t& set_hour(int8_t hour_) {
    hour = hour_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.hour = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return hour;
  }

  int8_t get_minute() const {
    return minute;
  }

  int8_t& set_minute(int8_t minute_) {
    minute = minute_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.minute = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return minute;
  }

  int8_t get_sec() const {
    return sec;
  }

  int8_t& set_sec(int8_t sec_) {
    sec = sec_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.sec = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return sec;
  }

  int32_t get_microsec() const {
    return microsec;
  }

  int32_t& set_microsec(int32_t microsec_) {
    microsec = microsec_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.microsec = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return microsec;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< DateTime >;
  friend void swap(DateTime& a, DateTime& b);
};

template <class Protocol_>
uint32_t DateTime::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class Value final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Value;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    nVal = 1,
    bVal = 2,
    iVal = 3,
    fVal = 4,
    sVal = 5,
    dVal = 6,
    tVal = 7,
    dtVal = 8,
    vVal = 9,
    eVal = 10,
    pVal = 11,
    lVal = 12,
    mVal = 13,
    uVal = 14,
    gVal = 15,
    ggVal = 16,
    duVal = 17,
  } ;

  Value()
      : type_(Type::__EMPTY__) {}

  Value(Value&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::nVal:
      {
        set_nVal(std::move(rhs.value_.nVal));
        break;
      }
      case Type::bVal:
      {
        set_bVal(std::move(rhs.value_.bVal));
        break;
      }
      case Type::iVal:
      {
        set_iVal(std::move(rhs.value_.iVal));
        break;
      }
      case Type::fVal:
      {
        set_fVal(std::move(rhs.value_.fVal));
        break;
      }
      case Type::sVal:
      {
        set_sVal(std::move(rhs.value_.sVal));
        break;
      }
      case Type::dVal:
      {
        set_dVal(std::move(rhs.value_.dVal));
        break;
      }
      case Type::tVal:
      {
        set_tVal(std::move(rhs.value_.tVal));
        break;
      }
      case Type::dtVal:
      {
        set_dtVal(std::move(rhs.value_.dtVal));
        break;
      }
      case Type::vVal:
      {
        set_vVal(std::move(*rhs.value_.vVal));
        break;
      }
      case Type::eVal:
      {
        set_eVal(std::move(*rhs.value_.eVal));
        break;
      }
      case Type::pVal:
      {
        set_pVal(std::move(*rhs.value_.pVal));
        break;
      }
      case Type::lVal:
      {
        set_lVal(std::move(*rhs.value_.lVal));
        break;
      }
      case Type::mVal:
      {
        set_mVal(std::move(*rhs.value_.mVal));
        break;
      }
      case Type::uVal:
      {
        set_uVal(std::move(*rhs.value_.uVal));
        break;
      }
      case Type::gVal:
      {
        set_gVal(std::move(*rhs.value_.gVal));
        break;
      }
      case Type::ggVal:
      {
        set_ggVal(std::move(*rhs.value_.ggVal));
        break;
      }
      case Type::duVal:
      {
        set_duVal(std::move(*rhs.value_.duVal));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  Value(const Value& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::nVal:
      {
        set_nVal(rhs.value_.nVal);
        break;
      }
      case Type::bVal:
      {
        set_bVal(rhs.value_.bVal);
        break;
      }
      case Type::iVal:
      {
        set_iVal(rhs.value_.iVal);
        break;
      }
      case Type::fVal:
      {
        set_fVal(rhs.value_.fVal);
        break;
      }
      case Type::sVal:
      {
        set_sVal(rhs.value_.sVal);
        break;
      }
      case Type::dVal:
      {
        set_dVal(rhs.value_.dVal);
        break;
      }
      case Type::tVal:
      {
        set_tVal(rhs.value_.tVal);
        break;
      }
      case Type::dtVal:
      {
        set_dtVal(rhs.value_.dtVal);
        break;
      }
      case Type::vVal:
      {
        set_vVal(*rhs.value_.vVal);
        break;
      }
      case Type::eVal:
      {
        set_eVal(*rhs.value_.eVal);
        break;
      }
      case Type::pVal:
      {
        set_pVal(*rhs.value_.pVal);
        break;
      }
      case Type::lVal:
      {
        set_lVal(*rhs.value_.lVal);
        break;
      }
      case Type::mVal:
      {
        set_mVal(*rhs.value_.mVal);
        break;
      }
      case Type::uVal:
      {
        set_uVal(*rhs.value_.uVal);
        break;
      }
      case Type::gVal:
      {
        set_gVal(*rhs.value_.gVal);
        break;
      }
      case Type::ggVal:
      {
        set_ggVal(*rhs.value_.ggVal);
        break;
      }
      case Type::duVal:
      {
        set_duVal(*rhs.value_.duVal);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  Value& operator=(Value&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::nVal:
      {
        set_nVal(std::move(rhs.value_.nVal));
        break;
      }
      case Type::bVal:
      {
        set_bVal(std::move(rhs.value_.bVal));
        break;
      }
      case Type::iVal:
      {
        set_iVal(std::move(rhs.value_.iVal));
        break;
      }
      case Type::fVal:
      {
        set_fVal(std::move(rhs.value_.fVal));
        break;
      }
      case Type::sVal:
      {
        set_sVal(std::move(rhs.value_.sVal));
        break;
      }
      case Type::dVal:
      {
        set_dVal(std::move(rhs.value_.dVal));
        break;
      }
      case Type::tVal:
      {
        set_tVal(std::move(rhs.value_.tVal));
        break;
      }
      case Type::dtVal:
      {
        set_dtVal(std::move(rhs.value_.dtVal));
        break;
      }
      case Type::vVal:
      {
        set_vVal(std::move(*rhs.value_.vVal));
        break;
      }
      case Type::eVal:
      {
        set_eVal(std::move(*rhs.value_.eVal));
        break;
      }
      case Type::pVal:
      {
        set_pVal(std::move(*rhs.value_.pVal));
        break;
      }
      case Type::lVal:
      {
        set_lVal(std::move(*rhs.value_.lVal));
        break;
      }
      case Type::mVal:
      {
        set_mVal(std::move(*rhs.value_.mVal));
        break;
      }
      case Type::uVal:
      {
        set_uVal(std::move(*rhs.value_.uVal));
        break;
      }
      case Type::gVal:
      {
        set_gVal(std::move(*rhs.value_.gVal));
        break;
      }
      case Type::ggVal:
      {
        set_ggVal(std::move(*rhs.value_.ggVal));
        break;
      }
      case Type::duVal:
      {
        set_duVal(std::move(*rhs.value_.duVal));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  Value& operator=(const Value& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::nVal:
      {
        set_nVal(rhs.value_.nVal);
        break;
      }
      case Type::bVal:
      {
        set_bVal(rhs.value_.bVal);
        break;
      }
      case Type::iVal:
      {
        set_iVal(rhs.value_.iVal);
        break;
      }
      case Type::fVal:
      {
        set_fVal(rhs.value_.fVal);
        break;
      }
      case Type::sVal:
      {
        set_sVal(rhs.value_.sVal);
        break;
      }
      case Type::dVal:
      {
        set_dVal(rhs.value_.dVal);
        break;
      }
      case Type::tVal:
      {
        set_tVal(rhs.value_.tVal);
        break;
      }
      case Type::dtVal:
      {
        set_dtVal(rhs.value_.dtVal);
        break;
      }
      case Type::vVal:
      {
        set_vVal(*rhs.value_.vVal);
        break;
      }
      case Type::eVal:
      {
        set_eVal(*rhs.value_.eVal);
        break;
      }
      case Type::pVal:
      {
        set_pVal(*rhs.value_.pVal);
        break;
      }
      case Type::lVal:
      {
        set_lVal(*rhs.value_.lVal);
        break;
      }
      case Type::mVal:
      {
        set_mVal(*rhs.value_.mVal);
        break;
      }
      case Type::uVal:
      {
        set_uVal(*rhs.value_.uVal);
        break;
      }
      case Type::gVal:
      {
        set_gVal(*rhs.value_.gVal);
        break;
      }
      case Type::ggVal:
      {
        set_ggVal(*rhs.value_.ggVal);
        break;
      }
      case Type::duVal:
      {
        set_duVal(*rhs.value_.duVal);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~Value() {
    __clear();
  }
  union storage_type {
    nebula::NullType nVal;
    bool bVal;
    int64_t iVal;
    double fVal;
    ::std::string sVal;
    nebula::Date dVal;
    nebula::Time tVal;
    nebula::DateTime dtVal;
    std::unique_ptr<nebula::Vertex> vVal;
    std::unique_ptr<nebula::Edge> eVal;
    std::unique_ptr<nebula::Path> pVal;
    std::unique_ptr<nebula::List> lVal;
    std::unique_ptr<nebula::Map> mVal;
    std::unique_ptr<nebula::Set> uVal;
    std::unique_ptr<nebula::DataSet> gVal;
    std::unique_ptr<nebula::Geography> ggVal;
    std::unique_ptr<nebula::Duration> duVal;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const Value& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Value& __x, const Value& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Value& rhs) const;
#ifndef SWIG
  friend bool operator>(const Value& __x, const Value& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Value& __x, const Value& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Value& __x, const Value& __y) {
    return !(__x < __y);
  }
#endif

  nebula::NullType& set_nVal(nebula::NullType t = nebula::NullType()) {
    __clear();
    type_ = Type::nVal;
    ::new (std::addressof(value_.nVal)) nebula::NullType(t);
    return value_.nVal;
  }

  bool& set_bVal(bool t = bool()) {
    __clear();
    type_ = Type::bVal;
    ::new (std::addressof(value_.bVal)) bool(t);
    return value_.bVal;
  }

  int64_t& set_iVal(int64_t t = int64_t()) {
    __clear();
    type_ = Type::iVal;
    ::new (std::addressof(value_.iVal)) int64_t(t);
    return value_.iVal;
  }

  double& set_fVal(double t = double()) {
    __clear();
    type_ = Type::fVal;
    ::new (std::addressof(value_.fVal)) double(t);
    return value_.fVal;
  }

  ::std::string& set_sVal(::std::string const &t) {
    __clear();
    type_ = Type::sVal;
    ::new (std::addressof(value_.sVal)) ::std::string(t);
    return value_.sVal;
  }

  ::std::string& set_sVal(::std::string&& t) {
    __clear();
    type_ = Type::sVal;
    ::new (std::addressof(value_.sVal)) ::std::string(std::move(t));
    return value_.sVal;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_sVal(T&&... t) {
    __clear();
    type_ = Type::sVal;
    ::new (std::addressof(value_.sVal)) ::std::string(std::forward<T>(t)...);
    return value_.sVal;
  }

  nebula::Date& set_dVal(nebula::Date const &t) {
    __clear();
    type_ = Type::dVal;
    ::new (std::addressof(value_.dVal)) nebula::Date(t);
    return value_.dVal;
  }

  nebula::Date& set_dVal(nebula::Date&& t) {
    __clear();
    type_ = Type::dVal;
    ::new (std::addressof(value_.dVal)) nebula::Date(std::move(t));
    return value_.dVal;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<nebula::Date, T...>> nebula::Date& set_dVal(T&&... t) {
    __clear();
    type_ = Type::dVal;
    ::new (std::addressof(value_.dVal)) nebula::Date(std::forward<T>(t)...);
    return value_.dVal;
  }

  nebula::Time& set_tVal(nebula::Time const &t) {
    __clear();
    type_ = Type::tVal;
    ::new (std::addressof(value_.tVal)) nebula::Time(t);
    return value_.tVal;
  }

  nebula::Time& set_tVal(nebula::Time&& t) {
    __clear();
    type_ = Type::tVal;
    ::new (std::addressof(value_.tVal)) nebula::Time(std::move(t));
    return value_.tVal;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<nebula::Time, T...>> nebula::Time& set_tVal(T&&... t) {
    __clear();
    type_ = Type::tVal;
    ::new (std::addressof(value_.tVal)) nebula::Time(std::forward<T>(t)...);
    return value_.tVal;
  }

  nebula::DateTime& set_dtVal(nebula::DateTime const &t) {
    __clear();
    type_ = Type::dtVal;
    ::new (std::addressof(value_.dtVal)) nebula::DateTime(t);
    return value_.dtVal;
  }

  nebula::DateTime& set_dtVal(nebula::DateTime&& t) {
    __clear();
    type_ = Type::dtVal;
    ::new (std::addressof(value_.dtVal)) nebula::DateTime(std::move(t));
    return value_.dtVal;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<nebula::DateTime, T...>> nebula::DateTime& set_dtVal(T&&... t) {
    __clear();
    type_ = Type::dtVal;
    ::new (std::addressof(value_.dtVal)) nebula::DateTime(std::forward<T>(t)...);
    return value_.dtVal;
  }
  std::unique_ptr<nebula::Vertex>& set_vVal(nebula::Vertex const &t);
  std::unique_ptr<nebula::Vertex>& set_vVal(nebula::Vertex&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t<nebula::Vertex, T...>> std::unique_ptr<nebula::Vertex>& set_vVal(T&&... t) {
    // defer resolution of ref_ in case ref_::element_type would here be incomplete
    using ref_ = folly::conditional_t<(sizeof...(T) < size_t(-1)), std::unique_ptr<nebula::Vertex>, void>;
    __clear();
    type_ = Type::vVal;
    ::new (std::addressof(value_.vVal)) ref_(new typename ref_::element_type(std::forward<T>(t)...));
    return value_.vVal;
  }
  std::unique_ptr<nebula::Edge>& set_eVal(nebula::Edge const &t);
  std::unique_ptr<nebula::Edge>& set_eVal(nebula::Edge&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t<nebula::Edge, T...>> std::unique_ptr<nebula::Edge>& set_eVal(T&&... t) {
    // defer resolution of ref_ in case ref_::element_type would here be incomplete
    using ref_ = folly::conditional_t<(sizeof...(T) < size_t(-1)), std::unique_ptr<nebula::Edge>, void>;
    __clear();
    type_ = Type::eVal;
    ::new (std::addressof(value_.eVal)) ref_(new typename ref_::element_type(std::forward<T>(t)...));
    return value_.eVal;
  }
  std::unique_ptr<nebula::Path>& set_pVal(nebula::Path const &t);
  std::unique_ptr<nebula::Path>& set_pVal(nebula::Path&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t<nebula::Path, T...>> std::unique_ptr<nebula::Path>& set_pVal(T&&... t) {
    // defer resolution of ref_ in case ref_::element_type would here be incomplete
    using ref_ = folly::conditional_t<(sizeof...(T) < size_t(-1)), std::unique_ptr<nebula::Path>, void>;
    __clear();
    type_ = Type::pVal;
    ::new (std::addressof(value_.pVal)) ref_(new typename ref_::element_type(std::forward<T>(t)...));
    return value_.pVal;
  }
  std::unique_ptr<nebula::List>& set_lVal(nebula::List const &t);
  std::unique_ptr<nebula::List>& set_lVal(nebula::List&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t<nebula::List, T...>> std::unique_ptr<nebula::List>& set_lVal(T&&... t) {
    // defer resolution of ref_ in case ref_::element_type would here be incomplete
    using ref_ = folly::conditional_t<(sizeof...(T) < size_t(-1)), std::unique_ptr<nebula::List>, void>;
    __clear();
    type_ = Type::lVal;
    ::new (std::addressof(value_.lVal)) ref_(new typename ref_::element_type(std::forward<T>(t)...));
    return value_.lVal;
  }
  std::unique_ptr<nebula::Map>& set_mVal(nebula::Map const &t);
  std::unique_ptr<nebula::Map>& set_mVal(nebula::Map&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t<nebula::Map, T...>> std::unique_ptr<nebula::Map>& set_mVal(T&&... t) {
    // defer resolution of ref_ in case ref_::element_type would here be incomplete
    using ref_ = folly::conditional_t<(sizeof...(T) < size_t(-1)), std::unique_ptr<nebula::Map>, void>;
    __clear();
    type_ = Type::mVal;
    ::new (std::addressof(value_.mVal)) ref_(new typename ref_::element_type(std::forward<T>(t)...));
    return value_.mVal;
  }
  std::unique_ptr<nebula::Set>& set_uVal(nebula::Set const &t);
  std::unique_ptr<nebula::Set>& set_uVal(nebula::Set&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t<nebula::Set, T...>> std::unique_ptr<nebula::Set>& set_uVal(T&&... t) {
    // defer resolution of ref_ in case ref_::element_type would here be incomplete
    using ref_ = folly::conditional_t<(sizeof...(T) < size_t(-1)), std::unique_ptr<nebula::Set>, void>;
    __clear();
    type_ = Type::uVal;
    ::new (std::addressof(value_.uVal)) ref_(new typename ref_::element_type(std::forward<T>(t)...));
    return value_.uVal;
  }
  std::unique_ptr<nebula::DataSet>& set_gVal(nebula::DataSet const &t);
  std::unique_ptr<nebula::DataSet>& set_gVal(nebula::DataSet&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t<nebula::DataSet, T...>> std::unique_ptr<nebula::DataSet>& set_gVal(T&&... t) {
    // defer resolution of ref_ in case ref_::element_type would here be incomplete
    using ref_ = folly::conditional_t<(sizeof...(T) < size_t(-1)), std::unique_ptr<nebula::DataSet>, void>;
    __clear();
    type_ = Type::gVal;
    ::new (std::addressof(value_.gVal)) ref_(new typename ref_::element_type(std::forward<T>(t)...));
    return value_.gVal;
  }
  std::unique_ptr<nebula::Geography>& set_ggVal(nebula::Geography const &t);
  std::unique_ptr<nebula::Geography>& set_ggVal(nebula::Geography&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t<nebula::Geography, T...>> std::unique_ptr<nebula::Geography>& set_ggVal(T&&... t) {
    // defer resolution of ref_ in case ref_::element_type would here be incomplete
    using ref_ = folly::conditional_t<(sizeof...(T) < size_t(-1)), std::unique_ptr<nebula::Geography>, void>;
    __clear();
    type_ = Type::ggVal;
    ::new (std::addressof(value_.ggVal)) ref_(new typename ref_::element_type(std::forward<T>(t)...));
    return value_.ggVal;
  }
  std::unique_ptr<nebula::Duration>& set_duVal(nebula::Duration const &t);
  std::unique_ptr<nebula::Duration>& set_duVal(nebula::Duration&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t<nebula::Duration, T...>> std::unique_ptr<nebula::Duration>& set_duVal(T&&... t) {
    // defer resolution of ref_ in case ref_::element_type would here be incomplete
    using ref_ = folly::conditional_t<(sizeof...(T) < size_t(-1)), std::unique_ptr<nebula::Duration>, void>;
    __clear();
    type_ = Type::duVal;
    ::new (std::addressof(value_.duVal)) ref_(new typename ref_::element_type(std::forward<T>(t)...));
    return value_.duVal;
  }

  nebula::NullType const & get_nVal() const {
    assert(type_ == Type::nVal);
    return value_.nVal;
  }

  bool const & get_bVal() const {
    assert(type_ == Type::bVal);
    return value_.bVal;
  }

  int64_t const & get_iVal() const {
    assert(type_ == Type::iVal);
    return value_.iVal;
  }

  double const & get_fVal() const {
    assert(type_ == Type::fVal);
    return value_.fVal;
  }

  ::std::string const & get_sVal() const {
    assert(type_ == Type::sVal);
    return value_.sVal;
  }

  nebula::Date const & get_dVal() const {
    assert(type_ == Type::dVal);
    return value_.dVal;
  }

  nebula::Time const & get_tVal() const {
    assert(type_ == Type::tVal);
    return value_.tVal;
  }

  nebula::DateTime const & get_dtVal() const {
    assert(type_ == Type::dtVal);
    return value_.dtVal;
  }

  std::unique_ptr<nebula::Vertex> const & get_vVal() const {
    assert(type_ == Type::vVal);
    return value_.vVal;
  }

  std::unique_ptr<nebula::Edge> const & get_eVal() const {
    assert(type_ == Type::eVal);
    return value_.eVal;
  }

  std::unique_ptr<nebula::Path> const & get_pVal() const {
    assert(type_ == Type::pVal);
    return value_.pVal;
  }

  std::unique_ptr<nebula::List> const & get_lVal() const {
    assert(type_ == Type::lVal);
    return value_.lVal;
  }

  std::unique_ptr<nebula::Map> const & get_mVal() const {
    assert(type_ == Type::mVal);
    return value_.mVal;
  }

  std::unique_ptr<nebula::Set> const & get_uVal() const {
    assert(type_ == Type::uVal);
    return value_.uVal;
  }

  std::unique_ptr<nebula::DataSet> const & get_gVal() const {
    assert(type_ == Type::gVal);
    return value_.gVal;
  }

  std::unique_ptr<nebula::Geography> const & get_ggVal() const {
    assert(type_ == Type::ggVal);
    return value_.ggVal;
  }

  std::unique_ptr<nebula::Duration> const & get_duVal() const {
    assert(type_ == Type::duVal);
    return value_.duVal;
  }

  nebula::NullType & mutable_nVal() {
    assert(type_ == Type::nVal);
    return value_.nVal;
  }

  bool & mutable_bVal() {
    assert(type_ == Type::bVal);
    return value_.bVal;
  }

  int64_t & mutable_iVal() {
    assert(type_ == Type::iVal);
    return value_.iVal;
  }

  double & mutable_fVal() {
    assert(type_ == Type::fVal);
    return value_.fVal;
  }

  ::std::string & mutable_sVal() {
    assert(type_ == Type::sVal);
    return value_.sVal;
  }

  nebula::Date & mutable_dVal() {
    assert(type_ == Type::dVal);
    return value_.dVal;
  }

  nebula::Time & mutable_tVal() {
    assert(type_ == Type::tVal);
    return value_.tVal;
  }

  nebula::DateTime & mutable_dtVal() {
    assert(type_ == Type::dtVal);
    return value_.dtVal;
  }

  std::unique_ptr<nebula::Vertex> & mutable_vVal() {
    assert(type_ == Type::vVal);
    return value_.vVal;
  }

  std::unique_ptr<nebula::Edge> & mutable_eVal() {
    assert(type_ == Type::eVal);
    return value_.eVal;
  }

  std::unique_ptr<nebula::Path> & mutable_pVal() {
    assert(type_ == Type::pVal);
    return value_.pVal;
  }

  std::unique_ptr<nebula::List> & mutable_lVal() {
    assert(type_ == Type::lVal);
    return value_.lVal;
  }

  std::unique_ptr<nebula::Map> & mutable_mVal() {
    assert(type_ == Type::mVal);
    return value_.mVal;
  }

  std::unique_ptr<nebula::Set> & mutable_uVal() {
    assert(type_ == Type::uVal);
    return value_.uVal;
  }

  std::unique_ptr<nebula::DataSet> & mutable_gVal() {
    assert(type_ == Type::gVal);
    return value_.gVal;
  }

  std::unique_ptr<nebula::Geography> & mutable_ggVal() {
    assert(type_ == Type::ggVal);
    return value_.ggVal;
  }

  std::unique_ptr<nebula::Duration> & mutable_duVal() {
    assert(type_ == Type::duVal);
    return value_.duVal;
  }

  nebula::NullType move_nVal() {
    assert(type_ == Type::nVal);
    return std::move(value_.nVal);
  }

  bool move_bVal() {
    assert(type_ == Type::bVal);
    return std::move(value_.bVal);
  }

  int64_t move_iVal() {
    assert(type_ == Type::iVal);
    return std::move(value_.iVal);
  }

  double move_fVal() {
    assert(type_ == Type::fVal);
    return std::move(value_.fVal);
  }

  ::std::string move_sVal() {
    assert(type_ == Type::sVal);
    return std::move(value_.sVal);
  }

  nebula::Date move_dVal() {
    assert(type_ == Type::dVal);
    return std::move(value_.dVal);
  }

  nebula::Time move_tVal() {
    assert(type_ == Type::tVal);
    return std::move(value_.tVal);
  }

  nebula::DateTime move_dtVal() {
    assert(type_ == Type::dtVal);
    return std::move(value_.dtVal);
  }

  std::unique_ptr<nebula::Vertex> move_vVal() {
    assert(type_ == Type::vVal);
    return std::move(value_.vVal);
  }

  std::unique_ptr<nebula::Edge> move_eVal() {
    assert(type_ == Type::eVal);
    return std::move(value_.eVal);
  }

  std::unique_ptr<nebula::Path> move_pVal() {
    assert(type_ == Type::pVal);
    return std::move(value_.pVal);
  }

  std::unique_ptr<nebula::List> move_lVal() {
    assert(type_ == Type::lVal);
    return std::move(value_.lVal);
  }

  std::unique_ptr<nebula::Map> move_mVal() {
    assert(type_ == Type::mVal);
    return std::move(value_.mVal);
  }

  std::unique_ptr<nebula::Set> move_uVal() {
    assert(type_ == Type::uVal);
    return std::move(value_.uVal);
  }

  std::unique_ptr<nebula::DataSet> move_gVal() {
    assert(type_ == Type::gVal);
    return std::move(value_.gVal);
  }

  std::unique_ptr<nebula::Geography> move_ggVal() {
    assert(type_ == Type::ggVal);
    return std::move(value_.ggVal);
  }

  std::unique_ptr<nebula::Duration> move_duVal() {
    assert(type_ == Type::duVal);
    return std::move(value_.duVal);
  }

  template <typename..., typename T = nebula::NullType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> nVal_ref() const& {
    return {value_.nVal, type_, nVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::NullType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> nVal_ref() const&& {
    return {std::move(value_.nVal), type_, nVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::NullType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> nVal_ref() & {
    return {value_.nVal, type_, nVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::NullType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> nVal_ref() && {
    return {std::move(value_.nVal), type_, nVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> bVal_ref() const& {
    return {value_.bVal, type_, bVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> bVal_ref() const&& {
    return {std::move(value_.bVal), type_, bVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> bVal_ref() & {
    return {value_.bVal, type_, bVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> bVal_ref() && {
    return {std::move(value_.bVal), type_, bVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> iVal_ref() const& {
    return {value_.iVal, type_, iVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> iVal_ref() const&& {
    return {std::move(value_.iVal), type_, iVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> iVal_ref() & {
    return {value_.iVal, type_, iVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> iVal_ref() && {
    return {std::move(value_.iVal), type_, iVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> fVal_ref() const& {
    return {value_.fVal, type_, fVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> fVal_ref() const&& {
    return {std::move(value_.fVal), type_, fVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> fVal_ref() & {
    return {value_.fVal, type_, fVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> fVal_ref() && {
    return {std::move(value_.fVal), type_, fVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> sVal_ref() const& {
    return {value_.sVal, type_, sVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> sVal_ref() const&& {
    return {std::move(value_.sVal), type_, sVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> sVal_ref() & {
    return {value_.sVal, type_, sVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> sVal_ref() && {
    return {std::move(value_.sVal), type_, sVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = nebula::Date>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> dVal_ref() const& {
    return {value_.dVal, type_, dVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Date>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> dVal_ref() const&& {
    return {std::move(value_.dVal), type_, dVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Date>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> dVal_ref() & {
    return {value_.dVal, type_, dVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Date>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> dVal_ref() && {
    return {std::move(value_.dVal), type_, dVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = nebula::Time>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> tVal_ref() const& {
    return {value_.tVal, type_, tVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Time>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> tVal_ref() const&& {
    return {std::move(value_.tVal), type_, tVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Time>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> tVal_ref() & {
    return {value_.tVal, type_, tVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Time>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> tVal_ref() && {
    return {std::move(value_.tVal), type_, tVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = nebula::DateTime>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> dtVal_ref() const& {
    return {value_.dtVal, type_, dtVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::DateTime>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> dtVal_ref() const&& {
    return {std::move(value_.dtVal), type_, dtVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::DateTime>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> dtVal_ref() & {
    return {value_.dtVal, type_, dtVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::DateTime>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> dtVal_ref() && {
    return {std::move(value_.dtVal), type_, dtVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = nebula::Vertex>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> vVal_ref() const& {
    return {value_.vVal, type_, vVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Vertex>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> vVal_ref() const&& {
    return {std::move(value_.vVal), type_, vVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Vertex>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> vVal_ref() & {
    return {value_.vVal, type_, vVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Vertex>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> vVal_ref() && {
    return {std::move(value_.vVal), type_, vVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = nebula::Edge>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> eVal_ref() const& {
    return {value_.eVal, type_, eVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Edge>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> eVal_ref() const&& {
    return {std::move(value_.eVal), type_, eVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Edge>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> eVal_ref() & {
    return {value_.eVal, type_, eVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Edge>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> eVal_ref() && {
    return {std::move(value_.eVal), type_, eVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = nebula::Path>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> pVal_ref() const& {
    return {value_.pVal, type_, pVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Path>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> pVal_ref() const&& {
    return {std::move(value_.pVal), type_, pVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Path>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> pVal_ref() & {
    return {value_.pVal, type_, pVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Path>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> pVal_ref() && {
    return {std::move(value_.pVal), type_, pVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = nebula::List>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> lVal_ref() const& {
    return {value_.lVal, type_, lVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::List>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> lVal_ref() const&& {
    return {std::move(value_.lVal), type_, lVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::List>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> lVal_ref() & {
    return {value_.lVal, type_, lVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::List>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> lVal_ref() && {
    return {std::move(value_.lVal), type_, lVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = nebula::Map>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> mVal_ref() const& {
    return {value_.mVal, type_, mVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Map>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> mVal_ref() const&& {
    return {std::move(value_.mVal), type_, mVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Map>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> mVal_ref() & {
    return {value_.mVal, type_, mVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Map>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> mVal_ref() && {
    return {std::move(value_.mVal), type_, mVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = nebula::Set>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> uVal_ref() const& {
    return {value_.uVal, type_, uVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Set>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> uVal_ref() const&& {
    return {std::move(value_.uVal), type_, uVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Set>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> uVal_ref() & {
    return {value_.uVal, type_, uVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Set>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> uVal_ref() && {
    return {std::move(value_.uVal), type_, uVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> gVal_ref() const& {
    return {value_.gVal, type_, gVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> gVal_ref() const&& {
    return {std::move(value_.gVal), type_, gVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> gVal_ref() & {
    return {value_.gVal, type_, gVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> gVal_ref() && {
    return {std::move(value_.gVal), type_, gVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = nebula::Geography>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> ggVal_ref() const& {
    return {value_.ggVal, type_, ggVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Geography>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> ggVal_ref() const&& {
    return {std::move(value_.ggVal), type_, ggVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Geography>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> ggVal_ref() & {
    return {value_.ggVal, type_, ggVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Geography>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> ggVal_ref() && {
    return {std::move(value_.ggVal), type_, ggVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = nebula::Duration>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> duVal_ref() const& {
    return {value_.duVal, type_, duVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Duration>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> duVal_ref() const&& {
    return {std::move(value_.duVal), type_, duVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Duration>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> duVal_ref() & {
    return {value_.duVal, type_, duVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Duration>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> duVal_ref() && {
    return {std::move(value_.duVal), type_, duVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Value >;
  friend void swap(Value& a, Value& b);
};

template <class Protocol_>
uint32_t Value::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class NList final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = NList;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  NList() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  NList(apache::thrift::FragileConstructor, ::std::vector<nebula::Value> values__arg);

  NList(NList&&) = default;

  NList(const NList&) = default;


  NList& operator=(NList&&) = default;

  NList& operator=(const NList&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector<nebula::Value> values;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool values;
  } __isset = {};
  bool operator==(const NList& rhs) const;
#ifndef SWIG
  friend bool operator!=(const NList& __x, const NList& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const NList& rhs) const;
#ifndef SWIG
  friend bool operator>(const NList& __x, const NList& __y) {
    return __y < __x;
  }
  friend bool operator<=(const NList& __x, const NList& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const NList& __x, const NList& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> values_ref() const& {
    return {this->values, __isset.values};
  }

  template <typename..., typename T = ::std::vector<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> values_ref() const&& {
    return {std::move(this->values), __isset.values};
  }

  template <typename..., typename T = ::std::vector<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> values_ref() & {
    return {this->values, __isset.values};
  }

  template <typename..., typename T = ::std::vector<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> values_ref() && {
    return {std::move(this->values), __isset.values};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector<nebula::Value>& get_values() const&;
  ::std::vector<nebula::Value> get_values() &&;

  template <typename T_NList_values_struct_setter = ::std::vector<nebula::Value>>
  ::std::vector<nebula::Value>& set_values(T_NList_values_struct_setter&& values_) {
    values = std::forward<T_NList_values_struct_setter>(values_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.values = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return values;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< NList >;
  friend void swap(NList& a, NList& b);
};

template <class Protocol_>
uint32_t NList::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class NMap final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = NMap;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  NMap() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  NMap(apache::thrift::FragileConstructor, std::unordered_map<::std::string, nebula::Value> kvs__arg);

  NMap(NMap&&) = default;

  NMap(const NMap&) = default;


  NMap& operator=(NMap&&) = default;

  NMap& operator=(const NMap&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  std::unordered_map<::std::string, nebula::Value> kvs;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool kvs;
  } __isset = {};
  bool operator==(const NMap& rhs) const;
#ifndef SWIG
  friend bool operator!=(const NMap& __x, const NMap& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const NMap& rhs) const;
#ifndef SWIG
  friend bool operator>(const NMap& __x, const NMap& __y) {
    return __y < __x;
  }
  friend bool operator<=(const NMap& __x, const NMap& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const NMap& __x, const NMap& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> kvs_ref() const& {
    return {this->kvs, __isset.kvs};
  }

  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> kvs_ref() const&& {
    return {std::move(this->kvs), __isset.kvs};
  }

  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> kvs_ref() & {
    return {this->kvs, __isset.kvs};
  }

  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> kvs_ref() && {
    return {std::move(this->kvs), __isset.kvs};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const std::unordered_map<::std::string, nebula::Value>& get_kvs() const&;
  std::unordered_map<::std::string, nebula::Value> get_kvs() &&;

  template <typename T_NMap_kvs_struct_setter = std::unordered_map<::std::string, nebula::Value>>
  std::unordered_map<::std::string, nebula::Value>& set_kvs(T_NMap_kvs_struct_setter&& kvs_) {
    kvs = std::forward<T_NMap_kvs_struct_setter>(kvs_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.kvs = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return kvs;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< NMap >;
  friend void swap(NMap& a, NMap& b);
};

template <class Protocol_>
uint32_t NMap::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class NSet final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = NSet;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  NSet() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  NSet(apache::thrift::FragileConstructor, std::unordered_set<nebula::Value> values__arg);

  NSet(NSet&&) = default;

  NSet(const NSet&) = default;


  NSet& operator=(NSet&&) = default;

  NSet& operator=(const NSet&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  std::unordered_set<nebula::Value> values;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool values;
  } __isset = {};
  bool operator==(const NSet& rhs) const;
#ifndef SWIG
  friend bool operator!=(const NSet& __x, const NSet& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const NSet& rhs) const;
#ifndef SWIG
  friend bool operator>(const NSet& __x, const NSet& __y) {
    return __y < __x;
  }
  friend bool operator<=(const NSet& __x, const NSet& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const NSet& __x, const NSet& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_set<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> values_ref() const& {
    return {this->values, __isset.values};
  }

  template <typename..., typename T = std::unordered_set<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> values_ref() const&& {
    return {std::move(this->values), __isset.values};
  }

  template <typename..., typename T = std::unordered_set<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> values_ref() & {
    return {this->values, __isset.values};
  }

  template <typename..., typename T = std::unordered_set<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> values_ref() && {
    return {std::move(this->values), __isset.values};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const std::unordered_set<nebula::Value>& get_values() const&;
  std::unordered_set<nebula::Value> get_values() &&;

  template <typename T_NSet_values_struct_setter = std::unordered_set<nebula::Value>>
  std::unordered_set<nebula::Value>& set_values(T_NSet_values_struct_setter&& values_) {
    values = std::forward<T_NSet_values_struct_setter>(values_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.values = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return values;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< NSet >;
  friend void swap(NSet& a, NSet& b);
};

template <class Protocol_>
uint32_t NSet::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class Row final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Row;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  Row() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Row(apache::thrift::FragileConstructor, ::std::vector<nebula::Value> values__arg);

  Row(Row&&) = default;

  Row(const Row&) = default;


  Row& operator=(Row&&) = default;

  Row& operator=(const Row&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector<nebula::Value> values;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool values;
  } __isset = {};
  bool operator==(const Row& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Row& __x, const Row& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Row& rhs) const;
#ifndef SWIG
  friend bool operator>(const Row& __x, const Row& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Row& __x, const Row& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Row& __x, const Row& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> values_ref() const& {
    return {this->values, __isset.values};
  }

  template <typename..., typename T = ::std::vector<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> values_ref() const&& {
    return {std::move(this->values), __isset.values};
  }

  template <typename..., typename T = ::std::vector<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> values_ref() & {
    return {this->values, __isset.values};
  }

  template <typename..., typename T = ::std::vector<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> values_ref() && {
    return {std::move(this->values), __isset.values};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector<nebula::Value>& get_values() const&;
  ::std::vector<nebula::Value> get_values() &&;

  template <typename T_Row_values_struct_setter = ::std::vector<nebula::Value>>
  ::std::vector<nebula::Value>& set_values(T_Row_values_struct_setter&& values_) {
    values = std::forward<T_Row_values_struct_setter>(values_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.values = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return values;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Row >;
  friend void swap(Row& a, Row& b);
};

template <class Protocol_>
uint32_t Row::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class DataSet final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = DataSet;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  DataSet() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  DataSet(apache::thrift::FragileConstructor, ::std::vector<::std::string> column_names__arg, ::std::vector<nebula::Row> rows__arg);

  DataSet(DataSet&&) = default;

  DataSet(const DataSet&) = default;


  DataSet& operator=(DataSet&&) = default;

  DataSet& operator=(const DataSet&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector<::std::string> column_names;
 private:
  ::std::vector<nebula::Row> rows;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool column_names;
    bool rows;
  } __isset = {};
  bool operator==(const DataSet& rhs) const;
#ifndef SWIG
  friend bool operator!=(const DataSet& __x, const DataSet& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const DataSet& rhs) const;
#ifndef SWIG
  friend bool operator>(const DataSet& __x, const DataSet& __y) {
    return __y < __x;
  }
  friend bool operator<=(const DataSet& __x, const DataSet& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const DataSet& __x, const DataSet& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> column_names_ref() const& {
    return {this->column_names, __isset.column_names};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> column_names_ref() const&& {
    return {std::move(this->column_names), __isset.column_names};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> column_names_ref() & {
    return {this->column_names, __isset.column_names};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> column_names_ref() && {
    return {std::move(this->column_names), __isset.column_names};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::Row>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> rows_ref() const& {
    return {this->rows, __isset.rows};
  }

  template <typename..., typename T = ::std::vector<nebula::Row>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> rows_ref() const&& {
    return {std::move(this->rows), __isset.rows};
  }

  template <typename..., typename T = ::std::vector<nebula::Row>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> rows_ref() & {
    return {this->rows, __isset.rows};
  }

  template <typename..., typename T = ::std::vector<nebula::Row>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> rows_ref() && {
    return {std::move(this->rows), __isset.rows};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector<::std::string>& get_column_names() const&;
  ::std::vector<::std::string> get_column_names() &&;

  template <typename T_DataSet_column_names_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_column_names(T_DataSet_column_names_struct_setter&& column_names_) {
    column_names = std::forward<T_DataSet_column_names_struct_setter>(column_names_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.column_names = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return column_names;
  }
  const ::std::vector<nebula::Row>& get_rows() const&;
  ::std::vector<nebula::Row> get_rows() &&;

  template <typename T_DataSet_rows_struct_setter = ::std::vector<nebula::Row>>
  ::std::vector<nebula::Row>& set_rows(T_DataSet_rows_struct_setter&& rows_) {
    rows = std::forward<T_DataSet_rows_struct_setter>(rows_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.rows = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return rows;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< DataSet >;
  friend void swap(DataSet& a, DataSet& b);
};

template <class Protocol_>
uint32_t DataSet::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class Coordinate final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Coordinate;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  Coordinate() :
      x(0),
      y(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Coordinate(apache::thrift::FragileConstructor, double x__arg, double y__arg);

  Coordinate(Coordinate&&) = default;

  Coordinate(const Coordinate&) = default;


  Coordinate& operator=(Coordinate&&) = default;

  Coordinate& operator=(const Coordinate&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  double x;
 private:
  double y;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool x;
    bool y;
  } __isset = {};
  bool operator==(const Coordinate& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Coordinate& __x, const Coordinate& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Coordinate& rhs) const;
#ifndef SWIG
  friend bool operator>(const Coordinate& __x, const Coordinate& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Coordinate& __x, const Coordinate& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Coordinate& __x, const Coordinate& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> x_ref() const& {
    return {this->x, __isset.x};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> x_ref() const&& {
    return {std::move(this->x), __isset.x};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> x_ref() & {
    return {this->x, __isset.x};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> x_ref() && {
    return {std::move(this->x), __isset.x};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> y_ref() const& {
    return {this->y, __isset.y};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> y_ref() const&& {
    return {std::move(this->y), __isset.y};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> y_ref() & {
    return {this->y, __isset.y};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> y_ref() && {
    return {std::move(this->y), __isset.y};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  double get_x() const {
    return x;
  }

  double& set_x(double x_) {
    x = x_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.x = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return x;
  }

  double get_y() const {
    return y;
  }

  double& set_y(double y_) {
    y = y_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.y = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return y;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Coordinate >;
  friend void swap(Coordinate& a, Coordinate& b);
};

template <class Protocol_>
uint32_t Coordinate::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class Point final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Point;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  Point() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Point(apache::thrift::FragileConstructor, nebula::Coordinate coord__arg);

  Point(Point&&) = default;

  Point(const Point&) = default;


  Point& operator=(Point&&) = default;

  Point& operator=(const Point&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  nebula::Coordinate coord;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool coord;
  } __isset = {};
  bool operator==(const Point& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Point& __x, const Point& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Point& rhs) const;
#ifndef SWIG
  friend bool operator>(const Point& __x, const Point& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Point& __x, const Point& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Point& __x, const Point& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::Coordinate>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> coord_ref() const& {
    return {this->coord, __isset.coord};
  }

  template <typename..., typename T = nebula::Coordinate>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> coord_ref() const&& {
    return {std::move(this->coord), __isset.coord};
  }

  template <typename..., typename T = nebula::Coordinate>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> coord_ref() & {
    return {this->coord, __isset.coord};
  }

  template <typename..., typename T = nebula::Coordinate>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> coord_ref() && {
    return {std::move(this->coord), __isset.coord};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const nebula::Coordinate& get_coord() const&;
  nebula::Coordinate get_coord() &&;

  template <typename T_Point_coord_struct_setter = nebula::Coordinate>
  nebula::Coordinate& set_coord(T_Point_coord_struct_setter&& coord_) {
    coord = std::forward<T_Point_coord_struct_setter>(coord_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.coord = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return coord;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Point >;
  friend void swap(Point& a, Point& b);
};

template <class Protocol_>
uint32_t Point::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class LineString final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = LineString;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  LineString() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  LineString(apache::thrift::FragileConstructor, ::std::vector<nebula::Coordinate> coordList__arg);

  LineString(LineString&&) = default;

  LineString(const LineString&) = default;


  LineString& operator=(LineString&&) = default;

  LineString& operator=(const LineString&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector<nebula::Coordinate> coordList;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool coordList;
  } __isset = {};
  bool operator==(const LineString& rhs) const;
#ifndef SWIG
  friend bool operator!=(const LineString& __x, const LineString& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const LineString& rhs) const;
#ifndef SWIG
  friend bool operator>(const LineString& __x, const LineString& __y) {
    return __y < __x;
  }
  friend bool operator<=(const LineString& __x, const LineString& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const LineString& __x, const LineString& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::Coordinate>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> coordList_ref() const& {
    return {this->coordList, __isset.coordList};
  }

  template <typename..., typename T = ::std::vector<nebula::Coordinate>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> coordList_ref() const&& {
    return {std::move(this->coordList), __isset.coordList};
  }

  template <typename..., typename T = ::std::vector<nebula::Coordinate>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> coordList_ref() & {
    return {this->coordList, __isset.coordList};
  }

  template <typename..., typename T = ::std::vector<nebula::Coordinate>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> coordList_ref() && {
    return {std::move(this->coordList), __isset.coordList};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector<nebula::Coordinate>& get_coordList() const&;
  ::std::vector<nebula::Coordinate> get_coordList() &&;

  template <typename T_LineString_coordList_struct_setter = ::std::vector<nebula::Coordinate>>
  ::std::vector<nebula::Coordinate>& set_coordList(T_LineString_coordList_struct_setter&& coordList_) {
    coordList = std::forward<T_LineString_coordList_struct_setter>(coordList_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.coordList = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return coordList;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< LineString >;
  friend void swap(LineString& a, LineString& b);
};

template <class Protocol_>
uint32_t LineString::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class Polygon final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Polygon;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  Polygon() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Polygon(apache::thrift::FragileConstructor, ::std::vector<::std::vector<nebula::Coordinate>> coordListList__arg);

  Polygon(Polygon&&) = default;

  Polygon(const Polygon&) = default;


  Polygon& operator=(Polygon&&) = default;

  Polygon& operator=(const Polygon&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector<::std::vector<nebula::Coordinate>> coordListList;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool coordListList;
  } __isset = {};
  bool operator==(const Polygon& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Polygon& __x, const Polygon& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Polygon& rhs) const;
#ifndef SWIG
  friend bool operator>(const Polygon& __x, const Polygon& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Polygon& __x, const Polygon& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Polygon& __x, const Polygon& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::vector<nebula::Coordinate>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> coordListList_ref() const& {
    return {this->coordListList, __isset.coordListList};
  }

  template <typename..., typename T = ::std::vector<::std::vector<nebula::Coordinate>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> coordListList_ref() const&& {
    return {std::move(this->coordListList), __isset.coordListList};
  }

  template <typename..., typename T = ::std::vector<::std::vector<nebula::Coordinate>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> coordListList_ref() & {
    return {this->coordListList, __isset.coordListList};
  }

  template <typename..., typename T = ::std::vector<::std::vector<nebula::Coordinate>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> coordListList_ref() && {
    return {std::move(this->coordListList), __isset.coordListList};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector<::std::vector<nebula::Coordinate>>& get_coordListList() const&;
  ::std::vector<::std::vector<nebula::Coordinate>> get_coordListList() &&;

  template <typename T_Polygon_coordListList_struct_setter = ::std::vector<::std::vector<nebula::Coordinate>>>
  ::std::vector<::std::vector<nebula::Coordinate>>& set_coordListList(T_Polygon_coordListList_struct_setter&& coordListList_) {
    coordListList = std::forward<T_Polygon_coordListList_struct_setter>(coordListList_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.coordListList = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return coordListList;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Polygon >;
  friend void swap(Polygon& a, Polygon& b);
};

template <class Protocol_>
uint32_t Polygon::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class Geography final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Geography;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    ptVal = 1,
    lsVal = 2,
    pgVal = 3,
  } ;

  Geography()
      : type_(Type::__EMPTY__) {}

  Geography(Geography&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ptVal:
      {
        set_ptVal(std::move(*rhs.value_.ptVal));
        break;
      }
      case Type::lsVal:
      {
        set_lsVal(std::move(*rhs.value_.lsVal));
        break;
      }
      case Type::pgVal:
      {
        set_pgVal(std::move(*rhs.value_.pgVal));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  Geography(const Geography& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ptVal:
      {
        set_ptVal(*rhs.value_.ptVal);
        break;
      }
      case Type::lsVal:
      {
        set_lsVal(*rhs.value_.lsVal);
        break;
      }
      case Type::pgVal:
      {
        set_pgVal(*rhs.value_.pgVal);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  Geography& operator=(Geography&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ptVal:
      {
        set_ptVal(std::move(*rhs.value_.ptVal));
        break;
      }
      case Type::lsVal:
      {
        set_lsVal(std::move(*rhs.value_.lsVal));
        break;
      }
      case Type::pgVal:
      {
        set_pgVal(std::move(*rhs.value_.pgVal));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  Geography& operator=(const Geography& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ptVal:
      {
        set_ptVal(*rhs.value_.ptVal);
        break;
      }
      case Type::lsVal:
      {
        set_lsVal(*rhs.value_.lsVal);
        break;
      }
      case Type::pgVal:
      {
        set_pgVal(*rhs.value_.pgVal);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~Geography() {
    __clear();
  }
  union storage_type {
    std::unique_ptr<nebula::Point> ptVal;
    std::unique_ptr<nebula::LineString> lsVal;
    std::unique_ptr<nebula::Polygon> pgVal;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const Geography& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Geography& __x, const Geography& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Geography& rhs) const;
#ifndef SWIG
  friend bool operator>(const Geography& __x, const Geography& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Geography& __x, const Geography& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Geography& __x, const Geography& __y) {
    return !(__x < __y);
  }
#endif
  std::unique_ptr<nebula::Point>& set_ptVal(nebula::Point const &t);
  std::unique_ptr<nebula::Point>& set_ptVal(nebula::Point&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t<nebula::Point, T...>> std::unique_ptr<nebula::Point>& set_ptVal(T&&... t) {
    // defer resolution of ref_ in case ref_::element_type would here be incomplete
    using ref_ = folly::conditional_t<(sizeof...(T) < size_t(-1)), std::unique_ptr<nebula::Point>, void>;
    __clear();
    type_ = Type::ptVal;
    ::new (std::addressof(value_.ptVal)) ref_(new typename ref_::element_type(std::forward<T>(t)...));
    return value_.ptVal;
  }
  std::unique_ptr<nebula::LineString>& set_lsVal(nebula::LineString const &t);
  std::unique_ptr<nebula::LineString>& set_lsVal(nebula::LineString&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t<nebula::LineString, T...>> std::unique_ptr<nebula::LineString>& set_lsVal(T&&... t) {
    // defer resolution of ref_ in case ref_::element_type would here be incomplete
    using ref_ = folly::conditional_t<(sizeof...(T) < size_t(-1)), std::unique_ptr<nebula::LineString>, void>;
    __clear();
    type_ = Type::lsVal;
    ::new (std::addressof(value_.lsVal)) ref_(new typename ref_::element_type(std::forward<T>(t)...));
    return value_.lsVal;
  }
  std::unique_ptr<nebula::Polygon>& set_pgVal(nebula::Polygon const &t);
  std::unique_ptr<nebula::Polygon>& set_pgVal(nebula::Polygon&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t<nebula::Polygon, T...>> std::unique_ptr<nebula::Polygon>& set_pgVal(T&&... t) {
    // defer resolution of ref_ in case ref_::element_type would here be incomplete
    using ref_ = folly::conditional_t<(sizeof...(T) < size_t(-1)), std::unique_ptr<nebula::Polygon>, void>;
    __clear();
    type_ = Type::pgVal;
    ::new (std::addressof(value_.pgVal)) ref_(new typename ref_::element_type(std::forward<T>(t)...));
    return value_.pgVal;
  }

  std::unique_ptr<nebula::Point> const & get_ptVal() const {
    assert(type_ == Type::ptVal);
    return value_.ptVal;
  }

  std::unique_ptr<nebula::LineString> const & get_lsVal() const {
    assert(type_ == Type::lsVal);
    return value_.lsVal;
  }

  std::unique_ptr<nebula::Polygon> const & get_pgVal() const {
    assert(type_ == Type::pgVal);
    return value_.pgVal;
  }

  std::unique_ptr<nebula::Point> & mutable_ptVal() {
    assert(type_ == Type::ptVal);
    return value_.ptVal;
  }

  std::unique_ptr<nebula::LineString> & mutable_lsVal() {
    assert(type_ == Type::lsVal);
    return value_.lsVal;
  }

  std::unique_ptr<nebula::Polygon> & mutable_pgVal() {
    assert(type_ == Type::pgVal);
    return value_.pgVal;
  }

  std::unique_ptr<nebula::Point> move_ptVal() {
    assert(type_ == Type::ptVal);
    return std::move(value_.ptVal);
  }

  std::unique_ptr<nebula::LineString> move_lsVal() {
    assert(type_ == Type::lsVal);
    return std::move(value_.lsVal);
  }

  std::unique_ptr<nebula::Polygon> move_pgVal() {
    assert(type_ == Type::pgVal);
    return std::move(value_.pgVal);
  }

  template <typename..., typename T = nebula::Point>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> ptVal_ref() const& {
    return {value_.ptVal, type_, ptVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Point>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> ptVal_ref() const&& {
    return {std::move(value_.ptVal), type_, ptVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Point>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> ptVal_ref() & {
    return {value_.ptVal, type_, ptVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Point>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> ptVal_ref() && {
    return {std::move(value_.ptVal), type_, ptVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = nebula::LineString>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> lsVal_ref() const& {
    return {value_.lsVal, type_, lsVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::LineString>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> lsVal_ref() const&& {
    return {std::move(value_.lsVal), type_, lsVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::LineString>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> lsVal_ref() & {
    return {value_.lsVal, type_, lsVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::LineString>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> lsVal_ref() && {
    return {std::move(value_.lsVal), type_, lsVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = nebula::Polygon>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> pgVal_ref() const& {
    return {value_.pgVal, type_, pgVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Polygon>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> pgVal_ref() const&& {
    return {std::move(value_.pgVal), type_, pgVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Polygon>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> pgVal_ref() & {
    return {value_.pgVal, type_, pgVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = nebula::Polygon>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> pgVal_ref() && {
    return {std::move(value_.pgVal), type_, pgVal, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Geography >;
  friend void swap(Geography& a, Geography& b);
};

template <class Protocol_>
uint32_t Geography::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class Tag final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Tag;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  Tag() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Tag(apache::thrift::FragileConstructor, ::std::string name__arg, std::unordered_map<::std::string, nebula::Value> props__arg);

  Tag(Tag&&) = default;

  Tag(const Tag&) = default;


  Tag& operator=(Tag&&) = default;

  Tag& operator=(const Tag&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string name;
 private:
  std::unordered_map<::std::string, nebula::Value> props;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool name;
    bool props;
  } __isset = {};
  bool operator==(const Tag& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Tag& __x, const Tag& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Tag& rhs) const;
#ifndef SWIG
  friend bool operator>(const Tag& __x, const Tag& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Tag& __x, const Tag& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Tag& __x, const Tag& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> props_ref() const& {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> props_ref() const&& {
    return {std::move(this->props), __isset.props};
  }

  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> props_ref() & {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> props_ref() && {
    return {std::move(this->props), __isset.props};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_Tag_name_struct_setter = ::std::string>
  ::std::string& set_name(T_Tag_name_struct_setter&& name_) {
    name = std::forward<T_Tag_name_struct_setter>(name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return name;
  }
  const std::unordered_map<::std::string, nebula::Value>& get_props() const&;
  std::unordered_map<::std::string, nebula::Value> get_props() &&;

  template <typename T_Tag_props_struct_setter = std::unordered_map<::std::string, nebula::Value>>
  std::unordered_map<::std::string, nebula::Value>& set_props(T_Tag_props_struct_setter&& props_) {
    props = std::forward<T_Tag_props_struct_setter>(props_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.props = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return props;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Tag >;
  friend void swap(Tag& a, Tag& b);
};

template <class Protocol_>
uint32_t Tag::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class Vertex final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Vertex;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  Vertex() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Vertex(apache::thrift::FragileConstructor, nebula::Value vid__arg, ::std::vector<nebula::Tag> tags__arg);

  Vertex(Vertex&&) = default;

  Vertex(const Vertex&) = default;


  Vertex& operator=(Vertex&&) = default;

  Vertex& operator=(const Vertex&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  nebula::Value vid;
 private:
  ::std::vector<nebula::Tag> tags;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool vid;
    bool tags;
  } __isset = {};
  bool operator==(const Vertex& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Vertex& __x, const Vertex& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Vertex& rhs) const;
#ifndef SWIG
  friend bool operator>(const Vertex& __x, const Vertex& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Vertex& __x, const Vertex& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Vertex& __x, const Vertex& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> vid_ref() const& {
    return {this->vid, __isset.vid};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> vid_ref() const&& {
    return {std::move(this->vid), __isset.vid};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> vid_ref() & {
    return {this->vid, __isset.vid};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> vid_ref() && {
    return {std::move(this->vid), __isset.vid};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::Tag>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> tags_ref() const& {
    return {this->tags, __isset.tags};
  }

  template <typename..., typename T = ::std::vector<nebula::Tag>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> tags_ref() const&& {
    return {std::move(this->tags), __isset.tags};
  }

  template <typename..., typename T = ::std::vector<nebula::Tag>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> tags_ref() & {
    return {this->tags, __isset.tags};
  }

  template <typename..., typename T = ::std::vector<nebula::Tag>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> tags_ref() && {
    return {std::move(this->tags), __isset.tags};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const nebula::Value& get_vid() const&;
  nebula::Value get_vid() &&;

  template <typename T_Vertex_vid_struct_setter = nebula::Value>
  nebula::Value& set_vid(T_Vertex_vid_struct_setter&& vid_) {
    vid = std::forward<T_Vertex_vid_struct_setter>(vid_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.vid = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return vid;
  }
  const ::std::vector<nebula::Tag>& get_tags() const&;
  ::std::vector<nebula::Tag> get_tags() &&;

  template <typename T_Vertex_tags_struct_setter = ::std::vector<nebula::Tag>>
  ::std::vector<nebula::Tag>& set_tags(T_Vertex_tags_struct_setter&& tags_) {
    tags = std::forward<T_Vertex_tags_struct_setter>(tags_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.tags = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return tags;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Vertex >;
  friend void swap(Vertex& a, Vertex& b);
};

template <class Protocol_>
uint32_t Vertex::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class Edge final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Edge;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  Edge();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Edge(apache::thrift::FragileConstructor, nebula::Value src__arg, nebula::Value dst__arg,  ::nebula::cpp2::EdgeType type__arg, ::std::string name__arg,  ::nebula::cpp2::EdgeRanking ranking__arg, std::unordered_map<::std::string, nebula::Value> props__arg);

  Edge(Edge&&) = default;

  Edge(const Edge&) = default;


  Edge& operator=(Edge&&) = default;

  Edge& operator=(const Edge&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~Edge();

 private:
  nebula::Value src;
 private:
  nebula::Value dst;
 private:
   ::nebula::cpp2::EdgeType type;
 private:
  ::std::string name;
 private:
   ::nebula::cpp2::EdgeRanking ranking;
 private:
  std::unordered_map<::std::string, nebula::Value> props;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool src;
    bool dst;
    bool type;
    bool name;
    bool ranking;
    bool props;
  } __isset = {};
  bool operator==(const Edge& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Edge& __x, const Edge& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Edge& rhs) const;
#ifndef SWIG
  friend bool operator>(const Edge& __x, const Edge& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Edge& __x, const Edge& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Edge& __x, const Edge& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> src_ref() const& {
    return {this->src, __isset.src};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> src_ref() const&& {
    return {std::move(this->src), __isset.src};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> src_ref() & {
    return {this->src, __isset.src};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> src_ref() && {
    return {std::move(this->src), __isset.src};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> dst_ref() const& {
    return {this->dst, __isset.dst};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> dst_ref() const&& {
    return {std::move(this->dst), __isset.dst};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> dst_ref() & {
    return {this->dst, __isset.dst};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> dst_ref() && {
    return {std::move(this->dst), __isset.dst};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> type_ref() const& {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> type_ref() const&& {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> type_ref() & {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> type_ref() && {
    return {std::move(this->type), __isset.type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::EdgeRanking>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> ranking_ref() const& {
    return {this->ranking, __isset.ranking};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeRanking>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> ranking_ref() const&& {
    return {std::move(this->ranking), __isset.ranking};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeRanking>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> ranking_ref() & {
    return {this->ranking, __isset.ranking};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeRanking>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> ranking_ref() && {
    return {std::move(this->ranking), __isset.ranking};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> props_ref() const& {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> props_ref() const&& {
    return {std::move(this->props), __isset.props};
  }

  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> props_ref() & {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> props_ref() && {
    return {std::move(this->props), __isset.props};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const nebula::Value& get_src() const&;
  nebula::Value get_src() &&;

  template <typename T_Edge_src_struct_setter = nebula::Value>
  nebula::Value& set_src(T_Edge_src_struct_setter&& src_) {
    src = std::forward<T_Edge_src_struct_setter>(src_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.src = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return src;
  }
  const nebula::Value& get_dst() const&;
  nebula::Value get_dst() &&;

  template <typename T_Edge_dst_struct_setter = nebula::Value>
  nebula::Value& set_dst(T_Edge_dst_struct_setter&& dst_) {
    dst = std::forward<T_Edge_dst_struct_setter>(dst_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.dst = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return dst;
  }

   ::nebula::cpp2::EdgeType get_type() const {
    return type;
  }

   ::nebula::cpp2::EdgeType& set_type( ::nebula::cpp2::EdgeType type_) {
    type = type_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return type;
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_Edge_name_struct_setter = ::std::string>
  ::std::string& set_name(T_Edge_name_struct_setter&& name_) {
    name = std::forward<T_Edge_name_struct_setter>(name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return name;
  }

   ::nebula::cpp2::EdgeRanking get_ranking() const {
    return ranking;
  }

   ::nebula::cpp2::EdgeRanking& set_ranking( ::nebula::cpp2::EdgeRanking ranking_) {
    ranking = ranking_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.ranking = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return ranking;
  }
  const std::unordered_map<::std::string, nebula::Value>& get_props() const&;
  std::unordered_map<::std::string, nebula::Value> get_props() &&;

  template <typename T_Edge_props_struct_setter = std::unordered_map<::std::string, nebula::Value>>
  std::unordered_map<::std::string, nebula::Value>& set_props(T_Edge_props_struct_setter&& props_) {
    props = std::forward<T_Edge_props_struct_setter>(props_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.props = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return props;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Edge >;
  friend void swap(Edge& a, Edge& b);
};

template <class Protocol_>
uint32_t Edge::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class Step final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Step;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  Step();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Step(apache::thrift::FragileConstructor, nebula::Vertex dst__arg,  ::nebula::cpp2::EdgeType type__arg, ::std::string name__arg,  ::nebula::cpp2::EdgeRanking ranking__arg, std::unordered_map<::std::string, nebula::Value> props__arg);

  Step(Step&&) = default;

  Step(const Step&) = default;


  Step& operator=(Step&&) = default;

  Step& operator=(const Step&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~Step();

 private:
  nebula::Vertex dst;
 private:
   ::nebula::cpp2::EdgeType type;
 private:
  ::std::string name;
 private:
   ::nebula::cpp2::EdgeRanking ranking;
 private:
  std::unordered_map<::std::string, nebula::Value> props;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool dst;
    bool type;
    bool name;
    bool ranking;
    bool props;
  } __isset = {};
  bool operator==(const Step& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Step& __x, const Step& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Step& rhs) const;
#ifndef SWIG
  friend bool operator>(const Step& __x, const Step& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Step& __x, const Step& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Step& __x, const Step& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::Vertex>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> dst_ref() const& {
    return {this->dst, __isset.dst};
  }

  template <typename..., typename T = nebula::Vertex>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> dst_ref() const&& {
    return {std::move(this->dst), __isset.dst};
  }

  template <typename..., typename T = nebula::Vertex>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> dst_ref() & {
    return {this->dst, __isset.dst};
  }

  template <typename..., typename T = nebula::Vertex>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> dst_ref() && {
    return {std::move(this->dst), __isset.dst};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> type_ref() const& {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> type_ref() const&& {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> type_ref() & {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> type_ref() && {
    return {std::move(this->type), __isset.type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::EdgeRanking>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> ranking_ref() const& {
    return {this->ranking, __isset.ranking};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeRanking>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> ranking_ref() const&& {
    return {std::move(this->ranking), __isset.ranking};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeRanking>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> ranking_ref() & {
    return {this->ranking, __isset.ranking};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeRanking>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> ranking_ref() && {
    return {std::move(this->ranking), __isset.ranking};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> props_ref() const& {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> props_ref() const&& {
    return {std::move(this->props), __isset.props};
  }

  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> props_ref() & {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> props_ref() && {
    return {std::move(this->props), __isset.props};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const nebula::Vertex& get_dst() const&;
  nebula::Vertex get_dst() &&;

  template <typename T_Step_dst_struct_setter = nebula::Vertex>
  nebula::Vertex& set_dst(T_Step_dst_struct_setter&& dst_) {
    dst = std::forward<T_Step_dst_struct_setter>(dst_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.dst = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return dst;
  }

   ::nebula::cpp2::EdgeType get_type() const {
    return type;
  }

   ::nebula::cpp2::EdgeType& set_type( ::nebula::cpp2::EdgeType type_) {
    type = type_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return type;
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_Step_name_struct_setter = ::std::string>
  ::std::string& set_name(T_Step_name_struct_setter&& name_) {
    name = std::forward<T_Step_name_struct_setter>(name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return name;
  }

   ::nebula::cpp2::EdgeRanking get_ranking() const {
    return ranking;
  }

   ::nebula::cpp2::EdgeRanking& set_ranking( ::nebula::cpp2::EdgeRanking ranking_) {
    ranking = ranking_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.ranking = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return ranking;
  }
  const std::unordered_map<::std::string, nebula::Value>& get_props() const&;
  std::unordered_map<::std::string, nebula::Value> get_props() &&;

  template <typename T_Step_props_struct_setter = std::unordered_map<::std::string, nebula::Value>>
  std::unordered_map<::std::string, nebula::Value>& set_props(T_Step_props_struct_setter&& props_) {
    props = std::forward<T_Step_props_struct_setter>(props_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.props = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return props;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Step >;
  friend void swap(Step& a, Step& b);
};

template <class Protocol_>
uint32_t Step::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class Path final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Path;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  Path() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Path(apache::thrift::FragileConstructor, nebula::Vertex src__arg, ::std::vector<nebula::Step> steps__arg);

  Path(Path&&) = default;

  Path(const Path&) = default;


  Path& operator=(Path&&) = default;

  Path& operator=(const Path&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  nebula::Vertex src;
 private:
  ::std::vector<nebula::Step> steps;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool src;
    bool steps;
  } __isset = {};
  bool operator==(const Path& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Path& __x, const Path& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Path& rhs) const;
#ifndef SWIG
  friend bool operator>(const Path& __x, const Path& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Path& __x, const Path& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Path& __x, const Path& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::Vertex>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> src_ref() const& {
    return {this->src, __isset.src};
  }

  template <typename..., typename T = nebula::Vertex>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> src_ref() const&& {
    return {std::move(this->src), __isset.src};
  }

  template <typename..., typename T = nebula::Vertex>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> src_ref() & {
    return {this->src, __isset.src};
  }

  template <typename..., typename T = nebula::Vertex>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> src_ref() && {
    return {std::move(this->src), __isset.src};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::Step>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> steps_ref() const& {
    return {this->steps, __isset.steps};
  }

  template <typename..., typename T = ::std::vector<nebula::Step>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> steps_ref() const&& {
    return {std::move(this->steps), __isset.steps};
  }

  template <typename..., typename T = ::std::vector<nebula::Step>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> steps_ref() & {
    return {this->steps, __isset.steps};
  }

  template <typename..., typename T = ::std::vector<nebula::Step>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> steps_ref() && {
    return {std::move(this->steps), __isset.steps};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const nebula::Vertex& get_src() const&;
  nebula::Vertex get_src() &&;

  template <typename T_Path_src_struct_setter = nebula::Vertex>
  nebula::Vertex& set_src(T_Path_src_struct_setter&& src_) {
    src = std::forward<T_Path_src_struct_setter>(src_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.src = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return src;
  }
  const ::std::vector<nebula::Step>& get_steps() const&;
  ::std::vector<nebula::Step> get_steps() &&;

  template <typename T_Path_steps_struct_setter = ::std::vector<nebula::Step>>
  ::std::vector<nebula::Step>& set_steps(T_Path_steps_struct_setter&& steps_) {
    steps = std::forward<T_Path_steps_struct_setter>(steps_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.steps = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return steps;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Path >;
  friend void swap(Path& a, Path& b);
};

template <class Protocol_>
uint32_t Path::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class HostAddr final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = HostAddr;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  HostAddr() :
      port(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  HostAddr(apache::thrift::FragileConstructor, ::std::string host__arg,  ::nebula::cpp2::Port port__arg);

  HostAddr(HostAddr&&) = default;

  HostAddr(const HostAddr&) = default;


  HostAddr& operator=(HostAddr&&) = default;

  HostAddr& operator=(const HostAddr&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string host;
 private:
   ::nebula::cpp2::Port port;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool host;
    bool port;
  } __isset = {};
  bool operator==(const HostAddr& rhs) const;
#ifndef SWIG
  friend bool operator!=(const HostAddr& __x, const HostAddr& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const HostAddr& rhs) const;
#ifndef SWIG
  friend bool operator>(const HostAddr& __x, const HostAddr& __y) {
    return __y < __x;
  }
  friend bool operator<=(const HostAddr& __x, const HostAddr& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const HostAddr& __x, const HostAddr& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> host_ref() const& {
    return {this->host, __isset.host};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> host_ref() const&& {
    return {std::move(this->host), __isset.host};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> host_ref() & {
    return {this->host, __isset.host};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> host_ref() && {
    return {std::move(this->host), __isset.host};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::Port>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> port_ref() const& {
    return {this->port, __isset.port};
  }

  template <typename..., typename T =  ::nebula::cpp2::Port>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> port_ref() const&& {
    return {std::move(this->port), __isset.port};
  }

  template <typename..., typename T =  ::nebula::cpp2::Port>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> port_ref() & {
    return {this->port, __isset.port};
  }

  template <typename..., typename T =  ::nebula::cpp2::Port>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> port_ref() && {
    return {std::move(this->port), __isset.port};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_host() const& {
    return host;
  }

  ::std::string get_host() && {
    return std::move(host);
  }

  template <typename T_HostAddr_host_struct_setter = ::std::string>
  ::std::string& set_host(T_HostAddr_host_struct_setter&& host_) {
    host = std::forward<T_HostAddr_host_struct_setter>(host_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.host = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return host;
  }

   ::nebula::cpp2::Port get_port() const {
    return port;
  }

   ::nebula::cpp2::Port& set_port( ::nebula::cpp2::Port port_) {
    port = port_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.port = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return port;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< HostAddr >;
  friend void swap(HostAddr& a, HostAddr& b);
};

template <class Protocol_>
uint32_t HostAddr::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class KeyValue final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = KeyValue;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  KeyValue() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  KeyValue(apache::thrift::FragileConstructor, ::std::string key__arg, ::std::string value__arg);

  KeyValue(KeyValue&&) = default;

  KeyValue(const KeyValue&) = default;


  KeyValue& operator=(KeyValue&&) = default;

  KeyValue& operator=(const KeyValue&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string key;
 private:
  ::std::string value;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool key;
    bool value;
  } __isset = {};
  bool operator==(const KeyValue& rhs) const;
#ifndef SWIG
  friend bool operator!=(const KeyValue& __x, const KeyValue& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const KeyValue& rhs) const;
#ifndef SWIG
  friend bool operator>(const KeyValue& __x, const KeyValue& __y) {
    return __y < __x;
  }
  friend bool operator<=(const KeyValue& __x, const KeyValue& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const KeyValue& __x, const KeyValue& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> key_ref() const& {
    return {this->key, __isset.key};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> key_ref() const&& {
    return {std::move(this->key), __isset.key};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> key_ref() & {
    return {this->key, __isset.key};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> key_ref() && {
    return {std::move(this->key), __isset.key};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> value_ref() const& {
    return {this->value, __isset.value};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> value_ref() const&& {
    return {std::move(this->value), __isset.value};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> value_ref() & {
    return {this->value, __isset.value};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> value_ref() && {
    return {std::move(this->value), __isset.value};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_key() const& {
    return key;
  }

  ::std::string get_key() && {
    return std::move(key);
  }

  template <typename T_KeyValue_key_struct_setter = ::std::string>
  ::std::string& set_key(T_KeyValue_key_struct_setter&& key_) {
    key = std::forward<T_KeyValue_key_struct_setter>(key_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.key = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return key;
  }

  const ::std::string& get_value() const& {
    return value;
  }

  ::std::string get_value() && {
    return std::move(value);
  }

  template <typename T_KeyValue_value_struct_setter = ::std::string>
  ::std::string& set_value(T_KeyValue_value_struct_setter&& value_) {
    value = std::forward<T_KeyValue_value_struct_setter>(value_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.value = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return value;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< KeyValue >;
  friend void swap(KeyValue& a, KeyValue& b);
};

template <class Protocol_>
uint32_t KeyValue::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class Duration final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Duration;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  Duration() :
      seconds(0),
      microseconds(0),
      months(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Duration(apache::thrift::FragileConstructor, int64_t seconds__arg, int32_t microseconds__arg, int32_t months__arg);

  Duration(Duration&&) = default;

  Duration(const Duration&) = default;


  Duration& operator=(Duration&&) = default;

  Duration& operator=(const Duration&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  int64_t seconds;
 private:
  int32_t microseconds;
 private:
  int32_t months;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool seconds;
    bool microseconds;
    bool months;
  } __isset = {};
  bool operator==(const Duration& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Duration& __x, const Duration& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Duration& rhs) const;
#ifndef SWIG
  friend bool operator>(const Duration& __x, const Duration& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Duration& __x, const Duration& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Duration& __x, const Duration& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> seconds_ref() const& {
    return {this->seconds, __isset.seconds};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> seconds_ref() const&& {
    return {std::move(this->seconds), __isset.seconds};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> seconds_ref() & {
    return {this->seconds, __isset.seconds};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> seconds_ref() && {
    return {std::move(this->seconds), __isset.seconds};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> microseconds_ref() const& {
    return {this->microseconds, __isset.microseconds};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> microseconds_ref() const&& {
    return {std::move(this->microseconds), __isset.microseconds};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> microseconds_ref() & {
    return {this->microseconds, __isset.microseconds};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> microseconds_ref() && {
    return {std::move(this->microseconds), __isset.microseconds};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> months_ref() const& {
    return {this->months, __isset.months};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> months_ref() const&& {
    return {std::move(this->months), __isset.months};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> months_ref() & {
    return {this->months, __isset.months};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> months_ref() && {
    return {std::move(this->months), __isset.months};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  int64_t get_seconds() const {
    return seconds;
  }

  int64_t& set_seconds(int64_t seconds_) {
    seconds = seconds_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.seconds = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return seconds;
  }

  int32_t get_microseconds() const {
    return microseconds;
  }

  int32_t& set_microseconds(int32_t microseconds_) {
    microseconds = microseconds_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.microseconds = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return microseconds;
  }

  int32_t get_months() const {
    return months;
  }

  int32_t& set_months(int32_t months_) {
    months = months_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.months = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return months;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Duration >;
  friend void swap(Duration& a, Duration& b);
};

template <class Protocol_>
uint32_t Duration::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class LogInfo final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = LogInfo;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  LogInfo() :
      log_id(0),
      term_id(0),
      commit_log_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  LogInfo(apache::thrift::FragileConstructor,  ::nebula::cpp2::LogID log_id__arg,  ::nebula::cpp2::TermID term_id__arg,  ::nebula::cpp2::LogID commit_log_id__arg, ::std::string checkpoint_path__arg);

  LogInfo(LogInfo&&) = default;

  LogInfo(const LogInfo&) = default;


  LogInfo& operator=(LogInfo&&) = default;

  LogInfo& operator=(const LogInfo&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::LogID log_id;
 private:
   ::nebula::cpp2::TermID term_id;
 private:
   ::nebula::cpp2::LogID commit_log_id;
 private:
  ::std::string checkpoint_path;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool log_id;
    bool term_id;
    bool commit_log_id;
    bool checkpoint_path;
  } __isset = {};
  bool operator==(const LogInfo& rhs) const;
#ifndef SWIG
  friend bool operator!=(const LogInfo& __x, const LogInfo& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const LogInfo& rhs) const;
#ifndef SWIG
  friend bool operator>(const LogInfo& __x, const LogInfo& __y) {
    return __y < __x;
  }
  friend bool operator<=(const LogInfo& __x, const LogInfo& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const LogInfo& __x, const LogInfo& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::LogID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> log_id_ref() const& {
    return {this->log_id, __isset.log_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::LogID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> log_id_ref() const&& {
    return {std::move(this->log_id), __isset.log_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::LogID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> log_id_ref() & {
    return {this->log_id, __isset.log_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::LogID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> log_id_ref() && {
    return {std::move(this->log_id), __isset.log_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::TermID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> term_id_ref() const& {
    return {this->term_id, __isset.term_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::TermID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> term_id_ref() const&& {
    return {std::move(this->term_id), __isset.term_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::TermID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> term_id_ref() & {
    return {this->term_id, __isset.term_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::TermID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> term_id_ref() && {
    return {std::move(this->term_id), __isset.term_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::LogID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> commit_log_id_ref() const& {
    return {this->commit_log_id, __isset.commit_log_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::LogID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> commit_log_id_ref() const&& {
    return {std::move(this->commit_log_id), __isset.commit_log_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::LogID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> commit_log_id_ref() & {
    return {this->commit_log_id, __isset.commit_log_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::LogID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> commit_log_id_ref() && {
    return {std::move(this->commit_log_id), __isset.commit_log_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> checkpoint_path_ref() const& {
    return {this->checkpoint_path, __isset.checkpoint_path};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> checkpoint_path_ref() const&& {
    return {std::move(this->checkpoint_path), __isset.checkpoint_path};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> checkpoint_path_ref() & {
    return {this->checkpoint_path, __isset.checkpoint_path};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> checkpoint_path_ref() && {
    return {std::move(this->checkpoint_path), __isset.checkpoint_path};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::LogID get_log_id() const {
    return log_id;
  }

   ::nebula::cpp2::LogID& set_log_id( ::nebula::cpp2::LogID log_id_) {
    log_id = log_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.log_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return log_id;
  }

   ::nebula::cpp2::TermID get_term_id() const {
    return term_id;
  }

   ::nebula::cpp2::TermID& set_term_id( ::nebula::cpp2::TermID term_id_) {
    term_id = term_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.term_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return term_id;
  }

   ::nebula::cpp2::LogID get_commit_log_id() const {
    return commit_log_id;
  }

   ::nebula::cpp2::LogID& set_commit_log_id( ::nebula::cpp2::LogID commit_log_id_) {
    commit_log_id = commit_log_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.commit_log_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return commit_log_id;
  }

  const ::std::string& get_checkpoint_path() const& {
    return checkpoint_path;
  }

  ::std::string get_checkpoint_path() && {
    return std::move(checkpoint_path);
  }

  template <typename T_LogInfo_checkpoint_path_struct_setter = ::std::string>
  ::std::string& set_checkpoint_path(T_LogInfo_checkpoint_path_struct_setter&& checkpoint_path_) {
    checkpoint_path = std::forward<T_LogInfo_checkpoint_path_struct_setter>(checkpoint_path_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.checkpoint_path = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return checkpoint_path;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< LogInfo >;
  friend void swap(LogInfo& a, LogInfo& b);
};

template <class Protocol_>
uint32_t LogInfo::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class DirInfo final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = DirInfo;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  DirInfo() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  DirInfo(apache::thrift::FragileConstructor, ::std::string root__arg, ::std::vector<::std::string> data__arg);

  DirInfo(DirInfo&&) = default;

  DirInfo(const DirInfo&) = default;


  DirInfo& operator=(DirInfo&&) = default;

  DirInfo& operator=(const DirInfo&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string root;
 private:
  ::std::vector<::std::string> data;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool root;
    bool data;
  } __isset = {};
  bool operator==(const DirInfo& rhs) const;
#ifndef SWIG
  friend bool operator!=(const DirInfo& __x, const DirInfo& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const DirInfo& rhs) const;
#ifndef SWIG
  friend bool operator>(const DirInfo& __x, const DirInfo& __y) {
    return __y < __x;
  }
  friend bool operator<=(const DirInfo& __x, const DirInfo& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const DirInfo& __x, const DirInfo& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> root_ref() const& {
    return {this->root, __isset.root};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> root_ref() const&& {
    return {std::move(this->root), __isset.root};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> root_ref() & {
    return {this->root, __isset.root};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> root_ref() && {
    return {std::move(this->root), __isset.root};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> data_ref() const& {
    return {this->data, __isset.data};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> data_ref() const&& {
    return {std::move(this->data), __isset.data};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> data_ref() & {
    return {this->data, __isset.data};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> data_ref() && {
    return {std::move(this->data), __isset.data};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_root() const& {
    return root;
  }

  ::std::string get_root() && {
    return std::move(root);
  }

  template <typename T_DirInfo_root_struct_setter = ::std::string>
  ::std::string& set_root(T_DirInfo_root_struct_setter&& root_) {
    root = std::forward<T_DirInfo_root_struct_setter>(root_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.root = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return root;
  }
  const ::std::vector<::std::string>& get_data() const&;
  ::std::vector<::std::string> get_data() &&;

  template <typename T_DirInfo_data_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_data(T_DirInfo_data_struct_setter&& data_) {
    data = std::forward<T_DirInfo_data_struct_setter>(data_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.data = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return data;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< DirInfo >;
  friend void swap(DirInfo& a, DirInfo& b);
};

template <class Protocol_>
uint32_t DirInfo::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class CheckpointInfo final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CheckpointInfo;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  CheckpointInfo() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CheckpointInfo(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::cpp2::LogInfo> parts__arg, ::std::string data_path__arg);

  CheckpointInfo(CheckpointInfo&&) = default;

  CheckpointInfo(const CheckpointInfo&) = default;


  CheckpointInfo& operator=(CheckpointInfo&&) = default;

  CheckpointInfo& operator=(const CheckpointInfo&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::cpp2::LogInfo> parts;
 private:
  ::std::string data_path;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool parts;
    bool data_path;
  } __isset = {};
  bool operator==(const CheckpointInfo& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CheckpointInfo& __x, const CheckpointInfo& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CheckpointInfo& rhs) const;
#ifndef SWIG
  friend bool operator>(const CheckpointInfo& __x, const CheckpointInfo& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CheckpointInfo& __x, const CheckpointInfo& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CheckpointInfo& __x, const CheckpointInfo& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::cpp2::LogInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> parts_ref() const& {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::cpp2::LogInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> parts_ref() const&& {
    return {std::move(this->parts), __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::cpp2::LogInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> parts_ref() & {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::cpp2::LogInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> parts_ref() && {
    return {std::move(this->parts), __isset.parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> data_path_ref() const& {
    return {this->data_path, __isset.data_path};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> data_path_ref() const&& {
    return {std::move(this->data_path), __isset.data_path};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> data_path_ref() & {
    return {this->data_path, __isset.data_path};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> data_path_ref() && {
    return {std::move(this->data_path), __isset.data_path};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::cpp2::LogInfo>& get_parts() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::cpp2::LogInfo> get_parts() &&;

  template <typename T_CheckpointInfo_parts_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::cpp2::LogInfo>>
  std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::cpp2::LogInfo>& set_parts(T_CheckpointInfo_parts_struct_setter&& parts_) {
    parts = std::forward<T_CheckpointInfo_parts_struct_setter>(parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return parts;
  }

  const ::std::string& get_data_path() const& {
    return data_path;
  }

  ::std::string get_data_path() && {
    return std::move(data_path);
  }

  template <typename T_CheckpointInfo_data_path_struct_setter = ::std::string>
  ::std::string& set_data_path(T_CheckpointInfo_data_path_struct_setter&& data_path_) {
    data_path = std::forward<T_CheckpointInfo_data_path_struct_setter>(data_path_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.data_path = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return data_path;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CheckpointInfo >;
  friend void swap(CheckpointInfo& a, CheckpointInfo& b);
};

template <class Protocol_>
uint32_t CheckpointInfo::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2
namespace nebula { namespace cpp2 {
class LogEntry final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = LogEntry;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  LogEntry() :
      cluster(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  LogEntry(apache::thrift::FragileConstructor,  ::nebula::cpp2::ClusterID cluster__arg, ::std::string log_str__arg);

  LogEntry(LogEntry&&) = default;

  LogEntry(const LogEntry&) = default;


  LogEntry& operator=(LogEntry&&) = default;

  LogEntry& operator=(const LogEntry&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ClusterID cluster;
 private:
  ::std::string log_str;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool cluster;
    bool log_str;
  } __isset = {};
  bool operator==(const LogEntry& rhs) const;
#ifndef SWIG
  friend bool operator!=(const LogEntry& __x, const LogEntry& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const LogEntry& rhs) const;
#ifndef SWIG
  friend bool operator>(const LogEntry& __x, const LogEntry& __y) {
    return __y < __x;
  }
  friend bool operator<=(const LogEntry& __x, const LogEntry& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const LogEntry& __x, const LogEntry& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> cluster_ref() const& {
    return {this->cluster, __isset.cluster};
  }

  template <typename..., typename T =  ::nebula::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> cluster_ref() const&& {
    return {std::move(this->cluster), __isset.cluster};
  }

  template <typename..., typename T =  ::nebula::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> cluster_ref() & {
    return {this->cluster, __isset.cluster};
  }

  template <typename..., typename T =  ::nebula::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> cluster_ref() && {
    return {std::move(this->cluster), __isset.cluster};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> log_str_ref() const& {
    return {this->log_str, __isset.log_str};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> log_str_ref() const&& {
    return {std::move(this->log_str), __isset.log_str};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> log_str_ref() & {
    return {this->log_str, __isset.log_str};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> log_str_ref() && {
    return {std::move(this->log_str), __isset.log_str};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ClusterID get_cluster() const {
    return cluster;
  }

   ::nebula::cpp2::ClusterID& set_cluster( ::nebula::cpp2::ClusterID cluster_) {
    cluster = cluster_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.cluster = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return cluster;
  }

  const ::std::string& get_log_str() const& {
    return log_str;
  }

  ::std::string get_log_str() && {
    return std::move(log_str);
  }

  template <typename T_LogEntry_log_str_struct_setter = ::std::string>
  ::std::string& set_log_str(T_LogEntry_log_str_struct_setter&& log_str_) {
    log_str = std::forward<T_LogEntry_log_str_struct_setter>(log_str_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.log_str = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return log_str;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< LogEntry >;
  friend void swap(LogEntry& a, LogEntry& b);
};

template <class Protocol_>
uint32_t LogEntry::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // nebula::cpp2

namespace apache { namespace thrift {

template <> struct TEnumDataStorage<::nebula::cpp2::SchemaID::Type>;

template <> struct TEnumTraits<::nebula::cpp2::SchemaID::Type> {
  using type = ::nebula::cpp2::SchemaID::Type;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};

template <> struct TEnumDataStorage<::nebula::cpp2::Value::Type>;

template <> struct TEnumTraits<::nebula::cpp2::Value::Type> {
  using type = ::nebula::cpp2::Value::Type;

  static constexpr std::size_t const size = 17;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};

template <> struct TEnumDataStorage<::nebula::cpp2::Geography::Type>;

template <> struct TEnumTraits<::nebula::cpp2::Geography::Type> {
  using type = ::nebula::cpp2::Geography::Type;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};
}} // apache::thrift
