/**
 * Autogenerated by Thrift for meta.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include "MetaServiceAsyncClient.h"

#include <thrift/lib/cpp2/gen/client_cpp.h>

namespace nebula { namespace meta { namespace cpp2 {
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::CreateSpaceReq*>> MetaService_createSpace_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_createSpace_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::DropSpaceReq*>> MetaService_dropSpace_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_dropSpace_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetSpaceReq*>> MetaService_getSpace_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetSpaceResp*>> MetaService_getSpace_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListSpacesReq*>> MetaService_listSpaces_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListSpacesResp*>> MetaService_listSpaces_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::CreateSpaceAsReq*>> MetaService_createSpaceAs_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_createSpaceAs_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::CreateTagReq*>> MetaService_createTag_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_createTag_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::AlterTagReq*>> MetaService_alterTag_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_alterTag_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::DropTagReq*>> MetaService_dropTag_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_dropTag_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetTagReq*>> MetaService_getTag_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetTagResp*>> MetaService_getTag_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListTagsReq*>> MetaService_listTags_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListTagsResp*>> MetaService_listTags_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::CreateEdgeReq*>> MetaService_createEdge_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_createEdge_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::AlterEdgeReq*>> MetaService_alterEdge_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_alterEdge_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::DropEdgeReq*>> MetaService_dropEdge_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_dropEdge_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetEdgeReq*>> MetaService_getEdge_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetEdgeResp*>> MetaService_getEdge_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListEdgesReq*>> MetaService_listEdges_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListEdgesResp*>> MetaService_listEdges_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListHostsReq*>> MetaService_listHosts_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListHostsResp*>> MetaService_listHosts_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetPartsAllocReq*>> MetaService_getPartsAlloc_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetPartsAllocResp*>> MetaService_getPartsAlloc_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListPartsReq*>> MetaService_listParts_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListPartsResp*>> MetaService_listParts_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::MultiPutReq*>> MetaService_multiPut_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_multiPut_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetReq*>> MetaService_get_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetResp*>> MetaService_get_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::MultiGetReq*>> MetaService_multiGet_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::MultiGetResp*>> MetaService_multiGet_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::RemoveReq*>> MetaService_remove_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_remove_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::RemoveRangeReq*>> MetaService_removeRange_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_removeRange_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ScanReq*>> MetaService_scan_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ScanResp*>> MetaService_scan_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::CreateTagIndexReq*>> MetaService_createTagIndex_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_createTagIndex_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::DropTagIndexReq*>> MetaService_dropTagIndex_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_dropTagIndex_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetTagIndexReq*>> MetaService_getTagIndex_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetTagIndexResp*>> MetaService_getTagIndex_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListTagIndexesReq*>> MetaService_listTagIndexes_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListTagIndexesResp*>> MetaService_listTagIndexes_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::RebuildIndexReq*>> MetaService_rebuildTagIndex_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_rebuildTagIndex_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListIndexStatusReq*>> MetaService_listTagIndexStatus_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListIndexStatusResp*>> MetaService_listTagIndexStatus_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::CreateEdgeIndexReq*>> MetaService_createEdgeIndex_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_createEdgeIndex_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::DropEdgeIndexReq*>> MetaService_dropEdgeIndex_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_dropEdgeIndex_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetEdgeIndexReq*>> MetaService_getEdgeIndex_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetEdgeIndexResp*>> MetaService_getEdgeIndex_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListEdgeIndexesReq*>> MetaService_listEdgeIndexes_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListEdgeIndexesResp*>> MetaService_listEdgeIndexes_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::RebuildIndexReq*>> MetaService_rebuildEdgeIndex_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_rebuildEdgeIndex_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListIndexStatusReq*>> MetaService_listEdgeIndexStatus_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListIndexStatusResp*>> MetaService_listEdgeIndexStatus_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::CreateUserReq*>> MetaService_createUser_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_createUser_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::DropUserReq*>> MetaService_dropUser_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_dropUser_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::AlterUserReq*>> MetaService_alterUser_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_alterUser_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GrantRoleReq*>> MetaService_grantRole_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_grantRole_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::RevokeRoleReq*>> MetaService_revokeRole_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_revokeRole_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListUsersReq*>> MetaService_listUsers_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListUsersResp*>> MetaService_listUsers_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListRolesReq*>> MetaService_listRoles_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListRolesResp*>> MetaService_listRoles_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetUserRolesReq*>> MetaService_getUserRoles_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListRolesResp*>> MetaService_getUserRoles_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ChangePasswordReq*>> MetaService_changePassword_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_changePassword_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::HBReq*>> MetaService_heartBeat_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::HBResp*>> MetaService_heartBeat_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::BalanceReq*>> MetaService_balance_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::BalanceResp*>> MetaService_balance_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::LeaderBalanceReq*>> MetaService_leaderBalance_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_leaderBalance_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::RegConfigReq*>> MetaService_regConfig_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_regConfig_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetConfigReq*>> MetaService_getConfig_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetConfigResp*>> MetaService_getConfig_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::SetConfigReq*>> MetaService_setConfig_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_setConfig_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListConfigsReq*>> MetaService_listConfigs_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListConfigsResp*>> MetaService_listConfigs_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::CreateSnapshotReq*>> MetaService_createSnapshot_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_createSnapshot_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::DropSnapshotReq*>> MetaService_dropSnapshot_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_dropSnapshot_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListSnapshotsReq*>> MetaService_listSnapshots_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListSnapshotsResp*>> MetaService_listSnapshots_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::AdminJobReq*>> MetaService_runAdminJob_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::AdminJobResp*>> MetaService_runAdminJob_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::AddZoneReq*>> MetaService_addZone_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_addZone_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::DropZoneReq*>> MetaService_dropZone_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_dropZone_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::AddHostIntoZoneReq*>> MetaService_addHostIntoZone_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_addHostIntoZone_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::DropHostFromZoneReq*>> MetaService_dropHostFromZone_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_dropHostFromZone_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetZoneReq*>> MetaService_getZone_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetZoneResp*>> MetaService_getZone_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListZonesReq*>> MetaService_listZones_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListZonesResp*>> MetaService_listZones_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::AddGroupReq*>> MetaService_addGroup_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_addGroup_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::DropGroupReq*>> MetaService_dropGroup_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_dropGroup_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::AddZoneIntoGroupReq*>> MetaService_addZoneIntoGroup_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_addZoneIntoGroup_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::DropZoneFromGroupReq*>> MetaService_dropZoneFromGroup_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_dropZoneFromGroup_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetGroupReq*>> MetaService_getGroup_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetGroupResp*>> MetaService_getGroup_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListGroupsReq*>> MetaService_listGroups_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListGroupsResp*>> MetaService_listGroups_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::CreateBackupReq*>> MetaService_createBackup_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::CreateBackupResp*>> MetaService_createBackup_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::RestoreMetaReq*>> MetaService_restoreMeta_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_restoreMeta_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::AddListenerReq*>> MetaService_addListener_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_addListener_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::RemoveListenerReq*>> MetaService_removeListener_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_removeListener_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListListenerReq*>> MetaService_listListener_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListListenerResp*>> MetaService_listListener_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetStatsReq*>> MetaService_getStats_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetStatsResp*>> MetaService_getStats_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::SignInFTServiceReq*>> MetaService_signInFTService_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_signInFTService_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::SignOutFTServiceReq*>> MetaService_signOutFTService_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_signOutFTService_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListFTClientsReq*>> MetaService_listFTClients_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListFTClientsResp*>> MetaService_listFTClients_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::CreateFTIndexReq*>> MetaService_createFTIndex_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_createFTIndex_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::DropFTIndexReq*>> MetaService_dropFTIndex_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_dropFTIndex_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListFTIndexesReq*>> MetaService_listFTIndexes_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListFTIndexesResp*>> MetaService_listFTIndexes_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::CreateSessionReq*>> MetaService_createSession_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::CreateSessionResp*>> MetaService_createSession_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::UpdateSessionsReq*>> MetaService_updateSessions_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::UpdateSessionsResp*>> MetaService_updateSessions_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListSessionsReq*>> MetaService_listSessions_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListSessionsResp*>> MetaService_listSessions_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetSessionReq*>> MetaService_getSession_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetSessionResp*>> MetaService_getSession_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::RemoveSessionReq*>> MetaService_removeSession_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_removeSession_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::KillQueryReq*>> MetaService_killQuery_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_killQuery_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ReportTaskReq*>> MetaService_reportTaskFinish_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ExecResp*>> MetaService_reportTaskFinish_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListClusterInfoReq*>> MetaService_listCluster_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::ListClusterInfoResp*>> MetaService_listCluster_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetMetaDirInfoReq*>> MetaService_getMetaDirInfo_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::GetMetaDirInfoResp*>> MetaService_getMetaDirInfo_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::VerifyClientVersionReq*>> MetaService_verifyClientVersion_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::meta::cpp2::VerifyClientVersionResp*>> MetaService_verifyClientVersion_presult;

template <typename Protocol_>
void MetaServiceAsyncClient::createSpaceT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_createSpace_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::CreateSpaceReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "createSpace";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::dropSpaceT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropSpaceReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_dropSpace_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::DropSpaceReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "dropSpace";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::getSpaceT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetSpaceReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_getSpace_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::GetSpaceReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "getSpace";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listSpacesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListSpacesReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listSpaces_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListSpacesReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listSpaces";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::createSpaceAsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_createSpaceAs_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::CreateSpaceAsReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "createSpaceAs";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::createTagT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateTagReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_createTag_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::CreateTagReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "createTag";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::alterTagT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AlterTagReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_alterTag_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::AlterTagReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "alterTag";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::dropTagT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropTagReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_dropTag_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::DropTagReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "dropTag";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::getTagT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetTagReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_getTag_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::GetTagReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "getTag";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listTagsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListTagsReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listTags_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListTagsReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listTags";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::createEdgeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_createEdge_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::CreateEdgeReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "createEdge";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::alterEdgeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_alterEdge_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::AlterEdgeReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "alterEdge";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::dropEdgeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropEdgeReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_dropEdge_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::DropEdgeReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "dropEdge";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::getEdgeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetEdgeReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_getEdge_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::GetEdgeReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "getEdge";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listEdgesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListEdgesReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listEdges_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListEdgesReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listEdges";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listHostsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListHostsReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listHosts_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListHostsReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listHosts";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::getPartsAllocT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_getPartsAlloc_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::GetPartsAllocReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "getPartsAlloc";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listPartsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListPartsReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listParts_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListPartsReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listParts";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::multiPutT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::MultiPutReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_multiPut_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::MultiPutReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "multiPut";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::getT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_get_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::GetReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "get";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::multiGetT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::MultiGetReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_multiGet_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::MultiGetReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "multiGet";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::removeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RemoveReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_remove_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::RemoveReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "remove";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::removeRangeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_removeRange_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::RemoveRangeReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "removeRange";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::scanT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ScanReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_scan_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ScanReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "scan";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::createTagIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_createTagIndex_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::CreateTagIndexReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "createTagIndex";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::dropTagIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_dropTagIndex_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::DropTagIndexReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "dropTagIndex";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::getTagIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_getTagIndex_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::GetTagIndexReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "getTagIndex";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listTagIndexesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listTagIndexes_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListTagIndexesReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listTagIndexes";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::rebuildTagIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_rebuildTagIndex_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::RebuildIndexReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "rebuildTagIndex";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listTagIndexStatusT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listTagIndexStatus_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListIndexStatusReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listTagIndexStatus";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::createEdgeIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_createEdgeIndex_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::CreateEdgeIndexReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "createEdgeIndex";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::dropEdgeIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_dropEdgeIndex_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::DropEdgeIndexReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "dropEdgeIndex";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::getEdgeIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_getEdgeIndex_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::GetEdgeIndexReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "getEdgeIndex";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listEdgeIndexesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listEdgeIndexes_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListEdgeIndexesReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listEdgeIndexes";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::rebuildEdgeIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_rebuildEdgeIndex_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::RebuildIndexReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "rebuildEdgeIndex";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listEdgeIndexStatusT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listEdgeIndexStatus_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListIndexStatusReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listEdgeIndexStatus";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::createUserT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateUserReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_createUser_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::CreateUserReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "createUser";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::dropUserT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropUserReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_dropUser_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::DropUserReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "dropUser";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::alterUserT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AlterUserReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_alterUser_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::AlterUserReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "alterUser";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::grantRoleT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GrantRoleReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_grantRole_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::GrantRoleReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "grantRole";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::revokeRoleT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_revokeRole_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::RevokeRoleReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "revokeRole";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listUsersT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListUsersReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listUsers_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListUsersReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listUsers";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listRolesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListRolesReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listRoles_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListRolesReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listRoles";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::getUserRolesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_getUserRoles_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::GetUserRolesReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "getUserRoles";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::changePasswordT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_changePassword_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ChangePasswordReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "changePassword";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::heartBeatT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::HBReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_heartBeat_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::HBReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "heartBeat";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::balanceT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::BalanceReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_balance_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::BalanceReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "balance";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::leaderBalanceT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::LeaderBalanceReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_leaderBalance_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::LeaderBalanceReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "leaderBalance";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::regConfigT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RegConfigReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_regConfig_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::RegConfigReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "regConfig";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::getConfigT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetConfigReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_getConfig_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::GetConfigReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "getConfig";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::setConfigT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::SetConfigReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_setConfig_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::SetConfigReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "setConfig";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listConfigsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListConfigsReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listConfigs_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListConfigsReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listConfigs";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::createSnapshotT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_createSnapshot_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::CreateSnapshotReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "createSnapshot";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::dropSnapshotT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_dropSnapshot_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::DropSnapshotReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "dropSnapshot";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listSnapshotsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listSnapshots_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListSnapshotsReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listSnapshots";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::runAdminJobT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AdminJobReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_runAdminJob_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::AdminJobReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "runAdminJob";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::addZoneT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AddZoneReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_addZone_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::AddZoneReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "addZone";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::dropZoneT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropZoneReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_dropZone_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::DropZoneReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "dropZone";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::addHostIntoZoneT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AddHostIntoZoneReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_addHostIntoZone_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::AddHostIntoZoneReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "addHostIntoZone";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::dropHostFromZoneT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropHostFromZoneReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_dropHostFromZone_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::DropHostFromZoneReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "dropHostFromZone";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::getZoneT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetZoneReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_getZone_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::GetZoneReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "getZone";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listZonesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListZonesReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listZones_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListZonesReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listZones";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::addGroupT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AddGroupReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_addGroup_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::AddGroupReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "addGroup";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::dropGroupT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropGroupReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_dropGroup_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::DropGroupReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "dropGroup";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::addZoneIntoGroupT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AddZoneIntoGroupReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_addZoneIntoGroup_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::AddZoneIntoGroupReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "addZoneIntoGroup";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::dropZoneFromGroupT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropZoneFromGroupReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_dropZoneFromGroup_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::DropZoneFromGroupReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "dropZoneFromGroup";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::getGroupT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetGroupReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_getGroup_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::GetGroupReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "getGroup";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listGroupsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListGroupsReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listGroups_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListGroupsReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listGroups";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::createBackupT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateBackupReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_createBackup_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::CreateBackupReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "createBackup";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::restoreMetaT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_restoreMeta_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::RestoreMetaReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "restoreMeta";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::addListenerT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AddListenerReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_addListener_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::AddListenerReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "addListener";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::removeListenerT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_removeListener_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::RemoveListenerReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "removeListener";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listListenerT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListListenerReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listListener_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListListenerReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listListener";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::getStatsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetStatsReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_getStats_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::GetStatsReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "getStats";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::signInFTServiceT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::SignInFTServiceReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_signInFTService_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::SignInFTServiceReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "signInFTService";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::signOutFTServiceT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::SignOutFTServiceReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_signOutFTService_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::SignOutFTServiceReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "signOutFTService";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listFTClientsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListFTClientsReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listFTClients_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListFTClientsReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listFTClients";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::createFTIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_createFTIndex_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::CreateFTIndexReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "createFTIndex";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::dropFTIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_dropFTIndex_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::DropFTIndexReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "dropFTIndex";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listFTIndexesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listFTIndexes_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListFTIndexesReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listFTIndexes";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::createSessionT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateSessionReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_createSession_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::CreateSessionReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "createSession";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::updateSessionsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_updateSessions_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::UpdateSessionsReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "updateSessions";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listSessionsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListSessionsReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listSessions_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListSessionsReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listSessions";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::getSessionT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetSessionReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_getSession_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::GetSessionReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "getSession";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::removeSessionT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_removeSession_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::RemoveSessionReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "removeSession";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::killQueryT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::KillQueryReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_killQuery_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::KillQueryReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "killQuery";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::reportTaskFinishT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ReportTaskReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_reportTaskFinish_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ReportTaskReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "reportTaskFinish";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::listClusterT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_listCluster_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::ListClusterInfoReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "listCluster";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::getMetaDirInfoT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_getMetaDirInfo_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::GetMetaDirInfoReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "getMetaDirInfo";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void MetaServiceAsyncClient::verifyClientVersionT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  MetaService_verifyClientVersion_pargs args;
  args.get<0>().value = const_cast< ::nebula::meta::cpp2::VerifyClientVersionReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "verifyClientVersion";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}



void MetaServiceAsyncClient::createSpace(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  createSpace(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::createSpace(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req) {
  auto ctx = createSpaceCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  createSpaceImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::createSpaceImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      createSpaceT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      createSpaceT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::createSpaceCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.createSpace");
}

void MetaServiceAsyncClient::sync_createSpace( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_createSpace(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_createSpace(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = createSpaceCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  createSpaceImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_createSpace(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_createSpace(const  ::nebula::meta::cpp2::CreateSpaceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_createSpace(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_createSpace(const  ::nebula::meta::cpp2::CreateSpaceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_createSpace(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_createSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_createSpace, channel_);
  createSpace(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_createSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_createSpace, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createSpace(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_createSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_createSpace, channel_);
  createSpace(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_createSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_createSpace, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createSpace(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::createSpace(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req) {
  createSpace(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_createSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_createSpace_presult;
  constexpr auto const fname = "createSpace";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_createSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_createSpace(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_createSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_createSpace(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_createSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_createSpace(_return, state);
}

void MetaServiceAsyncClient::dropSpace(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropSpaceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  dropSpace(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::dropSpace(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropSpaceReq& p_req) {
  auto ctx = dropSpaceCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  dropSpaceImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::dropSpaceImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropSpaceReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      dropSpaceT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      dropSpaceT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::dropSpaceCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.dropSpace");
}

void MetaServiceAsyncClient::sync_dropSpace( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropSpaceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_dropSpace(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_dropSpace(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropSpaceReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = dropSpaceCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  dropSpaceImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_dropSpace(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropSpace(const  ::nebula::meta::cpp2::DropSpaceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_dropSpace(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropSpace(const  ::nebula::meta::cpp2::DropSpaceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_dropSpace(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropSpaceReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropSpace, channel_);
  dropSpace(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropSpaceReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_dropSpace, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropSpace(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_dropSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropSpaceReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropSpace, channel_);
  dropSpace(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_dropSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropSpaceReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_dropSpace, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropSpace(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::dropSpace(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropSpaceReq& p_req) {
  dropSpace(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_dropSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_dropSpace_presult;
  constexpr auto const fname = "dropSpace";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_dropSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_dropSpace(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_dropSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_dropSpace(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_dropSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_dropSpace(_return, state);
}

void MetaServiceAsyncClient::getSpace(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetSpaceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  getSpace(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::getSpace(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetSpaceReq& p_req) {
  auto ctx = getSpaceCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  getSpaceImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::getSpaceImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetSpaceReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getSpaceT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getSpaceT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::getSpaceCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.getSpace");
}

void MetaServiceAsyncClient::sync_getSpace( ::nebula::meta::cpp2::GetSpaceResp& _return, const  ::nebula::meta::cpp2::GetSpaceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getSpace(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_getSpace(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetSpaceResp& _return, const  ::nebula::meta::cpp2::GetSpaceReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = getSpaceCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  getSpaceImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_getSpace(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::GetSpaceResp> MetaServiceAsyncClient::future_getSpace(const  ::nebula::meta::cpp2::GetSpaceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getSpace(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::GetSpaceResp> MetaServiceAsyncClient::semifuture_getSpace(const  ::nebula::meta::cpp2::GetSpaceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getSpace(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::GetSpaceResp> MetaServiceAsyncClient::future_getSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetSpaceReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::GetSpaceResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::GetSpaceResp>>(std::move(promise), recv_wrapped_getSpace, channel_);
  getSpace(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::GetSpaceResp> MetaServiceAsyncClient::semifuture_getSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetSpaceReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getSpace, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getSpace(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::GetSpaceResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_getSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetSpaceReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::GetSpaceResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::GetSpaceResp>>(std::move(promise), recv_wrapped_getSpace, channel_);
  getSpace(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetSpaceResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_getSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetSpaceReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getSpace, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getSpace(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::getSpace(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetSpaceReq& p_req) {
  getSpace(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_getSpace( ::nebula::meta::cpp2::GetSpaceResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_getSpace_presult;
  constexpr auto const fname = "getSpace";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_getSpace( ::nebula::meta::cpp2::GetSpaceResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getSpace(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_getSpace( ::nebula::meta::cpp2::GetSpaceResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getSpace(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_getSpace( ::nebula::meta::cpp2::GetSpaceResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getSpace(_return, state);
}

void MetaServiceAsyncClient::listSpaces(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListSpacesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listSpaces(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listSpaces(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListSpacesReq& p_req) {
  auto ctx = listSpacesCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listSpacesImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listSpacesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListSpacesReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listSpacesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listSpacesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listSpacesCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listSpaces");
}

void MetaServiceAsyncClient::sync_listSpaces( ::nebula::meta::cpp2::ListSpacesResp& _return, const  ::nebula::meta::cpp2::ListSpacesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listSpaces(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listSpaces(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListSpacesResp& _return, const  ::nebula::meta::cpp2::ListSpacesReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listSpacesCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listSpacesImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listSpaces(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListSpacesResp> MetaServiceAsyncClient::future_listSpaces(const  ::nebula::meta::cpp2::ListSpacesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listSpaces(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListSpacesResp> MetaServiceAsyncClient::semifuture_listSpaces(const  ::nebula::meta::cpp2::ListSpacesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listSpaces(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListSpacesResp> MetaServiceAsyncClient::future_listSpaces(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSpacesReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListSpacesResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListSpacesResp>>(std::move(promise), recv_wrapped_listSpaces, channel_);
  listSpaces(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListSpacesResp> MetaServiceAsyncClient::semifuture_listSpaces(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSpacesReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listSpaces, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listSpaces(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListSpacesResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listSpaces(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSpacesReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListSpacesResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListSpacesResp>>(std::move(promise), recv_wrapped_listSpaces, channel_);
  listSpaces(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListSpacesResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listSpaces(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSpacesReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listSpaces, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listSpaces(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listSpaces(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListSpacesReq& p_req) {
  listSpaces(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listSpaces( ::nebula::meta::cpp2::ListSpacesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listSpaces_presult;
  constexpr auto const fname = "listSpaces";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listSpaces( ::nebula::meta::cpp2::ListSpacesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listSpaces(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listSpaces( ::nebula::meta::cpp2::ListSpacesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listSpaces(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listSpaces( ::nebula::meta::cpp2::ListSpacesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listSpaces(_return, state);
}

void MetaServiceAsyncClient::createSpaceAs(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  createSpaceAs(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::createSpaceAs(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req) {
  auto ctx = createSpaceAsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  createSpaceAsImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::createSpaceAsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      createSpaceAsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      createSpaceAsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::createSpaceAsCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.createSpaceAs");
}

void MetaServiceAsyncClient::sync_createSpaceAs( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_createSpaceAs(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_createSpaceAs(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = createSpaceAsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  createSpaceAsImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_createSpaceAs(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_createSpaceAs(const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_createSpaceAs(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_createSpaceAs(const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_createSpaceAs(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_createSpaceAs(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_createSpaceAs, channel_);
  createSpaceAs(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_createSpaceAs(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_createSpaceAs, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createSpaceAs(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_createSpaceAs(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_createSpaceAs, channel_);
  createSpaceAs(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_createSpaceAs(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_createSpaceAs, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createSpaceAs(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::createSpaceAs(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req) {
  createSpaceAs(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_createSpaceAs( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_createSpaceAs_presult;
  constexpr auto const fname = "createSpaceAs";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_createSpaceAs( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_createSpaceAs(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_createSpaceAs( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_createSpaceAs(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_createSpaceAs( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_createSpaceAs(_return, state);
}

void MetaServiceAsyncClient::createTag(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateTagReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  createTag(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::createTag(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateTagReq& p_req) {
  auto ctx = createTagCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  createTagImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::createTagImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateTagReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      createTagT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      createTagT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::createTagCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.createTag");
}

void MetaServiceAsyncClient::sync_createTag( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateTagReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_createTag(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_createTag(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateTagReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = createTagCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  createTagImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_createTag(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_createTag(const  ::nebula::meta::cpp2::CreateTagReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_createTag(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_createTag(const  ::nebula::meta::cpp2::CreateTagReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_createTag(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_createTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateTagReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_createTag, channel_);
  createTag(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_createTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateTagReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_createTag, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createTag(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_createTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateTagReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_createTag, channel_);
  createTag(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_createTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateTagReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_createTag, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createTag(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::createTag(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateTagReq& p_req) {
  createTag(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_createTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_createTag_presult;
  constexpr auto const fname = "createTag";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_createTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_createTag(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_createTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_createTag(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_createTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_createTag(_return, state);
}

void MetaServiceAsyncClient::alterTag(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AlterTagReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  alterTag(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::alterTag(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AlterTagReq& p_req) {
  auto ctx = alterTagCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  alterTagImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::alterTagImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AlterTagReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      alterTagT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      alterTagT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::alterTagCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.alterTag");
}

void MetaServiceAsyncClient::sync_alterTag( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AlterTagReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_alterTag(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_alterTag(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AlterTagReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = alterTagCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  alterTagImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_alterTag(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_alterTag(const  ::nebula::meta::cpp2::AlterTagReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_alterTag(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_alterTag(const  ::nebula::meta::cpp2::AlterTagReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_alterTag(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_alterTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterTagReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_alterTag, channel_);
  alterTag(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_alterTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterTagReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_alterTag, channel_);
  auto callback = std::move(callbackAndFuture.first);
  alterTag(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_alterTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterTagReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_alterTag, channel_);
  alterTag(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_alterTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterTagReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_alterTag, channel_);
  auto callback = std::move(callbackAndFuture.first);
  alterTag(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::alterTag(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::AlterTagReq& p_req) {
  alterTag(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_alterTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_alterTag_presult;
  constexpr auto const fname = "alterTag";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_alterTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_alterTag(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_alterTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_alterTag(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_alterTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_alterTag(_return, state);
}

void MetaServiceAsyncClient::dropTag(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropTagReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  dropTag(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::dropTag(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropTagReq& p_req) {
  auto ctx = dropTagCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  dropTagImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::dropTagImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropTagReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      dropTagT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      dropTagT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::dropTagCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.dropTag");
}

void MetaServiceAsyncClient::sync_dropTag( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropTagReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_dropTag(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_dropTag(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropTagReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = dropTagCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  dropTagImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_dropTag(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropTag(const  ::nebula::meta::cpp2::DropTagReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_dropTag(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropTag(const  ::nebula::meta::cpp2::DropTagReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_dropTag(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropTagReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropTag, channel_);
  dropTag(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropTagReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_dropTag, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropTag(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_dropTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropTagReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropTag, channel_);
  dropTag(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_dropTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropTagReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_dropTag, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropTag(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::dropTag(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropTagReq& p_req) {
  dropTag(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_dropTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_dropTag_presult;
  constexpr auto const fname = "dropTag";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_dropTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_dropTag(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_dropTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_dropTag(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_dropTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_dropTag(_return, state);
}

void MetaServiceAsyncClient::getTag(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetTagReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  getTag(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::getTag(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetTagReq& p_req) {
  auto ctx = getTagCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  getTagImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::getTagImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetTagReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getTagT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getTagT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::getTagCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.getTag");
}

void MetaServiceAsyncClient::sync_getTag( ::nebula::meta::cpp2::GetTagResp& _return, const  ::nebula::meta::cpp2::GetTagReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getTag(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_getTag(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetTagResp& _return, const  ::nebula::meta::cpp2::GetTagReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = getTagCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  getTagImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_getTag(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::GetTagResp> MetaServiceAsyncClient::future_getTag(const  ::nebula::meta::cpp2::GetTagReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getTag(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::GetTagResp> MetaServiceAsyncClient::semifuture_getTag(const  ::nebula::meta::cpp2::GetTagReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getTag(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::GetTagResp> MetaServiceAsyncClient::future_getTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetTagReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::GetTagResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::GetTagResp>>(std::move(promise), recv_wrapped_getTag, channel_);
  getTag(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::GetTagResp> MetaServiceAsyncClient::semifuture_getTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetTagReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getTag, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getTag(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::GetTagResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_getTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetTagReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::GetTagResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::GetTagResp>>(std::move(promise), recv_wrapped_getTag, channel_);
  getTag(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetTagResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_getTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetTagReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getTag, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getTag(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::getTag(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetTagReq& p_req) {
  getTag(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_getTag( ::nebula::meta::cpp2::GetTagResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_getTag_presult;
  constexpr auto const fname = "getTag";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_getTag( ::nebula::meta::cpp2::GetTagResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getTag(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_getTag( ::nebula::meta::cpp2::GetTagResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getTag(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_getTag( ::nebula::meta::cpp2::GetTagResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getTag(_return, state);
}

void MetaServiceAsyncClient::listTags(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListTagsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listTags(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listTags(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListTagsReq& p_req) {
  auto ctx = listTagsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listTagsImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listTagsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListTagsReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listTagsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listTagsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listTagsCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listTags");
}

void MetaServiceAsyncClient::sync_listTags( ::nebula::meta::cpp2::ListTagsResp& _return, const  ::nebula::meta::cpp2::ListTagsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listTags(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listTags(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListTagsResp& _return, const  ::nebula::meta::cpp2::ListTagsReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listTagsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listTagsImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listTags(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListTagsResp> MetaServiceAsyncClient::future_listTags(const  ::nebula::meta::cpp2::ListTagsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listTags(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListTagsResp> MetaServiceAsyncClient::semifuture_listTags(const  ::nebula::meta::cpp2::ListTagsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listTags(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListTagsResp> MetaServiceAsyncClient::future_listTags(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListTagsReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListTagsResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListTagsResp>>(std::move(promise), recv_wrapped_listTags, channel_);
  listTags(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListTagsResp> MetaServiceAsyncClient::semifuture_listTags(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListTagsReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listTags, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listTags(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListTagsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listTags(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListTagsReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListTagsResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListTagsResp>>(std::move(promise), recv_wrapped_listTags, channel_);
  listTags(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListTagsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listTags(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListTagsReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listTags, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listTags(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listTags(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListTagsReq& p_req) {
  listTags(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listTags( ::nebula::meta::cpp2::ListTagsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listTags_presult;
  constexpr auto const fname = "listTags";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listTags( ::nebula::meta::cpp2::ListTagsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listTags(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listTags( ::nebula::meta::cpp2::ListTagsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listTags(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listTags( ::nebula::meta::cpp2::ListTagsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listTags(_return, state);
}

void MetaServiceAsyncClient::createEdge(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  createEdge(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::createEdge(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req) {
  auto ctx = createEdgeCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  createEdgeImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::createEdgeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      createEdgeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      createEdgeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::createEdgeCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.createEdge");
}

void MetaServiceAsyncClient::sync_createEdge( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_createEdge(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_createEdge(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = createEdgeCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  createEdgeImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_createEdge(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_createEdge(const  ::nebula::meta::cpp2::CreateEdgeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_createEdge(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_createEdge(const  ::nebula::meta::cpp2::CreateEdgeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_createEdge(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_createEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_createEdge, channel_);
  createEdge(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_createEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_createEdge, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createEdge(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_createEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_createEdge, channel_);
  createEdge(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_createEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_createEdge, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createEdge(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::createEdge(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req) {
  createEdge(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_createEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_createEdge_presult;
  constexpr auto const fname = "createEdge";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_createEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_createEdge(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_createEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_createEdge(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_createEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_createEdge(_return, state);
}

void MetaServiceAsyncClient::alterEdge(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  alterEdge(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::alterEdge(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req) {
  auto ctx = alterEdgeCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  alterEdgeImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::alterEdgeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      alterEdgeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      alterEdgeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::alterEdgeCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.alterEdge");
}

void MetaServiceAsyncClient::sync_alterEdge( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_alterEdge(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_alterEdge(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = alterEdgeCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  alterEdgeImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_alterEdge(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_alterEdge(const  ::nebula::meta::cpp2::AlterEdgeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_alterEdge(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_alterEdge(const  ::nebula::meta::cpp2::AlterEdgeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_alterEdge(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_alterEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_alterEdge, channel_);
  alterEdge(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_alterEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_alterEdge, channel_);
  auto callback = std::move(callbackAndFuture.first);
  alterEdge(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_alterEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_alterEdge, channel_);
  alterEdge(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_alterEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_alterEdge, channel_);
  auto callback = std::move(callbackAndFuture.first);
  alterEdge(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::alterEdge(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req) {
  alterEdge(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_alterEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_alterEdge_presult;
  constexpr auto const fname = "alterEdge";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_alterEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_alterEdge(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_alterEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_alterEdge(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_alterEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_alterEdge(_return, state);
}

void MetaServiceAsyncClient::dropEdge(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropEdgeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  dropEdge(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::dropEdge(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropEdgeReq& p_req) {
  auto ctx = dropEdgeCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  dropEdgeImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::dropEdgeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropEdgeReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      dropEdgeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      dropEdgeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::dropEdgeCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.dropEdge");
}

void MetaServiceAsyncClient::sync_dropEdge( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropEdgeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_dropEdge(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_dropEdge(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropEdgeReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = dropEdgeCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  dropEdgeImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_dropEdge(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropEdge(const  ::nebula::meta::cpp2::DropEdgeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_dropEdge(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropEdge(const  ::nebula::meta::cpp2::DropEdgeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_dropEdge(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropEdgeReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropEdge, channel_);
  dropEdge(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropEdgeReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_dropEdge, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropEdge(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_dropEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropEdgeReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropEdge, channel_);
  dropEdge(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_dropEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropEdgeReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_dropEdge, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropEdge(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::dropEdge(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropEdgeReq& p_req) {
  dropEdge(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_dropEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_dropEdge_presult;
  constexpr auto const fname = "dropEdge";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_dropEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_dropEdge(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_dropEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_dropEdge(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_dropEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_dropEdge(_return, state);
}

void MetaServiceAsyncClient::getEdge(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetEdgeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  getEdge(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::getEdge(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetEdgeReq& p_req) {
  auto ctx = getEdgeCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  getEdgeImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::getEdgeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetEdgeReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getEdgeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getEdgeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::getEdgeCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.getEdge");
}

void MetaServiceAsyncClient::sync_getEdge( ::nebula::meta::cpp2::GetEdgeResp& _return, const  ::nebula::meta::cpp2::GetEdgeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getEdge(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_getEdge(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetEdgeResp& _return, const  ::nebula::meta::cpp2::GetEdgeReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = getEdgeCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  getEdgeImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_getEdge(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::GetEdgeResp> MetaServiceAsyncClient::future_getEdge(const  ::nebula::meta::cpp2::GetEdgeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getEdge(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::GetEdgeResp> MetaServiceAsyncClient::semifuture_getEdge(const  ::nebula::meta::cpp2::GetEdgeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getEdge(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::GetEdgeResp> MetaServiceAsyncClient::future_getEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetEdgeReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::GetEdgeResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::GetEdgeResp>>(std::move(promise), recv_wrapped_getEdge, channel_);
  getEdge(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::GetEdgeResp> MetaServiceAsyncClient::semifuture_getEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetEdgeReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getEdge, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getEdge(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::GetEdgeResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_getEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetEdgeReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::GetEdgeResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::GetEdgeResp>>(std::move(promise), recv_wrapped_getEdge, channel_);
  getEdge(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetEdgeResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_getEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetEdgeReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getEdge, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getEdge(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::getEdge(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetEdgeReq& p_req) {
  getEdge(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_getEdge( ::nebula::meta::cpp2::GetEdgeResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_getEdge_presult;
  constexpr auto const fname = "getEdge";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_getEdge( ::nebula::meta::cpp2::GetEdgeResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getEdge(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_getEdge( ::nebula::meta::cpp2::GetEdgeResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getEdge(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_getEdge( ::nebula::meta::cpp2::GetEdgeResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getEdge(_return, state);
}

void MetaServiceAsyncClient::listEdges(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListEdgesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listEdges(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listEdges(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListEdgesReq& p_req) {
  auto ctx = listEdgesCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listEdgesImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listEdgesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListEdgesReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listEdgesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listEdgesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listEdgesCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listEdges");
}

void MetaServiceAsyncClient::sync_listEdges( ::nebula::meta::cpp2::ListEdgesResp& _return, const  ::nebula::meta::cpp2::ListEdgesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listEdges(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listEdges(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListEdgesResp& _return, const  ::nebula::meta::cpp2::ListEdgesReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listEdgesCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listEdgesImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listEdges(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListEdgesResp> MetaServiceAsyncClient::future_listEdges(const  ::nebula::meta::cpp2::ListEdgesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listEdges(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListEdgesResp> MetaServiceAsyncClient::semifuture_listEdges(const  ::nebula::meta::cpp2::ListEdgesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listEdges(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListEdgesResp> MetaServiceAsyncClient::future_listEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListEdgesReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListEdgesResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListEdgesResp>>(std::move(promise), recv_wrapped_listEdges, channel_);
  listEdges(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListEdgesResp> MetaServiceAsyncClient::semifuture_listEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListEdgesReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listEdges, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listEdges(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListEdgesResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListEdgesReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListEdgesResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListEdgesResp>>(std::move(promise), recv_wrapped_listEdges, channel_);
  listEdges(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListEdgesResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListEdgesReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listEdges, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listEdges(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listEdges(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListEdgesReq& p_req) {
  listEdges(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listEdges( ::nebula::meta::cpp2::ListEdgesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listEdges_presult;
  constexpr auto const fname = "listEdges";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listEdges( ::nebula::meta::cpp2::ListEdgesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listEdges(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listEdges( ::nebula::meta::cpp2::ListEdgesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listEdges(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listEdges( ::nebula::meta::cpp2::ListEdgesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listEdges(_return, state);
}

void MetaServiceAsyncClient::listHosts(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListHostsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listHosts(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listHosts(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListHostsReq& p_req) {
  auto ctx = listHostsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listHostsImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listHostsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListHostsReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listHostsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listHostsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listHostsCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listHosts");
}

void MetaServiceAsyncClient::sync_listHosts( ::nebula::meta::cpp2::ListHostsResp& _return, const  ::nebula::meta::cpp2::ListHostsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listHosts(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listHosts(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListHostsResp& _return, const  ::nebula::meta::cpp2::ListHostsReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listHostsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listHostsImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listHosts(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListHostsResp> MetaServiceAsyncClient::future_listHosts(const  ::nebula::meta::cpp2::ListHostsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listHosts(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListHostsResp> MetaServiceAsyncClient::semifuture_listHosts(const  ::nebula::meta::cpp2::ListHostsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listHosts(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListHostsResp> MetaServiceAsyncClient::future_listHosts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListHostsReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListHostsResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListHostsResp>>(std::move(promise), recv_wrapped_listHosts, channel_);
  listHosts(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListHostsResp> MetaServiceAsyncClient::semifuture_listHosts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListHostsReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listHosts, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listHosts(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListHostsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listHosts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListHostsReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListHostsResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListHostsResp>>(std::move(promise), recv_wrapped_listHosts, channel_);
  listHosts(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListHostsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listHosts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListHostsReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listHosts, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listHosts(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listHosts(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListHostsReq& p_req) {
  listHosts(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listHosts( ::nebula::meta::cpp2::ListHostsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listHosts_presult;
  constexpr auto const fname = "listHosts";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listHosts( ::nebula::meta::cpp2::ListHostsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listHosts(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listHosts( ::nebula::meta::cpp2::ListHostsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listHosts(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listHosts( ::nebula::meta::cpp2::ListHostsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listHosts(_return, state);
}

void MetaServiceAsyncClient::getPartsAlloc(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  getPartsAlloc(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::getPartsAlloc(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req) {
  auto ctx = getPartsAllocCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  getPartsAllocImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::getPartsAllocImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getPartsAllocT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getPartsAllocT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::getPartsAllocCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.getPartsAlloc");
}

void MetaServiceAsyncClient::sync_getPartsAlloc( ::nebula::meta::cpp2::GetPartsAllocResp& _return, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getPartsAlloc(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_getPartsAlloc(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetPartsAllocResp& _return, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = getPartsAllocCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  getPartsAllocImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_getPartsAlloc(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::GetPartsAllocResp> MetaServiceAsyncClient::future_getPartsAlloc(const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getPartsAlloc(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::GetPartsAllocResp> MetaServiceAsyncClient::semifuture_getPartsAlloc(const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getPartsAlloc(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::GetPartsAllocResp> MetaServiceAsyncClient::future_getPartsAlloc(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::GetPartsAllocResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::GetPartsAllocResp>>(std::move(promise), recv_wrapped_getPartsAlloc, channel_);
  getPartsAlloc(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::GetPartsAllocResp> MetaServiceAsyncClient::semifuture_getPartsAlloc(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getPartsAlloc, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getPartsAlloc(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::GetPartsAllocResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_getPartsAlloc(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::GetPartsAllocResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::GetPartsAllocResp>>(std::move(promise), recv_wrapped_getPartsAlloc, channel_);
  getPartsAlloc(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetPartsAllocResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_getPartsAlloc(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getPartsAlloc, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getPartsAlloc(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::getPartsAlloc(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req) {
  getPartsAlloc(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_getPartsAlloc( ::nebula::meta::cpp2::GetPartsAllocResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_getPartsAlloc_presult;
  constexpr auto const fname = "getPartsAlloc";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_getPartsAlloc( ::nebula::meta::cpp2::GetPartsAllocResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getPartsAlloc(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_getPartsAlloc( ::nebula::meta::cpp2::GetPartsAllocResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getPartsAlloc(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_getPartsAlloc( ::nebula::meta::cpp2::GetPartsAllocResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getPartsAlloc(_return, state);
}

void MetaServiceAsyncClient::listParts(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListPartsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listParts(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listParts(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListPartsReq& p_req) {
  auto ctx = listPartsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listPartsImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listPartsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListPartsReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listPartsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listPartsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listPartsCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listParts");
}

void MetaServiceAsyncClient::sync_listParts( ::nebula::meta::cpp2::ListPartsResp& _return, const  ::nebula::meta::cpp2::ListPartsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listParts(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listParts(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListPartsResp& _return, const  ::nebula::meta::cpp2::ListPartsReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listPartsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listPartsImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listParts(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListPartsResp> MetaServiceAsyncClient::future_listParts(const  ::nebula::meta::cpp2::ListPartsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listParts(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListPartsResp> MetaServiceAsyncClient::semifuture_listParts(const  ::nebula::meta::cpp2::ListPartsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listParts(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListPartsResp> MetaServiceAsyncClient::future_listParts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListPartsReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListPartsResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListPartsResp>>(std::move(promise), recv_wrapped_listParts, channel_);
  listParts(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListPartsResp> MetaServiceAsyncClient::semifuture_listParts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListPartsReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listParts, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listParts(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListPartsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listParts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListPartsReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListPartsResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListPartsResp>>(std::move(promise), recv_wrapped_listParts, channel_);
  listParts(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListPartsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listParts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListPartsReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listParts, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listParts(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listParts(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListPartsReq& p_req) {
  listParts(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listParts( ::nebula::meta::cpp2::ListPartsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listParts_presult;
  constexpr auto const fname = "listParts";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listParts( ::nebula::meta::cpp2::ListPartsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listParts(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listParts( ::nebula::meta::cpp2::ListPartsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listParts(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listParts( ::nebula::meta::cpp2::ListPartsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listParts(_return, state);
}

void MetaServiceAsyncClient::multiPut(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::MultiPutReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  multiPut(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::multiPut(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::MultiPutReq& p_req) {
  auto ctx = multiPutCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  multiPutImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::multiPutImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::MultiPutReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      multiPutT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      multiPutT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::multiPutCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.multiPut");
}

void MetaServiceAsyncClient::sync_multiPut( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::MultiPutReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_multiPut(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_multiPut(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::MultiPutReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = multiPutCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  multiPutImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_multiPut(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_multiPut(const  ::nebula::meta::cpp2::MultiPutReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_multiPut(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_multiPut(const  ::nebula::meta::cpp2::MultiPutReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_multiPut(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_multiPut(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MultiPutReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_multiPut, channel_);
  multiPut(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_multiPut(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MultiPutReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_multiPut, channel_);
  auto callback = std::move(callbackAndFuture.first);
  multiPut(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_multiPut(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MultiPutReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_multiPut, channel_);
  multiPut(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_multiPut(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MultiPutReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_multiPut, channel_);
  auto callback = std::move(callbackAndFuture.first);
  multiPut(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::multiPut(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::MultiPutReq& p_req) {
  multiPut(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_multiPut( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_multiPut_presult;
  constexpr auto const fname = "multiPut";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_multiPut( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_multiPut(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_multiPut( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_multiPut(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_multiPut( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_multiPut(_return, state);
}

void MetaServiceAsyncClient::get(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  get(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::get(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetReq& p_req) {
  auto ctx = getCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  getImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::getImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::getCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.get");
}

void MetaServiceAsyncClient::sync_get( ::nebula::meta::cpp2::GetResp& _return, const  ::nebula::meta::cpp2::GetReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_get(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_get(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetResp& _return, const  ::nebula::meta::cpp2::GetReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = getCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  getImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_get(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::GetResp> MetaServiceAsyncClient::future_get(const  ::nebula::meta::cpp2::GetReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_get(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::GetResp> MetaServiceAsyncClient::semifuture_get(const  ::nebula::meta::cpp2::GetReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_get(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::GetResp> MetaServiceAsyncClient::future_get(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::GetResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::GetResp>>(std::move(promise), recv_wrapped_get, channel_);
  get(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::GetResp> MetaServiceAsyncClient::semifuture_get(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_get, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::GetResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_get(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::GetResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::GetResp>>(std::move(promise), recv_wrapped_get, channel_);
  get(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_get(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_get, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::get(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetReq& p_req) {
  get(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_get( ::nebula::meta::cpp2::GetResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_get_presult;
  constexpr auto const fname = "get";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_get( ::nebula::meta::cpp2::GetResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_get(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_get( ::nebula::meta::cpp2::GetResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_get(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_get( ::nebula::meta::cpp2::GetResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_get(_return, state);
}

void MetaServiceAsyncClient::multiGet(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::MultiGetReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  multiGet(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::multiGet(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::MultiGetReq& p_req) {
  auto ctx = multiGetCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  multiGetImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::multiGetImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::MultiGetReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      multiGetT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      multiGetT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::multiGetCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.multiGet");
}

void MetaServiceAsyncClient::sync_multiGet( ::nebula::meta::cpp2::MultiGetResp& _return, const  ::nebula::meta::cpp2::MultiGetReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_multiGet(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_multiGet(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::MultiGetResp& _return, const  ::nebula::meta::cpp2::MultiGetReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = multiGetCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  multiGetImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_multiGet(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::MultiGetResp> MetaServiceAsyncClient::future_multiGet(const  ::nebula::meta::cpp2::MultiGetReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_multiGet(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::MultiGetResp> MetaServiceAsyncClient::semifuture_multiGet(const  ::nebula::meta::cpp2::MultiGetReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_multiGet(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::MultiGetResp> MetaServiceAsyncClient::future_multiGet(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MultiGetReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::MultiGetResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::MultiGetResp>>(std::move(promise), recv_wrapped_multiGet, channel_);
  multiGet(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::MultiGetResp> MetaServiceAsyncClient::semifuture_multiGet(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MultiGetReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_multiGet, channel_);
  auto callback = std::move(callbackAndFuture.first);
  multiGet(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::MultiGetResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_multiGet(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MultiGetReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::MultiGetResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::MultiGetResp>>(std::move(promise), recv_wrapped_multiGet, channel_);
  multiGet(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::MultiGetResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_multiGet(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MultiGetReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_multiGet, channel_);
  auto callback = std::move(callbackAndFuture.first);
  multiGet(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::multiGet(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::MultiGetReq& p_req) {
  multiGet(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_multiGet( ::nebula::meta::cpp2::MultiGetResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_multiGet_presult;
  constexpr auto const fname = "multiGet";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_multiGet( ::nebula::meta::cpp2::MultiGetResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_multiGet(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_multiGet( ::nebula::meta::cpp2::MultiGetResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_multiGet(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_multiGet( ::nebula::meta::cpp2::MultiGetResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_multiGet(_return, state);
}

void MetaServiceAsyncClient::remove(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RemoveReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  remove(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::remove(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RemoveReq& p_req) {
  auto ctx = removeCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  removeImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::removeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RemoveReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      removeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      removeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::removeCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.remove");
}

void MetaServiceAsyncClient::sync_remove( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RemoveReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_remove(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_remove(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RemoveReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = removeCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  removeImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_remove(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_remove(const  ::nebula::meta::cpp2::RemoveReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_remove(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_remove(const  ::nebula::meta::cpp2::RemoveReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_remove(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_remove(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_remove, channel_);
  remove(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_remove(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_remove, channel_);
  auto callback = std::move(callbackAndFuture.first);
  remove(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_remove(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_remove, channel_);
  remove(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_remove(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_remove, channel_);
  auto callback = std::move(callbackAndFuture.first);
  remove(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::remove(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::RemoveReq& p_req) {
  remove(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_remove( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_remove_presult;
  constexpr auto const fname = "remove";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_remove( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_remove(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_remove( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_remove(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_remove( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_remove(_return, state);
}

void MetaServiceAsyncClient::removeRange(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  removeRange(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::removeRange(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req) {
  auto ctx = removeRangeCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  removeRangeImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::removeRangeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      removeRangeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      removeRangeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::removeRangeCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.removeRange");
}

void MetaServiceAsyncClient::sync_removeRange( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_removeRange(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_removeRange(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = removeRangeCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  removeRangeImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_removeRange(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_removeRange(const  ::nebula::meta::cpp2::RemoveRangeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_removeRange(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_removeRange(const  ::nebula::meta::cpp2::RemoveRangeReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_removeRange(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_removeRange(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_removeRange, channel_);
  removeRange(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_removeRange(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_removeRange, channel_);
  auto callback = std::move(callbackAndFuture.first);
  removeRange(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_removeRange(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_removeRange, channel_);
  removeRange(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_removeRange(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_removeRange, channel_);
  auto callback = std::move(callbackAndFuture.first);
  removeRange(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::removeRange(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req) {
  removeRange(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_removeRange( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_removeRange_presult;
  constexpr auto const fname = "removeRange";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_removeRange( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_removeRange(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_removeRange( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_removeRange(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_removeRange( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_removeRange(_return, state);
}

void MetaServiceAsyncClient::scan(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ScanReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  scan(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::scan(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ScanReq& p_req) {
  auto ctx = scanCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  scanImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::scanImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ScanReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      scanT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      scanT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::scanCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.scan");
}

void MetaServiceAsyncClient::sync_scan( ::nebula::meta::cpp2::ScanResp& _return, const  ::nebula::meta::cpp2::ScanReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_scan(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_scan(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ScanResp& _return, const  ::nebula::meta::cpp2::ScanReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = scanCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  scanImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_scan(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ScanResp> MetaServiceAsyncClient::future_scan(const  ::nebula::meta::cpp2::ScanReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_scan(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ScanResp> MetaServiceAsyncClient::semifuture_scan(const  ::nebula::meta::cpp2::ScanReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_scan(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ScanResp> MetaServiceAsyncClient::future_scan(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ScanReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ScanResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ScanResp>>(std::move(promise), recv_wrapped_scan, channel_);
  scan(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ScanResp> MetaServiceAsyncClient::semifuture_scan(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ScanReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_scan, channel_);
  auto callback = std::move(callbackAndFuture.first);
  scan(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ScanResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_scan(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ScanReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ScanResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ScanResp>>(std::move(promise), recv_wrapped_scan, channel_);
  scan(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ScanResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_scan(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ScanReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_scan, channel_);
  auto callback = std::move(callbackAndFuture.first);
  scan(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::scan(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ScanReq& p_req) {
  scan(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_scan( ::nebula::meta::cpp2::ScanResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_scan_presult;
  constexpr auto const fname = "scan";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_scan( ::nebula::meta::cpp2::ScanResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_scan(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_scan( ::nebula::meta::cpp2::ScanResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_scan(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_scan( ::nebula::meta::cpp2::ScanResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_scan(_return, state);
}

void MetaServiceAsyncClient::createTagIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  createTagIndex(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::createTagIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req) {
  auto ctx = createTagIndexCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  createTagIndexImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::createTagIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      createTagIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      createTagIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::createTagIndexCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.createTagIndex");
}

void MetaServiceAsyncClient::sync_createTagIndex( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_createTagIndex(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_createTagIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = createTagIndexCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  createTagIndexImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_createTagIndex(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_createTagIndex(const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_createTagIndex(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_createTagIndex(const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_createTagIndex(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_createTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_createTagIndex, channel_);
  createTagIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_createTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_createTagIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createTagIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_createTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_createTagIndex, channel_);
  createTagIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_createTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_createTagIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createTagIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::createTagIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req) {
  createTagIndex(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_createTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_createTagIndex_presult;
  constexpr auto const fname = "createTagIndex";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_createTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_createTagIndex(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_createTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_createTagIndex(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_createTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_createTagIndex(_return, state);
}

void MetaServiceAsyncClient::dropTagIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  dropTagIndex(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::dropTagIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req) {
  auto ctx = dropTagIndexCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  dropTagIndexImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::dropTagIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      dropTagIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      dropTagIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::dropTagIndexCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.dropTagIndex");
}

void MetaServiceAsyncClient::sync_dropTagIndex( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_dropTagIndex(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_dropTagIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = dropTagIndexCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  dropTagIndexImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_dropTagIndex(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropTagIndex(const  ::nebula::meta::cpp2::DropTagIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_dropTagIndex(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropTagIndex(const  ::nebula::meta::cpp2::DropTagIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_dropTagIndex(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropTagIndex, channel_);
  dropTagIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_dropTagIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropTagIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_dropTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropTagIndex, channel_);
  dropTagIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_dropTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_dropTagIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropTagIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::dropTagIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req) {
  dropTagIndex(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_dropTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_dropTagIndex_presult;
  constexpr auto const fname = "dropTagIndex";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_dropTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_dropTagIndex(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_dropTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_dropTagIndex(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_dropTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_dropTagIndex(_return, state);
}

void MetaServiceAsyncClient::getTagIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  getTagIndex(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::getTagIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req) {
  auto ctx = getTagIndexCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  getTagIndexImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::getTagIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getTagIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getTagIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::getTagIndexCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.getTagIndex");
}

void MetaServiceAsyncClient::sync_getTagIndex( ::nebula::meta::cpp2::GetTagIndexResp& _return, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getTagIndex(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_getTagIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetTagIndexResp& _return, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = getTagIndexCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  getTagIndexImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_getTagIndex(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::GetTagIndexResp> MetaServiceAsyncClient::future_getTagIndex(const  ::nebula::meta::cpp2::GetTagIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getTagIndex(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::GetTagIndexResp> MetaServiceAsyncClient::semifuture_getTagIndex(const  ::nebula::meta::cpp2::GetTagIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getTagIndex(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::GetTagIndexResp> MetaServiceAsyncClient::future_getTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::GetTagIndexResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::GetTagIndexResp>>(std::move(promise), recv_wrapped_getTagIndex, channel_);
  getTagIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::GetTagIndexResp> MetaServiceAsyncClient::semifuture_getTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getTagIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getTagIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::GetTagIndexResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_getTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::GetTagIndexResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::GetTagIndexResp>>(std::move(promise), recv_wrapped_getTagIndex, channel_);
  getTagIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetTagIndexResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_getTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getTagIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getTagIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::getTagIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req) {
  getTagIndex(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_getTagIndex( ::nebula::meta::cpp2::GetTagIndexResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_getTagIndex_presult;
  constexpr auto const fname = "getTagIndex";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_getTagIndex( ::nebula::meta::cpp2::GetTagIndexResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getTagIndex(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_getTagIndex( ::nebula::meta::cpp2::GetTagIndexResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getTagIndex(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_getTagIndex( ::nebula::meta::cpp2::GetTagIndexResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getTagIndex(_return, state);
}

void MetaServiceAsyncClient::listTagIndexes(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listTagIndexes(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listTagIndexes(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req) {
  auto ctx = listTagIndexesCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listTagIndexesImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listTagIndexesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listTagIndexesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listTagIndexesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listTagIndexesCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listTagIndexes");
}

void MetaServiceAsyncClient::sync_listTagIndexes( ::nebula::meta::cpp2::ListTagIndexesResp& _return, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listTagIndexes(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listTagIndexes(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListTagIndexesResp& _return, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listTagIndexesCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listTagIndexesImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listTagIndexes(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListTagIndexesResp> MetaServiceAsyncClient::future_listTagIndexes(const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listTagIndexes(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListTagIndexesResp> MetaServiceAsyncClient::semifuture_listTagIndexes(const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listTagIndexes(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListTagIndexesResp> MetaServiceAsyncClient::future_listTagIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListTagIndexesResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListTagIndexesResp>>(std::move(promise), recv_wrapped_listTagIndexes, channel_);
  listTagIndexes(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListTagIndexesResp> MetaServiceAsyncClient::semifuture_listTagIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listTagIndexes, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listTagIndexes(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListTagIndexesResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listTagIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListTagIndexesResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListTagIndexesResp>>(std::move(promise), recv_wrapped_listTagIndexes, channel_);
  listTagIndexes(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListTagIndexesResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listTagIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listTagIndexes, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listTagIndexes(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listTagIndexes(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req) {
  listTagIndexes(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listTagIndexes( ::nebula::meta::cpp2::ListTagIndexesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listTagIndexes_presult;
  constexpr auto const fname = "listTagIndexes";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listTagIndexes( ::nebula::meta::cpp2::ListTagIndexesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listTagIndexes(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listTagIndexes( ::nebula::meta::cpp2::ListTagIndexesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listTagIndexes(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listTagIndexes( ::nebula::meta::cpp2::ListTagIndexesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listTagIndexes(_return, state);
}

void MetaServiceAsyncClient::rebuildTagIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  rebuildTagIndex(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::rebuildTagIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  auto ctx = rebuildTagIndexCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  rebuildTagIndexImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::rebuildTagIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      rebuildTagIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      rebuildTagIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::rebuildTagIndexCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.rebuildTagIndex");
}

void MetaServiceAsyncClient::sync_rebuildTagIndex( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_rebuildTagIndex(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_rebuildTagIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = rebuildTagIndexCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  rebuildTagIndexImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_rebuildTagIndex(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_rebuildTagIndex(const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_rebuildTagIndex(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_rebuildTagIndex(const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_rebuildTagIndex(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_rebuildTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_rebuildTagIndex, channel_);
  rebuildTagIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_rebuildTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_rebuildTagIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  rebuildTagIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_rebuildTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_rebuildTagIndex, channel_);
  rebuildTagIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_rebuildTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_rebuildTagIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  rebuildTagIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::rebuildTagIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  rebuildTagIndex(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_rebuildTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_rebuildTagIndex_presult;
  constexpr auto const fname = "rebuildTagIndex";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_rebuildTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_rebuildTagIndex(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_rebuildTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_rebuildTagIndex(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_rebuildTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_rebuildTagIndex(_return, state);
}

void MetaServiceAsyncClient::listTagIndexStatus(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listTagIndexStatus(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listTagIndexStatus(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  auto ctx = listTagIndexStatusCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listTagIndexStatusImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listTagIndexStatusImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listTagIndexStatusT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listTagIndexStatusT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listTagIndexStatusCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listTagIndexStatus");
}

void MetaServiceAsyncClient::sync_listTagIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listTagIndexStatus(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listTagIndexStatus(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListIndexStatusResp& _return, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listTagIndexStatusCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listTagIndexStatusImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listTagIndexStatus(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListIndexStatusResp> MetaServiceAsyncClient::future_listTagIndexStatus(const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listTagIndexStatus(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListIndexStatusResp> MetaServiceAsyncClient::semifuture_listTagIndexStatus(const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listTagIndexStatus(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListIndexStatusResp> MetaServiceAsyncClient::future_listTagIndexStatus(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListIndexStatusResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListIndexStatusResp>>(std::move(promise), recv_wrapped_listTagIndexStatus, channel_);
  listTagIndexStatus(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListIndexStatusResp> MetaServiceAsyncClient::semifuture_listTagIndexStatus(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listTagIndexStatus, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listTagIndexStatus(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListIndexStatusResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listTagIndexStatus(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListIndexStatusResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListIndexStatusResp>>(std::move(promise), recv_wrapped_listTagIndexStatus, channel_);
  listTagIndexStatus(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListIndexStatusResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listTagIndexStatus(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listTagIndexStatus, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listTagIndexStatus(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listTagIndexStatus(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  listTagIndexStatus(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listTagIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listTagIndexStatus_presult;
  constexpr auto const fname = "listTagIndexStatus";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listTagIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listTagIndexStatus(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listTagIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listTagIndexStatus(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listTagIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listTagIndexStatus(_return, state);
}

void MetaServiceAsyncClient::createEdgeIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  createEdgeIndex(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::createEdgeIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req) {
  auto ctx = createEdgeIndexCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  createEdgeIndexImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::createEdgeIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      createEdgeIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      createEdgeIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::createEdgeIndexCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.createEdgeIndex");
}

void MetaServiceAsyncClient::sync_createEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_createEdgeIndex(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_createEdgeIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = createEdgeIndexCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  createEdgeIndexImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_createEdgeIndex(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_createEdgeIndex(const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_createEdgeIndex(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_createEdgeIndex(const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_createEdgeIndex(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_createEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_createEdgeIndex, channel_);
  createEdgeIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_createEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_createEdgeIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createEdgeIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_createEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_createEdgeIndex, channel_);
  createEdgeIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_createEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_createEdgeIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createEdgeIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::createEdgeIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req) {
  createEdgeIndex(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_createEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_createEdgeIndex_presult;
  constexpr auto const fname = "createEdgeIndex";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_createEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_createEdgeIndex(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_createEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_createEdgeIndex(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_createEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_createEdgeIndex(_return, state);
}

void MetaServiceAsyncClient::dropEdgeIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  dropEdgeIndex(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::dropEdgeIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req) {
  auto ctx = dropEdgeIndexCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  dropEdgeIndexImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::dropEdgeIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      dropEdgeIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      dropEdgeIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::dropEdgeIndexCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.dropEdgeIndex");
}

void MetaServiceAsyncClient::sync_dropEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_dropEdgeIndex(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_dropEdgeIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = dropEdgeIndexCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  dropEdgeIndexImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_dropEdgeIndex(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropEdgeIndex(const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_dropEdgeIndex(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropEdgeIndex(const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_dropEdgeIndex(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropEdgeIndex, channel_);
  dropEdgeIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_dropEdgeIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropEdgeIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_dropEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropEdgeIndex, channel_);
  dropEdgeIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_dropEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_dropEdgeIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropEdgeIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::dropEdgeIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req) {
  dropEdgeIndex(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_dropEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_dropEdgeIndex_presult;
  constexpr auto const fname = "dropEdgeIndex";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_dropEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_dropEdgeIndex(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_dropEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_dropEdgeIndex(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_dropEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_dropEdgeIndex(_return, state);
}

void MetaServiceAsyncClient::getEdgeIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  getEdgeIndex(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::getEdgeIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req) {
  auto ctx = getEdgeIndexCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  getEdgeIndexImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::getEdgeIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getEdgeIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getEdgeIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::getEdgeIndexCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.getEdgeIndex");
}

void MetaServiceAsyncClient::sync_getEdgeIndex( ::nebula::meta::cpp2::GetEdgeIndexResp& _return, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getEdgeIndex(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_getEdgeIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetEdgeIndexResp& _return, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = getEdgeIndexCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  getEdgeIndexImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_getEdgeIndex(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::GetEdgeIndexResp> MetaServiceAsyncClient::future_getEdgeIndex(const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getEdgeIndex(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::GetEdgeIndexResp> MetaServiceAsyncClient::semifuture_getEdgeIndex(const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getEdgeIndex(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::GetEdgeIndexResp> MetaServiceAsyncClient::future_getEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::GetEdgeIndexResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::GetEdgeIndexResp>>(std::move(promise), recv_wrapped_getEdgeIndex, channel_);
  getEdgeIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::GetEdgeIndexResp> MetaServiceAsyncClient::semifuture_getEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getEdgeIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getEdgeIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::GetEdgeIndexResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_getEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::GetEdgeIndexResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::GetEdgeIndexResp>>(std::move(promise), recv_wrapped_getEdgeIndex, channel_);
  getEdgeIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetEdgeIndexResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_getEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getEdgeIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getEdgeIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::getEdgeIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req) {
  getEdgeIndex(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_getEdgeIndex( ::nebula::meta::cpp2::GetEdgeIndexResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_getEdgeIndex_presult;
  constexpr auto const fname = "getEdgeIndex";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_getEdgeIndex( ::nebula::meta::cpp2::GetEdgeIndexResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getEdgeIndex(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_getEdgeIndex( ::nebula::meta::cpp2::GetEdgeIndexResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getEdgeIndex(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_getEdgeIndex( ::nebula::meta::cpp2::GetEdgeIndexResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getEdgeIndex(_return, state);
}

void MetaServiceAsyncClient::listEdgeIndexes(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listEdgeIndexes(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listEdgeIndexes(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req) {
  auto ctx = listEdgeIndexesCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listEdgeIndexesImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listEdgeIndexesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listEdgeIndexesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listEdgeIndexesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listEdgeIndexesCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listEdgeIndexes");
}

void MetaServiceAsyncClient::sync_listEdgeIndexes( ::nebula::meta::cpp2::ListEdgeIndexesResp& _return, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listEdgeIndexes(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listEdgeIndexes(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListEdgeIndexesResp& _return, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listEdgeIndexesCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listEdgeIndexesImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listEdgeIndexes(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListEdgeIndexesResp> MetaServiceAsyncClient::future_listEdgeIndexes(const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listEdgeIndexes(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListEdgeIndexesResp> MetaServiceAsyncClient::semifuture_listEdgeIndexes(const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listEdgeIndexes(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListEdgeIndexesResp> MetaServiceAsyncClient::future_listEdgeIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListEdgeIndexesResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListEdgeIndexesResp>>(std::move(promise), recv_wrapped_listEdgeIndexes, channel_);
  listEdgeIndexes(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListEdgeIndexesResp> MetaServiceAsyncClient::semifuture_listEdgeIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listEdgeIndexes, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listEdgeIndexes(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListEdgeIndexesResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listEdgeIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListEdgeIndexesResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListEdgeIndexesResp>>(std::move(promise), recv_wrapped_listEdgeIndexes, channel_);
  listEdgeIndexes(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListEdgeIndexesResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listEdgeIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listEdgeIndexes, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listEdgeIndexes(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listEdgeIndexes(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req) {
  listEdgeIndexes(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listEdgeIndexes( ::nebula::meta::cpp2::ListEdgeIndexesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listEdgeIndexes_presult;
  constexpr auto const fname = "listEdgeIndexes";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listEdgeIndexes( ::nebula::meta::cpp2::ListEdgeIndexesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listEdgeIndexes(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listEdgeIndexes( ::nebula::meta::cpp2::ListEdgeIndexesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listEdgeIndexes(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listEdgeIndexes( ::nebula::meta::cpp2::ListEdgeIndexesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listEdgeIndexes(_return, state);
}

void MetaServiceAsyncClient::rebuildEdgeIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  rebuildEdgeIndex(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::rebuildEdgeIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  auto ctx = rebuildEdgeIndexCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  rebuildEdgeIndexImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::rebuildEdgeIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      rebuildEdgeIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      rebuildEdgeIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::rebuildEdgeIndexCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.rebuildEdgeIndex");
}

void MetaServiceAsyncClient::sync_rebuildEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_rebuildEdgeIndex(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_rebuildEdgeIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = rebuildEdgeIndexCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  rebuildEdgeIndexImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_rebuildEdgeIndex(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_rebuildEdgeIndex(const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_rebuildEdgeIndex(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_rebuildEdgeIndex(const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_rebuildEdgeIndex(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_rebuildEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_rebuildEdgeIndex, channel_);
  rebuildEdgeIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_rebuildEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_rebuildEdgeIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  rebuildEdgeIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_rebuildEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_rebuildEdgeIndex, channel_);
  rebuildEdgeIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_rebuildEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_rebuildEdgeIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  rebuildEdgeIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::rebuildEdgeIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
  rebuildEdgeIndex(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_rebuildEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_rebuildEdgeIndex_presult;
  constexpr auto const fname = "rebuildEdgeIndex";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_rebuildEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_rebuildEdgeIndex(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_rebuildEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_rebuildEdgeIndex(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_rebuildEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_rebuildEdgeIndex(_return, state);
}

void MetaServiceAsyncClient::listEdgeIndexStatus(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listEdgeIndexStatus(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listEdgeIndexStatus(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  auto ctx = listEdgeIndexStatusCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listEdgeIndexStatusImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listEdgeIndexStatusImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listEdgeIndexStatusT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listEdgeIndexStatusT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listEdgeIndexStatusCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listEdgeIndexStatus");
}

void MetaServiceAsyncClient::sync_listEdgeIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listEdgeIndexStatus(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listEdgeIndexStatus(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListIndexStatusResp& _return, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listEdgeIndexStatusCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listEdgeIndexStatusImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listEdgeIndexStatus(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListIndexStatusResp> MetaServiceAsyncClient::future_listEdgeIndexStatus(const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listEdgeIndexStatus(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListIndexStatusResp> MetaServiceAsyncClient::semifuture_listEdgeIndexStatus(const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listEdgeIndexStatus(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListIndexStatusResp> MetaServiceAsyncClient::future_listEdgeIndexStatus(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListIndexStatusResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListIndexStatusResp>>(std::move(promise), recv_wrapped_listEdgeIndexStatus, channel_);
  listEdgeIndexStatus(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListIndexStatusResp> MetaServiceAsyncClient::semifuture_listEdgeIndexStatus(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listEdgeIndexStatus, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listEdgeIndexStatus(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListIndexStatusResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listEdgeIndexStatus(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListIndexStatusResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListIndexStatusResp>>(std::move(promise), recv_wrapped_listEdgeIndexStatus, channel_);
  listEdgeIndexStatus(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListIndexStatusResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listEdgeIndexStatus(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listEdgeIndexStatus, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listEdgeIndexStatus(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listEdgeIndexStatus(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
  listEdgeIndexStatus(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listEdgeIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listEdgeIndexStatus_presult;
  constexpr auto const fname = "listEdgeIndexStatus";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listEdgeIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listEdgeIndexStatus(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listEdgeIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listEdgeIndexStatus(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listEdgeIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listEdgeIndexStatus(_return, state);
}

void MetaServiceAsyncClient::createUser(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateUserReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  createUser(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::createUser(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateUserReq& p_req) {
  auto ctx = createUserCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  createUserImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::createUserImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateUserReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      createUserT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      createUserT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::createUserCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.createUser");
}

void MetaServiceAsyncClient::sync_createUser( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateUserReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_createUser(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_createUser(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateUserReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = createUserCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  createUserImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_createUser(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_createUser(const  ::nebula::meta::cpp2::CreateUserReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_createUser(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_createUser(const  ::nebula::meta::cpp2::CreateUserReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_createUser(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_createUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateUserReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_createUser, channel_);
  createUser(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_createUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateUserReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_createUser, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createUser(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_createUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateUserReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_createUser, channel_);
  createUser(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_createUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateUserReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_createUser, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createUser(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::createUser(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateUserReq& p_req) {
  createUser(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_createUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_createUser_presult;
  constexpr auto const fname = "createUser";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_createUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_createUser(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_createUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_createUser(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_createUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_createUser(_return, state);
}

void MetaServiceAsyncClient::dropUser(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropUserReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  dropUser(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::dropUser(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropUserReq& p_req) {
  auto ctx = dropUserCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  dropUserImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::dropUserImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropUserReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      dropUserT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      dropUserT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::dropUserCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.dropUser");
}

void MetaServiceAsyncClient::sync_dropUser( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropUserReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_dropUser(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_dropUser(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropUserReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = dropUserCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  dropUserImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_dropUser(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropUser(const  ::nebula::meta::cpp2::DropUserReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_dropUser(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropUser(const  ::nebula::meta::cpp2::DropUserReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_dropUser(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropUserReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropUser, channel_);
  dropUser(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropUserReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_dropUser, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropUser(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_dropUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropUserReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropUser, channel_);
  dropUser(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_dropUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropUserReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_dropUser, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropUser(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::dropUser(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropUserReq& p_req) {
  dropUser(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_dropUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_dropUser_presult;
  constexpr auto const fname = "dropUser";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_dropUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_dropUser(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_dropUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_dropUser(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_dropUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_dropUser(_return, state);
}

void MetaServiceAsyncClient::alterUser(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AlterUserReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  alterUser(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::alterUser(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AlterUserReq& p_req) {
  auto ctx = alterUserCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  alterUserImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::alterUserImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AlterUserReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      alterUserT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      alterUserT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::alterUserCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.alterUser");
}

void MetaServiceAsyncClient::sync_alterUser( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AlterUserReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_alterUser(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_alterUser(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AlterUserReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = alterUserCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  alterUserImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_alterUser(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_alterUser(const  ::nebula::meta::cpp2::AlterUserReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_alterUser(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_alterUser(const  ::nebula::meta::cpp2::AlterUserReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_alterUser(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_alterUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterUserReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_alterUser, channel_);
  alterUser(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_alterUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterUserReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_alterUser, channel_);
  auto callback = std::move(callbackAndFuture.first);
  alterUser(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_alterUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterUserReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_alterUser, channel_);
  alterUser(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_alterUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterUserReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_alterUser, channel_);
  auto callback = std::move(callbackAndFuture.first);
  alterUser(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::alterUser(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::AlterUserReq& p_req) {
  alterUser(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_alterUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_alterUser_presult;
  constexpr auto const fname = "alterUser";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_alterUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_alterUser(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_alterUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_alterUser(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_alterUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_alterUser(_return, state);
}

void MetaServiceAsyncClient::grantRole(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GrantRoleReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  grantRole(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::grantRole(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GrantRoleReq& p_req) {
  auto ctx = grantRoleCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  grantRoleImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::grantRoleImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GrantRoleReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      grantRoleT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      grantRoleT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::grantRoleCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.grantRole");
}

void MetaServiceAsyncClient::sync_grantRole( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::GrantRoleReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_grantRole(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_grantRole(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::GrantRoleReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = grantRoleCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  grantRoleImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_grantRole(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_grantRole(const  ::nebula::meta::cpp2::GrantRoleReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_grantRole(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_grantRole(const  ::nebula::meta::cpp2::GrantRoleReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_grantRole(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_grantRole(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GrantRoleReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_grantRole, channel_);
  grantRole(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_grantRole(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GrantRoleReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_grantRole, channel_);
  auto callback = std::move(callbackAndFuture.first);
  grantRole(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_grantRole(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GrantRoleReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_grantRole, channel_);
  grantRole(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_grantRole(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GrantRoleReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_grantRole, channel_);
  auto callback = std::move(callbackAndFuture.first);
  grantRole(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::grantRole(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GrantRoleReq& p_req) {
  grantRole(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_grantRole( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_grantRole_presult;
  constexpr auto const fname = "grantRole";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_grantRole( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_grantRole(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_grantRole( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_grantRole(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_grantRole( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_grantRole(_return, state);
}

void MetaServiceAsyncClient::revokeRole(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  revokeRole(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::revokeRole(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req) {
  auto ctx = revokeRoleCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  revokeRoleImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::revokeRoleImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      revokeRoleT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      revokeRoleT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::revokeRoleCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.revokeRole");
}

void MetaServiceAsyncClient::sync_revokeRole( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_revokeRole(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_revokeRole(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = revokeRoleCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  revokeRoleImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_revokeRole(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_revokeRole(const  ::nebula::meta::cpp2::RevokeRoleReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_revokeRole(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_revokeRole(const  ::nebula::meta::cpp2::RevokeRoleReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_revokeRole(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_revokeRole(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_revokeRole, channel_);
  revokeRole(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_revokeRole(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_revokeRole, channel_);
  auto callback = std::move(callbackAndFuture.first);
  revokeRole(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_revokeRole(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_revokeRole, channel_);
  revokeRole(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_revokeRole(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_revokeRole, channel_);
  auto callback = std::move(callbackAndFuture.first);
  revokeRole(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::revokeRole(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req) {
  revokeRole(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_revokeRole( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_revokeRole_presult;
  constexpr auto const fname = "revokeRole";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_revokeRole( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_revokeRole(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_revokeRole( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_revokeRole(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_revokeRole( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_revokeRole(_return, state);
}

void MetaServiceAsyncClient::listUsers(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListUsersReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listUsers(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listUsers(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListUsersReq& p_req) {
  auto ctx = listUsersCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listUsersImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listUsersImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListUsersReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listUsersT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listUsersT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listUsersCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listUsers");
}

void MetaServiceAsyncClient::sync_listUsers( ::nebula::meta::cpp2::ListUsersResp& _return, const  ::nebula::meta::cpp2::ListUsersReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listUsers(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listUsers(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListUsersResp& _return, const  ::nebula::meta::cpp2::ListUsersReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listUsersCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listUsersImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listUsers(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListUsersResp> MetaServiceAsyncClient::future_listUsers(const  ::nebula::meta::cpp2::ListUsersReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listUsers(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListUsersResp> MetaServiceAsyncClient::semifuture_listUsers(const  ::nebula::meta::cpp2::ListUsersReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listUsers(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListUsersResp> MetaServiceAsyncClient::future_listUsers(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListUsersReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListUsersResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListUsersResp>>(std::move(promise), recv_wrapped_listUsers, channel_);
  listUsers(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListUsersResp> MetaServiceAsyncClient::semifuture_listUsers(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListUsersReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listUsers, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listUsers(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListUsersResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listUsers(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListUsersReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListUsersResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListUsersResp>>(std::move(promise), recv_wrapped_listUsers, channel_);
  listUsers(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListUsersResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listUsers(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListUsersReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listUsers, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listUsers(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listUsers(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListUsersReq& p_req) {
  listUsers(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listUsers( ::nebula::meta::cpp2::ListUsersResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listUsers_presult;
  constexpr auto const fname = "listUsers";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listUsers( ::nebula::meta::cpp2::ListUsersResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listUsers(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listUsers( ::nebula::meta::cpp2::ListUsersResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listUsers(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listUsers( ::nebula::meta::cpp2::ListUsersResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listUsers(_return, state);
}

void MetaServiceAsyncClient::listRoles(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListRolesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listRoles(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listRoles(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListRolesReq& p_req) {
  auto ctx = listRolesCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listRolesImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listRolesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListRolesReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listRolesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listRolesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listRolesCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listRoles");
}

void MetaServiceAsyncClient::sync_listRoles( ::nebula::meta::cpp2::ListRolesResp& _return, const  ::nebula::meta::cpp2::ListRolesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listRoles(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listRoles(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListRolesResp& _return, const  ::nebula::meta::cpp2::ListRolesReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listRolesCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listRolesImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listRoles(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListRolesResp> MetaServiceAsyncClient::future_listRoles(const  ::nebula::meta::cpp2::ListRolesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listRoles(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListRolesResp> MetaServiceAsyncClient::semifuture_listRoles(const  ::nebula::meta::cpp2::ListRolesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listRoles(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListRolesResp> MetaServiceAsyncClient::future_listRoles(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListRolesReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListRolesResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListRolesResp>>(std::move(promise), recv_wrapped_listRoles, channel_);
  listRoles(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListRolesResp> MetaServiceAsyncClient::semifuture_listRoles(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListRolesReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listRoles, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listRoles(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListRolesResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listRoles(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListRolesReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListRolesResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListRolesResp>>(std::move(promise), recv_wrapped_listRoles, channel_);
  listRoles(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListRolesResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listRoles(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListRolesReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listRoles, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listRoles(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listRoles(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListRolesReq& p_req) {
  listRoles(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listRoles( ::nebula::meta::cpp2::ListRolesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listRoles_presult;
  constexpr auto const fname = "listRoles";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listRoles( ::nebula::meta::cpp2::ListRolesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listRoles(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listRoles( ::nebula::meta::cpp2::ListRolesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listRoles(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listRoles( ::nebula::meta::cpp2::ListRolesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listRoles(_return, state);
}

void MetaServiceAsyncClient::getUserRoles(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  getUserRoles(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::getUserRoles(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req) {
  auto ctx = getUserRolesCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  getUserRolesImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::getUserRolesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getUserRolesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getUserRolesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::getUserRolesCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.getUserRoles");
}

void MetaServiceAsyncClient::sync_getUserRoles( ::nebula::meta::cpp2::ListRolesResp& _return, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getUserRoles(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_getUserRoles(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListRolesResp& _return, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = getUserRolesCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  getUserRolesImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_getUserRoles(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListRolesResp> MetaServiceAsyncClient::future_getUserRoles(const  ::nebula::meta::cpp2::GetUserRolesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getUserRoles(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListRolesResp> MetaServiceAsyncClient::semifuture_getUserRoles(const  ::nebula::meta::cpp2::GetUserRolesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getUserRoles(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListRolesResp> MetaServiceAsyncClient::future_getUserRoles(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListRolesResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListRolesResp>>(std::move(promise), recv_wrapped_getUserRoles, channel_);
  getUserRoles(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListRolesResp> MetaServiceAsyncClient::semifuture_getUserRoles(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getUserRoles, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getUserRoles(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListRolesResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_getUserRoles(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListRolesResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListRolesResp>>(std::move(promise), recv_wrapped_getUserRoles, channel_);
  getUserRoles(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListRolesResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_getUserRoles(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getUserRoles, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getUserRoles(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::getUserRoles(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req) {
  getUserRoles(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_getUserRoles( ::nebula::meta::cpp2::ListRolesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_getUserRoles_presult;
  constexpr auto const fname = "getUserRoles";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_getUserRoles( ::nebula::meta::cpp2::ListRolesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getUserRoles(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_getUserRoles( ::nebula::meta::cpp2::ListRolesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getUserRoles(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_getUserRoles( ::nebula::meta::cpp2::ListRolesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getUserRoles(_return, state);
}

void MetaServiceAsyncClient::changePassword(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  changePassword(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::changePassword(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req) {
  auto ctx = changePasswordCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  changePasswordImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::changePasswordImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      changePasswordT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      changePasswordT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::changePasswordCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.changePassword");
}

void MetaServiceAsyncClient::sync_changePassword( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_changePassword(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_changePassword(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = changePasswordCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  changePasswordImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_changePassword(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_changePassword(const  ::nebula::meta::cpp2::ChangePasswordReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_changePassword(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_changePassword(const  ::nebula::meta::cpp2::ChangePasswordReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_changePassword(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_changePassword(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_changePassword, channel_);
  changePassword(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_changePassword(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_changePassword, channel_);
  auto callback = std::move(callbackAndFuture.first);
  changePassword(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_changePassword(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_changePassword, channel_);
  changePassword(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_changePassword(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_changePassword, channel_);
  auto callback = std::move(callbackAndFuture.first);
  changePassword(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::changePassword(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req) {
  changePassword(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_changePassword( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_changePassword_presult;
  constexpr auto const fname = "changePassword";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_changePassword( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_changePassword(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_changePassword( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_changePassword(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_changePassword( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_changePassword(_return, state);
}

void MetaServiceAsyncClient::heartBeat(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::HBReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  heartBeat(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::heartBeat(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::HBReq& p_req) {
  auto ctx = heartBeatCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  heartBeatImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::heartBeatImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::HBReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      heartBeatT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      heartBeatT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::heartBeatCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.heartBeat");
}

void MetaServiceAsyncClient::sync_heartBeat( ::nebula::meta::cpp2::HBResp& _return, const  ::nebula::meta::cpp2::HBReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_heartBeat(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_heartBeat(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::HBResp& _return, const  ::nebula::meta::cpp2::HBReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = heartBeatCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  heartBeatImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_heartBeat(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::HBResp> MetaServiceAsyncClient::future_heartBeat(const  ::nebula::meta::cpp2::HBReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_heartBeat(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::HBResp> MetaServiceAsyncClient::semifuture_heartBeat(const  ::nebula::meta::cpp2::HBReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_heartBeat(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::HBResp> MetaServiceAsyncClient::future_heartBeat(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::HBReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::HBResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::HBResp>>(std::move(promise), recv_wrapped_heartBeat, channel_);
  heartBeat(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::HBResp> MetaServiceAsyncClient::semifuture_heartBeat(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::HBReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_heartBeat, channel_);
  auto callback = std::move(callbackAndFuture.first);
  heartBeat(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::HBResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_heartBeat(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::HBReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::HBResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::HBResp>>(std::move(promise), recv_wrapped_heartBeat, channel_);
  heartBeat(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::HBResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_heartBeat(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::HBReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_heartBeat, channel_);
  auto callback = std::move(callbackAndFuture.first);
  heartBeat(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::heartBeat(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::HBReq& p_req) {
  heartBeat(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_heartBeat( ::nebula::meta::cpp2::HBResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_heartBeat_presult;
  constexpr auto const fname = "heartBeat";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_heartBeat( ::nebula::meta::cpp2::HBResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_heartBeat(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_heartBeat( ::nebula::meta::cpp2::HBResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_heartBeat(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_heartBeat( ::nebula::meta::cpp2::HBResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_heartBeat(_return, state);
}

void MetaServiceAsyncClient::balance(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::BalanceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  balance(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::balance(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::BalanceReq& p_req) {
  auto ctx = balanceCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  balanceImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::balanceImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::BalanceReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      balanceT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      balanceT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::balanceCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.balance");
}

void MetaServiceAsyncClient::sync_balance( ::nebula::meta::cpp2::BalanceResp& _return, const  ::nebula::meta::cpp2::BalanceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_balance(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_balance(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::BalanceResp& _return, const  ::nebula::meta::cpp2::BalanceReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = balanceCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  balanceImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_balance(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::BalanceResp> MetaServiceAsyncClient::future_balance(const  ::nebula::meta::cpp2::BalanceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_balance(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::BalanceResp> MetaServiceAsyncClient::semifuture_balance(const  ::nebula::meta::cpp2::BalanceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_balance(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::BalanceResp> MetaServiceAsyncClient::future_balance(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::BalanceReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::BalanceResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::BalanceResp>>(std::move(promise), recv_wrapped_balance, channel_);
  balance(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::BalanceResp> MetaServiceAsyncClient::semifuture_balance(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::BalanceReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_balance, channel_);
  auto callback = std::move(callbackAndFuture.first);
  balance(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::BalanceResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_balance(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::BalanceReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::BalanceResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::BalanceResp>>(std::move(promise), recv_wrapped_balance, channel_);
  balance(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::BalanceResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_balance(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::BalanceReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_balance, channel_);
  auto callback = std::move(callbackAndFuture.first);
  balance(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::balance(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::BalanceReq& p_req) {
  balance(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_balance( ::nebula::meta::cpp2::BalanceResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_balance_presult;
  constexpr auto const fname = "balance";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_balance( ::nebula::meta::cpp2::BalanceResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_balance(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_balance( ::nebula::meta::cpp2::BalanceResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_balance(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_balance( ::nebula::meta::cpp2::BalanceResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_balance(_return, state);
}

void MetaServiceAsyncClient::leaderBalance(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::LeaderBalanceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  leaderBalance(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::leaderBalance(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::LeaderBalanceReq& p_req) {
  auto ctx = leaderBalanceCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  leaderBalanceImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::leaderBalanceImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::LeaderBalanceReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      leaderBalanceT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      leaderBalanceT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::leaderBalanceCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.leaderBalance");
}

void MetaServiceAsyncClient::sync_leaderBalance( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::LeaderBalanceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_leaderBalance(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_leaderBalance(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::LeaderBalanceReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = leaderBalanceCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  leaderBalanceImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_leaderBalance(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_leaderBalance(const  ::nebula::meta::cpp2::LeaderBalanceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_leaderBalance(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_leaderBalance(const  ::nebula::meta::cpp2::LeaderBalanceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_leaderBalance(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_leaderBalance(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::LeaderBalanceReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_leaderBalance, channel_);
  leaderBalance(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_leaderBalance(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::LeaderBalanceReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_leaderBalance, channel_);
  auto callback = std::move(callbackAndFuture.first);
  leaderBalance(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_leaderBalance(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::LeaderBalanceReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_leaderBalance, channel_);
  leaderBalance(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_leaderBalance(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::LeaderBalanceReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_leaderBalance, channel_);
  auto callback = std::move(callbackAndFuture.first);
  leaderBalance(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::leaderBalance(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::LeaderBalanceReq& p_req) {
  leaderBalance(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_leaderBalance( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_leaderBalance_presult;
  constexpr auto const fname = "leaderBalance";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_leaderBalance( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_leaderBalance(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_leaderBalance( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_leaderBalance(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_leaderBalance( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_leaderBalance(_return, state);
}

void MetaServiceAsyncClient::regConfig(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RegConfigReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  regConfig(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::regConfig(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RegConfigReq& p_req) {
  auto ctx = regConfigCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  regConfigImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::regConfigImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RegConfigReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      regConfigT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      regConfigT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::regConfigCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.regConfig");
}

void MetaServiceAsyncClient::sync_regConfig( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RegConfigReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_regConfig(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_regConfig(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RegConfigReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = regConfigCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  regConfigImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_regConfig(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_regConfig(const  ::nebula::meta::cpp2::RegConfigReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_regConfig(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_regConfig(const  ::nebula::meta::cpp2::RegConfigReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_regConfig(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_regConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RegConfigReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_regConfig, channel_);
  regConfig(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_regConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RegConfigReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_regConfig, channel_);
  auto callback = std::move(callbackAndFuture.first);
  regConfig(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_regConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RegConfigReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_regConfig, channel_);
  regConfig(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_regConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RegConfigReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_regConfig, channel_);
  auto callback = std::move(callbackAndFuture.first);
  regConfig(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::regConfig(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::RegConfigReq& p_req) {
  regConfig(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_regConfig( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_regConfig_presult;
  constexpr auto const fname = "regConfig";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_regConfig( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_regConfig(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_regConfig( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_regConfig(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_regConfig( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_regConfig(_return, state);
}

void MetaServiceAsyncClient::getConfig(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetConfigReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  getConfig(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::getConfig(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetConfigReq& p_req) {
  auto ctx = getConfigCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  getConfigImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::getConfigImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetConfigReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getConfigT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getConfigT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::getConfigCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.getConfig");
}

void MetaServiceAsyncClient::sync_getConfig( ::nebula::meta::cpp2::GetConfigResp& _return, const  ::nebula::meta::cpp2::GetConfigReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getConfig(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_getConfig(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetConfigResp& _return, const  ::nebula::meta::cpp2::GetConfigReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = getConfigCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  getConfigImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_getConfig(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::GetConfigResp> MetaServiceAsyncClient::future_getConfig(const  ::nebula::meta::cpp2::GetConfigReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getConfig(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::GetConfigResp> MetaServiceAsyncClient::semifuture_getConfig(const  ::nebula::meta::cpp2::GetConfigReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getConfig(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::GetConfigResp> MetaServiceAsyncClient::future_getConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetConfigReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::GetConfigResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::GetConfigResp>>(std::move(promise), recv_wrapped_getConfig, channel_);
  getConfig(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::GetConfigResp> MetaServiceAsyncClient::semifuture_getConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetConfigReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getConfig, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getConfig(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::GetConfigResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_getConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetConfigReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::GetConfigResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::GetConfigResp>>(std::move(promise), recv_wrapped_getConfig, channel_);
  getConfig(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetConfigResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_getConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetConfigReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getConfig, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getConfig(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::getConfig(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetConfigReq& p_req) {
  getConfig(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_getConfig( ::nebula::meta::cpp2::GetConfigResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_getConfig_presult;
  constexpr auto const fname = "getConfig";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_getConfig( ::nebula::meta::cpp2::GetConfigResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getConfig(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_getConfig( ::nebula::meta::cpp2::GetConfigResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getConfig(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_getConfig( ::nebula::meta::cpp2::GetConfigResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getConfig(_return, state);
}

void MetaServiceAsyncClient::setConfig(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::SetConfigReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  setConfig(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::setConfig(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::SetConfigReq& p_req) {
  auto ctx = setConfigCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  setConfigImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::setConfigImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::SetConfigReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      setConfigT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      setConfigT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::setConfigCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.setConfig");
}

void MetaServiceAsyncClient::sync_setConfig( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::SetConfigReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_setConfig(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_setConfig(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::SetConfigReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = setConfigCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  setConfigImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_setConfig(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_setConfig(const  ::nebula::meta::cpp2::SetConfigReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_setConfig(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_setConfig(const  ::nebula::meta::cpp2::SetConfigReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_setConfig(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_setConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SetConfigReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_setConfig, channel_);
  setConfig(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_setConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SetConfigReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_setConfig, channel_);
  auto callback = std::move(callbackAndFuture.first);
  setConfig(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_setConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SetConfigReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_setConfig, channel_);
  setConfig(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_setConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SetConfigReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_setConfig, channel_);
  auto callback = std::move(callbackAndFuture.first);
  setConfig(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::setConfig(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::SetConfigReq& p_req) {
  setConfig(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_setConfig( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_setConfig_presult;
  constexpr auto const fname = "setConfig";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_setConfig( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_setConfig(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_setConfig( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_setConfig(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_setConfig( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_setConfig(_return, state);
}

void MetaServiceAsyncClient::listConfigs(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListConfigsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listConfigs(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listConfigs(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListConfigsReq& p_req) {
  auto ctx = listConfigsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listConfigsImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listConfigsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListConfigsReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listConfigsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listConfigsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listConfigsCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listConfigs");
}

void MetaServiceAsyncClient::sync_listConfigs( ::nebula::meta::cpp2::ListConfigsResp& _return, const  ::nebula::meta::cpp2::ListConfigsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listConfigs(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listConfigs(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListConfigsResp& _return, const  ::nebula::meta::cpp2::ListConfigsReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listConfigsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listConfigsImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listConfigs(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListConfigsResp> MetaServiceAsyncClient::future_listConfigs(const  ::nebula::meta::cpp2::ListConfigsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listConfigs(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListConfigsResp> MetaServiceAsyncClient::semifuture_listConfigs(const  ::nebula::meta::cpp2::ListConfigsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listConfigs(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListConfigsResp> MetaServiceAsyncClient::future_listConfigs(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListConfigsReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListConfigsResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListConfigsResp>>(std::move(promise), recv_wrapped_listConfigs, channel_);
  listConfigs(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListConfigsResp> MetaServiceAsyncClient::semifuture_listConfigs(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListConfigsReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listConfigs, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listConfigs(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListConfigsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listConfigs(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListConfigsReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListConfigsResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListConfigsResp>>(std::move(promise), recv_wrapped_listConfigs, channel_);
  listConfigs(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListConfigsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listConfigs(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListConfigsReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listConfigs, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listConfigs(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listConfigs(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListConfigsReq& p_req) {
  listConfigs(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listConfigs( ::nebula::meta::cpp2::ListConfigsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listConfigs_presult;
  constexpr auto const fname = "listConfigs";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listConfigs( ::nebula::meta::cpp2::ListConfigsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listConfigs(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listConfigs( ::nebula::meta::cpp2::ListConfigsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listConfigs(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listConfigs( ::nebula::meta::cpp2::ListConfigsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listConfigs(_return, state);
}

void MetaServiceAsyncClient::createSnapshot(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  createSnapshot(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::createSnapshot(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req) {
  auto ctx = createSnapshotCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  createSnapshotImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::createSnapshotImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      createSnapshotT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      createSnapshotT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::createSnapshotCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.createSnapshot");
}

void MetaServiceAsyncClient::sync_createSnapshot( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_createSnapshot(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_createSnapshot(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = createSnapshotCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  createSnapshotImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_createSnapshot(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_createSnapshot(const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_createSnapshot(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_createSnapshot(const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_createSnapshot(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_createSnapshot(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_createSnapshot, channel_);
  createSnapshot(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_createSnapshot(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_createSnapshot, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createSnapshot(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_createSnapshot(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_createSnapshot, channel_);
  createSnapshot(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_createSnapshot(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_createSnapshot, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createSnapshot(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::createSnapshot(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req) {
  createSnapshot(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_createSnapshot( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_createSnapshot_presult;
  constexpr auto const fname = "createSnapshot";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_createSnapshot( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_createSnapshot(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_createSnapshot( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_createSnapshot(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_createSnapshot( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_createSnapshot(_return, state);
}

void MetaServiceAsyncClient::dropSnapshot(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  dropSnapshot(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::dropSnapshot(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req) {
  auto ctx = dropSnapshotCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  dropSnapshotImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::dropSnapshotImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      dropSnapshotT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      dropSnapshotT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::dropSnapshotCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.dropSnapshot");
}

void MetaServiceAsyncClient::sync_dropSnapshot( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_dropSnapshot(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_dropSnapshot(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = dropSnapshotCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  dropSnapshotImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_dropSnapshot(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropSnapshot(const  ::nebula::meta::cpp2::DropSnapshotReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_dropSnapshot(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropSnapshot(const  ::nebula::meta::cpp2::DropSnapshotReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_dropSnapshot(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropSnapshot(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropSnapshot, channel_);
  dropSnapshot(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropSnapshot(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_dropSnapshot, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropSnapshot(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_dropSnapshot(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropSnapshot, channel_);
  dropSnapshot(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_dropSnapshot(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_dropSnapshot, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropSnapshot(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::dropSnapshot(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req) {
  dropSnapshot(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_dropSnapshot( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_dropSnapshot_presult;
  constexpr auto const fname = "dropSnapshot";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_dropSnapshot( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_dropSnapshot(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_dropSnapshot( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_dropSnapshot(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_dropSnapshot( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_dropSnapshot(_return, state);
}

void MetaServiceAsyncClient::listSnapshots(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listSnapshots(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listSnapshots(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req) {
  auto ctx = listSnapshotsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listSnapshotsImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listSnapshotsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listSnapshotsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listSnapshotsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listSnapshotsCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listSnapshots");
}

void MetaServiceAsyncClient::sync_listSnapshots( ::nebula::meta::cpp2::ListSnapshotsResp& _return, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listSnapshots(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listSnapshots(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListSnapshotsResp& _return, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listSnapshotsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listSnapshotsImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listSnapshots(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListSnapshotsResp> MetaServiceAsyncClient::future_listSnapshots(const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listSnapshots(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListSnapshotsResp> MetaServiceAsyncClient::semifuture_listSnapshots(const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listSnapshots(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListSnapshotsResp> MetaServiceAsyncClient::future_listSnapshots(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListSnapshotsResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListSnapshotsResp>>(std::move(promise), recv_wrapped_listSnapshots, channel_);
  listSnapshots(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListSnapshotsResp> MetaServiceAsyncClient::semifuture_listSnapshots(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listSnapshots, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listSnapshots(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListSnapshotsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listSnapshots(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListSnapshotsResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListSnapshotsResp>>(std::move(promise), recv_wrapped_listSnapshots, channel_);
  listSnapshots(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListSnapshotsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listSnapshots(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listSnapshots, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listSnapshots(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listSnapshots(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req) {
  listSnapshots(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listSnapshots( ::nebula::meta::cpp2::ListSnapshotsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listSnapshots_presult;
  constexpr auto const fname = "listSnapshots";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listSnapshots( ::nebula::meta::cpp2::ListSnapshotsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listSnapshots(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listSnapshots( ::nebula::meta::cpp2::ListSnapshotsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listSnapshots(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listSnapshots( ::nebula::meta::cpp2::ListSnapshotsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listSnapshots(_return, state);
}

void MetaServiceAsyncClient::runAdminJob(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AdminJobReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  runAdminJob(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::runAdminJob(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AdminJobReq& p_req) {
  auto ctx = runAdminJobCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  runAdminJobImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::runAdminJobImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AdminJobReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      runAdminJobT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      runAdminJobT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::runAdminJobCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.runAdminJob");
}

void MetaServiceAsyncClient::sync_runAdminJob( ::nebula::meta::cpp2::AdminJobResp& _return, const  ::nebula::meta::cpp2::AdminJobReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_runAdminJob(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_runAdminJob(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::AdminJobResp& _return, const  ::nebula::meta::cpp2::AdminJobReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = runAdminJobCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  runAdminJobImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_runAdminJob(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::AdminJobResp> MetaServiceAsyncClient::future_runAdminJob(const  ::nebula::meta::cpp2::AdminJobReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_runAdminJob(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::AdminJobResp> MetaServiceAsyncClient::semifuture_runAdminJob(const  ::nebula::meta::cpp2::AdminJobReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_runAdminJob(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::AdminJobResp> MetaServiceAsyncClient::future_runAdminJob(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AdminJobReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::AdminJobResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::AdminJobResp>>(std::move(promise), recv_wrapped_runAdminJob, channel_);
  runAdminJob(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::AdminJobResp> MetaServiceAsyncClient::semifuture_runAdminJob(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AdminJobReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_runAdminJob, channel_);
  auto callback = std::move(callbackAndFuture.first);
  runAdminJob(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::AdminJobResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_runAdminJob(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AdminJobReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::AdminJobResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::AdminJobResp>>(std::move(promise), recv_wrapped_runAdminJob, channel_);
  runAdminJob(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::AdminJobResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_runAdminJob(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AdminJobReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_runAdminJob, channel_);
  auto callback = std::move(callbackAndFuture.first);
  runAdminJob(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::runAdminJob(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::AdminJobReq& p_req) {
  runAdminJob(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_runAdminJob( ::nebula::meta::cpp2::AdminJobResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_runAdminJob_presult;
  constexpr auto const fname = "runAdminJob";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_runAdminJob( ::nebula::meta::cpp2::AdminJobResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_runAdminJob(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_runAdminJob( ::nebula::meta::cpp2::AdminJobResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_runAdminJob(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_runAdminJob( ::nebula::meta::cpp2::AdminJobResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_runAdminJob(_return, state);
}

void MetaServiceAsyncClient::addZone(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AddZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  addZone(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::addZone(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AddZoneReq& p_req) {
  auto ctx = addZoneCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  addZoneImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::addZoneImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AddZoneReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      addZoneT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      addZoneT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::addZoneCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.addZone");
}

void MetaServiceAsyncClient::sync_addZone( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AddZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_addZone(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_addZone(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AddZoneReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = addZoneCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  addZoneImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_addZone(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_addZone(const  ::nebula::meta::cpp2::AddZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_addZone(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_addZone(const  ::nebula::meta::cpp2::AddZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_addZone(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_addZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddZoneReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_addZone, channel_);
  addZone(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_addZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddZoneReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_addZone, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addZone(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_addZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddZoneReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_addZone, channel_);
  addZone(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_addZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddZoneReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_addZone, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addZone(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::addZone(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::AddZoneReq& p_req) {
  addZone(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_addZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_addZone_presult;
  constexpr auto const fname = "addZone";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_addZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_addZone(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_addZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_addZone(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_addZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_addZone(_return, state);
}

void MetaServiceAsyncClient::dropZone(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  dropZone(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::dropZone(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropZoneReq& p_req) {
  auto ctx = dropZoneCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  dropZoneImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::dropZoneImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropZoneReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      dropZoneT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      dropZoneT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::dropZoneCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.dropZone");
}

void MetaServiceAsyncClient::sync_dropZone( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_dropZone(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_dropZone(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropZoneReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = dropZoneCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  dropZoneImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_dropZone(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropZone(const  ::nebula::meta::cpp2::DropZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_dropZone(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropZone(const  ::nebula::meta::cpp2::DropZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_dropZone(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropZoneReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropZone, channel_);
  dropZone(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropZoneReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_dropZone, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropZone(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_dropZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropZoneReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropZone, channel_);
  dropZone(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_dropZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropZoneReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_dropZone, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropZone(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::dropZone(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropZoneReq& p_req) {
  dropZone(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_dropZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_dropZone_presult;
  constexpr auto const fname = "dropZone";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_dropZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_dropZone(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_dropZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_dropZone(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_dropZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_dropZone(_return, state);
}

void MetaServiceAsyncClient::addHostIntoZone(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AddHostIntoZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  addHostIntoZone(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::addHostIntoZone(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AddHostIntoZoneReq& p_req) {
  auto ctx = addHostIntoZoneCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  addHostIntoZoneImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::addHostIntoZoneImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AddHostIntoZoneReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      addHostIntoZoneT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      addHostIntoZoneT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::addHostIntoZoneCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.addHostIntoZone");
}

void MetaServiceAsyncClient::sync_addHostIntoZone( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AddHostIntoZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_addHostIntoZone(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_addHostIntoZone(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AddHostIntoZoneReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = addHostIntoZoneCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  addHostIntoZoneImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_addHostIntoZone(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_addHostIntoZone(const  ::nebula::meta::cpp2::AddHostIntoZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_addHostIntoZone(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_addHostIntoZone(const  ::nebula::meta::cpp2::AddHostIntoZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_addHostIntoZone(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_addHostIntoZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddHostIntoZoneReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_addHostIntoZone, channel_);
  addHostIntoZone(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_addHostIntoZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddHostIntoZoneReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_addHostIntoZone, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addHostIntoZone(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_addHostIntoZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddHostIntoZoneReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_addHostIntoZone, channel_);
  addHostIntoZone(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_addHostIntoZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddHostIntoZoneReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_addHostIntoZone, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addHostIntoZone(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::addHostIntoZone(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::AddHostIntoZoneReq& p_req) {
  addHostIntoZone(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_addHostIntoZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_addHostIntoZone_presult;
  constexpr auto const fname = "addHostIntoZone";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_addHostIntoZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_addHostIntoZone(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_addHostIntoZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_addHostIntoZone(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_addHostIntoZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_addHostIntoZone(_return, state);
}

void MetaServiceAsyncClient::dropHostFromZone(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropHostFromZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  dropHostFromZone(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::dropHostFromZone(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropHostFromZoneReq& p_req) {
  auto ctx = dropHostFromZoneCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  dropHostFromZoneImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::dropHostFromZoneImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropHostFromZoneReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      dropHostFromZoneT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      dropHostFromZoneT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::dropHostFromZoneCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.dropHostFromZone");
}

void MetaServiceAsyncClient::sync_dropHostFromZone( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropHostFromZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_dropHostFromZone(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_dropHostFromZone(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropHostFromZoneReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = dropHostFromZoneCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  dropHostFromZoneImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_dropHostFromZone(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropHostFromZone(const  ::nebula::meta::cpp2::DropHostFromZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_dropHostFromZone(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropHostFromZone(const  ::nebula::meta::cpp2::DropHostFromZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_dropHostFromZone(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropHostFromZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropHostFromZoneReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropHostFromZone, channel_);
  dropHostFromZone(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropHostFromZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropHostFromZoneReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_dropHostFromZone, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropHostFromZone(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_dropHostFromZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropHostFromZoneReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropHostFromZone, channel_);
  dropHostFromZone(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_dropHostFromZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropHostFromZoneReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_dropHostFromZone, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropHostFromZone(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::dropHostFromZone(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropHostFromZoneReq& p_req) {
  dropHostFromZone(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_dropHostFromZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_dropHostFromZone_presult;
  constexpr auto const fname = "dropHostFromZone";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_dropHostFromZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_dropHostFromZone(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_dropHostFromZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_dropHostFromZone(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_dropHostFromZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_dropHostFromZone(_return, state);
}

void MetaServiceAsyncClient::getZone(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  getZone(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::getZone(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetZoneReq& p_req) {
  auto ctx = getZoneCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  getZoneImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::getZoneImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetZoneReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getZoneT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getZoneT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::getZoneCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.getZone");
}

void MetaServiceAsyncClient::sync_getZone( ::nebula::meta::cpp2::GetZoneResp& _return, const  ::nebula::meta::cpp2::GetZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getZone(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_getZone(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetZoneResp& _return, const  ::nebula::meta::cpp2::GetZoneReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = getZoneCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  getZoneImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_getZone(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::GetZoneResp> MetaServiceAsyncClient::future_getZone(const  ::nebula::meta::cpp2::GetZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getZone(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::GetZoneResp> MetaServiceAsyncClient::semifuture_getZone(const  ::nebula::meta::cpp2::GetZoneReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getZone(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::GetZoneResp> MetaServiceAsyncClient::future_getZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetZoneReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::GetZoneResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::GetZoneResp>>(std::move(promise), recv_wrapped_getZone, channel_);
  getZone(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::GetZoneResp> MetaServiceAsyncClient::semifuture_getZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetZoneReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getZone, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getZone(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::GetZoneResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_getZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetZoneReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::GetZoneResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::GetZoneResp>>(std::move(promise), recv_wrapped_getZone, channel_);
  getZone(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetZoneResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_getZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetZoneReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getZone, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getZone(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::getZone(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetZoneReq& p_req) {
  getZone(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_getZone( ::nebula::meta::cpp2::GetZoneResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_getZone_presult;
  constexpr auto const fname = "getZone";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_getZone( ::nebula::meta::cpp2::GetZoneResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getZone(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_getZone( ::nebula::meta::cpp2::GetZoneResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getZone(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_getZone( ::nebula::meta::cpp2::GetZoneResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getZone(_return, state);
}

void MetaServiceAsyncClient::listZones(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListZonesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listZones(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listZones(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListZonesReq& p_req) {
  auto ctx = listZonesCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listZonesImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listZonesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListZonesReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listZonesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listZonesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listZonesCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listZones");
}

void MetaServiceAsyncClient::sync_listZones( ::nebula::meta::cpp2::ListZonesResp& _return, const  ::nebula::meta::cpp2::ListZonesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listZones(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listZones(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListZonesResp& _return, const  ::nebula::meta::cpp2::ListZonesReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listZonesCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listZonesImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listZones(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListZonesResp> MetaServiceAsyncClient::future_listZones(const  ::nebula::meta::cpp2::ListZonesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listZones(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListZonesResp> MetaServiceAsyncClient::semifuture_listZones(const  ::nebula::meta::cpp2::ListZonesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listZones(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListZonesResp> MetaServiceAsyncClient::future_listZones(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListZonesReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListZonesResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListZonesResp>>(std::move(promise), recv_wrapped_listZones, channel_);
  listZones(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListZonesResp> MetaServiceAsyncClient::semifuture_listZones(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListZonesReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listZones, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listZones(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListZonesResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listZones(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListZonesReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListZonesResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListZonesResp>>(std::move(promise), recv_wrapped_listZones, channel_);
  listZones(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListZonesResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listZones(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListZonesReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listZones, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listZones(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listZones(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListZonesReq& p_req) {
  listZones(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listZones( ::nebula::meta::cpp2::ListZonesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listZones_presult;
  constexpr auto const fname = "listZones";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listZones( ::nebula::meta::cpp2::ListZonesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listZones(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listZones( ::nebula::meta::cpp2::ListZonesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listZones(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listZones( ::nebula::meta::cpp2::ListZonesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listZones(_return, state);
}

void MetaServiceAsyncClient::addGroup(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AddGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  addGroup(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::addGroup(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AddGroupReq& p_req) {
  auto ctx = addGroupCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  addGroupImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::addGroupImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AddGroupReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      addGroupT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      addGroupT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::addGroupCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.addGroup");
}

void MetaServiceAsyncClient::sync_addGroup( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AddGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_addGroup(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_addGroup(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AddGroupReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = addGroupCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  addGroupImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_addGroup(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_addGroup(const  ::nebula::meta::cpp2::AddGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_addGroup(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_addGroup(const  ::nebula::meta::cpp2::AddGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_addGroup(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_addGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddGroupReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_addGroup, channel_);
  addGroup(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_addGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddGroupReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_addGroup, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addGroup(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_addGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddGroupReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_addGroup, channel_);
  addGroup(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_addGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddGroupReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_addGroup, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addGroup(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::addGroup(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::AddGroupReq& p_req) {
  addGroup(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_addGroup( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_addGroup_presult;
  constexpr auto const fname = "addGroup";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_addGroup( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_addGroup(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_addGroup( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_addGroup(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_addGroup( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_addGroup(_return, state);
}

void MetaServiceAsyncClient::dropGroup(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  dropGroup(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::dropGroup(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropGroupReq& p_req) {
  auto ctx = dropGroupCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  dropGroupImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::dropGroupImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropGroupReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      dropGroupT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      dropGroupT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::dropGroupCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.dropGroup");
}

void MetaServiceAsyncClient::sync_dropGroup( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_dropGroup(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_dropGroup(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropGroupReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = dropGroupCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  dropGroupImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_dropGroup(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropGroup(const  ::nebula::meta::cpp2::DropGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_dropGroup(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropGroup(const  ::nebula::meta::cpp2::DropGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_dropGroup(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropGroupReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropGroup, channel_);
  dropGroup(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropGroupReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_dropGroup, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropGroup(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_dropGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropGroupReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropGroup, channel_);
  dropGroup(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_dropGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropGroupReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_dropGroup, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropGroup(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::dropGroup(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropGroupReq& p_req) {
  dropGroup(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_dropGroup( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_dropGroup_presult;
  constexpr auto const fname = "dropGroup";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_dropGroup( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_dropGroup(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_dropGroup( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_dropGroup(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_dropGroup( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_dropGroup(_return, state);
}

void MetaServiceAsyncClient::addZoneIntoGroup(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AddZoneIntoGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  addZoneIntoGroup(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::addZoneIntoGroup(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AddZoneIntoGroupReq& p_req) {
  auto ctx = addZoneIntoGroupCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  addZoneIntoGroupImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::addZoneIntoGroupImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AddZoneIntoGroupReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      addZoneIntoGroupT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      addZoneIntoGroupT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::addZoneIntoGroupCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.addZoneIntoGroup");
}

void MetaServiceAsyncClient::sync_addZoneIntoGroup( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AddZoneIntoGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_addZoneIntoGroup(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_addZoneIntoGroup(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AddZoneIntoGroupReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = addZoneIntoGroupCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  addZoneIntoGroupImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_addZoneIntoGroup(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_addZoneIntoGroup(const  ::nebula::meta::cpp2::AddZoneIntoGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_addZoneIntoGroup(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_addZoneIntoGroup(const  ::nebula::meta::cpp2::AddZoneIntoGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_addZoneIntoGroup(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_addZoneIntoGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddZoneIntoGroupReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_addZoneIntoGroup, channel_);
  addZoneIntoGroup(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_addZoneIntoGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddZoneIntoGroupReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_addZoneIntoGroup, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addZoneIntoGroup(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_addZoneIntoGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddZoneIntoGroupReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_addZoneIntoGroup, channel_);
  addZoneIntoGroup(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_addZoneIntoGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddZoneIntoGroupReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_addZoneIntoGroup, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addZoneIntoGroup(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::addZoneIntoGroup(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::AddZoneIntoGroupReq& p_req) {
  addZoneIntoGroup(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_addZoneIntoGroup( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_addZoneIntoGroup_presult;
  constexpr auto const fname = "addZoneIntoGroup";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_addZoneIntoGroup( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_addZoneIntoGroup(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_addZoneIntoGroup( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_addZoneIntoGroup(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_addZoneIntoGroup( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_addZoneIntoGroup(_return, state);
}

void MetaServiceAsyncClient::dropZoneFromGroup(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropZoneFromGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  dropZoneFromGroup(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::dropZoneFromGroup(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropZoneFromGroupReq& p_req) {
  auto ctx = dropZoneFromGroupCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  dropZoneFromGroupImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::dropZoneFromGroupImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropZoneFromGroupReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      dropZoneFromGroupT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      dropZoneFromGroupT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::dropZoneFromGroupCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.dropZoneFromGroup");
}

void MetaServiceAsyncClient::sync_dropZoneFromGroup( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropZoneFromGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_dropZoneFromGroup(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_dropZoneFromGroup(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropZoneFromGroupReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = dropZoneFromGroupCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  dropZoneFromGroupImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_dropZoneFromGroup(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropZoneFromGroup(const  ::nebula::meta::cpp2::DropZoneFromGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_dropZoneFromGroup(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropZoneFromGroup(const  ::nebula::meta::cpp2::DropZoneFromGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_dropZoneFromGroup(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropZoneFromGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropZoneFromGroupReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropZoneFromGroup, channel_);
  dropZoneFromGroup(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropZoneFromGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropZoneFromGroupReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_dropZoneFromGroup, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropZoneFromGroup(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_dropZoneFromGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropZoneFromGroupReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropZoneFromGroup, channel_);
  dropZoneFromGroup(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_dropZoneFromGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropZoneFromGroupReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_dropZoneFromGroup, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropZoneFromGroup(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::dropZoneFromGroup(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropZoneFromGroupReq& p_req) {
  dropZoneFromGroup(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_dropZoneFromGroup( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_dropZoneFromGroup_presult;
  constexpr auto const fname = "dropZoneFromGroup";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_dropZoneFromGroup( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_dropZoneFromGroup(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_dropZoneFromGroup( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_dropZoneFromGroup(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_dropZoneFromGroup( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_dropZoneFromGroup(_return, state);
}

void MetaServiceAsyncClient::getGroup(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  getGroup(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::getGroup(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetGroupReq& p_req) {
  auto ctx = getGroupCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  getGroupImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::getGroupImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetGroupReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getGroupT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getGroupT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::getGroupCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.getGroup");
}

void MetaServiceAsyncClient::sync_getGroup( ::nebula::meta::cpp2::GetGroupResp& _return, const  ::nebula::meta::cpp2::GetGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getGroup(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_getGroup(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetGroupResp& _return, const  ::nebula::meta::cpp2::GetGroupReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = getGroupCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  getGroupImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_getGroup(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::GetGroupResp> MetaServiceAsyncClient::future_getGroup(const  ::nebula::meta::cpp2::GetGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getGroup(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::GetGroupResp> MetaServiceAsyncClient::semifuture_getGroup(const  ::nebula::meta::cpp2::GetGroupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getGroup(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::GetGroupResp> MetaServiceAsyncClient::future_getGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetGroupReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::GetGroupResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::GetGroupResp>>(std::move(promise), recv_wrapped_getGroup, channel_);
  getGroup(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::GetGroupResp> MetaServiceAsyncClient::semifuture_getGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetGroupReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getGroup, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getGroup(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::GetGroupResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_getGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetGroupReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::GetGroupResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::GetGroupResp>>(std::move(promise), recv_wrapped_getGroup, channel_);
  getGroup(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetGroupResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_getGroup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetGroupReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getGroup, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getGroup(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::getGroup(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetGroupReq& p_req) {
  getGroup(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_getGroup( ::nebula::meta::cpp2::GetGroupResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_getGroup_presult;
  constexpr auto const fname = "getGroup";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_getGroup( ::nebula::meta::cpp2::GetGroupResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getGroup(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_getGroup( ::nebula::meta::cpp2::GetGroupResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getGroup(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_getGroup( ::nebula::meta::cpp2::GetGroupResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getGroup(_return, state);
}

void MetaServiceAsyncClient::listGroups(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListGroupsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listGroups(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listGroups(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListGroupsReq& p_req) {
  auto ctx = listGroupsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listGroupsImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listGroupsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListGroupsReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listGroupsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listGroupsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listGroupsCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listGroups");
}

void MetaServiceAsyncClient::sync_listGroups( ::nebula::meta::cpp2::ListGroupsResp& _return, const  ::nebula::meta::cpp2::ListGroupsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listGroups(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listGroups(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListGroupsResp& _return, const  ::nebula::meta::cpp2::ListGroupsReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listGroupsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listGroupsImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listGroups(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListGroupsResp> MetaServiceAsyncClient::future_listGroups(const  ::nebula::meta::cpp2::ListGroupsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listGroups(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListGroupsResp> MetaServiceAsyncClient::semifuture_listGroups(const  ::nebula::meta::cpp2::ListGroupsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listGroups(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListGroupsResp> MetaServiceAsyncClient::future_listGroups(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListGroupsReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListGroupsResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListGroupsResp>>(std::move(promise), recv_wrapped_listGroups, channel_);
  listGroups(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListGroupsResp> MetaServiceAsyncClient::semifuture_listGroups(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListGroupsReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listGroups, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listGroups(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListGroupsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listGroups(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListGroupsReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListGroupsResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListGroupsResp>>(std::move(promise), recv_wrapped_listGroups, channel_);
  listGroups(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListGroupsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listGroups(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListGroupsReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listGroups, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listGroups(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listGroups(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListGroupsReq& p_req) {
  listGroups(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listGroups( ::nebula::meta::cpp2::ListGroupsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listGroups_presult;
  constexpr auto const fname = "listGroups";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listGroups( ::nebula::meta::cpp2::ListGroupsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listGroups(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listGroups( ::nebula::meta::cpp2::ListGroupsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listGroups(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listGroups( ::nebula::meta::cpp2::ListGroupsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listGroups(_return, state);
}

void MetaServiceAsyncClient::createBackup(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateBackupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  createBackup(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::createBackup(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateBackupReq& p_req) {
  auto ctx = createBackupCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  createBackupImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::createBackupImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateBackupReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      createBackupT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      createBackupT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::createBackupCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.createBackup");
}

void MetaServiceAsyncClient::sync_createBackup( ::nebula::meta::cpp2::CreateBackupResp& _return, const  ::nebula::meta::cpp2::CreateBackupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_createBackup(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_createBackup(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::CreateBackupResp& _return, const  ::nebula::meta::cpp2::CreateBackupReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = createBackupCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  createBackupImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_createBackup(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::CreateBackupResp> MetaServiceAsyncClient::future_createBackup(const  ::nebula::meta::cpp2::CreateBackupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_createBackup(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::CreateBackupResp> MetaServiceAsyncClient::semifuture_createBackup(const  ::nebula::meta::cpp2::CreateBackupReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_createBackup(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::CreateBackupResp> MetaServiceAsyncClient::future_createBackup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateBackupReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::CreateBackupResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::CreateBackupResp>>(std::move(promise), recv_wrapped_createBackup, channel_);
  createBackup(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::CreateBackupResp> MetaServiceAsyncClient::semifuture_createBackup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateBackupReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_createBackup, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createBackup(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::CreateBackupResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_createBackup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateBackupReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::CreateBackupResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::CreateBackupResp>>(std::move(promise), recv_wrapped_createBackup, channel_);
  createBackup(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::CreateBackupResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_createBackup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateBackupReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_createBackup, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createBackup(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::createBackup(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateBackupReq& p_req) {
  createBackup(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_createBackup( ::nebula::meta::cpp2::CreateBackupResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_createBackup_presult;
  constexpr auto const fname = "createBackup";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_createBackup( ::nebula::meta::cpp2::CreateBackupResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_createBackup(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_createBackup( ::nebula::meta::cpp2::CreateBackupResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_createBackup(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_createBackup( ::nebula::meta::cpp2::CreateBackupResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_createBackup(_return, state);
}

void MetaServiceAsyncClient::restoreMeta(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  restoreMeta(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::restoreMeta(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req) {
  auto ctx = restoreMetaCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  restoreMetaImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::restoreMetaImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      restoreMetaT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      restoreMetaT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::restoreMetaCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.restoreMeta");
}

void MetaServiceAsyncClient::sync_restoreMeta( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_restoreMeta(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_restoreMeta(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = restoreMetaCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  restoreMetaImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_restoreMeta(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_restoreMeta(const  ::nebula::meta::cpp2::RestoreMetaReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_restoreMeta(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_restoreMeta(const  ::nebula::meta::cpp2::RestoreMetaReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_restoreMeta(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_restoreMeta(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_restoreMeta, channel_);
  restoreMeta(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_restoreMeta(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_restoreMeta, channel_);
  auto callback = std::move(callbackAndFuture.first);
  restoreMeta(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_restoreMeta(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_restoreMeta, channel_);
  restoreMeta(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_restoreMeta(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_restoreMeta, channel_);
  auto callback = std::move(callbackAndFuture.first);
  restoreMeta(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::restoreMeta(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req) {
  restoreMeta(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_restoreMeta( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_restoreMeta_presult;
  constexpr auto const fname = "restoreMeta";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_restoreMeta( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_restoreMeta(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_restoreMeta( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_restoreMeta(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_restoreMeta( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_restoreMeta(_return, state);
}

void MetaServiceAsyncClient::addListener(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AddListenerReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  addListener(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::addListener(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AddListenerReq& p_req) {
  auto ctx = addListenerCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  addListenerImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::addListenerImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AddListenerReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      addListenerT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      addListenerT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::addListenerCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.addListener");
}

void MetaServiceAsyncClient::sync_addListener( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AddListenerReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_addListener(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_addListener(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AddListenerReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = addListenerCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  addListenerImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_addListener(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_addListener(const  ::nebula::meta::cpp2::AddListenerReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_addListener(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_addListener(const  ::nebula::meta::cpp2::AddListenerReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_addListener(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_addListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddListenerReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_addListener, channel_);
  addListener(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_addListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddListenerReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_addListener, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addListener(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_addListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddListenerReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_addListener, channel_);
  addListener(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_addListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddListenerReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_addListener, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addListener(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::addListener(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::AddListenerReq& p_req) {
  addListener(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_addListener( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_addListener_presult;
  constexpr auto const fname = "addListener";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_addListener( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_addListener(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_addListener( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_addListener(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_addListener( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_addListener(_return, state);
}

void MetaServiceAsyncClient::removeListener(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  removeListener(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::removeListener(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req) {
  auto ctx = removeListenerCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  removeListenerImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::removeListenerImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      removeListenerT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      removeListenerT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::removeListenerCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.removeListener");
}

void MetaServiceAsyncClient::sync_removeListener( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_removeListener(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_removeListener(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = removeListenerCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  removeListenerImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_removeListener(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_removeListener(const  ::nebula::meta::cpp2::RemoveListenerReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_removeListener(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_removeListener(const  ::nebula::meta::cpp2::RemoveListenerReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_removeListener(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_removeListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_removeListener, channel_);
  removeListener(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_removeListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_removeListener, channel_);
  auto callback = std::move(callbackAndFuture.first);
  removeListener(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_removeListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_removeListener, channel_);
  removeListener(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_removeListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_removeListener, channel_);
  auto callback = std::move(callbackAndFuture.first);
  removeListener(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::removeListener(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req) {
  removeListener(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_removeListener( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_removeListener_presult;
  constexpr auto const fname = "removeListener";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_removeListener( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_removeListener(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_removeListener( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_removeListener(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_removeListener( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_removeListener(_return, state);
}

void MetaServiceAsyncClient::listListener(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListListenerReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listListener(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listListener(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListListenerReq& p_req) {
  auto ctx = listListenerCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listListenerImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listListenerImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListListenerReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listListenerT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listListenerT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listListenerCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listListener");
}

void MetaServiceAsyncClient::sync_listListener( ::nebula::meta::cpp2::ListListenerResp& _return, const  ::nebula::meta::cpp2::ListListenerReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listListener(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listListener(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListListenerResp& _return, const  ::nebula::meta::cpp2::ListListenerReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listListenerCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listListenerImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listListener(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListListenerResp> MetaServiceAsyncClient::future_listListener(const  ::nebula::meta::cpp2::ListListenerReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listListener(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListListenerResp> MetaServiceAsyncClient::semifuture_listListener(const  ::nebula::meta::cpp2::ListListenerReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listListener(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListListenerResp> MetaServiceAsyncClient::future_listListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListListenerReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListListenerResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListListenerResp>>(std::move(promise), recv_wrapped_listListener, channel_);
  listListener(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListListenerResp> MetaServiceAsyncClient::semifuture_listListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListListenerReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listListener, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listListener(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListListenerResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListListenerReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListListenerResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListListenerResp>>(std::move(promise), recv_wrapped_listListener, channel_);
  listListener(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListListenerResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListListenerReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listListener, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listListener(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listListener(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListListenerReq& p_req) {
  listListener(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listListener( ::nebula::meta::cpp2::ListListenerResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listListener_presult;
  constexpr auto const fname = "listListener";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listListener( ::nebula::meta::cpp2::ListListenerResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listListener(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listListener( ::nebula::meta::cpp2::ListListenerResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listListener(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listListener( ::nebula::meta::cpp2::ListListenerResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listListener(_return, state);
}

void MetaServiceAsyncClient::getStats(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetStatsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  getStats(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::getStats(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetStatsReq& p_req) {
  auto ctx = getStatsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  getStatsImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::getStatsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetStatsReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getStatsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getStatsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::getStatsCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.getStats");
}

void MetaServiceAsyncClient::sync_getStats( ::nebula::meta::cpp2::GetStatsResp& _return, const  ::nebula::meta::cpp2::GetStatsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getStats(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_getStats(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetStatsResp& _return, const  ::nebula::meta::cpp2::GetStatsReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = getStatsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  getStatsImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_getStats(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::GetStatsResp> MetaServiceAsyncClient::future_getStats(const  ::nebula::meta::cpp2::GetStatsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getStats(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::GetStatsResp> MetaServiceAsyncClient::semifuture_getStats(const  ::nebula::meta::cpp2::GetStatsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getStats(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::GetStatsResp> MetaServiceAsyncClient::future_getStats(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetStatsReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::GetStatsResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::GetStatsResp>>(std::move(promise), recv_wrapped_getStats, channel_);
  getStats(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::GetStatsResp> MetaServiceAsyncClient::semifuture_getStats(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetStatsReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getStats, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getStats(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::GetStatsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_getStats(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetStatsReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::GetStatsResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::GetStatsResp>>(std::move(promise), recv_wrapped_getStats, channel_);
  getStats(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetStatsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_getStats(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetStatsReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getStats, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getStats(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::getStats(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetStatsReq& p_req) {
  getStats(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_getStats( ::nebula::meta::cpp2::GetStatsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_getStats_presult;
  constexpr auto const fname = "getStats";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_getStats( ::nebula::meta::cpp2::GetStatsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getStats(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_getStats( ::nebula::meta::cpp2::GetStatsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getStats(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_getStats( ::nebula::meta::cpp2::GetStatsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getStats(_return, state);
}

void MetaServiceAsyncClient::signInFTService(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::SignInFTServiceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  signInFTService(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::signInFTService(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::SignInFTServiceReq& p_req) {
  auto ctx = signInFTServiceCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  signInFTServiceImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::signInFTServiceImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::SignInFTServiceReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      signInFTServiceT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      signInFTServiceT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::signInFTServiceCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.signInFTService");
}

void MetaServiceAsyncClient::sync_signInFTService( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::SignInFTServiceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_signInFTService(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_signInFTService(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::SignInFTServiceReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = signInFTServiceCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  signInFTServiceImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_signInFTService(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_signInFTService(const  ::nebula::meta::cpp2::SignInFTServiceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_signInFTService(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_signInFTService(const  ::nebula::meta::cpp2::SignInFTServiceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_signInFTService(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_signInFTService(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SignInFTServiceReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_signInFTService, channel_);
  signInFTService(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_signInFTService(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SignInFTServiceReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_signInFTService, channel_);
  auto callback = std::move(callbackAndFuture.first);
  signInFTService(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_signInFTService(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SignInFTServiceReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_signInFTService, channel_);
  signInFTService(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_signInFTService(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SignInFTServiceReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_signInFTService, channel_);
  auto callback = std::move(callbackAndFuture.first);
  signInFTService(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::signInFTService(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::SignInFTServiceReq& p_req) {
  signInFTService(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_signInFTService( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_signInFTService_presult;
  constexpr auto const fname = "signInFTService";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_signInFTService( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_signInFTService(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_signInFTService( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_signInFTService(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_signInFTService( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_signInFTService(_return, state);
}

void MetaServiceAsyncClient::signOutFTService(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::SignOutFTServiceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  signOutFTService(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::signOutFTService(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::SignOutFTServiceReq& p_req) {
  auto ctx = signOutFTServiceCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  signOutFTServiceImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::signOutFTServiceImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::SignOutFTServiceReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      signOutFTServiceT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      signOutFTServiceT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::signOutFTServiceCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.signOutFTService");
}

void MetaServiceAsyncClient::sync_signOutFTService( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::SignOutFTServiceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_signOutFTService(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_signOutFTService(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::SignOutFTServiceReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = signOutFTServiceCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  signOutFTServiceImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_signOutFTService(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_signOutFTService(const  ::nebula::meta::cpp2::SignOutFTServiceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_signOutFTService(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_signOutFTService(const  ::nebula::meta::cpp2::SignOutFTServiceReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_signOutFTService(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_signOutFTService(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SignOutFTServiceReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_signOutFTService, channel_);
  signOutFTService(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_signOutFTService(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SignOutFTServiceReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_signOutFTService, channel_);
  auto callback = std::move(callbackAndFuture.first);
  signOutFTService(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_signOutFTService(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SignOutFTServiceReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_signOutFTService, channel_);
  signOutFTService(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_signOutFTService(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SignOutFTServiceReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_signOutFTService, channel_);
  auto callback = std::move(callbackAndFuture.first);
  signOutFTService(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::signOutFTService(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::SignOutFTServiceReq& p_req) {
  signOutFTService(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_signOutFTService( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_signOutFTService_presult;
  constexpr auto const fname = "signOutFTService";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_signOutFTService( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_signOutFTService(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_signOutFTService( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_signOutFTService(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_signOutFTService( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_signOutFTService(_return, state);
}

void MetaServiceAsyncClient::listFTClients(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListFTClientsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listFTClients(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listFTClients(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListFTClientsReq& p_req) {
  auto ctx = listFTClientsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listFTClientsImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listFTClientsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListFTClientsReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listFTClientsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listFTClientsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listFTClientsCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listFTClients");
}

void MetaServiceAsyncClient::sync_listFTClients( ::nebula::meta::cpp2::ListFTClientsResp& _return, const  ::nebula::meta::cpp2::ListFTClientsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listFTClients(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listFTClients(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListFTClientsResp& _return, const  ::nebula::meta::cpp2::ListFTClientsReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listFTClientsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listFTClientsImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listFTClients(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListFTClientsResp> MetaServiceAsyncClient::future_listFTClients(const  ::nebula::meta::cpp2::ListFTClientsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listFTClients(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListFTClientsResp> MetaServiceAsyncClient::semifuture_listFTClients(const  ::nebula::meta::cpp2::ListFTClientsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listFTClients(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListFTClientsResp> MetaServiceAsyncClient::future_listFTClients(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListFTClientsReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListFTClientsResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListFTClientsResp>>(std::move(promise), recv_wrapped_listFTClients, channel_);
  listFTClients(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListFTClientsResp> MetaServiceAsyncClient::semifuture_listFTClients(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListFTClientsReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listFTClients, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listFTClients(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListFTClientsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listFTClients(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListFTClientsReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListFTClientsResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListFTClientsResp>>(std::move(promise), recv_wrapped_listFTClients, channel_);
  listFTClients(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListFTClientsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listFTClients(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListFTClientsReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listFTClients, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listFTClients(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listFTClients(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListFTClientsReq& p_req) {
  listFTClients(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listFTClients( ::nebula::meta::cpp2::ListFTClientsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listFTClients_presult;
  constexpr auto const fname = "listFTClients";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listFTClients( ::nebula::meta::cpp2::ListFTClientsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listFTClients(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listFTClients( ::nebula::meta::cpp2::ListFTClientsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listFTClients(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listFTClients( ::nebula::meta::cpp2::ListFTClientsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listFTClients(_return, state);
}

void MetaServiceAsyncClient::createFTIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  createFTIndex(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::createFTIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req) {
  auto ctx = createFTIndexCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  createFTIndexImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::createFTIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      createFTIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      createFTIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::createFTIndexCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.createFTIndex");
}

void MetaServiceAsyncClient::sync_createFTIndex( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_createFTIndex(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_createFTIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = createFTIndexCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  createFTIndexImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_createFTIndex(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_createFTIndex(const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_createFTIndex(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_createFTIndex(const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_createFTIndex(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_createFTIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_createFTIndex, channel_);
  createFTIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_createFTIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_createFTIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createFTIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_createFTIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_createFTIndex, channel_);
  createFTIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_createFTIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_createFTIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createFTIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::createFTIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req) {
  createFTIndex(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_createFTIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_createFTIndex_presult;
  constexpr auto const fname = "createFTIndex";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_createFTIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_createFTIndex(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_createFTIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_createFTIndex(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_createFTIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_createFTIndex(_return, state);
}

void MetaServiceAsyncClient::dropFTIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  dropFTIndex(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::dropFTIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req) {
  auto ctx = dropFTIndexCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  dropFTIndexImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::dropFTIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      dropFTIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      dropFTIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::dropFTIndexCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.dropFTIndex");
}

void MetaServiceAsyncClient::sync_dropFTIndex( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_dropFTIndex(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_dropFTIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = dropFTIndexCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  dropFTIndexImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_dropFTIndex(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropFTIndex(const  ::nebula::meta::cpp2::DropFTIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_dropFTIndex(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropFTIndex(const  ::nebula::meta::cpp2::DropFTIndexReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_dropFTIndex(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_dropFTIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropFTIndex, channel_);
  dropFTIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_dropFTIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_dropFTIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropFTIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_dropFTIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_dropFTIndex, channel_);
  dropFTIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_dropFTIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_dropFTIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  dropFTIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::dropFTIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req) {
  dropFTIndex(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_dropFTIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_dropFTIndex_presult;
  constexpr auto const fname = "dropFTIndex";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_dropFTIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_dropFTIndex(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_dropFTIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_dropFTIndex(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_dropFTIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_dropFTIndex(_return, state);
}

void MetaServiceAsyncClient::listFTIndexes(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listFTIndexes(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listFTIndexes(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req) {
  auto ctx = listFTIndexesCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listFTIndexesImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listFTIndexesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listFTIndexesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listFTIndexesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listFTIndexesCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listFTIndexes");
}

void MetaServiceAsyncClient::sync_listFTIndexes( ::nebula::meta::cpp2::ListFTIndexesResp& _return, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listFTIndexes(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listFTIndexes(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListFTIndexesResp& _return, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listFTIndexesCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listFTIndexesImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listFTIndexes(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListFTIndexesResp> MetaServiceAsyncClient::future_listFTIndexes(const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listFTIndexes(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListFTIndexesResp> MetaServiceAsyncClient::semifuture_listFTIndexes(const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listFTIndexes(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListFTIndexesResp> MetaServiceAsyncClient::future_listFTIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListFTIndexesResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListFTIndexesResp>>(std::move(promise), recv_wrapped_listFTIndexes, channel_);
  listFTIndexes(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListFTIndexesResp> MetaServiceAsyncClient::semifuture_listFTIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listFTIndexes, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listFTIndexes(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListFTIndexesResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listFTIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListFTIndexesResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListFTIndexesResp>>(std::move(promise), recv_wrapped_listFTIndexes, channel_);
  listFTIndexes(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListFTIndexesResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listFTIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listFTIndexes, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listFTIndexes(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listFTIndexes(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req) {
  listFTIndexes(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listFTIndexes( ::nebula::meta::cpp2::ListFTIndexesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listFTIndexes_presult;
  constexpr auto const fname = "listFTIndexes";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listFTIndexes( ::nebula::meta::cpp2::ListFTIndexesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listFTIndexes(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listFTIndexes( ::nebula::meta::cpp2::ListFTIndexesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listFTIndexes(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listFTIndexes( ::nebula::meta::cpp2::ListFTIndexesResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listFTIndexes(_return, state);
}

void MetaServiceAsyncClient::createSession(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateSessionReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  createSession(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::createSession(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateSessionReq& p_req) {
  auto ctx = createSessionCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  createSessionImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::createSessionImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateSessionReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      createSessionT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      createSessionT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::createSessionCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.createSession");
}

void MetaServiceAsyncClient::sync_createSession( ::nebula::meta::cpp2::CreateSessionResp& _return, const  ::nebula::meta::cpp2::CreateSessionReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_createSession(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_createSession(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::CreateSessionResp& _return, const  ::nebula::meta::cpp2::CreateSessionReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = createSessionCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  createSessionImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_createSession(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::CreateSessionResp> MetaServiceAsyncClient::future_createSession(const  ::nebula::meta::cpp2::CreateSessionReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_createSession(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::CreateSessionResp> MetaServiceAsyncClient::semifuture_createSession(const  ::nebula::meta::cpp2::CreateSessionReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_createSession(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::CreateSessionResp> MetaServiceAsyncClient::future_createSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSessionReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::CreateSessionResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::CreateSessionResp>>(std::move(promise), recv_wrapped_createSession, channel_);
  createSession(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::CreateSessionResp> MetaServiceAsyncClient::semifuture_createSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSessionReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_createSession, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createSession(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::CreateSessionResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_createSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSessionReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::CreateSessionResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::CreateSessionResp>>(std::move(promise), recv_wrapped_createSession, channel_);
  createSession(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::CreateSessionResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_createSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSessionReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_createSession, channel_);
  auto callback = std::move(callbackAndFuture.first);
  createSession(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::createSession(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateSessionReq& p_req) {
  createSession(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_createSession( ::nebula::meta::cpp2::CreateSessionResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_createSession_presult;
  constexpr auto const fname = "createSession";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_createSession( ::nebula::meta::cpp2::CreateSessionResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_createSession(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_createSession( ::nebula::meta::cpp2::CreateSessionResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_createSession(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_createSession( ::nebula::meta::cpp2::CreateSessionResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_createSession(_return, state);
}

void MetaServiceAsyncClient::updateSessions(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  updateSessions(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::updateSessions(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req) {
  auto ctx = updateSessionsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  updateSessionsImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::updateSessionsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      updateSessionsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      updateSessionsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::updateSessionsCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.updateSessions");
}

void MetaServiceAsyncClient::sync_updateSessions( ::nebula::meta::cpp2::UpdateSessionsResp& _return, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_updateSessions(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_updateSessions(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::UpdateSessionsResp& _return, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = updateSessionsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  updateSessionsImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_updateSessions(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::UpdateSessionsResp> MetaServiceAsyncClient::future_updateSessions(const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_updateSessions(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::UpdateSessionsResp> MetaServiceAsyncClient::semifuture_updateSessions(const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_updateSessions(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::UpdateSessionsResp> MetaServiceAsyncClient::future_updateSessions(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::UpdateSessionsResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::UpdateSessionsResp>>(std::move(promise), recv_wrapped_updateSessions, channel_);
  updateSessions(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::UpdateSessionsResp> MetaServiceAsyncClient::semifuture_updateSessions(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_updateSessions, channel_);
  auto callback = std::move(callbackAndFuture.first);
  updateSessions(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::UpdateSessionsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_updateSessions(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::UpdateSessionsResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::UpdateSessionsResp>>(std::move(promise), recv_wrapped_updateSessions, channel_);
  updateSessions(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::UpdateSessionsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_updateSessions(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_updateSessions, channel_);
  auto callback = std::move(callbackAndFuture.first);
  updateSessions(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::updateSessions(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req) {
  updateSessions(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_updateSessions( ::nebula::meta::cpp2::UpdateSessionsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_updateSessions_presult;
  constexpr auto const fname = "updateSessions";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_updateSessions( ::nebula::meta::cpp2::UpdateSessionsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_updateSessions(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_updateSessions( ::nebula::meta::cpp2::UpdateSessionsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_updateSessions(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_updateSessions( ::nebula::meta::cpp2::UpdateSessionsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_updateSessions(_return, state);
}

void MetaServiceAsyncClient::listSessions(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListSessionsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listSessions(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listSessions(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListSessionsReq& p_req) {
  auto ctx = listSessionsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listSessionsImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listSessionsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListSessionsReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listSessionsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listSessionsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listSessionsCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listSessions");
}

void MetaServiceAsyncClient::sync_listSessions( ::nebula::meta::cpp2::ListSessionsResp& _return, const  ::nebula::meta::cpp2::ListSessionsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listSessions(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listSessions(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListSessionsResp& _return, const  ::nebula::meta::cpp2::ListSessionsReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listSessionsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listSessionsImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listSessions(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListSessionsResp> MetaServiceAsyncClient::future_listSessions(const  ::nebula::meta::cpp2::ListSessionsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listSessions(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListSessionsResp> MetaServiceAsyncClient::semifuture_listSessions(const  ::nebula::meta::cpp2::ListSessionsReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listSessions(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListSessionsResp> MetaServiceAsyncClient::future_listSessions(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSessionsReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListSessionsResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListSessionsResp>>(std::move(promise), recv_wrapped_listSessions, channel_);
  listSessions(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListSessionsResp> MetaServiceAsyncClient::semifuture_listSessions(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSessionsReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listSessions, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listSessions(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListSessionsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listSessions(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSessionsReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListSessionsResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListSessionsResp>>(std::move(promise), recv_wrapped_listSessions, channel_);
  listSessions(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListSessionsResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listSessions(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSessionsReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listSessions, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listSessions(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listSessions(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListSessionsReq& p_req) {
  listSessions(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listSessions( ::nebula::meta::cpp2::ListSessionsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listSessions_presult;
  constexpr auto const fname = "listSessions";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listSessions( ::nebula::meta::cpp2::ListSessionsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listSessions(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listSessions( ::nebula::meta::cpp2::ListSessionsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listSessions(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listSessions( ::nebula::meta::cpp2::ListSessionsResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listSessions(_return, state);
}

void MetaServiceAsyncClient::getSession(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetSessionReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  getSession(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::getSession(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetSessionReq& p_req) {
  auto ctx = getSessionCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  getSessionImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::getSessionImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetSessionReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getSessionT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getSessionT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::getSessionCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.getSession");
}

void MetaServiceAsyncClient::sync_getSession( ::nebula::meta::cpp2::GetSessionResp& _return, const  ::nebula::meta::cpp2::GetSessionReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getSession(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_getSession(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetSessionResp& _return, const  ::nebula::meta::cpp2::GetSessionReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = getSessionCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  getSessionImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_getSession(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::GetSessionResp> MetaServiceAsyncClient::future_getSession(const  ::nebula::meta::cpp2::GetSessionReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getSession(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::GetSessionResp> MetaServiceAsyncClient::semifuture_getSession(const  ::nebula::meta::cpp2::GetSessionReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getSession(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::GetSessionResp> MetaServiceAsyncClient::future_getSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetSessionReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::GetSessionResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::GetSessionResp>>(std::move(promise), recv_wrapped_getSession, channel_);
  getSession(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::GetSessionResp> MetaServiceAsyncClient::semifuture_getSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetSessionReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getSession, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getSession(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::GetSessionResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_getSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetSessionReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::GetSessionResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::GetSessionResp>>(std::move(promise), recv_wrapped_getSession, channel_);
  getSession(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetSessionResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_getSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetSessionReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getSession, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getSession(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::getSession(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetSessionReq& p_req) {
  getSession(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_getSession( ::nebula::meta::cpp2::GetSessionResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_getSession_presult;
  constexpr auto const fname = "getSession";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_getSession( ::nebula::meta::cpp2::GetSessionResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getSession(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_getSession( ::nebula::meta::cpp2::GetSessionResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getSession(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_getSession( ::nebula::meta::cpp2::GetSessionResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getSession(_return, state);
}

void MetaServiceAsyncClient::removeSession(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  removeSession(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::removeSession(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req) {
  auto ctx = removeSessionCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  removeSessionImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::removeSessionImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      removeSessionT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      removeSessionT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::removeSessionCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.removeSession");
}

void MetaServiceAsyncClient::sync_removeSession( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_removeSession(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_removeSession(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = removeSessionCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  removeSessionImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_removeSession(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_removeSession(const  ::nebula::meta::cpp2::RemoveSessionReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_removeSession(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_removeSession(const  ::nebula::meta::cpp2::RemoveSessionReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_removeSession(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_removeSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_removeSession, channel_);
  removeSession(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_removeSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_removeSession, channel_);
  auto callback = std::move(callbackAndFuture.first);
  removeSession(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_removeSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_removeSession, channel_);
  removeSession(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_removeSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_removeSession, channel_);
  auto callback = std::move(callbackAndFuture.first);
  removeSession(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::removeSession(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req) {
  removeSession(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_removeSession( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_removeSession_presult;
  constexpr auto const fname = "removeSession";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_removeSession( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_removeSession(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_removeSession( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_removeSession(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_removeSession( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_removeSession(_return, state);
}

void MetaServiceAsyncClient::killQuery(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::KillQueryReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  killQuery(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::killQuery(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::KillQueryReq& p_req) {
  auto ctx = killQueryCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  killQueryImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::killQueryImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::KillQueryReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      killQueryT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      killQueryT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::killQueryCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.killQuery");
}

void MetaServiceAsyncClient::sync_killQuery( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::KillQueryReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_killQuery(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_killQuery(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::KillQueryReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = killQueryCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  killQueryImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_killQuery(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_killQuery(const  ::nebula::meta::cpp2::KillQueryReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_killQuery(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_killQuery(const  ::nebula::meta::cpp2::KillQueryReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_killQuery(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_killQuery(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::KillQueryReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_killQuery, channel_);
  killQuery(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_killQuery(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::KillQueryReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_killQuery, channel_);
  auto callback = std::move(callbackAndFuture.first);
  killQuery(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_killQuery(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::KillQueryReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_killQuery, channel_);
  killQuery(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_killQuery(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::KillQueryReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_killQuery, channel_);
  auto callback = std::move(callbackAndFuture.first);
  killQuery(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::killQuery(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::KillQueryReq& p_req) {
  killQuery(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_killQuery( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_killQuery_presult;
  constexpr auto const fname = "killQuery";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_killQuery( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_killQuery(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_killQuery( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_killQuery(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_killQuery( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_killQuery(_return, state);
}

void MetaServiceAsyncClient::reportTaskFinish(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ReportTaskReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  reportTaskFinish(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::reportTaskFinish(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ReportTaskReq& p_req) {
  auto ctx = reportTaskFinishCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  reportTaskFinishImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::reportTaskFinishImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ReportTaskReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      reportTaskFinishT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      reportTaskFinishT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::reportTaskFinishCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.reportTaskFinish");
}

void MetaServiceAsyncClient::sync_reportTaskFinish( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::ReportTaskReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_reportTaskFinish(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_reportTaskFinish(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::ReportTaskReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = reportTaskFinishCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  reportTaskFinishImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_reportTaskFinish(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_reportTaskFinish(const  ::nebula::meta::cpp2::ReportTaskReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_reportTaskFinish(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_reportTaskFinish(const  ::nebula::meta::cpp2::ReportTaskReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_reportTaskFinish(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::future_reportTaskFinish(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ReportTaskReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ExecResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_reportTaskFinish, channel_);
  reportTaskFinish(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> MetaServiceAsyncClient::semifuture_reportTaskFinish(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ReportTaskReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_reportTaskFinish, channel_);
  auto callback = std::move(callbackAndFuture.first);
  reportTaskFinish(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_reportTaskFinish(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ReportTaskReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ExecResp>>(std::move(promise), recv_wrapped_reportTaskFinish, channel_);
  reportTaskFinish(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_reportTaskFinish(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ReportTaskReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_reportTaskFinish, channel_);
  auto callback = std::move(callbackAndFuture.first);
  reportTaskFinish(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::reportTaskFinish(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ReportTaskReq& p_req) {
  reportTaskFinish(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_reportTaskFinish( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_reportTaskFinish_presult;
  constexpr auto const fname = "reportTaskFinish";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_reportTaskFinish( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_reportTaskFinish(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_reportTaskFinish( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_reportTaskFinish(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_reportTaskFinish( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_reportTaskFinish(_return, state);
}

void MetaServiceAsyncClient::listCluster(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  listCluster(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::listCluster(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req) {
  auto ctx = listClusterCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  listClusterImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::listClusterImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listClusterT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listClusterT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::listClusterCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.listCluster");
}

void MetaServiceAsyncClient::sync_listCluster( ::nebula::meta::cpp2::ListClusterInfoResp& _return, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_listCluster(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_listCluster(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListClusterInfoResp& _return, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = listClusterCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  listClusterImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_listCluster(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::ListClusterInfoResp> MetaServiceAsyncClient::future_listCluster(const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_listCluster(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::ListClusterInfoResp> MetaServiceAsyncClient::semifuture_listCluster(const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_listCluster(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::ListClusterInfoResp> MetaServiceAsyncClient::future_listCluster(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::ListClusterInfoResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::ListClusterInfoResp>>(std::move(promise), recv_wrapped_listCluster, channel_);
  listCluster(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::ListClusterInfoResp> MetaServiceAsyncClient::semifuture_listCluster(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_listCluster, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listCluster(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::ListClusterInfoResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_listCluster(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::ListClusterInfoResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::ListClusterInfoResp>>(std::move(promise), recv_wrapped_listCluster, channel_);
  listCluster(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListClusterInfoResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_listCluster(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_listCluster, channel_);
  auto callback = std::move(callbackAndFuture.first);
  listCluster(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::listCluster(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req) {
  listCluster(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_listCluster( ::nebula::meta::cpp2::ListClusterInfoResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_listCluster_presult;
  constexpr auto const fname = "listCluster";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_listCluster( ::nebula::meta::cpp2::ListClusterInfoResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_listCluster(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_listCluster( ::nebula::meta::cpp2::ListClusterInfoResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_listCluster(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_listCluster( ::nebula::meta::cpp2::ListClusterInfoResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_listCluster(_return, state);
}

void MetaServiceAsyncClient::getMetaDirInfo(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  getMetaDirInfo(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::getMetaDirInfo(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req) {
  auto ctx = getMetaDirInfoCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  getMetaDirInfoImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::getMetaDirInfoImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getMetaDirInfoT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getMetaDirInfoT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::getMetaDirInfoCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.getMetaDirInfo");
}

void MetaServiceAsyncClient::sync_getMetaDirInfo( ::nebula::meta::cpp2::GetMetaDirInfoResp& _return, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getMetaDirInfo(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_getMetaDirInfo(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetMetaDirInfoResp& _return, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = getMetaDirInfoCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  getMetaDirInfoImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_getMetaDirInfo(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::GetMetaDirInfoResp> MetaServiceAsyncClient::future_getMetaDirInfo(const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getMetaDirInfo(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::GetMetaDirInfoResp> MetaServiceAsyncClient::semifuture_getMetaDirInfo(const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getMetaDirInfo(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::GetMetaDirInfoResp> MetaServiceAsyncClient::future_getMetaDirInfo(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::GetMetaDirInfoResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::GetMetaDirInfoResp>>(std::move(promise), recv_wrapped_getMetaDirInfo, channel_);
  getMetaDirInfo(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::GetMetaDirInfoResp> MetaServiceAsyncClient::semifuture_getMetaDirInfo(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getMetaDirInfo, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getMetaDirInfo(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::GetMetaDirInfoResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_getMetaDirInfo(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::GetMetaDirInfoResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::GetMetaDirInfoResp>>(std::move(promise), recv_wrapped_getMetaDirInfo, channel_);
  getMetaDirInfo(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetMetaDirInfoResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_getMetaDirInfo(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getMetaDirInfo, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getMetaDirInfo(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::getMetaDirInfo(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req) {
  getMetaDirInfo(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_getMetaDirInfo( ::nebula::meta::cpp2::GetMetaDirInfoResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_getMetaDirInfo_presult;
  constexpr auto const fname = "getMetaDirInfo";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_getMetaDirInfo( ::nebula::meta::cpp2::GetMetaDirInfoResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getMetaDirInfo(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_getMetaDirInfo( ::nebula::meta::cpp2::GetMetaDirInfoResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getMetaDirInfo(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_getMetaDirInfo( ::nebula::meta::cpp2::GetMetaDirInfoResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getMetaDirInfo(_return, state);
}

void MetaServiceAsyncClient::verifyClientVersion(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  verifyClientVersion(rpcOptions, std::move(callback), p_req);
}

void MetaServiceAsyncClient::verifyClientVersion(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req) {
  auto ctx = verifyClientVersionCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  verifyClientVersionImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void MetaServiceAsyncClient::verifyClientVersionImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      verifyClientVersionT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      verifyClientVersionT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> MetaServiceAsyncClient::verifyClientVersionCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "MetaService.verifyClientVersion");
}

void MetaServiceAsyncClient::sync_verifyClientVersion( ::nebula::meta::cpp2::VerifyClientVersionResp& _return, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_verifyClientVersion(rpcOptions, _return, p_req);
}

void MetaServiceAsyncClient::sync_verifyClientVersion(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::VerifyClientVersionResp& _return, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = verifyClientVersionCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  verifyClientVersionImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_verifyClientVersion(_return, returnState);
  });
}


folly::Future< ::nebula::meta::cpp2::VerifyClientVersionResp> MetaServiceAsyncClient::future_verifyClientVersion(const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_verifyClientVersion(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::meta::cpp2::VerifyClientVersionResp> MetaServiceAsyncClient::semifuture_verifyClientVersion(const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_verifyClientVersion(rpcOptions, p_req);
}

folly::Future< ::nebula::meta::cpp2::VerifyClientVersionResp> MetaServiceAsyncClient::future_verifyClientVersion(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req) {
  folly::Promise< ::nebula::meta::cpp2::VerifyClientVersionResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::meta::cpp2::VerifyClientVersionResp>>(std::move(promise), recv_wrapped_verifyClientVersion, channel_);
  verifyClientVersion(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::meta::cpp2::VerifyClientVersionResp> MetaServiceAsyncClient::semifuture_verifyClientVersion(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_verifyClientVersion, channel_);
  auto callback = std::move(callbackAndFuture.first);
  verifyClientVersion(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::meta::cpp2::VerifyClientVersionResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_future_verifyClientVersion(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req) {
  folly::Promise<std::pair< ::nebula::meta::cpp2::VerifyClientVersionResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::meta::cpp2::VerifyClientVersionResp>>(std::move(promise), recv_wrapped_verifyClientVersion, channel_);
  verifyClientVersion(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::meta::cpp2::VerifyClientVersionResp, std::unique_ptr<apache::thrift::transport::THeader>>> MetaServiceAsyncClient::header_semifuture_verifyClientVersion(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_verifyClientVersion, channel_);
  auto callback = std::move(callbackAndFuture.first);
  verifyClientVersion(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void MetaServiceAsyncClient::verifyClientVersion(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req) {
  verifyClientVersion(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MetaServiceAsyncClient::recv_wrapped_verifyClientVersion( ::nebula::meta::cpp2::VerifyClientVersionResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = MetaService_verifyClientVersion_presult;
  constexpr auto const fname = "verifyClientVersion";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MetaServiceAsyncClient::recv_verifyClientVersion( ::nebula::meta::cpp2::VerifyClientVersionResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_verifyClientVersion(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MetaServiceAsyncClient::recv_instance_verifyClientVersion( ::nebula::meta::cpp2::VerifyClientVersionResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_verifyClientVersion(_return, state);
}

folly::exception_wrapper MetaServiceAsyncClient::recv_instance_wrapped_verifyClientVersion( ::nebula::meta::cpp2::VerifyClientVersionResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_verifyClientVersion(_return, state);
}


}}} // nebula::meta::cpp2
