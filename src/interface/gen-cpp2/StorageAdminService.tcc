/**
 * Autogenerated by Thrift for storage.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include "StorageAdminService.h"

#include <thrift/lib/cpp2/gen/service_tcc.h>

namespace nebula { namespace storage { namespace cpp2 {
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::TransLeaderReq*>> StorageAdminService_transLeader_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_transLeader_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AddPartReq*>> StorageAdminService_addPart_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_addPart_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AddLearnerReq*>> StorageAdminService_addLearner_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_addLearner_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::RemovePartReq*>> StorageAdminService_removePart_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_removePart_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::MemberChangeReq*>> StorageAdminService_memberChange_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_memberChange_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::CatchUpDataReq*>> StorageAdminService_waitingForCatchUpData_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_waitingForCatchUpData_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::CreateCPRequest*>> StorageAdminService_createCheckpoint_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::CreateCPResp*>> StorageAdminService_createCheckpoint_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::DropCPRequest*>> StorageAdminService_dropCheckpoint_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::DropCPResp*>> StorageAdminService_dropCheckpoint_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::BlockingSignRequest*>> StorageAdminService_blockingWrites_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::BlockingSignResp*>> StorageAdminService_blockingWrites_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::GetLeaderReq*>> StorageAdminService_getLeaderParts_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::GetLeaderPartsResp*>> StorageAdminService_getLeaderParts_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::CheckPeersReq*>> StorageAdminService_checkPeers_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AdminExecResp*>> StorageAdminService_checkPeers_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AddTaskRequest*>> StorageAdminService_addAdminTask_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AddTaskResp*>> StorageAdminService_addAdminTask_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::StopTaskRequest*>> StorageAdminService_stopAdminTask_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::StopTaskResp*>> StorageAdminService_stopAdminTask_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ClearSpaceReq*>> StorageAdminService_clearSpace_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ClearSpaceResp*>> StorageAdminService_clearSpace_presult;
template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::setUpAndProcess_transLeader(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(std::move(req), std::move(serializedRequest), ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, &StorageAdminServiceAsyncProcessor::process_transLeader<ProtocolIn_, ProtocolOut_>, this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::process_transLeader(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  StorageAdminService_transLeader_pargs args;
   ::nebula::storage::cpp2::TransLeaderReq uarg_req;
  args.get<0>().value = &uarg_req;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "StorageAdminService.transLeader", ctx));
  try {
    deserializeRequest<ProtocolIn_>(args, ctx->getMethodName(), serializedRequest, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "transLeader");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(req), std::move(ctxStack), return_transLeader<ProtocolIn_,ProtocolOut_>, throw_wrapped_transLeader<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  if (!callback->isRequestActive()) {
    return;
  }
  iface_->async_tm_transLeader(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue StorageAdminServiceAsyncProcessor::return_transLeader(int32_t protoSeqId, apache::thrift::ContextStack* ctx,  ::nebula::storage::cpp2::AdminExecResp const& _return) {
  ProtocolOut_ prot;
  StorageAdminService_transLeader_presult result;
  result.get<0>().value = const_cast< ::nebula::storage::cpp2::AdminExecResp*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("transLeader", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void StorageAdminServiceAsyncProcessor::throw_wrapped_transLeader(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "transLeader");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::setUpAndProcess_addPart(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(std::move(req), std::move(serializedRequest), ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, &StorageAdminServiceAsyncProcessor::process_addPart<ProtocolIn_, ProtocolOut_>, this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::process_addPart(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  StorageAdminService_addPart_pargs args;
   ::nebula::storage::cpp2::AddPartReq uarg_req;
  args.get<0>().value = &uarg_req;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "StorageAdminService.addPart", ctx));
  try {
    deserializeRequest<ProtocolIn_>(args, ctx->getMethodName(), serializedRequest, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "addPart");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(req), std::move(ctxStack), return_addPart<ProtocolIn_,ProtocolOut_>, throw_wrapped_addPart<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  if (!callback->isRequestActive()) {
    return;
  }
  iface_->async_tm_addPart(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue StorageAdminServiceAsyncProcessor::return_addPart(int32_t protoSeqId, apache::thrift::ContextStack* ctx,  ::nebula::storage::cpp2::AdminExecResp const& _return) {
  ProtocolOut_ prot;
  StorageAdminService_addPart_presult result;
  result.get<0>().value = const_cast< ::nebula::storage::cpp2::AdminExecResp*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("addPart", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void StorageAdminServiceAsyncProcessor::throw_wrapped_addPart(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "addPart");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::setUpAndProcess_addLearner(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(std::move(req), std::move(serializedRequest), ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, &StorageAdminServiceAsyncProcessor::process_addLearner<ProtocolIn_, ProtocolOut_>, this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::process_addLearner(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  StorageAdminService_addLearner_pargs args;
   ::nebula::storage::cpp2::AddLearnerReq uarg_req;
  args.get<0>().value = &uarg_req;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "StorageAdminService.addLearner", ctx));
  try {
    deserializeRequest<ProtocolIn_>(args, ctx->getMethodName(), serializedRequest, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "addLearner");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(req), std::move(ctxStack), return_addLearner<ProtocolIn_,ProtocolOut_>, throw_wrapped_addLearner<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  if (!callback->isRequestActive()) {
    return;
  }
  iface_->async_tm_addLearner(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue StorageAdminServiceAsyncProcessor::return_addLearner(int32_t protoSeqId, apache::thrift::ContextStack* ctx,  ::nebula::storage::cpp2::AdminExecResp const& _return) {
  ProtocolOut_ prot;
  StorageAdminService_addLearner_presult result;
  result.get<0>().value = const_cast< ::nebula::storage::cpp2::AdminExecResp*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("addLearner", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void StorageAdminServiceAsyncProcessor::throw_wrapped_addLearner(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "addLearner");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::setUpAndProcess_removePart(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(std::move(req), std::move(serializedRequest), ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, &StorageAdminServiceAsyncProcessor::process_removePart<ProtocolIn_, ProtocolOut_>, this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::process_removePart(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  StorageAdminService_removePart_pargs args;
   ::nebula::storage::cpp2::RemovePartReq uarg_req;
  args.get<0>().value = &uarg_req;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "StorageAdminService.removePart", ctx));
  try {
    deserializeRequest<ProtocolIn_>(args, ctx->getMethodName(), serializedRequest, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "removePart");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(req), std::move(ctxStack), return_removePart<ProtocolIn_,ProtocolOut_>, throw_wrapped_removePart<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  if (!callback->isRequestActive()) {
    return;
  }
  iface_->async_tm_removePart(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue StorageAdminServiceAsyncProcessor::return_removePart(int32_t protoSeqId, apache::thrift::ContextStack* ctx,  ::nebula::storage::cpp2::AdminExecResp const& _return) {
  ProtocolOut_ prot;
  StorageAdminService_removePart_presult result;
  result.get<0>().value = const_cast< ::nebula::storage::cpp2::AdminExecResp*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("removePart", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void StorageAdminServiceAsyncProcessor::throw_wrapped_removePart(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "removePart");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::setUpAndProcess_memberChange(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(std::move(req), std::move(serializedRequest), ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, &StorageAdminServiceAsyncProcessor::process_memberChange<ProtocolIn_, ProtocolOut_>, this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::process_memberChange(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  StorageAdminService_memberChange_pargs args;
   ::nebula::storage::cpp2::MemberChangeReq uarg_req;
  args.get<0>().value = &uarg_req;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "StorageAdminService.memberChange", ctx));
  try {
    deserializeRequest<ProtocolIn_>(args, ctx->getMethodName(), serializedRequest, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "memberChange");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(req), std::move(ctxStack), return_memberChange<ProtocolIn_,ProtocolOut_>, throw_wrapped_memberChange<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  if (!callback->isRequestActive()) {
    return;
  }
  iface_->async_tm_memberChange(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue StorageAdminServiceAsyncProcessor::return_memberChange(int32_t protoSeqId, apache::thrift::ContextStack* ctx,  ::nebula::storage::cpp2::AdminExecResp const& _return) {
  ProtocolOut_ prot;
  StorageAdminService_memberChange_presult result;
  result.get<0>().value = const_cast< ::nebula::storage::cpp2::AdminExecResp*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("memberChange", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void StorageAdminServiceAsyncProcessor::throw_wrapped_memberChange(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "memberChange");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::setUpAndProcess_waitingForCatchUpData(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(std::move(req), std::move(serializedRequest), ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, &StorageAdminServiceAsyncProcessor::process_waitingForCatchUpData<ProtocolIn_, ProtocolOut_>, this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::process_waitingForCatchUpData(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  StorageAdminService_waitingForCatchUpData_pargs args;
   ::nebula::storage::cpp2::CatchUpDataReq uarg_req;
  args.get<0>().value = &uarg_req;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "StorageAdminService.waitingForCatchUpData", ctx));
  try {
    deserializeRequest<ProtocolIn_>(args, ctx->getMethodName(), serializedRequest, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "waitingForCatchUpData");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(req), std::move(ctxStack), return_waitingForCatchUpData<ProtocolIn_,ProtocolOut_>, throw_wrapped_waitingForCatchUpData<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  if (!callback->isRequestActive()) {
    return;
  }
  iface_->async_tm_waitingForCatchUpData(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue StorageAdminServiceAsyncProcessor::return_waitingForCatchUpData(int32_t protoSeqId, apache::thrift::ContextStack* ctx,  ::nebula::storage::cpp2::AdminExecResp const& _return) {
  ProtocolOut_ prot;
  StorageAdminService_waitingForCatchUpData_presult result;
  result.get<0>().value = const_cast< ::nebula::storage::cpp2::AdminExecResp*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("waitingForCatchUpData", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void StorageAdminServiceAsyncProcessor::throw_wrapped_waitingForCatchUpData(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "waitingForCatchUpData");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::setUpAndProcess_createCheckpoint(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(std::move(req), std::move(serializedRequest), ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, &StorageAdminServiceAsyncProcessor::process_createCheckpoint<ProtocolIn_, ProtocolOut_>, this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::process_createCheckpoint(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  StorageAdminService_createCheckpoint_pargs args;
   ::nebula::storage::cpp2::CreateCPRequest uarg_req;
  args.get<0>().value = &uarg_req;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "StorageAdminService.createCheckpoint", ctx));
  try {
    deserializeRequest<ProtocolIn_>(args, ctx->getMethodName(), serializedRequest, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "createCheckpoint");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback< ::nebula::storage::cpp2::CreateCPResp>>(std::move(req), std::move(ctxStack), return_createCheckpoint<ProtocolIn_,ProtocolOut_>, throw_wrapped_createCheckpoint<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  if (!callback->isRequestActive()) {
    return;
  }
  iface_->async_tm_createCheckpoint(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue StorageAdminServiceAsyncProcessor::return_createCheckpoint(int32_t protoSeqId, apache::thrift::ContextStack* ctx,  ::nebula::storage::cpp2::CreateCPResp const& _return) {
  ProtocolOut_ prot;
  StorageAdminService_createCheckpoint_presult result;
  result.get<0>().value = const_cast< ::nebula::storage::cpp2::CreateCPResp*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("createCheckpoint", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void StorageAdminServiceAsyncProcessor::throw_wrapped_createCheckpoint(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "createCheckpoint");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::setUpAndProcess_dropCheckpoint(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(std::move(req), std::move(serializedRequest), ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, &StorageAdminServiceAsyncProcessor::process_dropCheckpoint<ProtocolIn_, ProtocolOut_>, this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::process_dropCheckpoint(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  StorageAdminService_dropCheckpoint_pargs args;
   ::nebula::storage::cpp2::DropCPRequest uarg_req;
  args.get<0>().value = &uarg_req;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "StorageAdminService.dropCheckpoint", ctx));
  try {
    deserializeRequest<ProtocolIn_>(args, ctx->getMethodName(), serializedRequest, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "dropCheckpoint");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback< ::nebula::storage::cpp2::DropCPResp>>(std::move(req), std::move(ctxStack), return_dropCheckpoint<ProtocolIn_,ProtocolOut_>, throw_wrapped_dropCheckpoint<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  if (!callback->isRequestActive()) {
    return;
  }
  iface_->async_tm_dropCheckpoint(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue StorageAdminServiceAsyncProcessor::return_dropCheckpoint(int32_t protoSeqId, apache::thrift::ContextStack* ctx,  ::nebula::storage::cpp2::DropCPResp const& _return) {
  ProtocolOut_ prot;
  StorageAdminService_dropCheckpoint_presult result;
  result.get<0>().value = const_cast< ::nebula::storage::cpp2::DropCPResp*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("dropCheckpoint", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void StorageAdminServiceAsyncProcessor::throw_wrapped_dropCheckpoint(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "dropCheckpoint");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::setUpAndProcess_blockingWrites(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(std::move(req), std::move(serializedRequest), ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, &StorageAdminServiceAsyncProcessor::process_blockingWrites<ProtocolIn_, ProtocolOut_>, this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::process_blockingWrites(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  StorageAdminService_blockingWrites_pargs args;
   ::nebula::storage::cpp2::BlockingSignRequest uarg_req;
  args.get<0>().value = &uarg_req;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "StorageAdminService.blockingWrites", ctx));
  try {
    deserializeRequest<ProtocolIn_>(args, ctx->getMethodName(), serializedRequest, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "blockingWrites");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback< ::nebula::storage::cpp2::BlockingSignResp>>(std::move(req), std::move(ctxStack), return_blockingWrites<ProtocolIn_,ProtocolOut_>, throw_wrapped_blockingWrites<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  if (!callback->isRequestActive()) {
    return;
  }
  iface_->async_tm_blockingWrites(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue StorageAdminServiceAsyncProcessor::return_blockingWrites(int32_t protoSeqId, apache::thrift::ContextStack* ctx,  ::nebula::storage::cpp2::BlockingSignResp const& _return) {
  ProtocolOut_ prot;
  StorageAdminService_blockingWrites_presult result;
  result.get<0>().value = const_cast< ::nebula::storage::cpp2::BlockingSignResp*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("blockingWrites", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void StorageAdminServiceAsyncProcessor::throw_wrapped_blockingWrites(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "blockingWrites");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::setUpAndProcess_getLeaderParts(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(std::move(req), std::move(serializedRequest), ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, &StorageAdminServiceAsyncProcessor::process_getLeaderParts<ProtocolIn_, ProtocolOut_>, this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::process_getLeaderParts(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  StorageAdminService_getLeaderParts_pargs args;
   ::nebula::storage::cpp2::GetLeaderReq uarg_req;
  args.get<0>().value = &uarg_req;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "StorageAdminService.getLeaderParts", ctx));
  try {
    deserializeRequest<ProtocolIn_>(args, ctx->getMethodName(), serializedRequest, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "getLeaderParts");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback< ::nebula::storage::cpp2::GetLeaderPartsResp>>(std::move(req), std::move(ctxStack), return_getLeaderParts<ProtocolIn_,ProtocolOut_>, throw_wrapped_getLeaderParts<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  if (!callback->isRequestActive()) {
    return;
  }
  iface_->async_tm_getLeaderParts(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue StorageAdminServiceAsyncProcessor::return_getLeaderParts(int32_t protoSeqId, apache::thrift::ContextStack* ctx,  ::nebula::storage::cpp2::GetLeaderPartsResp const& _return) {
  ProtocolOut_ prot;
  StorageAdminService_getLeaderParts_presult result;
  result.get<0>().value = const_cast< ::nebula::storage::cpp2::GetLeaderPartsResp*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("getLeaderParts", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void StorageAdminServiceAsyncProcessor::throw_wrapped_getLeaderParts(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "getLeaderParts");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::setUpAndProcess_checkPeers(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(std::move(req), std::move(serializedRequest), ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, &StorageAdminServiceAsyncProcessor::process_checkPeers<ProtocolIn_, ProtocolOut_>, this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::process_checkPeers(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  StorageAdminService_checkPeers_pargs args;
   ::nebula::storage::cpp2::CheckPeersReq uarg_req;
  args.get<0>().value = &uarg_req;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "StorageAdminService.checkPeers", ctx));
  try {
    deserializeRequest<ProtocolIn_>(args, ctx->getMethodName(), serializedRequest, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "checkPeers");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback< ::nebula::storage::cpp2::AdminExecResp>>(std::move(req), std::move(ctxStack), return_checkPeers<ProtocolIn_,ProtocolOut_>, throw_wrapped_checkPeers<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  if (!callback->isRequestActive()) {
    return;
  }
  iface_->async_tm_checkPeers(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue StorageAdminServiceAsyncProcessor::return_checkPeers(int32_t protoSeqId, apache::thrift::ContextStack* ctx,  ::nebula::storage::cpp2::AdminExecResp const& _return) {
  ProtocolOut_ prot;
  StorageAdminService_checkPeers_presult result;
  result.get<0>().value = const_cast< ::nebula::storage::cpp2::AdminExecResp*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("checkPeers", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void StorageAdminServiceAsyncProcessor::throw_wrapped_checkPeers(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "checkPeers");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::setUpAndProcess_addAdminTask(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(std::move(req), std::move(serializedRequest), ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, &StorageAdminServiceAsyncProcessor::process_addAdminTask<ProtocolIn_, ProtocolOut_>, this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::process_addAdminTask(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  StorageAdminService_addAdminTask_pargs args;
   ::nebula::storage::cpp2::AddTaskRequest uarg_req;
  args.get<0>().value = &uarg_req;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "StorageAdminService.addAdminTask", ctx));
  try {
    deserializeRequest<ProtocolIn_>(args, ctx->getMethodName(), serializedRequest, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "addAdminTask");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback< ::nebula::storage::cpp2::AddTaskResp>>(std::move(req), std::move(ctxStack), return_addAdminTask<ProtocolIn_,ProtocolOut_>, throw_wrapped_addAdminTask<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  if (!callback->isRequestActive()) {
    return;
  }
  iface_->async_tm_addAdminTask(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue StorageAdminServiceAsyncProcessor::return_addAdminTask(int32_t protoSeqId, apache::thrift::ContextStack* ctx,  ::nebula::storage::cpp2::AddTaskResp const& _return) {
  ProtocolOut_ prot;
  StorageAdminService_addAdminTask_presult result;
  result.get<0>().value = const_cast< ::nebula::storage::cpp2::AddTaskResp*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("addAdminTask", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void StorageAdminServiceAsyncProcessor::throw_wrapped_addAdminTask(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "addAdminTask");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::setUpAndProcess_stopAdminTask(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(std::move(req), std::move(serializedRequest), ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, &StorageAdminServiceAsyncProcessor::process_stopAdminTask<ProtocolIn_, ProtocolOut_>, this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::process_stopAdminTask(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  StorageAdminService_stopAdminTask_pargs args;
   ::nebula::storage::cpp2::StopTaskRequest uarg_req;
  args.get<0>().value = &uarg_req;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "StorageAdminService.stopAdminTask", ctx));
  try {
    deserializeRequest<ProtocolIn_>(args, ctx->getMethodName(), serializedRequest, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "stopAdminTask");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback< ::nebula::storage::cpp2::StopTaskResp>>(std::move(req), std::move(ctxStack), return_stopAdminTask<ProtocolIn_,ProtocolOut_>, throw_wrapped_stopAdminTask<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  if (!callback->isRequestActive()) {
    return;
  }
  iface_->async_tm_stopAdminTask(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue StorageAdminServiceAsyncProcessor::return_stopAdminTask(int32_t protoSeqId, apache::thrift::ContextStack* ctx,  ::nebula::storage::cpp2::StopTaskResp const& _return) {
  ProtocolOut_ prot;
  StorageAdminService_stopAdminTask_presult result;
  result.get<0>().value = const_cast< ::nebula::storage::cpp2::StopTaskResp*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("stopAdminTask", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void StorageAdminServiceAsyncProcessor::throw_wrapped_stopAdminTask(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "stopAdminTask");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::setUpAndProcess_clearSpace(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(std::move(req), std::move(serializedRequest), ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, &StorageAdminServiceAsyncProcessor::process_clearSpace<ProtocolIn_, ProtocolOut_>, this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void StorageAdminServiceAsyncProcessor::process_clearSpace(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  StorageAdminService_clearSpace_pargs args;
   ::nebula::storage::cpp2::ClearSpaceReq uarg_req;
  args.get<0>().value = &uarg_req;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "StorageAdminService.clearSpace", ctx));
  try {
    deserializeRequest<ProtocolIn_>(args, ctx->getMethodName(), serializedRequest, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "clearSpace");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback< ::nebula::storage::cpp2::ClearSpaceResp>>(std::move(req), std::move(ctxStack), return_clearSpace<ProtocolIn_,ProtocolOut_>, throw_wrapped_clearSpace<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  if (!callback->isRequestActive()) {
    return;
  }
  iface_->async_tm_clearSpace(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue StorageAdminServiceAsyncProcessor::return_clearSpace(int32_t protoSeqId, apache::thrift::ContextStack* ctx,  ::nebula::storage::cpp2::ClearSpaceResp const& _return) {
  ProtocolOut_ prot;
  StorageAdminService_clearSpace_presult result;
  result.get<0>().value = const_cast< ::nebula::storage::cpp2::ClearSpaceResp*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("clearSpace", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void StorageAdminServiceAsyncProcessor::throw_wrapped_clearSpace(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "clearSpace");
    return;
  }
}


}}} // nebula::storage::cpp2
