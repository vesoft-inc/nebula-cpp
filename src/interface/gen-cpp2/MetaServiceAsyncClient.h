/**
 * Autogenerated by Thrift for meta.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/client_h.h>

#include "meta_types.h"
#include "common_types.h"

namespace apache { namespace thrift {
  class Cpp2RequestContext;
  namespace detail { namespace ac { struct ClientRequestContext; }}
  namespace transport { class THeader; }
}}

namespace nebula { namespace meta { namespace cpp2 {

class MetaServiceAsyncClient : public apache::thrift::GeneratedAsyncClient {
 public:
  using apache::thrift::GeneratedAsyncClient::GeneratedAsyncClient;

  char const* getServiceName() const noexcept override {
    return "MetaService";
  }


  virtual void createSpace(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req);
  virtual void createSpace(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req);
 protected:
  void createSpaceImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req);
 public:

  virtual void sync_createSpace( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req);
  virtual void sync_createSpace(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_createSpace(const  ::nebula::meta::cpp2::CreateSpaceReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_createSpace(const  ::nebula::meta::cpp2::CreateSpaceReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_createSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_createSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_createSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_createSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createSpace(const  ::nebula::meta::cpp2::CreateSpaceReq& p_req) {
    return co_createSpace<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req) {
    return co_createSpace<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createSpace(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = createSpaceCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      createSpaceImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      createSpaceImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_createSpace(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void createSpace(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req);


  static folly::exception_wrapper recv_wrapped_createSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_createSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_createSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_createSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void createSpaceT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateSpaceReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> createSpaceCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void dropSpace(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropSpaceReq& p_req);
  virtual void dropSpace(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropSpaceReq& p_req);
 protected:
  void dropSpaceImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropSpaceReq& p_req);
 public:

  virtual void sync_dropSpace( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropSpaceReq& p_req);
  virtual void sync_dropSpace(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropSpaceReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropSpace(const  ::nebula::meta::cpp2::DropSpaceReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropSpace(const  ::nebula::meta::cpp2::DropSpaceReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropSpaceReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropSpaceReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_dropSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropSpaceReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_dropSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropSpaceReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropSpace(const  ::nebula::meta::cpp2::DropSpaceReq& p_req) {
    return co_dropSpace<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropSpaceReq& p_req) {
    return co_dropSpace<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropSpace(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::DropSpaceReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = dropSpaceCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      dropSpaceImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      dropSpaceImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_dropSpace(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void dropSpace(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropSpaceReq& p_req);


  static folly::exception_wrapper recv_wrapped_dropSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_dropSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_dropSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_dropSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void dropSpaceT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropSpaceReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> dropSpaceCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void getSpace(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetSpaceReq& p_req);
  virtual void getSpace(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetSpaceReq& p_req);
 protected:
  void getSpaceImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetSpaceReq& p_req);
 public:

  virtual void sync_getSpace( ::nebula::meta::cpp2::GetSpaceResp& _return, const  ::nebula::meta::cpp2::GetSpaceReq& p_req);
  virtual void sync_getSpace(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetSpaceResp& _return, const  ::nebula::meta::cpp2::GetSpaceReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::GetSpaceResp> future_getSpace(const  ::nebula::meta::cpp2::GetSpaceReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetSpaceResp> semifuture_getSpace(const  ::nebula::meta::cpp2::GetSpaceReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::GetSpaceResp> future_getSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetSpaceReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetSpaceResp> semifuture_getSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetSpaceReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::GetSpaceResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_getSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetSpaceReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetSpaceResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_getSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetSpaceReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetSpaceResp> co_getSpace(const  ::nebula::meta::cpp2::GetSpaceReq& p_req) {
    return co_getSpace<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetSpaceResp> co_getSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetSpaceReq& p_req) {
    return co_getSpace<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::GetSpaceResp> co_getSpace(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::GetSpaceReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = getSpaceCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      getSpaceImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      getSpaceImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::GetSpaceResp _return;
    if (auto ew = recv_wrapped_getSpace(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void getSpace(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetSpaceReq& p_req);


  static folly::exception_wrapper recv_wrapped_getSpace( ::nebula::meta::cpp2::GetSpaceResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_getSpace( ::nebula::meta::cpp2::GetSpaceResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_getSpace( ::nebula::meta::cpp2::GetSpaceResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_getSpace( ::nebula::meta::cpp2::GetSpaceResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void getSpaceT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetSpaceReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> getSpaceCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void listSpaces(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListSpacesReq& p_req);
  virtual void listSpaces(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListSpacesReq& p_req);
 protected:
  void listSpacesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListSpacesReq& p_req);
 public:

  virtual void sync_listSpaces( ::nebula::meta::cpp2::ListSpacesResp& _return, const  ::nebula::meta::cpp2::ListSpacesReq& p_req);
  virtual void sync_listSpaces(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListSpacesResp& _return, const  ::nebula::meta::cpp2::ListSpacesReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListSpacesResp> future_listSpaces(const  ::nebula::meta::cpp2::ListSpacesReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListSpacesResp> semifuture_listSpaces(const  ::nebula::meta::cpp2::ListSpacesReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListSpacesResp> future_listSpaces(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSpacesReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListSpacesResp> semifuture_listSpaces(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSpacesReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListSpacesResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_listSpaces(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSpacesReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListSpacesResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_listSpaces(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSpacesReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListSpacesResp> co_listSpaces(const  ::nebula::meta::cpp2::ListSpacesReq& p_req) {
    return co_listSpaces<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListSpacesResp> co_listSpaces(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSpacesReq& p_req) {
    return co_listSpaces<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListSpacesResp> co_listSpaces(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ListSpacesReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = listSpacesCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      listSpacesImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      listSpacesImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListSpacesResp _return;
    if (auto ew = recv_wrapped_listSpaces(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void listSpaces(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListSpacesReq& p_req);


  static folly::exception_wrapper recv_wrapped_listSpaces( ::nebula::meta::cpp2::ListSpacesResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_listSpaces( ::nebula::meta::cpp2::ListSpacesResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_listSpaces( ::nebula::meta::cpp2::ListSpacesResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_listSpaces( ::nebula::meta::cpp2::ListSpacesResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void listSpacesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListSpacesReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> listSpacesCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void alterSpace(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AlterSpaceReq& p_req);
  virtual void alterSpace(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AlterSpaceReq& p_req);
 protected:
  void alterSpaceImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AlterSpaceReq& p_req);
 public:

  virtual void sync_alterSpace( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AlterSpaceReq& p_req);
  virtual void sync_alterSpace(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AlterSpaceReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_alterSpace(const  ::nebula::meta::cpp2::AlterSpaceReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_alterSpace(const  ::nebula::meta::cpp2::AlterSpaceReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_alterSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterSpaceReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_alterSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterSpaceReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_alterSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterSpaceReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_alterSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterSpaceReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_alterSpace(const  ::nebula::meta::cpp2::AlterSpaceReq& p_req) {
    return co_alterSpace<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_alterSpace(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterSpaceReq& p_req) {
    return co_alterSpace<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_alterSpace(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::AlterSpaceReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = alterSpaceCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      alterSpaceImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      alterSpaceImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_alterSpace(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void alterSpace(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::AlterSpaceReq& p_req);


  static folly::exception_wrapper recv_wrapped_alterSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_alterSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_alterSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_alterSpace( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void alterSpaceT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AlterSpaceReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> alterSpaceCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void createSpaceAs(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req);
  virtual void createSpaceAs(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req);
 protected:
  void createSpaceAsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req);
 public:

  virtual void sync_createSpaceAs( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req);
  virtual void sync_createSpaceAs(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_createSpaceAs(const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_createSpaceAs(const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_createSpaceAs(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_createSpaceAs(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_createSpaceAs(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_createSpaceAs(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createSpaceAs(const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req) {
    return co_createSpaceAs<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createSpaceAs(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req) {
    return co_createSpaceAs<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createSpaceAs(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = createSpaceAsCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      createSpaceAsImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      createSpaceAsImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_createSpaceAs(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void createSpaceAs(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req);


  static folly::exception_wrapper recv_wrapped_createSpaceAs( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_createSpaceAs( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_createSpaceAs( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_createSpaceAs( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void createSpaceAsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateSpaceAsReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> createSpaceAsCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void createTag(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateTagReq& p_req);
  virtual void createTag(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateTagReq& p_req);
 protected:
  void createTagImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateTagReq& p_req);
 public:

  virtual void sync_createTag( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateTagReq& p_req);
  virtual void sync_createTag(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateTagReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_createTag(const  ::nebula::meta::cpp2::CreateTagReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_createTag(const  ::nebula::meta::cpp2::CreateTagReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_createTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateTagReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_createTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateTagReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_createTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateTagReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_createTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateTagReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createTag(const  ::nebula::meta::cpp2::CreateTagReq& p_req) {
    return co_createTag<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateTagReq& p_req) {
    return co_createTag<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createTag(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::CreateTagReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = createTagCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      createTagImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      createTagImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_createTag(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void createTag(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateTagReq& p_req);


  static folly::exception_wrapper recv_wrapped_createTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_createTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_createTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_createTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void createTagT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateTagReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> createTagCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void alterTag(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AlterTagReq& p_req);
  virtual void alterTag(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AlterTagReq& p_req);
 protected:
  void alterTagImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AlterTagReq& p_req);
 public:

  virtual void sync_alterTag( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AlterTagReq& p_req);
  virtual void sync_alterTag(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AlterTagReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_alterTag(const  ::nebula::meta::cpp2::AlterTagReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_alterTag(const  ::nebula::meta::cpp2::AlterTagReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_alterTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterTagReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_alterTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterTagReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_alterTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterTagReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_alterTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterTagReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_alterTag(const  ::nebula::meta::cpp2::AlterTagReq& p_req) {
    return co_alterTag<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_alterTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterTagReq& p_req) {
    return co_alterTag<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_alterTag(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::AlterTagReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = alterTagCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      alterTagImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      alterTagImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_alterTag(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void alterTag(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::AlterTagReq& p_req);


  static folly::exception_wrapper recv_wrapped_alterTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_alterTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_alterTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_alterTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void alterTagT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AlterTagReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> alterTagCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void dropTag(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropTagReq& p_req);
  virtual void dropTag(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropTagReq& p_req);
 protected:
  void dropTagImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropTagReq& p_req);
 public:

  virtual void sync_dropTag( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropTagReq& p_req);
  virtual void sync_dropTag(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropTagReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropTag(const  ::nebula::meta::cpp2::DropTagReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropTag(const  ::nebula::meta::cpp2::DropTagReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropTagReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropTagReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_dropTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropTagReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_dropTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropTagReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropTag(const  ::nebula::meta::cpp2::DropTagReq& p_req) {
    return co_dropTag<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropTagReq& p_req) {
    return co_dropTag<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropTag(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::DropTagReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = dropTagCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      dropTagImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      dropTagImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_dropTag(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void dropTag(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropTagReq& p_req);


  static folly::exception_wrapper recv_wrapped_dropTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_dropTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_dropTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_dropTag( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void dropTagT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropTagReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> dropTagCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void getTag(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetTagReq& p_req);
  virtual void getTag(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetTagReq& p_req);
 protected:
  void getTagImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetTagReq& p_req);
 public:

  virtual void sync_getTag( ::nebula::meta::cpp2::GetTagResp& _return, const  ::nebula::meta::cpp2::GetTagReq& p_req);
  virtual void sync_getTag(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetTagResp& _return, const  ::nebula::meta::cpp2::GetTagReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::GetTagResp> future_getTag(const  ::nebula::meta::cpp2::GetTagReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetTagResp> semifuture_getTag(const  ::nebula::meta::cpp2::GetTagReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::GetTagResp> future_getTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetTagReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetTagResp> semifuture_getTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetTagReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::GetTagResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_getTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetTagReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetTagResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_getTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetTagReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetTagResp> co_getTag(const  ::nebula::meta::cpp2::GetTagReq& p_req) {
    return co_getTag<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetTagResp> co_getTag(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetTagReq& p_req) {
    return co_getTag<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::GetTagResp> co_getTag(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::GetTagReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = getTagCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      getTagImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      getTagImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::GetTagResp _return;
    if (auto ew = recv_wrapped_getTag(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void getTag(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetTagReq& p_req);


  static folly::exception_wrapper recv_wrapped_getTag( ::nebula::meta::cpp2::GetTagResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_getTag( ::nebula::meta::cpp2::GetTagResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_getTag( ::nebula::meta::cpp2::GetTagResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_getTag( ::nebula::meta::cpp2::GetTagResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void getTagT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetTagReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> getTagCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void listTags(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListTagsReq& p_req);
  virtual void listTags(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListTagsReq& p_req);
 protected:
  void listTagsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListTagsReq& p_req);
 public:

  virtual void sync_listTags( ::nebula::meta::cpp2::ListTagsResp& _return, const  ::nebula::meta::cpp2::ListTagsReq& p_req);
  virtual void sync_listTags(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListTagsResp& _return, const  ::nebula::meta::cpp2::ListTagsReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListTagsResp> future_listTags(const  ::nebula::meta::cpp2::ListTagsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListTagsResp> semifuture_listTags(const  ::nebula::meta::cpp2::ListTagsReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListTagsResp> future_listTags(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListTagsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListTagsResp> semifuture_listTags(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListTagsReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListTagsResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_listTags(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListTagsReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListTagsResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_listTags(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListTagsReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListTagsResp> co_listTags(const  ::nebula::meta::cpp2::ListTagsReq& p_req) {
    return co_listTags<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListTagsResp> co_listTags(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListTagsReq& p_req) {
    return co_listTags<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListTagsResp> co_listTags(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ListTagsReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = listTagsCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      listTagsImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      listTagsImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListTagsResp _return;
    if (auto ew = recv_wrapped_listTags(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void listTags(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListTagsReq& p_req);


  static folly::exception_wrapper recv_wrapped_listTags( ::nebula::meta::cpp2::ListTagsResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_listTags( ::nebula::meta::cpp2::ListTagsResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_listTags( ::nebula::meta::cpp2::ListTagsResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_listTags( ::nebula::meta::cpp2::ListTagsResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void listTagsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListTagsReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> listTagsCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void createEdge(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req);
  virtual void createEdge(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req);
 protected:
  void createEdgeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req);
 public:

  virtual void sync_createEdge( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req);
  virtual void sync_createEdge(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_createEdge(const  ::nebula::meta::cpp2::CreateEdgeReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_createEdge(const  ::nebula::meta::cpp2::CreateEdgeReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_createEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_createEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_createEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_createEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createEdge(const  ::nebula::meta::cpp2::CreateEdgeReq& p_req) {
    return co_createEdge<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req) {
    return co_createEdge<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createEdge(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = createEdgeCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      createEdgeImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      createEdgeImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_createEdge(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void createEdge(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req);


  static folly::exception_wrapper recv_wrapped_createEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_createEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_createEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_createEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void createEdgeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateEdgeReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> createEdgeCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void alterEdge(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req);
  virtual void alterEdge(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req);
 protected:
  void alterEdgeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req);
 public:

  virtual void sync_alterEdge( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req);
  virtual void sync_alterEdge(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_alterEdge(const  ::nebula::meta::cpp2::AlterEdgeReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_alterEdge(const  ::nebula::meta::cpp2::AlterEdgeReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_alterEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_alterEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_alterEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_alterEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_alterEdge(const  ::nebula::meta::cpp2::AlterEdgeReq& p_req) {
    return co_alterEdge<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_alterEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req) {
    return co_alterEdge<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_alterEdge(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = alterEdgeCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      alterEdgeImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      alterEdgeImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_alterEdge(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void alterEdge(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req);


  static folly::exception_wrapper recv_wrapped_alterEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_alterEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_alterEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_alterEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void alterEdgeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AlterEdgeReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> alterEdgeCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void dropEdge(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropEdgeReq& p_req);
  virtual void dropEdge(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropEdgeReq& p_req);
 protected:
  void dropEdgeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropEdgeReq& p_req);
 public:

  virtual void sync_dropEdge( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropEdgeReq& p_req);
  virtual void sync_dropEdge(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropEdgeReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropEdge(const  ::nebula::meta::cpp2::DropEdgeReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropEdge(const  ::nebula::meta::cpp2::DropEdgeReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropEdgeReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropEdgeReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_dropEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropEdgeReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_dropEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropEdgeReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropEdge(const  ::nebula::meta::cpp2::DropEdgeReq& p_req) {
    return co_dropEdge<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropEdgeReq& p_req) {
    return co_dropEdge<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropEdge(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::DropEdgeReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = dropEdgeCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      dropEdgeImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      dropEdgeImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_dropEdge(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void dropEdge(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropEdgeReq& p_req);


  static folly::exception_wrapper recv_wrapped_dropEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_dropEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_dropEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_dropEdge( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void dropEdgeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropEdgeReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> dropEdgeCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void getEdge(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetEdgeReq& p_req);
  virtual void getEdge(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetEdgeReq& p_req);
 protected:
  void getEdgeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetEdgeReq& p_req);
 public:

  virtual void sync_getEdge( ::nebula::meta::cpp2::GetEdgeResp& _return, const  ::nebula::meta::cpp2::GetEdgeReq& p_req);
  virtual void sync_getEdge(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetEdgeResp& _return, const  ::nebula::meta::cpp2::GetEdgeReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::GetEdgeResp> future_getEdge(const  ::nebula::meta::cpp2::GetEdgeReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetEdgeResp> semifuture_getEdge(const  ::nebula::meta::cpp2::GetEdgeReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::GetEdgeResp> future_getEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetEdgeReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetEdgeResp> semifuture_getEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetEdgeReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::GetEdgeResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_getEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetEdgeReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetEdgeResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_getEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetEdgeReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetEdgeResp> co_getEdge(const  ::nebula::meta::cpp2::GetEdgeReq& p_req) {
    return co_getEdge<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetEdgeResp> co_getEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetEdgeReq& p_req) {
    return co_getEdge<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::GetEdgeResp> co_getEdge(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::GetEdgeReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = getEdgeCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      getEdgeImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      getEdgeImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::GetEdgeResp _return;
    if (auto ew = recv_wrapped_getEdge(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void getEdge(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetEdgeReq& p_req);


  static folly::exception_wrapper recv_wrapped_getEdge( ::nebula::meta::cpp2::GetEdgeResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_getEdge( ::nebula::meta::cpp2::GetEdgeResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_getEdge( ::nebula::meta::cpp2::GetEdgeResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_getEdge( ::nebula::meta::cpp2::GetEdgeResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void getEdgeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetEdgeReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> getEdgeCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void listEdges(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListEdgesReq& p_req);
  virtual void listEdges(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListEdgesReq& p_req);
 protected:
  void listEdgesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListEdgesReq& p_req);
 public:

  virtual void sync_listEdges( ::nebula::meta::cpp2::ListEdgesResp& _return, const  ::nebula::meta::cpp2::ListEdgesReq& p_req);
  virtual void sync_listEdges(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListEdgesResp& _return, const  ::nebula::meta::cpp2::ListEdgesReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListEdgesResp> future_listEdges(const  ::nebula::meta::cpp2::ListEdgesReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListEdgesResp> semifuture_listEdges(const  ::nebula::meta::cpp2::ListEdgesReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListEdgesResp> future_listEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListEdgesReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListEdgesResp> semifuture_listEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListEdgesReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListEdgesResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_listEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListEdgesReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListEdgesResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_listEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListEdgesReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListEdgesResp> co_listEdges(const  ::nebula::meta::cpp2::ListEdgesReq& p_req) {
    return co_listEdges<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListEdgesResp> co_listEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListEdgesReq& p_req) {
    return co_listEdges<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListEdgesResp> co_listEdges(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ListEdgesReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = listEdgesCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      listEdgesImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      listEdgesImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListEdgesResp _return;
    if (auto ew = recv_wrapped_listEdges(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void listEdges(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListEdgesReq& p_req);


  static folly::exception_wrapper recv_wrapped_listEdges( ::nebula::meta::cpp2::ListEdgesResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_listEdges( ::nebula::meta::cpp2::ListEdgesResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_listEdges( ::nebula::meta::cpp2::ListEdgesResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_listEdges( ::nebula::meta::cpp2::ListEdgesResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void listEdgesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListEdgesReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> listEdgesCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void addHosts(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AddHostsReq& p_req);
  virtual void addHosts(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AddHostsReq& p_req);
 protected:
  void addHostsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AddHostsReq& p_req);
 public:

  virtual void sync_addHosts( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AddHostsReq& p_req);
  virtual void sync_addHosts(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AddHostsReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_addHosts(const  ::nebula::meta::cpp2::AddHostsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_addHosts(const  ::nebula::meta::cpp2::AddHostsReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_addHosts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddHostsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_addHosts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddHostsReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_addHosts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddHostsReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_addHosts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddHostsReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_addHosts(const  ::nebula::meta::cpp2::AddHostsReq& p_req) {
    return co_addHosts<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_addHosts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddHostsReq& p_req) {
    return co_addHosts<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_addHosts(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::AddHostsReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = addHostsCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      addHostsImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      addHostsImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_addHosts(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void addHosts(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::AddHostsReq& p_req);


  static folly::exception_wrapper recv_wrapped_addHosts( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_addHosts( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_addHosts( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_addHosts( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void addHostsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AddHostsReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> addHostsCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void addHostsIntoZone(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AddHostsIntoZoneReq& p_req);
  virtual void addHostsIntoZone(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AddHostsIntoZoneReq& p_req);
 protected:
  void addHostsIntoZoneImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AddHostsIntoZoneReq& p_req);
 public:

  virtual void sync_addHostsIntoZone( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AddHostsIntoZoneReq& p_req);
  virtual void sync_addHostsIntoZone(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AddHostsIntoZoneReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_addHostsIntoZone(const  ::nebula::meta::cpp2::AddHostsIntoZoneReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_addHostsIntoZone(const  ::nebula::meta::cpp2::AddHostsIntoZoneReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_addHostsIntoZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddHostsIntoZoneReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_addHostsIntoZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddHostsIntoZoneReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_addHostsIntoZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddHostsIntoZoneReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_addHostsIntoZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddHostsIntoZoneReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_addHostsIntoZone(const  ::nebula::meta::cpp2::AddHostsIntoZoneReq& p_req) {
    return co_addHostsIntoZone<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_addHostsIntoZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddHostsIntoZoneReq& p_req) {
    return co_addHostsIntoZone<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_addHostsIntoZone(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::AddHostsIntoZoneReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = addHostsIntoZoneCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      addHostsIntoZoneImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      addHostsIntoZoneImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_addHostsIntoZone(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void addHostsIntoZone(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::AddHostsIntoZoneReq& p_req);


  static folly::exception_wrapper recv_wrapped_addHostsIntoZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_addHostsIntoZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_addHostsIntoZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_addHostsIntoZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void addHostsIntoZoneT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AddHostsIntoZoneReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> addHostsIntoZoneCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void dropHosts(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropHostsReq& p_req);
  virtual void dropHosts(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropHostsReq& p_req);
 protected:
  void dropHostsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropHostsReq& p_req);
 public:

  virtual void sync_dropHosts( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropHostsReq& p_req);
  virtual void sync_dropHosts(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropHostsReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropHosts(const  ::nebula::meta::cpp2::DropHostsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropHosts(const  ::nebula::meta::cpp2::DropHostsReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropHosts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropHostsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropHosts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropHostsReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_dropHosts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropHostsReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_dropHosts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropHostsReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropHosts(const  ::nebula::meta::cpp2::DropHostsReq& p_req) {
    return co_dropHosts<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropHosts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropHostsReq& p_req) {
    return co_dropHosts<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropHosts(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::DropHostsReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = dropHostsCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      dropHostsImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      dropHostsImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_dropHosts(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void dropHosts(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropHostsReq& p_req);


  static folly::exception_wrapper recv_wrapped_dropHosts( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_dropHosts( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_dropHosts( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_dropHosts( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void dropHostsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropHostsReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> dropHostsCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void listHosts(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListHostsReq& p_req);
  virtual void listHosts(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListHostsReq& p_req);
 protected:
  void listHostsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListHostsReq& p_req);
 public:

  virtual void sync_listHosts( ::nebula::meta::cpp2::ListHostsResp& _return, const  ::nebula::meta::cpp2::ListHostsReq& p_req);
  virtual void sync_listHosts(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListHostsResp& _return, const  ::nebula::meta::cpp2::ListHostsReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListHostsResp> future_listHosts(const  ::nebula::meta::cpp2::ListHostsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListHostsResp> semifuture_listHosts(const  ::nebula::meta::cpp2::ListHostsReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListHostsResp> future_listHosts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListHostsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListHostsResp> semifuture_listHosts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListHostsReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListHostsResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_listHosts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListHostsReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListHostsResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_listHosts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListHostsReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListHostsResp> co_listHosts(const  ::nebula::meta::cpp2::ListHostsReq& p_req) {
    return co_listHosts<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListHostsResp> co_listHosts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListHostsReq& p_req) {
    return co_listHosts<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListHostsResp> co_listHosts(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ListHostsReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = listHostsCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      listHostsImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      listHostsImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListHostsResp _return;
    if (auto ew = recv_wrapped_listHosts(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void listHosts(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListHostsReq& p_req);


  static folly::exception_wrapper recv_wrapped_listHosts( ::nebula::meta::cpp2::ListHostsResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_listHosts( ::nebula::meta::cpp2::ListHostsResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_listHosts( ::nebula::meta::cpp2::ListHostsResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_listHosts( ::nebula::meta::cpp2::ListHostsResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void listHostsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListHostsReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> listHostsCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void getPartsAlloc(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req);
  virtual void getPartsAlloc(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req);
 protected:
  void getPartsAllocImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req);
 public:

  virtual void sync_getPartsAlloc( ::nebula::meta::cpp2::GetPartsAllocResp& _return, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req);
  virtual void sync_getPartsAlloc(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetPartsAllocResp& _return, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::GetPartsAllocResp> future_getPartsAlloc(const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetPartsAllocResp> semifuture_getPartsAlloc(const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::GetPartsAllocResp> future_getPartsAlloc(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetPartsAllocResp> semifuture_getPartsAlloc(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::GetPartsAllocResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_getPartsAlloc(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetPartsAllocResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_getPartsAlloc(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetPartsAllocResp> co_getPartsAlloc(const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req) {
    return co_getPartsAlloc<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetPartsAllocResp> co_getPartsAlloc(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req) {
    return co_getPartsAlloc<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::GetPartsAllocResp> co_getPartsAlloc(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = getPartsAllocCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      getPartsAllocImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      getPartsAllocImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::GetPartsAllocResp _return;
    if (auto ew = recv_wrapped_getPartsAlloc(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void getPartsAlloc(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req);


  static folly::exception_wrapper recv_wrapped_getPartsAlloc( ::nebula::meta::cpp2::GetPartsAllocResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_getPartsAlloc( ::nebula::meta::cpp2::GetPartsAllocResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_getPartsAlloc( ::nebula::meta::cpp2::GetPartsAllocResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_getPartsAlloc( ::nebula::meta::cpp2::GetPartsAllocResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void getPartsAllocT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetPartsAllocReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> getPartsAllocCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void listParts(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListPartsReq& p_req);
  virtual void listParts(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListPartsReq& p_req);
 protected:
  void listPartsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListPartsReq& p_req);
 public:

  virtual void sync_listParts( ::nebula::meta::cpp2::ListPartsResp& _return, const  ::nebula::meta::cpp2::ListPartsReq& p_req);
  virtual void sync_listParts(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListPartsResp& _return, const  ::nebula::meta::cpp2::ListPartsReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListPartsResp> future_listParts(const  ::nebula::meta::cpp2::ListPartsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListPartsResp> semifuture_listParts(const  ::nebula::meta::cpp2::ListPartsReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListPartsResp> future_listParts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListPartsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListPartsResp> semifuture_listParts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListPartsReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListPartsResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_listParts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListPartsReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListPartsResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_listParts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListPartsReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListPartsResp> co_listParts(const  ::nebula::meta::cpp2::ListPartsReq& p_req) {
    return co_listParts<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListPartsResp> co_listParts(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListPartsReq& p_req) {
    return co_listParts<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListPartsResp> co_listParts(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ListPartsReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = listPartsCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      listPartsImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      listPartsImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListPartsResp _return;
    if (auto ew = recv_wrapped_listParts(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void listParts(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListPartsReq& p_req);


  static folly::exception_wrapper recv_wrapped_listParts( ::nebula::meta::cpp2::ListPartsResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_listParts( ::nebula::meta::cpp2::ListPartsResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_listParts( ::nebula::meta::cpp2::ListPartsResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_listParts( ::nebula::meta::cpp2::ListPartsResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void listPartsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListPartsReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> listPartsCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void getWorkerId(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetWorkerIdReq& p_req);
  virtual void getWorkerId(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetWorkerIdReq& p_req);
 protected:
  void getWorkerIdImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetWorkerIdReq& p_req);
 public:

  virtual void sync_getWorkerId( ::nebula::meta::cpp2::GetWorkerIdResp& _return, const  ::nebula::meta::cpp2::GetWorkerIdReq& p_req);
  virtual void sync_getWorkerId(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetWorkerIdResp& _return, const  ::nebula::meta::cpp2::GetWorkerIdReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::GetWorkerIdResp> future_getWorkerId(const  ::nebula::meta::cpp2::GetWorkerIdReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetWorkerIdResp> semifuture_getWorkerId(const  ::nebula::meta::cpp2::GetWorkerIdReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::GetWorkerIdResp> future_getWorkerId(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetWorkerIdReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetWorkerIdResp> semifuture_getWorkerId(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetWorkerIdReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::GetWorkerIdResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_getWorkerId(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetWorkerIdReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetWorkerIdResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_getWorkerId(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetWorkerIdReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetWorkerIdResp> co_getWorkerId(const  ::nebula::meta::cpp2::GetWorkerIdReq& p_req) {
    return co_getWorkerId<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetWorkerIdResp> co_getWorkerId(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetWorkerIdReq& p_req) {
    return co_getWorkerId<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::GetWorkerIdResp> co_getWorkerId(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::GetWorkerIdReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = getWorkerIdCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      getWorkerIdImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      getWorkerIdImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::GetWorkerIdResp _return;
    if (auto ew = recv_wrapped_getWorkerId(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void getWorkerId(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetWorkerIdReq& p_req);


  static folly::exception_wrapper recv_wrapped_getWorkerId( ::nebula::meta::cpp2::GetWorkerIdResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_getWorkerId( ::nebula::meta::cpp2::GetWorkerIdResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_getWorkerId( ::nebula::meta::cpp2::GetWorkerIdResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_getWorkerId( ::nebula::meta::cpp2::GetWorkerIdResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void getWorkerIdT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetWorkerIdReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> getWorkerIdCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void multiPut(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::MultiPutReq& p_req);
  virtual void multiPut(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::MultiPutReq& p_req);
 protected:
  void multiPutImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::MultiPutReq& p_req);
 public:

  virtual void sync_multiPut( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::MultiPutReq& p_req);
  virtual void sync_multiPut(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::MultiPutReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_multiPut(const  ::nebula::meta::cpp2::MultiPutReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_multiPut(const  ::nebula::meta::cpp2::MultiPutReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_multiPut(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MultiPutReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_multiPut(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MultiPutReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_multiPut(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MultiPutReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_multiPut(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MultiPutReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_multiPut(const  ::nebula::meta::cpp2::MultiPutReq& p_req) {
    return co_multiPut<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_multiPut(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MultiPutReq& p_req) {
    return co_multiPut<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_multiPut(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::MultiPutReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = multiPutCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      multiPutImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      multiPutImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_multiPut(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void multiPut(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::MultiPutReq& p_req);


  static folly::exception_wrapper recv_wrapped_multiPut( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_multiPut( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_multiPut( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_multiPut( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void multiPutT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::MultiPutReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> multiPutCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void get(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetReq& p_req);
  virtual void get(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetReq& p_req);
 protected:
  void getImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetReq& p_req);
 public:

  virtual void sync_get( ::nebula::meta::cpp2::GetResp& _return, const  ::nebula::meta::cpp2::GetReq& p_req);
  virtual void sync_get(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetResp& _return, const  ::nebula::meta::cpp2::GetReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::GetResp> future_get(const  ::nebula::meta::cpp2::GetReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetResp> semifuture_get(const  ::nebula::meta::cpp2::GetReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::GetResp> future_get(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetResp> semifuture_get(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::GetResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_get(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_get(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetResp> co_get(const  ::nebula::meta::cpp2::GetReq& p_req) {
    return co_get<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetResp> co_get(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetReq& p_req) {
    return co_get<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::GetResp> co_get(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::GetReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = getCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      getImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      getImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::GetResp _return;
    if (auto ew = recv_wrapped_get(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void get(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetReq& p_req);


  static folly::exception_wrapper recv_wrapped_get( ::nebula::meta::cpp2::GetResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_get( ::nebula::meta::cpp2::GetResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_get( ::nebula::meta::cpp2::GetResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_get( ::nebula::meta::cpp2::GetResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void getT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> getCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void multiGet(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::MultiGetReq& p_req);
  virtual void multiGet(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::MultiGetReq& p_req);
 protected:
  void multiGetImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::MultiGetReq& p_req);
 public:

  virtual void sync_multiGet( ::nebula::meta::cpp2::MultiGetResp& _return, const  ::nebula::meta::cpp2::MultiGetReq& p_req);
  virtual void sync_multiGet(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::MultiGetResp& _return, const  ::nebula::meta::cpp2::MultiGetReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::MultiGetResp> future_multiGet(const  ::nebula::meta::cpp2::MultiGetReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::MultiGetResp> semifuture_multiGet(const  ::nebula::meta::cpp2::MultiGetReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::MultiGetResp> future_multiGet(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MultiGetReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::MultiGetResp> semifuture_multiGet(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MultiGetReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::MultiGetResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_multiGet(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MultiGetReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::MultiGetResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_multiGet(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MultiGetReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::MultiGetResp> co_multiGet(const  ::nebula::meta::cpp2::MultiGetReq& p_req) {
    return co_multiGet<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::MultiGetResp> co_multiGet(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MultiGetReq& p_req) {
    return co_multiGet<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::MultiGetResp> co_multiGet(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::MultiGetReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = multiGetCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      multiGetImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      multiGetImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::MultiGetResp _return;
    if (auto ew = recv_wrapped_multiGet(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void multiGet(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::MultiGetReq& p_req);


  static folly::exception_wrapper recv_wrapped_multiGet( ::nebula::meta::cpp2::MultiGetResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_multiGet( ::nebula::meta::cpp2::MultiGetResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_multiGet( ::nebula::meta::cpp2::MultiGetResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_multiGet( ::nebula::meta::cpp2::MultiGetResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void multiGetT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::MultiGetReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> multiGetCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void remove(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RemoveReq& p_req);
  virtual void remove(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RemoveReq& p_req);
 protected:
  void removeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RemoveReq& p_req);
 public:

  virtual void sync_remove( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RemoveReq& p_req);
  virtual void sync_remove(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RemoveReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_remove(const  ::nebula::meta::cpp2::RemoveReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_remove(const  ::nebula::meta::cpp2::RemoveReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_remove(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_remove(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_remove(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_remove(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_remove(const  ::nebula::meta::cpp2::RemoveReq& p_req) {
    return co_remove<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_remove(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveReq& p_req) {
    return co_remove<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_remove(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::RemoveReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = removeCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      removeImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      removeImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_remove(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void remove(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::RemoveReq& p_req);


  static folly::exception_wrapper recv_wrapped_remove( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_remove( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_remove( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_remove( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void removeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RemoveReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> removeCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void removeRange(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req);
  virtual void removeRange(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req);
 protected:
  void removeRangeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req);
 public:

  virtual void sync_removeRange( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req);
  virtual void sync_removeRange(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_removeRange(const  ::nebula::meta::cpp2::RemoveRangeReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_removeRange(const  ::nebula::meta::cpp2::RemoveRangeReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_removeRange(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_removeRange(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_removeRange(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_removeRange(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_removeRange(const  ::nebula::meta::cpp2::RemoveRangeReq& p_req) {
    return co_removeRange<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_removeRange(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req) {
    return co_removeRange<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_removeRange(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = removeRangeCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      removeRangeImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      removeRangeImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_removeRange(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void removeRange(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req);


  static folly::exception_wrapper recv_wrapped_removeRange( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_removeRange( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_removeRange( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_removeRange( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void removeRangeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RemoveRangeReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> removeRangeCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void scan(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ScanReq& p_req);
  virtual void scan(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ScanReq& p_req);
 protected:
  void scanImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ScanReq& p_req);
 public:

  virtual void sync_scan( ::nebula::meta::cpp2::ScanResp& _return, const  ::nebula::meta::cpp2::ScanReq& p_req);
  virtual void sync_scan(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ScanResp& _return, const  ::nebula::meta::cpp2::ScanReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ScanResp> future_scan(const  ::nebula::meta::cpp2::ScanReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ScanResp> semifuture_scan(const  ::nebula::meta::cpp2::ScanReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ScanResp> future_scan(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ScanReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ScanResp> semifuture_scan(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ScanReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ScanResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_scan(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ScanReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ScanResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_scan(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ScanReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ScanResp> co_scan(const  ::nebula::meta::cpp2::ScanReq& p_req) {
    return co_scan<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ScanResp> co_scan(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ScanReq& p_req) {
    return co_scan<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ScanResp> co_scan(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ScanReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = scanCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      scanImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      scanImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ScanResp _return;
    if (auto ew = recv_wrapped_scan(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void scan(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ScanReq& p_req);


  static folly::exception_wrapper recv_wrapped_scan( ::nebula::meta::cpp2::ScanResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_scan( ::nebula::meta::cpp2::ScanResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_scan( ::nebula::meta::cpp2::ScanResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_scan( ::nebula::meta::cpp2::ScanResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void scanT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ScanReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> scanCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void createTagIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req);
  virtual void createTagIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req);
 protected:
  void createTagIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req);
 public:

  virtual void sync_createTagIndex( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req);
  virtual void sync_createTagIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_createTagIndex(const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_createTagIndex(const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_createTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_createTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_createTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_createTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createTagIndex(const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req) {
    return co_createTagIndex<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req) {
    return co_createTagIndex<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createTagIndex(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = createTagIndexCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      createTagIndexImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      createTagIndexImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_createTagIndex(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void createTagIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req);


  static folly::exception_wrapper recv_wrapped_createTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_createTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_createTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_createTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void createTagIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateTagIndexReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> createTagIndexCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void dropTagIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req);
  virtual void dropTagIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req);
 protected:
  void dropTagIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req);
 public:

  virtual void sync_dropTagIndex( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req);
  virtual void sync_dropTagIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropTagIndex(const  ::nebula::meta::cpp2::DropTagIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropTagIndex(const  ::nebula::meta::cpp2::DropTagIndexReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_dropTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_dropTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropTagIndex(const  ::nebula::meta::cpp2::DropTagIndexReq& p_req) {
    return co_dropTagIndex<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req) {
    return co_dropTagIndex<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropTagIndex(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = dropTagIndexCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      dropTagIndexImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      dropTagIndexImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_dropTagIndex(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void dropTagIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req);


  static folly::exception_wrapper recv_wrapped_dropTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_dropTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_dropTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_dropTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void dropTagIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropTagIndexReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> dropTagIndexCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void getTagIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req);
  virtual void getTagIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req);
 protected:
  void getTagIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req);
 public:

  virtual void sync_getTagIndex( ::nebula::meta::cpp2::GetTagIndexResp& _return, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req);
  virtual void sync_getTagIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetTagIndexResp& _return, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::GetTagIndexResp> future_getTagIndex(const  ::nebula::meta::cpp2::GetTagIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetTagIndexResp> semifuture_getTagIndex(const  ::nebula::meta::cpp2::GetTagIndexReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::GetTagIndexResp> future_getTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetTagIndexResp> semifuture_getTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::GetTagIndexResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_getTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetTagIndexResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_getTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetTagIndexResp> co_getTagIndex(const  ::nebula::meta::cpp2::GetTagIndexReq& p_req) {
    return co_getTagIndex<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetTagIndexResp> co_getTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req) {
    return co_getTagIndex<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::GetTagIndexResp> co_getTagIndex(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = getTagIndexCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      getTagIndexImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      getTagIndexImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::GetTagIndexResp _return;
    if (auto ew = recv_wrapped_getTagIndex(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void getTagIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req);


  static folly::exception_wrapper recv_wrapped_getTagIndex( ::nebula::meta::cpp2::GetTagIndexResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_getTagIndex( ::nebula::meta::cpp2::GetTagIndexResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_getTagIndex( ::nebula::meta::cpp2::GetTagIndexResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_getTagIndex( ::nebula::meta::cpp2::GetTagIndexResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void getTagIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetTagIndexReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> getTagIndexCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void listTagIndexes(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req);
  virtual void listTagIndexes(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req);
 protected:
  void listTagIndexesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req);
 public:

  virtual void sync_listTagIndexes( ::nebula::meta::cpp2::ListTagIndexesResp& _return, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req);
  virtual void sync_listTagIndexes(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListTagIndexesResp& _return, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListTagIndexesResp> future_listTagIndexes(const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListTagIndexesResp> semifuture_listTagIndexes(const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListTagIndexesResp> future_listTagIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListTagIndexesResp> semifuture_listTagIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListTagIndexesResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_listTagIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListTagIndexesResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_listTagIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListTagIndexesResp> co_listTagIndexes(const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req) {
    return co_listTagIndexes<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListTagIndexesResp> co_listTagIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req) {
    return co_listTagIndexes<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListTagIndexesResp> co_listTagIndexes(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = listTagIndexesCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      listTagIndexesImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      listTagIndexesImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListTagIndexesResp _return;
    if (auto ew = recv_wrapped_listTagIndexes(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void listTagIndexes(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req);


  static folly::exception_wrapper recv_wrapped_listTagIndexes( ::nebula::meta::cpp2::ListTagIndexesResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_listTagIndexes( ::nebula::meta::cpp2::ListTagIndexesResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_listTagIndexes( ::nebula::meta::cpp2::ListTagIndexesResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_listTagIndexes( ::nebula::meta::cpp2::ListTagIndexesResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void listTagIndexesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListTagIndexesReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> listTagIndexesCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void rebuildTagIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
  virtual void rebuildTagIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
 protected:
  void rebuildTagIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
 public:

  virtual void sync_rebuildTagIndex( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
  virtual void sync_rebuildTagIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_rebuildTagIndex(const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_rebuildTagIndex(const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_rebuildTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_rebuildTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_rebuildTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_rebuildTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_rebuildTagIndex(const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
    return co_rebuildTagIndex<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_rebuildTagIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
    return co_rebuildTagIndex<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_rebuildTagIndex(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = rebuildTagIndexCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      rebuildTagIndexImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      rebuildTagIndexImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_rebuildTagIndex(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void rebuildTagIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);


  static folly::exception_wrapper recv_wrapped_rebuildTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_rebuildTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_rebuildTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_rebuildTagIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void rebuildTagIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> rebuildTagIndexCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void listTagIndexStatus(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
  virtual void listTagIndexStatus(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
 protected:
  void listTagIndexStatusImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
 public:

  virtual void sync_listTagIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
  virtual void sync_listTagIndexStatus(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListIndexStatusResp& _return, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListIndexStatusResp> future_listTagIndexStatus(const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListIndexStatusResp> semifuture_listTagIndexStatus(const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListIndexStatusResp> future_listTagIndexStatus(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListIndexStatusResp> semifuture_listTagIndexStatus(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListIndexStatusResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_listTagIndexStatus(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListIndexStatusResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_listTagIndexStatus(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListIndexStatusResp> co_listTagIndexStatus(const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
    return co_listTagIndexStatus<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListIndexStatusResp> co_listTagIndexStatus(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
    return co_listTagIndexStatus<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListIndexStatusResp> co_listTagIndexStatus(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = listTagIndexStatusCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      listTagIndexStatusImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      listTagIndexStatusImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListIndexStatusResp _return;
    if (auto ew = recv_wrapped_listTagIndexStatus(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void listTagIndexStatus(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);


  static folly::exception_wrapper recv_wrapped_listTagIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_listTagIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_listTagIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_listTagIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void listTagIndexStatusT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> listTagIndexStatusCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void createEdgeIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req);
  virtual void createEdgeIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req);
 protected:
  void createEdgeIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req);
 public:

  virtual void sync_createEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req);
  virtual void sync_createEdgeIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_createEdgeIndex(const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_createEdgeIndex(const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_createEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_createEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_createEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_createEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createEdgeIndex(const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req) {
    return co_createEdgeIndex<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req) {
    return co_createEdgeIndex<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createEdgeIndex(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = createEdgeIndexCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      createEdgeIndexImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      createEdgeIndexImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_createEdgeIndex(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void createEdgeIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req);


  static folly::exception_wrapper recv_wrapped_createEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_createEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_createEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_createEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void createEdgeIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateEdgeIndexReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> createEdgeIndexCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void dropEdgeIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req);
  virtual void dropEdgeIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req);
 protected:
  void dropEdgeIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req);
 public:

  virtual void sync_dropEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req);
  virtual void sync_dropEdgeIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropEdgeIndex(const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropEdgeIndex(const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_dropEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_dropEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropEdgeIndex(const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req) {
    return co_dropEdgeIndex<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req) {
    return co_dropEdgeIndex<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropEdgeIndex(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = dropEdgeIndexCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      dropEdgeIndexImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      dropEdgeIndexImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_dropEdgeIndex(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void dropEdgeIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req);


  static folly::exception_wrapper recv_wrapped_dropEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_dropEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_dropEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_dropEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void dropEdgeIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropEdgeIndexReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> dropEdgeIndexCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void getEdgeIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req);
  virtual void getEdgeIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req);
 protected:
  void getEdgeIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req);
 public:

  virtual void sync_getEdgeIndex( ::nebula::meta::cpp2::GetEdgeIndexResp& _return, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req);
  virtual void sync_getEdgeIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetEdgeIndexResp& _return, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::GetEdgeIndexResp> future_getEdgeIndex(const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetEdgeIndexResp> semifuture_getEdgeIndex(const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::GetEdgeIndexResp> future_getEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetEdgeIndexResp> semifuture_getEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::GetEdgeIndexResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_getEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetEdgeIndexResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_getEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetEdgeIndexResp> co_getEdgeIndex(const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req) {
    return co_getEdgeIndex<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetEdgeIndexResp> co_getEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req) {
    return co_getEdgeIndex<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::GetEdgeIndexResp> co_getEdgeIndex(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = getEdgeIndexCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      getEdgeIndexImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      getEdgeIndexImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::GetEdgeIndexResp _return;
    if (auto ew = recv_wrapped_getEdgeIndex(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void getEdgeIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req);


  static folly::exception_wrapper recv_wrapped_getEdgeIndex( ::nebula::meta::cpp2::GetEdgeIndexResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_getEdgeIndex( ::nebula::meta::cpp2::GetEdgeIndexResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_getEdgeIndex( ::nebula::meta::cpp2::GetEdgeIndexResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_getEdgeIndex( ::nebula::meta::cpp2::GetEdgeIndexResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void getEdgeIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetEdgeIndexReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> getEdgeIndexCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void listEdgeIndexes(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req);
  virtual void listEdgeIndexes(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req);
 protected:
  void listEdgeIndexesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req);
 public:

  virtual void sync_listEdgeIndexes( ::nebula::meta::cpp2::ListEdgeIndexesResp& _return, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req);
  virtual void sync_listEdgeIndexes(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListEdgeIndexesResp& _return, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListEdgeIndexesResp> future_listEdgeIndexes(const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListEdgeIndexesResp> semifuture_listEdgeIndexes(const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListEdgeIndexesResp> future_listEdgeIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListEdgeIndexesResp> semifuture_listEdgeIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListEdgeIndexesResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_listEdgeIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListEdgeIndexesResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_listEdgeIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListEdgeIndexesResp> co_listEdgeIndexes(const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req) {
    return co_listEdgeIndexes<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListEdgeIndexesResp> co_listEdgeIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req) {
    return co_listEdgeIndexes<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListEdgeIndexesResp> co_listEdgeIndexes(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = listEdgeIndexesCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      listEdgeIndexesImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      listEdgeIndexesImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListEdgeIndexesResp _return;
    if (auto ew = recv_wrapped_listEdgeIndexes(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void listEdgeIndexes(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req);


  static folly::exception_wrapper recv_wrapped_listEdgeIndexes( ::nebula::meta::cpp2::ListEdgeIndexesResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_listEdgeIndexes( ::nebula::meta::cpp2::ListEdgeIndexesResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_listEdgeIndexes( ::nebula::meta::cpp2::ListEdgeIndexesResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_listEdgeIndexes( ::nebula::meta::cpp2::ListEdgeIndexesResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void listEdgeIndexesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListEdgeIndexesReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> listEdgeIndexesCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void rebuildEdgeIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
  virtual void rebuildEdgeIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
 protected:
  void rebuildEdgeIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
 public:

  virtual void sync_rebuildEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
  virtual void sync_rebuildEdgeIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_rebuildEdgeIndex(const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_rebuildEdgeIndex(const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_rebuildEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_rebuildEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_rebuildEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_rebuildEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_rebuildEdgeIndex(const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
    return co_rebuildEdgeIndex<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_rebuildEdgeIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
    return co_rebuildEdgeIndex<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_rebuildEdgeIndex(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = rebuildEdgeIndexCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      rebuildEdgeIndexImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      rebuildEdgeIndexImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_rebuildEdgeIndex(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void rebuildEdgeIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);


  static folly::exception_wrapper recv_wrapped_rebuildEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_rebuildEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_rebuildEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_rebuildEdgeIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void rebuildEdgeIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RebuildIndexReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> rebuildEdgeIndexCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void listEdgeIndexStatus(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
  virtual void listEdgeIndexStatus(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
 protected:
  void listEdgeIndexStatusImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
 public:

  virtual void sync_listEdgeIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
  virtual void sync_listEdgeIndexStatus(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListIndexStatusResp& _return, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListIndexStatusResp> future_listEdgeIndexStatus(const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListIndexStatusResp> semifuture_listEdgeIndexStatus(const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListIndexStatusResp> future_listEdgeIndexStatus(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListIndexStatusResp> semifuture_listEdgeIndexStatus(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListIndexStatusResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_listEdgeIndexStatus(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListIndexStatusResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_listEdgeIndexStatus(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListIndexStatusResp> co_listEdgeIndexStatus(const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
    return co_listEdgeIndexStatus<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListIndexStatusResp> co_listEdgeIndexStatus(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
    return co_listEdgeIndexStatus<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListIndexStatusResp> co_listEdgeIndexStatus(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = listEdgeIndexStatusCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      listEdgeIndexStatusImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      listEdgeIndexStatusImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListIndexStatusResp _return;
    if (auto ew = recv_wrapped_listEdgeIndexStatus(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void listEdgeIndexStatus(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);


  static folly::exception_wrapper recv_wrapped_listEdgeIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_listEdgeIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_listEdgeIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_listEdgeIndexStatus( ::nebula::meta::cpp2::ListIndexStatusResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void listEdgeIndexStatusT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListIndexStatusReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> listEdgeIndexStatusCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void createUser(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateUserReq& p_req);
  virtual void createUser(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateUserReq& p_req);
 protected:
  void createUserImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateUserReq& p_req);
 public:

  virtual void sync_createUser( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateUserReq& p_req);
  virtual void sync_createUser(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateUserReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_createUser(const  ::nebula::meta::cpp2::CreateUserReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_createUser(const  ::nebula::meta::cpp2::CreateUserReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_createUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateUserReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_createUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateUserReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_createUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateUserReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_createUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateUserReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createUser(const  ::nebula::meta::cpp2::CreateUserReq& p_req) {
    return co_createUser<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateUserReq& p_req) {
    return co_createUser<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createUser(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::CreateUserReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = createUserCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      createUserImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      createUserImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_createUser(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void createUser(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateUserReq& p_req);


  static folly::exception_wrapper recv_wrapped_createUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_createUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_createUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_createUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void createUserT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateUserReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> createUserCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void dropUser(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropUserReq& p_req);
  virtual void dropUser(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropUserReq& p_req);
 protected:
  void dropUserImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropUserReq& p_req);
 public:

  virtual void sync_dropUser( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropUserReq& p_req);
  virtual void sync_dropUser(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropUserReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropUser(const  ::nebula::meta::cpp2::DropUserReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropUser(const  ::nebula::meta::cpp2::DropUserReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropUserReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropUserReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_dropUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropUserReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_dropUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropUserReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropUser(const  ::nebula::meta::cpp2::DropUserReq& p_req) {
    return co_dropUser<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropUserReq& p_req) {
    return co_dropUser<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropUser(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::DropUserReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = dropUserCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      dropUserImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      dropUserImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_dropUser(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void dropUser(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropUserReq& p_req);


  static folly::exception_wrapper recv_wrapped_dropUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_dropUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_dropUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_dropUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void dropUserT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropUserReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> dropUserCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void alterUser(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AlterUserReq& p_req);
  virtual void alterUser(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AlterUserReq& p_req);
 protected:
  void alterUserImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AlterUserReq& p_req);
 public:

  virtual void sync_alterUser( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AlterUserReq& p_req);
  virtual void sync_alterUser(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AlterUserReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_alterUser(const  ::nebula::meta::cpp2::AlterUserReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_alterUser(const  ::nebula::meta::cpp2::AlterUserReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_alterUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterUserReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_alterUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterUserReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_alterUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterUserReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_alterUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterUserReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_alterUser(const  ::nebula::meta::cpp2::AlterUserReq& p_req) {
    return co_alterUser<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_alterUser(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AlterUserReq& p_req) {
    return co_alterUser<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_alterUser(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::AlterUserReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = alterUserCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      alterUserImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      alterUserImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_alterUser(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void alterUser(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::AlterUserReq& p_req);


  static folly::exception_wrapper recv_wrapped_alterUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_alterUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_alterUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_alterUser( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void alterUserT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AlterUserReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> alterUserCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void grantRole(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GrantRoleReq& p_req);
  virtual void grantRole(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GrantRoleReq& p_req);
 protected:
  void grantRoleImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GrantRoleReq& p_req);
 public:

  virtual void sync_grantRole( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::GrantRoleReq& p_req);
  virtual void sync_grantRole(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::GrantRoleReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_grantRole(const  ::nebula::meta::cpp2::GrantRoleReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_grantRole(const  ::nebula::meta::cpp2::GrantRoleReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_grantRole(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GrantRoleReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_grantRole(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GrantRoleReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_grantRole(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GrantRoleReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_grantRole(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GrantRoleReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_grantRole(const  ::nebula::meta::cpp2::GrantRoleReq& p_req) {
    return co_grantRole<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_grantRole(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GrantRoleReq& p_req) {
    return co_grantRole<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_grantRole(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::GrantRoleReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = grantRoleCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      grantRoleImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      grantRoleImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_grantRole(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void grantRole(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GrantRoleReq& p_req);


  static folly::exception_wrapper recv_wrapped_grantRole( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_grantRole( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_grantRole( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_grantRole( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void grantRoleT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GrantRoleReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> grantRoleCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void revokeRole(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req);
  virtual void revokeRole(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req);
 protected:
  void revokeRoleImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req);
 public:

  virtual void sync_revokeRole( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req);
  virtual void sync_revokeRole(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_revokeRole(const  ::nebula::meta::cpp2::RevokeRoleReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_revokeRole(const  ::nebula::meta::cpp2::RevokeRoleReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_revokeRole(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_revokeRole(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_revokeRole(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_revokeRole(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_revokeRole(const  ::nebula::meta::cpp2::RevokeRoleReq& p_req) {
    return co_revokeRole<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_revokeRole(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req) {
    return co_revokeRole<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_revokeRole(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = revokeRoleCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      revokeRoleImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      revokeRoleImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_revokeRole(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void revokeRole(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req);


  static folly::exception_wrapper recv_wrapped_revokeRole( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_revokeRole( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_revokeRole( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_revokeRole( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void revokeRoleT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RevokeRoleReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> revokeRoleCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void listUsers(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListUsersReq& p_req);
  virtual void listUsers(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListUsersReq& p_req);
 protected:
  void listUsersImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListUsersReq& p_req);
 public:

  virtual void sync_listUsers( ::nebula::meta::cpp2::ListUsersResp& _return, const  ::nebula::meta::cpp2::ListUsersReq& p_req);
  virtual void sync_listUsers(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListUsersResp& _return, const  ::nebula::meta::cpp2::ListUsersReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListUsersResp> future_listUsers(const  ::nebula::meta::cpp2::ListUsersReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListUsersResp> semifuture_listUsers(const  ::nebula::meta::cpp2::ListUsersReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListUsersResp> future_listUsers(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListUsersReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListUsersResp> semifuture_listUsers(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListUsersReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListUsersResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_listUsers(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListUsersReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListUsersResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_listUsers(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListUsersReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListUsersResp> co_listUsers(const  ::nebula::meta::cpp2::ListUsersReq& p_req) {
    return co_listUsers<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListUsersResp> co_listUsers(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListUsersReq& p_req) {
    return co_listUsers<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListUsersResp> co_listUsers(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ListUsersReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = listUsersCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      listUsersImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      listUsersImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListUsersResp _return;
    if (auto ew = recv_wrapped_listUsers(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void listUsers(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListUsersReq& p_req);


  static folly::exception_wrapper recv_wrapped_listUsers( ::nebula::meta::cpp2::ListUsersResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_listUsers( ::nebula::meta::cpp2::ListUsersResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_listUsers( ::nebula::meta::cpp2::ListUsersResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_listUsers( ::nebula::meta::cpp2::ListUsersResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void listUsersT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListUsersReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> listUsersCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void listRoles(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListRolesReq& p_req);
  virtual void listRoles(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListRolesReq& p_req);
 protected:
  void listRolesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListRolesReq& p_req);
 public:

  virtual void sync_listRoles( ::nebula::meta::cpp2::ListRolesResp& _return, const  ::nebula::meta::cpp2::ListRolesReq& p_req);
  virtual void sync_listRoles(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListRolesResp& _return, const  ::nebula::meta::cpp2::ListRolesReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListRolesResp> future_listRoles(const  ::nebula::meta::cpp2::ListRolesReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListRolesResp> semifuture_listRoles(const  ::nebula::meta::cpp2::ListRolesReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListRolesResp> future_listRoles(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListRolesReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListRolesResp> semifuture_listRoles(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListRolesReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListRolesResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_listRoles(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListRolesReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListRolesResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_listRoles(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListRolesReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListRolesResp> co_listRoles(const  ::nebula::meta::cpp2::ListRolesReq& p_req) {
    return co_listRoles<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListRolesResp> co_listRoles(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListRolesReq& p_req) {
    return co_listRoles<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListRolesResp> co_listRoles(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ListRolesReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = listRolesCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      listRolesImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      listRolesImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListRolesResp _return;
    if (auto ew = recv_wrapped_listRoles(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void listRoles(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListRolesReq& p_req);


  static folly::exception_wrapper recv_wrapped_listRoles( ::nebula::meta::cpp2::ListRolesResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_listRoles( ::nebula::meta::cpp2::ListRolesResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_listRoles( ::nebula::meta::cpp2::ListRolesResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_listRoles( ::nebula::meta::cpp2::ListRolesResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void listRolesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListRolesReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> listRolesCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void getUserRoles(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req);
  virtual void getUserRoles(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req);
 protected:
  void getUserRolesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req);
 public:

  virtual void sync_getUserRoles( ::nebula::meta::cpp2::ListRolesResp& _return, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req);
  virtual void sync_getUserRoles(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListRolesResp& _return, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListRolesResp> future_getUserRoles(const  ::nebula::meta::cpp2::GetUserRolesReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListRolesResp> semifuture_getUserRoles(const  ::nebula::meta::cpp2::GetUserRolesReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListRolesResp> future_getUserRoles(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListRolesResp> semifuture_getUserRoles(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListRolesResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_getUserRoles(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListRolesResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_getUserRoles(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListRolesResp> co_getUserRoles(const  ::nebula::meta::cpp2::GetUserRolesReq& p_req) {
    return co_getUserRoles<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListRolesResp> co_getUserRoles(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req) {
    return co_getUserRoles<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListRolesResp> co_getUserRoles(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = getUserRolesCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      getUserRolesImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      getUserRolesImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListRolesResp _return;
    if (auto ew = recv_wrapped_getUserRoles(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void getUserRoles(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req);


  static folly::exception_wrapper recv_wrapped_getUserRoles( ::nebula::meta::cpp2::ListRolesResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_getUserRoles( ::nebula::meta::cpp2::ListRolesResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_getUserRoles( ::nebula::meta::cpp2::ListRolesResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_getUserRoles( ::nebula::meta::cpp2::ListRolesResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void getUserRolesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetUserRolesReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> getUserRolesCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void changePassword(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req);
  virtual void changePassword(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req);
 protected:
  void changePasswordImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req);
 public:

  virtual void sync_changePassword( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req);
  virtual void sync_changePassword(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_changePassword(const  ::nebula::meta::cpp2::ChangePasswordReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_changePassword(const  ::nebula::meta::cpp2::ChangePasswordReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_changePassword(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_changePassword(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_changePassword(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_changePassword(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_changePassword(const  ::nebula::meta::cpp2::ChangePasswordReq& p_req) {
    return co_changePassword<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_changePassword(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req) {
    return co_changePassword<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_changePassword(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = changePasswordCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      changePasswordImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      changePasswordImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_changePassword(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void changePassword(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req);


  static folly::exception_wrapper recv_wrapped_changePassword( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_changePassword( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_changePassword( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_changePassword( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void changePasswordT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ChangePasswordReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> changePasswordCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void heartBeat(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::HBReq& p_req);
  virtual void heartBeat(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::HBReq& p_req);
 protected:
  void heartBeatImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::HBReq& p_req);
 public:

  virtual void sync_heartBeat( ::nebula::meta::cpp2::HBResp& _return, const  ::nebula::meta::cpp2::HBReq& p_req);
  virtual void sync_heartBeat(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::HBResp& _return, const  ::nebula::meta::cpp2::HBReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::HBResp> future_heartBeat(const  ::nebula::meta::cpp2::HBReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::HBResp> semifuture_heartBeat(const  ::nebula::meta::cpp2::HBReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::HBResp> future_heartBeat(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::HBReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::HBResp> semifuture_heartBeat(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::HBReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::HBResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_heartBeat(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::HBReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::HBResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_heartBeat(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::HBReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::HBResp> co_heartBeat(const  ::nebula::meta::cpp2::HBReq& p_req) {
    return co_heartBeat<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::HBResp> co_heartBeat(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::HBReq& p_req) {
    return co_heartBeat<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::HBResp> co_heartBeat(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::HBReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = heartBeatCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      heartBeatImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      heartBeatImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::HBResp _return;
    if (auto ew = recv_wrapped_heartBeat(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void heartBeat(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::HBReq& p_req);


  static folly::exception_wrapper recv_wrapped_heartBeat( ::nebula::meta::cpp2::HBResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_heartBeat( ::nebula::meta::cpp2::HBResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_heartBeat( ::nebula::meta::cpp2::HBResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_heartBeat( ::nebula::meta::cpp2::HBResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void heartBeatT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::HBReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> heartBeatCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void agentHeartbeat(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AgentHBReq& p_req);
  virtual void agentHeartbeat(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AgentHBReq& p_req);
 protected:
  void agentHeartbeatImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AgentHBReq& p_req);
 public:

  virtual void sync_agentHeartbeat( ::nebula::meta::cpp2::AgentHBResp& _return, const  ::nebula::meta::cpp2::AgentHBReq& p_req);
  virtual void sync_agentHeartbeat(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::AgentHBResp& _return, const  ::nebula::meta::cpp2::AgentHBReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::AgentHBResp> future_agentHeartbeat(const  ::nebula::meta::cpp2::AgentHBReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::AgentHBResp> semifuture_agentHeartbeat(const  ::nebula::meta::cpp2::AgentHBReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::AgentHBResp> future_agentHeartbeat(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AgentHBReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::AgentHBResp> semifuture_agentHeartbeat(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AgentHBReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::AgentHBResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_agentHeartbeat(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AgentHBReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::AgentHBResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_agentHeartbeat(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AgentHBReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::AgentHBResp> co_agentHeartbeat(const  ::nebula::meta::cpp2::AgentHBReq& p_req) {
    return co_agentHeartbeat<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::AgentHBResp> co_agentHeartbeat(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AgentHBReq& p_req) {
    return co_agentHeartbeat<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::AgentHBResp> co_agentHeartbeat(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::AgentHBReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = agentHeartbeatCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      agentHeartbeatImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      agentHeartbeatImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::AgentHBResp _return;
    if (auto ew = recv_wrapped_agentHeartbeat(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void agentHeartbeat(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::AgentHBReq& p_req);


  static folly::exception_wrapper recv_wrapped_agentHeartbeat( ::nebula::meta::cpp2::AgentHBResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_agentHeartbeat( ::nebula::meta::cpp2::AgentHBResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_agentHeartbeat( ::nebula::meta::cpp2::AgentHBResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_agentHeartbeat( ::nebula::meta::cpp2::AgentHBResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void agentHeartbeatT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AgentHBReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> agentHeartbeatCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void regConfig(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RegConfigReq& p_req);
  virtual void regConfig(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RegConfigReq& p_req);
 protected:
  void regConfigImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RegConfigReq& p_req);
 public:

  virtual void sync_regConfig( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RegConfigReq& p_req);
  virtual void sync_regConfig(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RegConfigReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_regConfig(const  ::nebula::meta::cpp2::RegConfigReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_regConfig(const  ::nebula::meta::cpp2::RegConfigReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_regConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RegConfigReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_regConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RegConfigReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_regConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RegConfigReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_regConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RegConfigReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_regConfig(const  ::nebula::meta::cpp2::RegConfigReq& p_req) {
    return co_regConfig<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_regConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RegConfigReq& p_req) {
    return co_regConfig<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_regConfig(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::RegConfigReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = regConfigCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      regConfigImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      regConfigImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_regConfig(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void regConfig(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::RegConfigReq& p_req);


  static folly::exception_wrapper recv_wrapped_regConfig( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_regConfig( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_regConfig( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_regConfig( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void regConfigT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RegConfigReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> regConfigCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void getConfig(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetConfigReq& p_req);
  virtual void getConfig(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetConfigReq& p_req);
 protected:
  void getConfigImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetConfigReq& p_req);
 public:

  virtual void sync_getConfig( ::nebula::meta::cpp2::GetConfigResp& _return, const  ::nebula::meta::cpp2::GetConfigReq& p_req);
  virtual void sync_getConfig(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetConfigResp& _return, const  ::nebula::meta::cpp2::GetConfigReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::GetConfigResp> future_getConfig(const  ::nebula::meta::cpp2::GetConfigReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetConfigResp> semifuture_getConfig(const  ::nebula::meta::cpp2::GetConfigReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::GetConfigResp> future_getConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetConfigReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetConfigResp> semifuture_getConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetConfigReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::GetConfigResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_getConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetConfigReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetConfigResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_getConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetConfigReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetConfigResp> co_getConfig(const  ::nebula::meta::cpp2::GetConfigReq& p_req) {
    return co_getConfig<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetConfigResp> co_getConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetConfigReq& p_req) {
    return co_getConfig<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::GetConfigResp> co_getConfig(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::GetConfigReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = getConfigCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      getConfigImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      getConfigImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::GetConfigResp _return;
    if (auto ew = recv_wrapped_getConfig(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void getConfig(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetConfigReq& p_req);


  static folly::exception_wrapper recv_wrapped_getConfig( ::nebula::meta::cpp2::GetConfigResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_getConfig( ::nebula::meta::cpp2::GetConfigResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_getConfig( ::nebula::meta::cpp2::GetConfigResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_getConfig( ::nebula::meta::cpp2::GetConfigResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void getConfigT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetConfigReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> getConfigCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void setConfig(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::SetConfigReq& p_req);
  virtual void setConfig(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::SetConfigReq& p_req);
 protected:
  void setConfigImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::SetConfigReq& p_req);
 public:

  virtual void sync_setConfig( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::SetConfigReq& p_req);
  virtual void sync_setConfig(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::SetConfigReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_setConfig(const  ::nebula::meta::cpp2::SetConfigReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_setConfig(const  ::nebula::meta::cpp2::SetConfigReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_setConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SetConfigReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_setConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SetConfigReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_setConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SetConfigReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_setConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SetConfigReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_setConfig(const  ::nebula::meta::cpp2::SetConfigReq& p_req) {
    return co_setConfig<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_setConfig(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SetConfigReq& p_req) {
    return co_setConfig<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_setConfig(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::SetConfigReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = setConfigCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      setConfigImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      setConfigImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_setConfig(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void setConfig(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::SetConfigReq& p_req);


  static folly::exception_wrapper recv_wrapped_setConfig( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_setConfig( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_setConfig( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_setConfig( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void setConfigT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::SetConfigReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> setConfigCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void listConfigs(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListConfigsReq& p_req);
  virtual void listConfigs(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListConfigsReq& p_req);
 protected:
  void listConfigsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListConfigsReq& p_req);
 public:

  virtual void sync_listConfigs( ::nebula::meta::cpp2::ListConfigsResp& _return, const  ::nebula::meta::cpp2::ListConfigsReq& p_req);
  virtual void sync_listConfigs(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListConfigsResp& _return, const  ::nebula::meta::cpp2::ListConfigsReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListConfigsResp> future_listConfigs(const  ::nebula::meta::cpp2::ListConfigsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListConfigsResp> semifuture_listConfigs(const  ::nebula::meta::cpp2::ListConfigsReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListConfigsResp> future_listConfigs(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListConfigsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListConfigsResp> semifuture_listConfigs(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListConfigsReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListConfigsResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_listConfigs(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListConfigsReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListConfigsResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_listConfigs(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListConfigsReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListConfigsResp> co_listConfigs(const  ::nebula::meta::cpp2::ListConfigsReq& p_req) {
    return co_listConfigs<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListConfigsResp> co_listConfigs(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListConfigsReq& p_req) {
    return co_listConfigs<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListConfigsResp> co_listConfigs(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ListConfigsReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = listConfigsCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      listConfigsImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      listConfigsImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListConfigsResp _return;
    if (auto ew = recv_wrapped_listConfigs(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void listConfigs(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListConfigsReq& p_req);


  static folly::exception_wrapper recv_wrapped_listConfigs( ::nebula::meta::cpp2::ListConfigsResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_listConfigs( ::nebula::meta::cpp2::ListConfigsResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_listConfigs( ::nebula::meta::cpp2::ListConfigsResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_listConfigs( ::nebula::meta::cpp2::ListConfigsResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void listConfigsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListConfigsReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> listConfigsCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void createSnapshot(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req);
  virtual void createSnapshot(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req);
 protected:
  void createSnapshotImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req);
 public:

  virtual void sync_createSnapshot( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req);
  virtual void sync_createSnapshot(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_createSnapshot(const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_createSnapshot(const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_createSnapshot(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_createSnapshot(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_createSnapshot(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_createSnapshot(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createSnapshot(const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req) {
    return co_createSnapshot<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createSnapshot(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req) {
    return co_createSnapshot<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createSnapshot(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = createSnapshotCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      createSnapshotImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      createSnapshotImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_createSnapshot(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void createSnapshot(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req);


  static folly::exception_wrapper recv_wrapped_createSnapshot( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_createSnapshot( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_createSnapshot( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_createSnapshot( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void createSnapshotT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateSnapshotReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> createSnapshotCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void dropSnapshot(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req);
  virtual void dropSnapshot(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req);
 protected:
  void dropSnapshotImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req);
 public:

  virtual void sync_dropSnapshot( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req);
  virtual void sync_dropSnapshot(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropSnapshot(const  ::nebula::meta::cpp2::DropSnapshotReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropSnapshot(const  ::nebula::meta::cpp2::DropSnapshotReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropSnapshot(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropSnapshot(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_dropSnapshot(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_dropSnapshot(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropSnapshot(const  ::nebula::meta::cpp2::DropSnapshotReq& p_req) {
    return co_dropSnapshot<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropSnapshot(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req) {
    return co_dropSnapshot<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropSnapshot(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = dropSnapshotCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      dropSnapshotImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      dropSnapshotImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_dropSnapshot(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void dropSnapshot(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req);


  static folly::exception_wrapper recv_wrapped_dropSnapshot( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_dropSnapshot( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_dropSnapshot( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_dropSnapshot( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void dropSnapshotT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropSnapshotReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> dropSnapshotCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void listSnapshots(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req);
  virtual void listSnapshots(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req);
 protected:
  void listSnapshotsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req);
 public:

  virtual void sync_listSnapshots( ::nebula::meta::cpp2::ListSnapshotsResp& _return, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req);
  virtual void sync_listSnapshots(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListSnapshotsResp& _return, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListSnapshotsResp> future_listSnapshots(const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListSnapshotsResp> semifuture_listSnapshots(const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListSnapshotsResp> future_listSnapshots(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListSnapshotsResp> semifuture_listSnapshots(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListSnapshotsResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_listSnapshots(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListSnapshotsResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_listSnapshots(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListSnapshotsResp> co_listSnapshots(const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req) {
    return co_listSnapshots<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListSnapshotsResp> co_listSnapshots(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req) {
    return co_listSnapshots<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListSnapshotsResp> co_listSnapshots(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = listSnapshotsCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      listSnapshotsImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      listSnapshotsImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListSnapshotsResp _return;
    if (auto ew = recv_wrapped_listSnapshots(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void listSnapshots(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req);


  static folly::exception_wrapper recv_wrapped_listSnapshots( ::nebula::meta::cpp2::ListSnapshotsResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_listSnapshots( ::nebula::meta::cpp2::ListSnapshotsResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_listSnapshots( ::nebula::meta::cpp2::ListSnapshotsResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_listSnapshots( ::nebula::meta::cpp2::ListSnapshotsResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void listSnapshotsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListSnapshotsReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> listSnapshotsCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void runAdminJob(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AdminJobReq& p_req);
  virtual void runAdminJob(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AdminJobReq& p_req);
 protected:
  void runAdminJobImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AdminJobReq& p_req);
 public:

  virtual void sync_runAdminJob( ::nebula::meta::cpp2::AdminJobResp& _return, const  ::nebula::meta::cpp2::AdminJobReq& p_req);
  virtual void sync_runAdminJob(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::AdminJobResp& _return, const  ::nebula::meta::cpp2::AdminJobReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::AdminJobResp> future_runAdminJob(const  ::nebula::meta::cpp2::AdminJobReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::AdminJobResp> semifuture_runAdminJob(const  ::nebula::meta::cpp2::AdminJobReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::AdminJobResp> future_runAdminJob(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AdminJobReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::AdminJobResp> semifuture_runAdminJob(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AdminJobReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::AdminJobResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_runAdminJob(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AdminJobReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::AdminJobResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_runAdminJob(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AdminJobReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::AdminJobResp> co_runAdminJob(const  ::nebula::meta::cpp2::AdminJobReq& p_req) {
    return co_runAdminJob<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::AdminJobResp> co_runAdminJob(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AdminJobReq& p_req) {
    return co_runAdminJob<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::AdminJobResp> co_runAdminJob(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::AdminJobReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = runAdminJobCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      runAdminJobImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      runAdminJobImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::AdminJobResp _return;
    if (auto ew = recv_wrapped_runAdminJob(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void runAdminJob(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::AdminJobReq& p_req);


  static folly::exception_wrapper recv_wrapped_runAdminJob( ::nebula::meta::cpp2::AdminJobResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_runAdminJob( ::nebula::meta::cpp2::AdminJobResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_runAdminJob( ::nebula::meta::cpp2::AdminJobResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_runAdminJob( ::nebula::meta::cpp2::AdminJobResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void runAdminJobT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AdminJobReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> runAdminJobCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void mergeZone(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::MergeZoneReq& p_req);
  virtual void mergeZone(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::MergeZoneReq& p_req);
 protected:
  void mergeZoneImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::MergeZoneReq& p_req);
 public:

  virtual void sync_mergeZone( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::MergeZoneReq& p_req);
  virtual void sync_mergeZone(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::MergeZoneReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_mergeZone(const  ::nebula::meta::cpp2::MergeZoneReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_mergeZone(const  ::nebula::meta::cpp2::MergeZoneReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_mergeZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MergeZoneReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_mergeZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MergeZoneReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_mergeZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MergeZoneReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_mergeZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MergeZoneReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_mergeZone(const  ::nebula::meta::cpp2::MergeZoneReq& p_req) {
    return co_mergeZone<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_mergeZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::MergeZoneReq& p_req) {
    return co_mergeZone<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_mergeZone(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::MergeZoneReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = mergeZoneCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      mergeZoneImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      mergeZoneImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_mergeZone(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void mergeZone(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::MergeZoneReq& p_req);


  static folly::exception_wrapper recv_wrapped_mergeZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_mergeZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_mergeZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_mergeZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void mergeZoneT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::MergeZoneReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> mergeZoneCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void dropZone(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropZoneReq& p_req);
  virtual void dropZone(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropZoneReq& p_req);
 protected:
  void dropZoneImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropZoneReq& p_req);
 public:

  virtual void sync_dropZone( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropZoneReq& p_req);
  virtual void sync_dropZone(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropZoneReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropZone(const  ::nebula::meta::cpp2::DropZoneReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropZone(const  ::nebula::meta::cpp2::DropZoneReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropZoneReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropZoneReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_dropZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropZoneReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_dropZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropZoneReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropZone(const  ::nebula::meta::cpp2::DropZoneReq& p_req) {
    return co_dropZone<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropZoneReq& p_req) {
    return co_dropZone<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropZone(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::DropZoneReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = dropZoneCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      dropZoneImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      dropZoneImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_dropZone(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void dropZone(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropZoneReq& p_req);


  static folly::exception_wrapper recv_wrapped_dropZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_dropZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_dropZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_dropZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void dropZoneT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropZoneReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> dropZoneCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void divideZone(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DivideZoneReq& p_req);
  virtual void divideZone(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DivideZoneReq& p_req);
 protected:
  void divideZoneImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DivideZoneReq& p_req);
 public:

  virtual void sync_divideZone( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DivideZoneReq& p_req);
  virtual void sync_divideZone(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DivideZoneReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_divideZone(const  ::nebula::meta::cpp2::DivideZoneReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_divideZone(const  ::nebula::meta::cpp2::DivideZoneReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_divideZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DivideZoneReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_divideZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DivideZoneReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_divideZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DivideZoneReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_divideZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DivideZoneReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_divideZone(const  ::nebula::meta::cpp2::DivideZoneReq& p_req) {
    return co_divideZone<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_divideZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DivideZoneReq& p_req) {
    return co_divideZone<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_divideZone(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::DivideZoneReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = divideZoneCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      divideZoneImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      divideZoneImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_divideZone(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void divideZone(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DivideZoneReq& p_req);


  static folly::exception_wrapper recv_wrapped_divideZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_divideZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_divideZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_divideZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void divideZoneT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DivideZoneReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> divideZoneCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void renameZone(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RenameZoneReq& p_req);
  virtual void renameZone(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RenameZoneReq& p_req);
 protected:
  void renameZoneImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RenameZoneReq& p_req);
 public:

  virtual void sync_renameZone( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RenameZoneReq& p_req);
  virtual void sync_renameZone(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RenameZoneReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_renameZone(const  ::nebula::meta::cpp2::RenameZoneReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_renameZone(const  ::nebula::meta::cpp2::RenameZoneReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_renameZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RenameZoneReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_renameZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RenameZoneReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_renameZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RenameZoneReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_renameZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RenameZoneReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_renameZone(const  ::nebula::meta::cpp2::RenameZoneReq& p_req) {
    return co_renameZone<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_renameZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RenameZoneReq& p_req) {
    return co_renameZone<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_renameZone(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::RenameZoneReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = renameZoneCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      renameZoneImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      renameZoneImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_renameZone(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void renameZone(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::RenameZoneReq& p_req);


  static folly::exception_wrapper recv_wrapped_renameZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_renameZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_renameZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_renameZone( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void renameZoneT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RenameZoneReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> renameZoneCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void getZone(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetZoneReq& p_req);
  virtual void getZone(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetZoneReq& p_req);
 protected:
  void getZoneImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetZoneReq& p_req);
 public:

  virtual void sync_getZone( ::nebula::meta::cpp2::GetZoneResp& _return, const  ::nebula::meta::cpp2::GetZoneReq& p_req);
  virtual void sync_getZone(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetZoneResp& _return, const  ::nebula::meta::cpp2::GetZoneReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::GetZoneResp> future_getZone(const  ::nebula::meta::cpp2::GetZoneReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetZoneResp> semifuture_getZone(const  ::nebula::meta::cpp2::GetZoneReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::GetZoneResp> future_getZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetZoneReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetZoneResp> semifuture_getZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetZoneReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::GetZoneResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_getZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetZoneReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetZoneResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_getZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetZoneReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetZoneResp> co_getZone(const  ::nebula::meta::cpp2::GetZoneReq& p_req) {
    return co_getZone<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetZoneResp> co_getZone(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetZoneReq& p_req) {
    return co_getZone<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::GetZoneResp> co_getZone(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::GetZoneReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = getZoneCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      getZoneImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      getZoneImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::GetZoneResp _return;
    if (auto ew = recv_wrapped_getZone(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void getZone(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetZoneReq& p_req);


  static folly::exception_wrapper recv_wrapped_getZone( ::nebula::meta::cpp2::GetZoneResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_getZone( ::nebula::meta::cpp2::GetZoneResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_getZone( ::nebula::meta::cpp2::GetZoneResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_getZone( ::nebula::meta::cpp2::GetZoneResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void getZoneT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetZoneReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> getZoneCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void listZones(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListZonesReq& p_req);
  virtual void listZones(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListZonesReq& p_req);
 protected:
  void listZonesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListZonesReq& p_req);
 public:

  virtual void sync_listZones( ::nebula::meta::cpp2::ListZonesResp& _return, const  ::nebula::meta::cpp2::ListZonesReq& p_req);
  virtual void sync_listZones(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListZonesResp& _return, const  ::nebula::meta::cpp2::ListZonesReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListZonesResp> future_listZones(const  ::nebula::meta::cpp2::ListZonesReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListZonesResp> semifuture_listZones(const  ::nebula::meta::cpp2::ListZonesReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListZonesResp> future_listZones(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListZonesReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListZonesResp> semifuture_listZones(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListZonesReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListZonesResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_listZones(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListZonesReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListZonesResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_listZones(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListZonesReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListZonesResp> co_listZones(const  ::nebula::meta::cpp2::ListZonesReq& p_req) {
    return co_listZones<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListZonesResp> co_listZones(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListZonesReq& p_req) {
    return co_listZones<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListZonesResp> co_listZones(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ListZonesReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = listZonesCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      listZonesImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      listZonesImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListZonesResp _return;
    if (auto ew = recv_wrapped_listZones(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void listZones(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListZonesReq& p_req);


  static folly::exception_wrapper recv_wrapped_listZones( ::nebula::meta::cpp2::ListZonesResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_listZones( ::nebula::meta::cpp2::ListZonesResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_listZones( ::nebula::meta::cpp2::ListZonesResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_listZones( ::nebula::meta::cpp2::ListZonesResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void listZonesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListZonesReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> listZonesCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void addListener(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AddListenerReq& p_req);
  virtual void addListener(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::AddListenerReq& p_req);
 protected:
  void addListenerImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AddListenerReq& p_req);
 public:

  virtual void sync_addListener( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AddListenerReq& p_req);
  virtual void sync_addListener(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::AddListenerReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_addListener(const  ::nebula::meta::cpp2::AddListenerReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_addListener(const  ::nebula::meta::cpp2::AddListenerReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_addListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddListenerReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_addListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddListenerReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_addListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddListenerReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_addListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddListenerReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_addListener(const  ::nebula::meta::cpp2::AddListenerReq& p_req) {
    return co_addListener<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_addListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::AddListenerReq& p_req) {
    return co_addListener<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_addListener(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::AddListenerReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = addListenerCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      addListenerImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      addListenerImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_addListener(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void addListener(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::AddListenerReq& p_req);


  static folly::exception_wrapper recv_wrapped_addListener( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_addListener( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_addListener( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_addListener( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void addListenerT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::AddListenerReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> addListenerCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void removeListener(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req);
  virtual void removeListener(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req);
 protected:
  void removeListenerImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req);
 public:

  virtual void sync_removeListener( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req);
  virtual void sync_removeListener(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_removeListener(const  ::nebula::meta::cpp2::RemoveListenerReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_removeListener(const  ::nebula::meta::cpp2::RemoveListenerReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_removeListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_removeListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_removeListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_removeListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_removeListener(const  ::nebula::meta::cpp2::RemoveListenerReq& p_req) {
    return co_removeListener<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_removeListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req) {
    return co_removeListener<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_removeListener(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = removeListenerCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      removeListenerImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      removeListenerImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_removeListener(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void removeListener(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req);


  static folly::exception_wrapper recv_wrapped_removeListener( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_removeListener( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_removeListener( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_removeListener( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void removeListenerT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RemoveListenerReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> removeListenerCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void listListener(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListListenerReq& p_req);
  virtual void listListener(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListListenerReq& p_req);
 protected:
  void listListenerImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListListenerReq& p_req);
 public:

  virtual void sync_listListener( ::nebula::meta::cpp2::ListListenerResp& _return, const  ::nebula::meta::cpp2::ListListenerReq& p_req);
  virtual void sync_listListener(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListListenerResp& _return, const  ::nebula::meta::cpp2::ListListenerReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListListenerResp> future_listListener(const  ::nebula::meta::cpp2::ListListenerReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListListenerResp> semifuture_listListener(const  ::nebula::meta::cpp2::ListListenerReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListListenerResp> future_listListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListListenerReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListListenerResp> semifuture_listListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListListenerReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListListenerResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_listListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListListenerReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListListenerResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_listListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListListenerReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListListenerResp> co_listListener(const  ::nebula::meta::cpp2::ListListenerReq& p_req) {
    return co_listListener<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListListenerResp> co_listListener(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListListenerReq& p_req) {
    return co_listListener<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListListenerResp> co_listListener(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ListListenerReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = listListenerCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      listListenerImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      listListenerImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListListenerResp _return;
    if (auto ew = recv_wrapped_listListener(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void listListener(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListListenerReq& p_req);


  static folly::exception_wrapper recv_wrapped_listListener( ::nebula::meta::cpp2::ListListenerResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_listListener( ::nebula::meta::cpp2::ListListenerResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_listListener( ::nebula::meta::cpp2::ListListenerResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_listListener( ::nebula::meta::cpp2::ListListenerResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void listListenerT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListListenerReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> listListenerCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void getStats(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetStatsReq& p_req);
  virtual void getStats(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetStatsReq& p_req);
 protected:
  void getStatsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetStatsReq& p_req);
 public:

  virtual void sync_getStats( ::nebula::meta::cpp2::GetStatsResp& _return, const  ::nebula::meta::cpp2::GetStatsReq& p_req);
  virtual void sync_getStats(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetStatsResp& _return, const  ::nebula::meta::cpp2::GetStatsReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::GetStatsResp> future_getStats(const  ::nebula::meta::cpp2::GetStatsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetStatsResp> semifuture_getStats(const  ::nebula::meta::cpp2::GetStatsReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::GetStatsResp> future_getStats(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetStatsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetStatsResp> semifuture_getStats(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetStatsReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::GetStatsResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_getStats(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetStatsReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetStatsResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_getStats(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetStatsReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetStatsResp> co_getStats(const  ::nebula::meta::cpp2::GetStatsReq& p_req) {
    return co_getStats<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetStatsResp> co_getStats(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetStatsReq& p_req) {
    return co_getStats<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::GetStatsResp> co_getStats(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::GetStatsReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = getStatsCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      getStatsImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      getStatsImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::GetStatsResp _return;
    if (auto ew = recv_wrapped_getStats(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void getStats(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetStatsReq& p_req);


  static folly::exception_wrapper recv_wrapped_getStats( ::nebula::meta::cpp2::GetStatsResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_getStats( ::nebula::meta::cpp2::GetStatsResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_getStats( ::nebula::meta::cpp2::GetStatsResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_getStats( ::nebula::meta::cpp2::GetStatsResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void getStatsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetStatsReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> getStatsCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void signInService(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::SignInServiceReq& p_req);
  virtual void signInService(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::SignInServiceReq& p_req);
 protected:
  void signInServiceImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::SignInServiceReq& p_req);
 public:

  virtual void sync_signInService( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::SignInServiceReq& p_req);
  virtual void sync_signInService(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::SignInServiceReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_signInService(const  ::nebula::meta::cpp2::SignInServiceReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_signInService(const  ::nebula::meta::cpp2::SignInServiceReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_signInService(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SignInServiceReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_signInService(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SignInServiceReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_signInService(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SignInServiceReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_signInService(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SignInServiceReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_signInService(const  ::nebula::meta::cpp2::SignInServiceReq& p_req) {
    return co_signInService<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_signInService(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SignInServiceReq& p_req) {
    return co_signInService<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_signInService(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::SignInServiceReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = signInServiceCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      signInServiceImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      signInServiceImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_signInService(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void signInService(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::SignInServiceReq& p_req);


  static folly::exception_wrapper recv_wrapped_signInService( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_signInService( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_signInService( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_signInService( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void signInServiceT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::SignInServiceReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> signInServiceCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void signOutService(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::SignOutServiceReq& p_req);
  virtual void signOutService(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::SignOutServiceReq& p_req);
 protected:
  void signOutServiceImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::SignOutServiceReq& p_req);
 public:

  virtual void sync_signOutService( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::SignOutServiceReq& p_req);
  virtual void sync_signOutService(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::SignOutServiceReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_signOutService(const  ::nebula::meta::cpp2::SignOutServiceReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_signOutService(const  ::nebula::meta::cpp2::SignOutServiceReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_signOutService(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SignOutServiceReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_signOutService(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SignOutServiceReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_signOutService(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SignOutServiceReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_signOutService(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SignOutServiceReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_signOutService(const  ::nebula::meta::cpp2::SignOutServiceReq& p_req) {
    return co_signOutService<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_signOutService(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::SignOutServiceReq& p_req) {
    return co_signOutService<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_signOutService(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::SignOutServiceReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = signOutServiceCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      signOutServiceImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      signOutServiceImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_signOutService(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void signOutService(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::SignOutServiceReq& p_req);


  static folly::exception_wrapper recv_wrapped_signOutService( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_signOutService( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_signOutService( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_signOutService( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void signOutServiceT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::SignOutServiceReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> signOutServiceCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void listServiceClients(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListServiceClientsReq& p_req);
  virtual void listServiceClients(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListServiceClientsReq& p_req);
 protected:
  void listServiceClientsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListServiceClientsReq& p_req);
 public:

  virtual void sync_listServiceClients( ::nebula::meta::cpp2::ListServiceClientsResp& _return, const  ::nebula::meta::cpp2::ListServiceClientsReq& p_req);
  virtual void sync_listServiceClients(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListServiceClientsResp& _return, const  ::nebula::meta::cpp2::ListServiceClientsReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListServiceClientsResp> future_listServiceClients(const  ::nebula::meta::cpp2::ListServiceClientsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListServiceClientsResp> semifuture_listServiceClients(const  ::nebula::meta::cpp2::ListServiceClientsReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListServiceClientsResp> future_listServiceClients(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListServiceClientsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListServiceClientsResp> semifuture_listServiceClients(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListServiceClientsReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListServiceClientsResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_listServiceClients(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListServiceClientsReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListServiceClientsResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_listServiceClients(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListServiceClientsReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListServiceClientsResp> co_listServiceClients(const  ::nebula::meta::cpp2::ListServiceClientsReq& p_req) {
    return co_listServiceClients<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListServiceClientsResp> co_listServiceClients(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListServiceClientsReq& p_req) {
    return co_listServiceClients<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListServiceClientsResp> co_listServiceClients(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ListServiceClientsReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = listServiceClientsCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      listServiceClientsImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      listServiceClientsImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListServiceClientsResp _return;
    if (auto ew = recv_wrapped_listServiceClients(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void listServiceClients(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListServiceClientsReq& p_req);


  static folly::exception_wrapper recv_wrapped_listServiceClients( ::nebula::meta::cpp2::ListServiceClientsResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_listServiceClients( ::nebula::meta::cpp2::ListServiceClientsResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_listServiceClients( ::nebula::meta::cpp2::ListServiceClientsResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_listServiceClients( ::nebula::meta::cpp2::ListServiceClientsResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void listServiceClientsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListServiceClientsReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> listServiceClientsCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void createFTIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req);
  virtual void createFTIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req);
 protected:
  void createFTIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req);
 public:

  virtual void sync_createFTIndex( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req);
  virtual void sync_createFTIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_createFTIndex(const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_createFTIndex(const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_createFTIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_createFTIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_createFTIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_createFTIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createFTIndex(const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req) {
    return co_createFTIndex<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createFTIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req) {
    return co_createFTIndex<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_createFTIndex(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = createFTIndexCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      createFTIndexImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      createFTIndexImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_createFTIndex(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void createFTIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req);


  static folly::exception_wrapper recv_wrapped_createFTIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_createFTIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_createFTIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_createFTIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void createFTIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateFTIndexReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> createFTIndexCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void dropFTIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req);
  virtual void dropFTIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req);
 protected:
  void dropFTIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req);
 public:

  virtual void sync_dropFTIndex( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req);
  virtual void sync_dropFTIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropFTIndex(const  ::nebula::meta::cpp2::DropFTIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropFTIndex(const  ::nebula::meta::cpp2::DropFTIndexReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_dropFTIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_dropFTIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_dropFTIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_dropFTIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropFTIndex(const  ::nebula::meta::cpp2::DropFTIndexReq& p_req) {
    return co_dropFTIndex<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropFTIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req) {
    return co_dropFTIndex<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_dropFTIndex(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = dropFTIndexCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      dropFTIndexImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      dropFTIndexImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_dropFTIndex(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void dropFTIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req);


  static folly::exception_wrapper recv_wrapped_dropFTIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_dropFTIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_dropFTIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_dropFTIndex( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void dropFTIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::DropFTIndexReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> dropFTIndexCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void listFTIndexes(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req);
  virtual void listFTIndexes(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req);
 protected:
  void listFTIndexesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req);
 public:

  virtual void sync_listFTIndexes( ::nebula::meta::cpp2::ListFTIndexesResp& _return, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req);
  virtual void sync_listFTIndexes(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListFTIndexesResp& _return, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListFTIndexesResp> future_listFTIndexes(const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListFTIndexesResp> semifuture_listFTIndexes(const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListFTIndexesResp> future_listFTIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListFTIndexesResp> semifuture_listFTIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListFTIndexesResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_listFTIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListFTIndexesResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_listFTIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListFTIndexesResp> co_listFTIndexes(const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req) {
    return co_listFTIndexes<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListFTIndexesResp> co_listFTIndexes(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req) {
    return co_listFTIndexes<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListFTIndexesResp> co_listFTIndexes(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = listFTIndexesCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      listFTIndexesImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      listFTIndexesImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListFTIndexesResp _return;
    if (auto ew = recv_wrapped_listFTIndexes(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void listFTIndexes(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req);


  static folly::exception_wrapper recv_wrapped_listFTIndexes( ::nebula::meta::cpp2::ListFTIndexesResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_listFTIndexes( ::nebula::meta::cpp2::ListFTIndexesResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_listFTIndexes( ::nebula::meta::cpp2::ListFTIndexesResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_listFTIndexes( ::nebula::meta::cpp2::ListFTIndexesResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void listFTIndexesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListFTIndexesReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> listFTIndexesCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void createSession(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateSessionReq& p_req);
  virtual void createSession(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateSessionReq& p_req);
 protected:
  void createSessionImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateSessionReq& p_req);
 public:

  virtual void sync_createSession( ::nebula::meta::cpp2::CreateSessionResp& _return, const  ::nebula::meta::cpp2::CreateSessionReq& p_req);
  virtual void sync_createSession(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::CreateSessionResp& _return, const  ::nebula::meta::cpp2::CreateSessionReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::CreateSessionResp> future_createSession(const  ::nebula::meta::cpp2::CreateSessionReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::CreateSessionResp> semifuture_createSession(const  ::nebula::meta::cpp2::CreateSessionReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::CreateSessionResp> future_createSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSessionReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::CreateSessionResp> semifuture_createSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSessionReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::CreateSessionResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_createSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSessionReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::CreateSessionResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_createSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSessionReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::CreateSessionResp> co_createSession(const  ::nebula::meta::cpp2::CreateSessionReq& p_req) {
    return co_createSession<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::CreateSessionResp> co_createSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateSessionReq& p_req) {
    return co_createSession<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::CreateSessionResp> co_createSession(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::CreateSessionReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = createSessionCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      createSessionImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      createSessionImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::CreateSessionResp _return;
    if (auto ew = recv_wrapped_createSession(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void createSession(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateSessionReq& p_req);


  static folly::exception_wrapper recv_wrapped_createSession( ::nebula::meta::cpp2::CreateSessionResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_createSession( ::nebula::meta::cpp2::CreateSessionResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_createSession( ::nebula::meta::cpp2::CreateSessionResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_createSession( ::nebula::meta::cpp2::CreateSessionResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void createSessionT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateSessionReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> createSessionCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void updateSessions(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req);
  virtual void updateSessions(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req);
 protected:
  void updateSessionsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req);
 public:

  virtual void sync_updateSessions( ::nebula::meta::cpp2::UpdateSessionsResp& _return, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req);
  virtual void sync_updateSessions(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::UpdateSessionsResp& _return, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::UpdateSessionsResp> future_updateSessions(const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::UpdateSessionsResp> semifuture_updateSessions(const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::UpdateSessionsResp> future_updateSessions(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::UpdateSessionsResp> semifuture_updateSessions(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::UpdateSessionsResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_updateSessions(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::UpdateSessionsResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_updateSessions(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::UpdateSessionsResp> co_updateSessions(const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req) {
    return co_updateSessions<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::UpdateSessionsResp> co_updateSessions(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req) {
    return co_updateSessions<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::UpdateSessionsResp> co_updateSessions(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = updateSessionsCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      updateSessionsImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      updateSessionsImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::UpdateSessionsResp _return;
    if (auto ew = recv_wrapped_updateSessions(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void updateSessions(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req);


  static folly::exception_wrapper recv_wrapped_updateSessions( ::nebula::meta::cpp2::UpdateSessionsResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_updateSessions( ::nebula::meta::cpp2::UpdateSessionsResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_updateSessions( ::nebula::meta::cpp2::UpdateSessionsResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_updateSessions( ::nebula::meta::cpp2::UpdateSessionsResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void updateSessionsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::UpdateSessionsReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> updateSessionsCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void listSessions(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListSessionsReq& p_req);
  virtual void listSessions(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListSessionsReq& p_req);
 protected:
  void listSessionsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListSessionsReq& p_req);
 public:

  virtual void sync_listSessions( ::nebula::meta::cpp2::ListSessionsResp& _return, const  ::nebula::meta::cpp2::ListSessionsReq& p_req);
  virtual void sync_listSessions(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListSessionsResp& _return, const  ::nebula::meta::cpp2::ListSessionsReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListSessionsResp> future_listSessions(const  ::nebula::meta::cpp2::ListSessionsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListSessionsResp> semifuture_listSessions(const  ::nebula::meta::cpp2::ListSessionsReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListSessionsResp> future_listSessions(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSessionsReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListSessionsResp> semifuture_listSessions(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSessionsReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListSessionsResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_listSessions(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSessionsReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListSessionsResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_listSessions(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSessionsReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListSessionsResp> co_listSessions(const  ::nebula::meta::cpp2::ListSessionsReq& p_req) {
    return co_listSessions<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListSessionsResp> co_listSessions(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListSessionsReq& p_req) {
    return co_listSessions<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListSessionsResp> co_listSessions(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ListSessionsReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = listSessionsCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      listSessionsImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      listSessionsImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListSessionsResp _return;
    if (auto ew = recv_wrapped_listSessions(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void listSessions(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListSessionsReq& p_req);


  static folly::exception_wrapper recv_wrapped_listSessions( ::nebula::meta::cpp2::ListSessionsResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_listSessions( ::nebula::meta::cpp2::ListSessionsResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_listSessions( ::nebula::meta::cpp2::ListSessionsResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_listSessions( ::nebula::meta::cpp2::ListSessionsResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void listSessionsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListSessionsReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> listSessionsCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void getSession(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetSessionReq& p_req);
  virtual void getSession(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetSessionReq& p_req);
 protected:
  void getSessionImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetSessionReq& p_req);
 public:

  virtual void sync_getSession( ::nebula::meta::cpp2::GetSessionResp& _return, const  ::nebula::meta::cpp2::GetSessionReq& p_req);
  virtual void sync_getSession(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetSessionResp& _return, const  ::nebula::meta::cpp2::GetSessionReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::GetSessionResp> future_getSession(const  ::nebula::meta::cpp2::GetSessionReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetSessionResp> semifuture_getSession(const  ::nebula::meta::cpp2::GetSessionReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::GetSessionResp> future_getSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetSessionReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetSessionResp> semifuture_getSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetSessionReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::GetSessionResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_getSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetSessionReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetSessionResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_getSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetSessionReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetSessionResp> co_getSession(const  ::nebula::meta::cpp2::GetSessionReq& p_req) {
    return co_getSession<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetSessionResp> co_getSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetSessionReq& p_req) {
    return co_getSession<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::GetSessionResp> co_getSession(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::GetSessionReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = getSessionCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      getSessionImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      getSessionImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::GetSessionResp _return;
    if (auto ew = recv_wrapped_getSession(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void getSession(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetSessionReq& p_req);


  static folly::exception_wrapper recv_wrapped_getSession( ::nebula::meta::cpp2::GetSessionResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_getSession( ::nebula::meta::cpp2::GetSessionResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_getSession( ::nebula::meta::cpp2::GetSessionResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_getSession( ::nebula::meta::cpp2::GetSessionResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void getSessionT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetSessionReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> getSessionCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void removeSession(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req);
  virtual void removeSession(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req);
 protected:
  void removeSessionImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req);
 public:

  virtual void sync_removeSession( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req);
  virtual void sync_removeSession(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_removeSession(const  ::nebula::meta::cpp2::RemoveSessionReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_removeSession(const  ::nebula::meta::cpp2::RemoveSessionReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_removeSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_removeSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_removeSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_removeSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_removeSession(const  ::nebula::meta::cpp2::RemoveSessionReq& p_req) {
    return co_removeSession<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_removeSession(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req) {
    return co_removeSession<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_removeSession(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = removeSessionCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      removeSessionImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      removeSessionImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_removeSession(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void removeSession(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req);


  static folly::exception_wrapper recv_wrapped_removeSession( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_removeSession( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_removeSession( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_removeSession( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void removeSessionT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RemoveSessionReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> removeSessionCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void killQuery(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::KillQueryReq& p_req);
  virtual void killQuery(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::KillQueryReq& p_req);
 protected:
  void killQueryImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::KillQueryReq& p_req);
 public:

  virtual void sync_killQuery( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::KillQueryReq& p_req);
  virtual void sync_killQuery(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::KillQueryReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_killQuery(const  ::nebula::meta::cpp2::KillQueryReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_killQuery(const  ::nebula::meta::cpp2::KillQueryReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_killQuery(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::KillQueryReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_killQuery(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::KillQueryReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_killQuery(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::KillQueryReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_killQuery(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::KillQueryReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_killQuery(const  ::nebula::meta::cpp2::KillQueryReq& p_req) {
    return co_killQuery<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_killQuery(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::KillQueryReq& p_req) {
    return co_killQuery<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_killQuery(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::KillQueryReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = killQueryCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      killQueryImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      killQueryImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_killQuery(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void killQuery(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::KillQueryReq& p_req);


  static folly::exception_wrapper recv_wrapped_killQuery( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_killQuery( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_killQuery( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_killQuery( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void killQueryT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::KillQueryReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> killQueryCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void reportTaskFinish(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ReportTaskReq& p_req);
  virtual void reportTaskFinish(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ReportTaskReq& p_req);
 protected:
  void reportTaskFinishImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ReportTaskReq& p_req);
 public:

  virtual void sync_reportTaskFinish( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::ReportTaskReq& p_req);
  virtual void sync_reportTaskFinish(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::ReportTaskReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_reportTaskFinish(const  ::nebula::meta::cpp2::ReportTaskReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_reportTaskFinish(const  ::nebula::meta::cpp2::ReportTaskReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_reportTaskFinish(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ReportTaskReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_reportTaskFinish(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ReportTaskReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_reportTaskFinish(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ReportTaskReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_reportTaskFinish(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ReportTaskReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_reportTaskFinish(const  ::nebula::meta::cpp2::ReportTaskReq& p_req) {
    return co_reportTaskFinish<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_reportTaskFinish(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ReportTaskReq& p_req) {
    return co_reportTaskFinish<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_reportTaskFinish(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ReportTaskReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = reportTaskFinishCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      reportTaskFinishImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      reportTaskFinishImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_reportTaskFinish(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void reportTaskFinish(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ReportTaskReq& p_req);


  static folly::exception_wrapper recv_wrapped_reportTaskFinish( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_reportTaskFinish( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_reportTaskFinish( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_reportTaskFinish( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void reportTaskFinishT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ReportTaskReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> reportTaskFinishCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void createBackup(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateBackupReq& p_req);
  virtual void createBackup(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::CreateBackupReq& p_req);
 protected:
  void createBackupImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateBackupReq& p_req);
 public:

  virtual void sync_createBackup( ::nebula::meta::cpp2::CreateBackupResp& _return, const  ::nebula::meta::cpp2::CreateBackupReq& p_req);
  virtual void sync_createBackup(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::CreateBackupResp& _return, const  ::nebula::meta::cpp2::CreateBackupReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::CreateBackupResp> future_createBackup(const  ::nebula::meta::cpp2::CreateBackupReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::CreateBackupResp> semifuture_createBackup(const  ::nebula::meta::cpp2::CreateBackupReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::CreateBackupResp> future_createBackup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateBackupReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::CreateBackupResp> semifuture_createBackup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateBackupReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::CreateBackupResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_createBackup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateBackupReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::CreateBackupResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_createBackup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateBackupReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::CreateBackupResp> co_createBackup(const  ::nebula::meta::cpp2::CreateBackupReq& p_req) {
    return co_createBackup<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::CreateBackupResp> co_createBackup(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::CreateBackupReq& p_req) {
    return co_createBackup<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::CreateBackupResp> co_createBackup(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::CreateBackupReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = createBackupCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      createBackupImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      createBackupImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::CreateBackupResp _return;
    if (auto ew = recv_wrapped_createBackup(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void createBackup(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::CreateBackupReq& p_req);


  static folly::exception_wrapper recv_wrapped_createBackup( ::nebula::meta::cpp2::CreateBackupResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_createBackup( ::nebula::meta::cpp2::CreateBackupResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_createBackup( ::nebula::meta::cpp2::CreateBackupResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_createBackup( ::nebula::meta::cpp2::CreateBackupResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void createBackupT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::CreateBackupReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> createBackupCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void restoreMeta(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req);
  virtual void restoreMeta(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req);
 protected:
  void restoreMetaImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req);
 public:

  virtual void sync_restoreMeta( ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req);
  virtual void sync_restoreMeta(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ExecResp& _return, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_restoreMeta(const  ::nebula::meta::cpp2::RestoreMetaReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_restoreMeta(const  ::nebula::meta::cpp2::RestoreMetaReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ExecResp> future_restoreMeta(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ExecResp> semifuture_restoreMeta(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_restoreMeta(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ExecResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_restoreMeta(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_restoreMeta(const  ::nebula::meta::cpp2::RestoreMetaReq& p_req) {
    return co_restoreMeta<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_restoreMeta(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req) {
    return co_restoreMeta<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ExecResp> co_restoreMeta(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = restoreMetaCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      restoreMetaImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      restoreMetaImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ExecResp _return;
    if (auto ew = recv_wrapped_restoreMeta(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void restoreMeta(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req);


  static folly::exception_wrapper recv_wrapped_restoreMeta( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_restoreMeta( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_restoreMeta( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_restoreMeta( ::nebula::meta::cpp2::ExecResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void restoreMetaT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::RestoreMetaReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> restoreMetaCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void listCluster(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req);
  virtual void listCluster(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req);
 protected:
  void listClusterImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req);
 public:

  virtual void sync_listCluster( ::nebula::meta::cpp2::ListClusterInfoResp& _return, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req);
  virtual void sync_listCluster(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::ListClusterInfoResp& _return, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::ListClusterInfoResp> future_listCluster(const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListClusterInfoResp> semifuture_listCluster(const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::ListClusterInfoResp> future_listCluster(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::ListClusterInfoResp> semifuture_listCluster(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::ListClusterInfoResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_listCluster(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::ListClusterInfoResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_listCluster(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListClusterInfoResp> co_listCluster(const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req) {
    return co_listCluster<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::ListClusterInfoResp> co_listCluster(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req) {
    return co_listCluster<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::ListClusterInfoResp> co_listCluster(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = listClusterCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      listClusterImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      listClusterImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::ListClusterInfoResp _return;
    if (auto ew = recv_wrapped_listCluster(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void listCluster(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req);


  static folly::exception_wrapper recv_wrapped_listCluster( ::nebula::meta::cpp2::ListClusterInfoResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_listCluster( ::nebula::meta::cpp2::ListClusterInfoResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_listCluster( ::nebula::meta::cpp2::ListClusterInfoResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_listCluster( ::nebula::meta::cpp2::ListClusterInfoResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void listClusterT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::ListClusterInfoReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> listClusterCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void getMetaDirInfo(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req);
  virtual void getMetaDirInfo(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req);
 protected:
  void getMetaDirInfoImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req);
 public:

  virtual void sync_getMetaDirInfo( ::nebula::meta::cpp2::GetMetaDirInfoResp& _return, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req);
  virtual void sync_getMetaDirInfo(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::GetMetaDirInfoResp& _return, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::GetMetaDirInfoResp> future_getMetaDirInfo(const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetMetaDirInfoResp> semifuture_getMetaDirInfo(const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::GetMetaDirInfoResp> future_getMetaDirInfo(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::GetMetaDirInfoResp> semifuture_getMetaDirInfo(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::GetMetaDirInfoResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_getMetaDirInfo(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::GetMetaDirInfoResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_getMetaDirInfo(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetMetaDirInfoResp> co_getMetaDirInfo(const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req) {
    return co_getMetaDirInfo<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::GetMetaDirInfoResp> co_getMetaDirInfo(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req) {
    return co_getMetaDirInfo<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::GetMetaDirInfoResp> co_getMetaDirInfo(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = getMetaDirInfoCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      getMetaDirInfoImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      getMetaDirInfoImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::GetMetaDirInfoResp _return;
    if (auto ew = recv_wrapped_getMetaDirInfo(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void getMetaDirInfo(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req);


  static folly::exception_wrapper recv_wrapped_getMetaDirInfo( ::nebula::meta::cpp2::GetMetaDirInfoResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_getMetaDirInfo( ::nebula::meta::cpp2::GetMetaDirInfoResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_getMetaDirInfo( ::nebula::meta::cpp2::GetMetaDirInfoResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_getMetaDirInfo( ::nebula::meta::cpp2::GetMetaDirInfoResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void getMetaDirInfoT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::GetMetaDirInfoReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> getMetaDirInfoCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void verifyClientVersion(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req);
  virtual void verifyClientVersion(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req);
 protected:
  void verifyClientVersionImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req);
 public:

  virtual void sync_verifyClientVersion( ::nebula::meta::cpp2::VerifyClientVersionResp& _return, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req);
  virtual void sync_verifyClientVersion(apache::thrift::RpcOptions& rpcOptions,  ::nebula::meta::cpp2::VerifyClientVersionResp& _return, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req);

  virtual folly::Future< ::nebula::meta::cpp2::VerifyClientVersionResp> future_verifyClientVersion(const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::VerifyClientVersionResp> semifuture_verifyClientVersion(const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req);
  virtual folly::Future< ::nebula::meta::cpp2::VerifyClientVersionResp> future_verifyClientVersion(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req);
  virtual folly::SemiFuture< ::nebula::meta::cpp2::VerifyClientVersionResp> semifuture_verifyClientVersion(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req);
  virtual folly::Future<std::pair< ::nebula::meta::cpp2::VerifyClientVersionResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_verifyClientVersion(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::meta::cpp2::VerifyClientVersionResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_verifyClientVersion(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::VerifyClientVersionResp> co_verifyClientVersion(const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req) {
    return co_verifyClientVersion<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::meta::cpp2::VerifyClientVersionResp> co_verifyClientVersion(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req) {
    return co_verifyClientVersion<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::meta::cpp2::VerifyClientVersionResp> co_verifyClientVersion(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = verifyClientVersionCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      verifyClientVersionImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      verifyClientVersionImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::meta::cpp2::VerifyClientVersionResp _return;
    if (auto ew = recv_wrapped_verifyClientVersion(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void verifyClientVersion(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req);


  static folly::exception_wrapper recv_wrapped_verifyClientVersion( ::nebula::meta::cpp2::VerifyClientVersionResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_verifyClientVersion( ::nebula::meta::cpp2::VerifyClientVersionResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_verifyClientVersion( ::nebula::meta::cpp2::VerifyClientVersionResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_verifyClientVersion( ::nebula::meta::cpp2::VerifyClientVersionResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void verifyClientVersionT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::meta::cpp2::VerifyClientVersionReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> verifyClientVersionCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
};

}}} // nebula::meta::cpp2
