/**
 * Autogenerated by Thrift for storage.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/client_h.h>

#include "storage_types.h"
#include "common_types.h"
#include "meta_types.h"

namespace apache { namespace thrift {
  class Cpp2RequestContext;
  namespace detail { namespace ac { struct ClientRequestContext; }}
  namespace transport { class THeader; }
}}

namespace nebula { namespace storage { namespace cpp2 {

class GraphStorageServiceAsyncClient : public apache::thrift::GeneratedAsyncClient {
 public:
  using apache::thrift::GeneratedAsyncClient::GeneratedAsyncClient;

  char const* getServiceName() const noexcept override {
    return "GraphStorageService";
  }


  virtual void getNeighbors(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req);
  virtual void getNeighbors(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req);
 protected:
  void getNeighborsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req);
 public:

  virtual void sync_getNeighbors( ::nebula::storage::cpp2::GetNeighborsResponse& _return, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req);
  virtual void sync_getNeighbors(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::GetNeighborsResponse& _return, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::GetNeighborsResponse> future_getNeighbors(const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::GetNeighborsResponse> semifuture_getNeighbors(const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::GetNeighborsResponse> future_getNeighbors(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::GetNeighborsResponse> semifuture_getNeighbors(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::GetNeighborsResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_getNeighbors(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::GetNeighborsResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_getNeighbors(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::GetNeighborsResponse> co_getNeighbors(const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req) {
    return co_getNeighbors<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::GetNeighborsResponse> co_getNeighbors(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req) {
    return co_getNeighbors<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::GetNeighborsResponse> co_getNeighbors(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = getNeighborsCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      getNeighborsImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      getNeighborsImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::GetNeighborsResponse _return;
    if (auto ew = recv_wrapped_getNeighbors(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void getNeighbors(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req);


  static folly::exception_wrapper recv_wrapped_getNeighbors( ::nebula::storage::cpp2::GetNeighborsResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_getNeighbors( ::nebula::storage::cpp2::GetNeighborsResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_getNeighbors( ::nebula::storage::cpp2::GetNeighborsResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_getNeighbors( ::nebula::storage::cpp2::GetNeighborsResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void getNeighborsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> getNeighborsCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void getDstBySrc(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::GetDstBySrcRequest& p_req);
  virtual void getDstBySrc(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::GetDstBySrcRequest& p_req);
 protected:
  void getDstBySrcImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::GetDstBySrcRequest& p_req);
 public:

  virtual void sync_getDstBySrc( ::nebula::storage::cpp2::GetDstBySrcResponse& _return, const  ::nebula::storage::cpp2::GetDstBySrcRequest& p_req);
  virtual void sync_getDstBySrc(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::GetDstBySrcResponse& _return, const  ::nebula::storage::cpp2::GetDstBySrcRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::GetDstBySrcResponse> future_getDstBySrc(const  ::nebula::storage::cpp2::GetDstBySrcRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::GetDstBySrcResponse> semifuture_getDstBySrc(const  ::nebula::storage::cpp2::GetDstBySrcRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::GetDstBySrcResponse> future_getDstBySrc(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetDstBySrcRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::GetDstBySrcResponse> semifuture_getDstBySrc(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetDstBySrcRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::GetDstBySrcResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_getDstBySrc(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetDstBySrcRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::GetDstBySrcResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_getDstBySrc(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetDstBySrcRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::GetDstBySrcResponse> co_getDstBySrc(const  ::nebula::storage::cpp2::GetDstBySrcRequest& p_req) {
    return co_getDstBySrc<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::GetDstBySrcResponse> co_getDstBySrc(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetDstBySrcRequest& p_req) {
    return co_getDstBySrc<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::GetDstBySrcResponse> co_getDstBySrc(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::GetDstBySrcRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = getDstBySrcCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      getDstBySrcImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      getDstBySrcImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::GetDstBySrcResponse _return;
    if (auto ew = recv_wrapped_getDstBySrc(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void getDstBySrc(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::GetDstBySrcRequest& p_req);


  static folly::exception_wrapper recv_wrapped_getDstBySrc( ::nebula::storage::cpp2::GetDstBySrcResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_getDstBySrc( ::nebula::storage::cpp2::GetDstBySrcResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_getDstBySrc( ::nebula::storage::cpp2::GetDstBySrcResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_getDstBySrc( ::nebula::storage::cpp2::GetDstBySrcResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void getDstBySrcT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::GetDstBySrcRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> getDstBySrcCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void getProps(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::GetPropRequest& p_req);
  virtual void getProps(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::GetPropRequest& p_req);
 protected:
  void getPropsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::GetPropRequest& p_req);
 public:

  virtual void sync_getProps( ::nebula::storage::cpp2::GetPropResponse& _return, const  ::nebula::storage::cpp2::GetPropRequest& p_req);
  virtual void sync_getProps(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::GetPropResponse& _return, const  ::nebula::storage::cpp2::GetPropRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::GetPropResponse> future_getProps(const  ::nebula::storage::cpp2::GetPropRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::GetPropResponse> semifuture_getProps(const  ::nebula::storage::cpp2::GetPropRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::GetPropResponse> future_getProps(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetPropRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::GetPropResponse> semifuture_getProps(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetPropRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::GetPropResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_getProps(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetPropRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::GetPropResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_getProps(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetPropRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::GetPropResponse> co_getProps(const  ::nebula::storage::cpp2::GetPropRequest& p_req) {
    return co_getProps<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::GetPropResponse> co_getProps(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetPropRequest& p_req) {
    return co_getProps<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::GetPropResponse> co_getProps(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::GetPropRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = getPropsCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      getPropsImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      getPropsImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::GetPropResponse _return;
    if (auto ew = recv_wrapped_getProps(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void getProps(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::GetPropRequest& p_req);


  static folly::exception_wrapper recv_wrapped_getProps( ::nebula::storage::cpp2::GetPropResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_getProps( ::nebula::storage::cpp2::GetPropResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_getProps( ::nebula::storage::cpp2::GetPropResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_getProps( ::nebula::storage::cpp2::GetPropResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void getPropsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::GetPropRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> getPropsCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void addVertices(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req);
  virtual void addVertices(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req);
 protected:
  void addVerticesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req);
 public:

  virtual void sync_addVertices( ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req);
  virtual void sync_addVertices(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::ExecResponse> future_addVertices(const  ::nebula::storage::cpp2::AddVerticesRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> semifuture_addVertices(const  ::nebula::storage::cpp2::AddVerticesRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::ExecResponse> future_addVertices(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> semifuture_addVertices(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_addVertices(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_addVertices(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_addVertices(const  ::nebula::storage::cpp2::AddVerticesRequest& p_req) {
    return co_addVertices<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_addVertices(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req) {
    return co_addVertices<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_addVertices(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = addVerticesCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      addVerticesImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      addVerticesImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::ExecResponse _return;
    if (auto ew = recv_wrapped_addVertices(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void addVertices(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req);


  static folly::exception_wrapper recv_wrapped_addVertices( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_addVertices( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_addVertices( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_addVertices( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void addVerticesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> addVerticesCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void addEdges(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
  virtual void addEdges(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
 protected:
  void addEdgesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
 public:

  virtual void sync_addEdges( ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
  virtual void sync_addEdges(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::ExecResponse> future_addEdges(const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> semifuture_addEdges(const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::ExecResponse> future_addEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> semifuture_addEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_addEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_addEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_addEdges(const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
    return co_addEdges<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_addEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
    return co_addEdges<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_addEdges(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = addEdgesCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      addEdgesImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      addEdgesImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::ExecResponse _return;
    if (auto ew = recv_wrapped_addEdges(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void addEdges(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);


  static folly::exception_wrapper recv_wrapped_addEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_addEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_addEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_addEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void addEdgesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> addEdgesCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void deleteEdges(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
  virtual void deleteEdges(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
 protected:
  void deleteEdgesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
 public:

  virtual void sync_deleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
  virtual void sync_deleteEdges(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::ExecResponse> future_deleteEdges(const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> semifuture_deleteEdges(const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::ExecResponse> future_deleteEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> semifuture_deleteEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_deleteEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_deleteEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_deleteEdges(const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
    return co_deleteEdges<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_deleteEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
    return co_deleteEdges<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_deleteEdges(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = deleteEdgesCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      deleteEdgesImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      deleteEdgesImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::ExecResponse _return;
    if (auto ew = recv_wrapped_deleteEdges(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void deleteEdges(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);


  static folly::exception_wrapper recv_wrapped_deleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_deleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_deleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_deleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void deleteEdgesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> deleteEdgesCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void deleteVertices(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req);
  virtual void deleteVertices(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req);
 protected:
  void deleteVerticesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req);
 public:

  virtual void sync_deleteVertices( ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req);
  virtual void sync_deleteVertices(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::ExecResponse> future_deleteVertices(const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> semifuture_deleteVertices(const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::ExecResponse> future_deleteVertices(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> semifuture_deleteVertices(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_deleteVertices(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_deleteVertices(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_deleteVertices(const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req) {
    return co_deleteVertices<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_deleteVertices(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req) {
    return co_deleteVertices<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_deleteVertices(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = deleteVerticesCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      deleteVerticesImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      deleteVerticesImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::ExecResponse _return;
    if (auto ew = recv_wrapped_deleteVertices(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void deleteVertices(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req);


  static folly::exception_wrapper recv_wrapped_deleteVertices( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_deleteVertices( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_deleteVertices( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_deleteVertices( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void deleteVerticesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> deleteVerticesCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void deleteTags(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req);
  virtual void deleteTags(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req);
 protected:
  void deleteTagsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req);
 public:

  virtual void sync_deleteTags( ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req);
  virtual void sync_deleteTags(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::ExecResponse> future_deleteTags(const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> semifuture_deleteTags(const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::ExecResponse> future_deleteTags(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> semifuture_deleteTags(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_deleteTags(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_deleteTags(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_deleteTags(const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req) {
    return co_deleteTags<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_deleteTags(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req) {
    return co_deleteTags<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_deleteTags(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = deleteTagsCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      deleteTagsImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      deleteTagsImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::ExecResponse _return;
    if (auto ew = recv_wrapped_deleteTags(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void deleteTags(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req);


  static folly::exception_wrapper recv_wrapped_deleteTags( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_deleteTags( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_deleteTags( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_deleteTags( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void deleteTagsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> deleteTagsCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void updateVertex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req);
  virtual void updateVertex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req);
 protected:
  void updateVertexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req);
 public:

  virtual void sync_updateVertex( ::nebula::storage::cpp2::UpdateResponse& _return, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req);
  virtual void sync_updateVertex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::UpdateResponse& _return, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::UpdateResponse> future_updateVertex(const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::UpdateResponse> semifuture_updateVertex(const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::UpdateResponse> future_updateVertex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::UpdateResponse> semifuture_updateVertex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::UpdateResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_updateVertex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::UpdateResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_updateVertex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::UpdateResponse> co_updateVertex(const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req) {
    return co_updateVertex<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::UpdateResponse> co_updateVertex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req) {
    return co_updateVertex<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::UpdateResponse> co_updateVertex(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = updateVertexCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      updateVertexImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      updateVertexImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::UpdateResponse _return;
    if (auto ew = recv_wrapped_updateVertex(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void updateVertex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req);


  static folly::exception_wrapper recv_wrapped_updateVertex( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_updateVertex( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_updateVertex( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_updateVertex( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void updateVertexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> updateVertexCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void updateEdge(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
  virtual void updateEdge(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
 protected:
  void updateEdgeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
 public:

  virtual void sync_updateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
  virtual void sync_updateEdge(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::UpdateResponse& _return, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::UpdateResponse> future_updateEdge(const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::UpdateResponse> semifuture_updateEdge(const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::UpdateResponse> future_updateEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::UpdateResponse> semifuture_updateEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::UpdateResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_updateEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::UpdateResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_updateEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::UpdateResponse> co_updateEdge(const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
    return co_updateEdge<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::UpdateResponse> co_updateEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
    return co_updateEdge<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::UpdateResponse> co_updateEdge(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = updateEdgeCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      updateEdgeImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      updateEdgeImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::UpdateResponse _return;
    if (auto ew = recv_wrapped_updateEdge(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void updateEdge(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);


  static folly::exception_wrapper recv_wrapped_updateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_updateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_updateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_updateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void updateEdgeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> updateEdgeCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void scanVertex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req);
  virtual void scanVertex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req);
 protected:
  void scanVertexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req);
 public:

  virtual void sync_scanVertex( ::nebula::storage::cpp2::ScanResponse& _return, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req);
  virtual void sync_scanVertex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ScanResponse& _return, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::ScanResponse> future_scanVertex(const  ::nebula::storage::cpp2::ScanVertexRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ScanResponse> semifuture_scanVertex(const  ::nebula::storage::cpp2::ScanVertexRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::ScanResponse> future_scanVertex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ScanResponse> semifuture_scanVertex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::ScanResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_scanVertex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ScanResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_scanVertex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ScanResponse> co_scanVertex(const  ::nebula::storage::cpp2::ScanVertexRequest& p_req) {
    return co_scanVertex<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ScanResponse> co_scanVertex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req) {
    return co_scanVertex<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::ScanResponse> co_scanVertex(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = scanVertexCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      scanVertexImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      scanVertexImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::ScanResponse _return;
    if (auto ew = recv_wrapped_scanVertex(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void scanVertex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req);


  static folly::exception_wrapper recv_wrapped_scanVertex( ::nebula::storage::cpp2::ScanResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_scanVertex( ::nebula::storage::cpp2::ScanResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_scanVertex( ::nebula::storage::cpp2::ScanResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_scanVertex( ::nebula::storage::cpp2::ScanResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void scanVertexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> scanVertexCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void scanEdge(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req);
  virtual void scanEdge(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req);
 protected:
  void scanEdgeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req);
 public:

  virtual void sync_scanEdge( ::nebula::storage::cpp2::ScanResponse& _return, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req);
  virtual void sync_scanEdge(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ScanResponse& _return, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::ScanResponse> future_scanEdge(const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ScanResponse> semifuture_scanEdge(const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::ScanResponse> future_scanEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ScanResponse> semifuture_scanEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::ScanResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_scanEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ScanResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_scanEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ScanResponse> co_scanEdge(const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req) {
    return co_scanEdge<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ScanResponse> co_scanEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req) {
    return co_scanEdge<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::ScanResponse> co_scanEdge(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = scanEdgeCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      scanEdgeImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      scanEdgeImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::ScanResponse _return;
    if (auto ew = recv_wrapped_scanEdge(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void scanEdge(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req);


  static folly::exception_wrapper recv_wrapped_scanEdge( ::nebula::storage::cpp2::ScanResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_scanEdge( ::nebula::storage::cpp2::ScanResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_scanEdge( ::nebula::storage::cpp2::ScanResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_scanEdge( ::nebula::storage::cpp2::ScanResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void scanEdgeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> scanEdgeCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void getUUID(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::GetUUIDReq& p_req);
  virtual void getUUID(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::GetUUIDReq& p_req);
 protected:
  void getUUIDImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::GetUUIDReq& p_req);
 public:

  virtual void sync_getUUID( ::nebula::storage::cpp2::GetUUIDResp& _return, const  ::nebula::storage::cpp2::GetUUIDReq& p_req);
  virtual void sync_getUUID(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::GetUUIDResp& _return, const  ::nebula::storage::cpp2::GetUUIDReq& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::GetUUIDResp> future_getUUID(const  ::nebula::storage::cpp2::GetUUIDReq& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::GetUUIDResp> semifuture_getUUID(const  ::nebula::storage::cpp2::GetUUIDReq& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::GetUUIDResp> future_getUUID(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetUUIDReq& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::GetUUIDResp> semifuture_getUUID(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetUUIDReq& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::GetUUIDResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_getUUID(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetUUIDReq& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::GetUUIDResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_getUUID(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetUUIDReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::GetUUIDResp> co_getUUID(const  ::nebula::storage::cpp2::GetUUIDReq& p_req) {
    return co_getUUID<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::GetUUIDResp> co_getUUID(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetUUIDReq& p_req) {
    return co_getUUID<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::GetUUIDResp> co_getUUID(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::GetUUIDReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = getUUIDCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      getUUIDImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      getUUIDImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::GetUUIDResp _return;
    if (auto ew = recv_wrapped_getUUID(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void getUUID(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::GetUUIDReq& p_req);


  static folly::exception_wrapper recv_wrapped_getUUID( ::nebula::storage::cpp2::GetUUIDResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_getUUID( ::nebula::storage::cpp2::GetUUIDResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_getUUID( ::nebula::storage::cpp2::GetUUIDResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_getUUID( ::nebula::storage::cpp2::GetUUIDResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void getUUIDT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::GetUUIDReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> getUUIDCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void lookupIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req);
  virtual void lookupIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req);
 protected:
  void lookupIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req);
 public:

  virtual void sync_lookupIndex( ::nebula::storage::cpp2::LookupIndexResp& _return, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req);
  virtual void sync_lookupIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::LookupIndexResp& _return, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::LookupIndexResp> future_lookupIndex(const  ::nebula::storage::cpp2::LookupIndexRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::LookupIndexResp> semifuture_lookupIndex(const  ::nebula::storage::cpp2::LookupIndexRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::LookupIndexResp> future_lookupIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::LookupIndexResp> semifuture_lookupIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::LookupIndexResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_lookupIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::LookupIndexResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_lookupIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::LookupIndexResp> co_lookupIndex(const  ::nebula::storage::cpp2::LookupIndexRequest& p_req) {
    return co_lookupIndex<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::LookupIndexResp> co_lookupIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req) {
    return co_lookupIndex<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::LookupIndexResp> co_lookupIndex(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = lookupIndexCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      lookupIndexImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      lookupIndexImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::LookupIndexResp _return;
    if (auto ew = recv_wrapped_lookupIndex(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void lookupIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req);


  static folly::exception_wrapper recv_wrapped_lookupIndex( ::nebula::storage::cpp2::LookupIndexResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_lookupIndex( ::nebula::storage::cpp2::LookupIndexResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_lookupIndex( ::nebula::storage::cpp2::LookupIndexResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_lookupIndex( ::nebula::storage::cpp2::LookupIndexResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void lookupIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> lookupIndexCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void lookupAndTraverse(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req);
  virtual void lookupAndTraverse(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req);
 protected:
  void lookupAndTraverseImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req);
 public:

  virtual void sync_lookupAndTraverse( ::nebula::storage::cpp2::GetNeighborsResponse& _return, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req);
  virtual void sync_lookupAndTraverse(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::GetNeighborsResponse& _return, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::GetNeighborsResponse> future_lookupAndTraverse(const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::GetNeighborsResponse> semifuture_lookupAndTraverse(const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::GetNeighborsResponse> future_lookupAndTraverse(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::GetNeighborsResponse> semifuture_lookupAndTraverse(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::GetNeighborsResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_lookupAndTraverse(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::GetNeighborsResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_lookupAndTraverse(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::GetNeighborsResponse> co_lookupAndTraverse(const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req) {
    return co_lookupAndTraverse<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::GetNeighborsResponse> co_lookupAndTraverse(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req) {
    return co_lookupAndTraverse<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::GetNeighborsResponse> co_lookupAndTraverse(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = lookupAndTraverseCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      lookupAndTraverseImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      lookupAndTraverseImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::GetNeighborsResponse _return;
    if (auto ew = recv_wrapped_lookupAndTraverse(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void lookupAndTraverse(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req);


  static folly::exception_wrapper recv_wrapped_lookupAndTraverse( ::nebula::storage::cpp2::GetNeighborsResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_lookupAndTraverse( ::nebula::storage::cpp2::GetNeighborsResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_lookupAndTraverse( ::nebula::storage::cpp2::GetNeighborsResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_lookupAndTraverse( ::nebula::storage::cpp2::GetNeighborsResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void lookupAndTraverseT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> lookupAndTraverseCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void chainUpdateEdge(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
  virtual void chainUpdateEdge(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
 protected:
  void chainUpdateEdgeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
 public:

  virtual void sync_chainUpdateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
  virtual void sync_chainUpdateEdge(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::UpdateResponse& _return, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::UpdateResponse> future_chainUpdateEdge(const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::UpdateResponse> semifuture_chainUpdateEdge(const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::UpdateResponse> future_chainUpdateEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::UpdateResponse> semifuture_chainUpdateEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::UpdateResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_chainUpdateEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::UpdateResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_chainUpdateEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::UpdateResponse> co_chainUpdateEdge(const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
    return co_chainUpdateEdge<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::UpdateResponse> co_chainUpdateEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
    return co_chainUpdateEdge<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::UpdateResponse> co_chainUpdateEdge(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = chainUpdateEdgeCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      chainUpdateEdgeImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      chainUpdateEdgeImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::UpdateResponse _return;
    if (auto ew = recv_wrapped_chainUpdateEdge(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void chainUpdateEdge(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);


  static folly::exception_wrapper recv_wrapped_chainUpdateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_chainUpdateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_chainUpdateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_chainUpdateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void chainUpdateEdgeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> chainUpdateEdgeCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void chainAddEdges(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
  virtual void chainAddEdges(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
 protected:
  void chainAddEdgesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
 public:

  virtual void sync_chainAddEdges( ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
  virtual void sync_chainAddEdges(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::ExecResponse> future_chainAddEdges(const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> semifuture_chainAddEdges(const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::ExecResponse> future_chainAddEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> semifuture_chainAddEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_chainAddEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_chainAddEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_chainAddEdges(const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
    return co_chainAddEdges<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_chainAddEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
    return co_chainAddEdges<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_chainAddEdges(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = chainAddEdgesCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      chainAddEdgesImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      chainAddEdgesImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::ExecResponse _return;
    if (auto ew = recv_wrapped_chainAddEdges(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void chainAddEdges(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);


  static folly::exception_wrapper recv_wrapped_chainAddEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_chainAddEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_chainAddEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_chainAddEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void chainAddEdgesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> chainAddEdgesCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void chainDeleteEdges(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
  virtual void chainDeleteEdges(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
 protected:
  void chainDeleteEdgesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
 public:

  virtual void sync_chainDeleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
  virtual void sync_chainDeleteEdges(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::ExecResponse> future_chainDeleteEdges(const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> semifuture_chainDeleteEdges(const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::ExecResponse> future_chainDeleteEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> semifuture_chainDeleteEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_chainDeleteEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_chainDeleteEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_chainDeleteEdges(const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
    return co_chainDeleteEdges<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_chainDeleteEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
    return co_chainDeleteEdges<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_chainDeleteEdges(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = chainDeleteEdgesCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      chainDeleteEdgesImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      chainDeleteEdgesImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::ExecResponse _return;
    if (auto ew = recv_wrapped_chainDeleteEdges(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void chainDeleteEdges(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);


  static folly::exception_wrapper recv_wrapped_chainDeleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_chainDeleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_chainDeleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_chainDeleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void chainDeleteEdgesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> chainDeleteEdgesCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void get(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::KVGetRequest& p_req);
  virtual void get(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::KVGetRequest& p_req);
 protected:
  void getImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::KVGetRequest& p_req);
 public:

  virtual void sync_get( ::nebula::storage::cpp2::KVGetResponse& _return, const  ::nebula::storage::cpp2::KVGetRequest& p_req);
  virtual void sync_get(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::KVGetResponse& _return, const  ::nebula::storage::cpp2::KVGetRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::KVGetResponse> future_get(const  ::nebula::storage::cpp2::KVGetRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::KVGetResponse> semifuture_get(const  ::nebula::storage::cpp2::KVGetRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::KVGetResponse> future_get(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVGetRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::KVGetResponse> semifuture_get(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVGetRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::KVGetResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_get(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVGetRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::KVGetResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_get(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVGetRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::KVGetResponse> co_get(const  ::nebula::storage::cpp2::KVGetRequest& p_req) {
    return co_get<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::KVGetResponse> co_get(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVGetRequest& p_req) {
    return co_get<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::KVGetResponse> co_get(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::KVGetRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = getCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      getImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      getImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::KVGetResponse _return;
    if (auto ew = recv_wrapped_get(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void get(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::KVGetRequest& p_req);


  static folly::exception_wrapper recv_wrapped_get( ::nebula::storage::cpp2::KVGetResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_get( ::nebula::storage::cpp2::KVGetResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_get( ::nebula::storage::cpp2::KVGetResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_get( ::nebula::storage::cpp2::KVGetResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void getT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::KVGetRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> getCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void put(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::KVPutRequest& p_req);
  virtual void put(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::KVPutRequest& p_req);
 protected:
  void putImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::KVPutRequest& p_req);
 public:

  virtual void sync_put( ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::KVPutRequest& p_req);
  virtual void sync_put(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::KVPutRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::ExecResponse> future_put(const  ::nebula::storage::cpp2::KVPutRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> semifuture_put(const  ::nebula::storage::cpp2::KVPutRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::ExecResponse> future_put(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVPutRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> semifuture_put(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVPutRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_put(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVPutRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_put(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVPutRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_put(const  ::nebula::storage::cpp2::KVPutRequest& p_req) {
    return co_put<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_put(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVPutRequest& p_req) {
    return co_put<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_put(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::KVPutRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = putCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      putImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      putImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::ExecResponse _return;
    if (auto ew = recv_wrapped_put(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void put(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::KVPutRequest& p_req);


  static folly::exception_wrapper recv_wrapped_put( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_put( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_put( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_put( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void putT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::KVPutRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> putCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void remove(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req);
  virtual void remove(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req);
 protected:
  void removeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req);
 public:

  virtual void sync_remove( ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req);
  virtual void sync_remove(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req);

  virtual folly::Future< ::nebula::storage::cpp2::ExecResponse> future_remove(const  ::nebula::storage::cpp2::KVRemoveRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> semifuture_remove(const  ::nebula::storage::cpp2::KVRemoveRequest& p_req);
  virtual folly::Future< ::nebula::storage::cpp2::ExecResponse> future_remove(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req);
  virtual folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> semifuture_remove(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req);
  virtual folly::Future<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_remove(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req);
  virtual folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_remove(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_remove(const  ::nebula::storage::cpp2::KVRemoveRequest& p_req) {
    return co_remove<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_remove(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req) {
    return co_remove<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task< ::nebula::storage::cpp2::ExecResponse> co_remove(apache::thrift::RpcOptions* rpcOptions, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = removeCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      removeImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      removeImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
     ::nebula::storage::cpp2::ExecResponse _return;
    if (auto ew = recv_wrapped_remove(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void remove(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req);


  static folly::exception_wrapper recv_wrapped_remove( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_remove( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_remove( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_remove( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void removeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> removeCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
};

}}} // nebula::storage::cpp2
