/**
 * Autogenerated by Thrift for graph.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/service_h.h>

#include "GraphServiceAsyncClient.h"
#include "graph_types.h"
#include "common_types.h"
#include "common/graph/PairOps-inl.h"
#include "common/graph/ProfilingStatsOps-inl.h"
#include "common/graph/PlanNodeBranchInfoOps-inl.h"
#include "common/graph/PlanNodeDescriptionOps-inl.h"
#include "common/graph/PlanDescriptionOps-inl.h"
#include "common/graph/ExecutionResponseOps-inl.h"
#include "common/graph/AuthResponseOps-inl.h"
#include "common/graph/VerifyClientVersionRespOps-inl.h"
#include "common/graph/VerifyClientVersionReqOps-inl.h"

namespace folly {
  class IOBuf;
  class IOBufQueue;
}
namespace apache { namespace thrift {
  class Cpp2RequestContext;
  class BinaryProtocolReader;
  class CompactProtocolReader;
  namespace transport { class THeader; }
}}

namespace nebula { namespace graph { namespace cpp2 {

class GraphServiceSvAsyncIf {
 public:
  virtual ~GraphServiceSvAsyncIf() {}
  virtual void async_tm_authenticate(std::unique_ptr<apache::thrift::HandlerCallback<nebula::AuthResponse>> callback, const ::std::string& p_username, const ::std::string& p_password) = 0;
  virtual folly::Future<nebula::AuthResponse> future_authenticate(const ::std::string& p_username, const ::std::string& p_password) = 0;
  virtual folly::SemiFuture<nebula::AuthResponse> semifuture_authenticate(const ::std::string& p_username, const ::std::string& p_password) = 0;
  virtual void async_tm_signout(std::unique_ptr<apache::thrift::HandlerCallbackBase> callback, int64_t p_sessionId) = 0;
  virtual folly::Future<folly::Unit> future_signout(int64_t p_sessionId) = 0;
  virtual folly::SemiFuture<folly::Unit> semifuture_signout(int64_t p_sessionId) = 0;
  virtual void async_tm_execute(std::unique_ptr<apache::thrift::HandlerCallback<nebula::ExecutionResponse>> callback, int64_t p_sessionId, const ::std::string& p_stmt) = 0;
  virtual folly::Future<nebula::ExecutionResponse> future_execute(int64_t p_sessionId, const ::std::string& p_stmt) = 0;
  virtual folly::SemiFuture<nebula::ExecutionResponse> semifuture_execute(int64_t p_sessionId, const ::std::string& p_stmt) = 0;
  virtual void async_tm_executeWithParameter(std::unique_ptr<apache::thrift::HandlerCallback<nebula::ExecutionResponse>> callback, int64_t p_sessionId, const ::std::string& p_stmt, const std::unordered_map<::std::string, nebula::Value>& p_parameterMap) = 0;
  virtual folly::Future<nebula::ExecutionResponse> future_executeWithParameter(int64_t p_sessionId, const ::std::string& p_stmt, const std::unordered_map<::std::string, nebula::Value>& p_parameterMap) = 0;
  virtual folly::SemiFuture<nebula::ExecutionResponse> semifuture_executeWithParameter(int64_t p_sessionId, const ::std::string& p_stmt, const std::unordered_map<::std::string, nebula::Value>& p_parameterMap) = 0;
  virtual void async_tm_executeJson(std::unique_ptr<apache::thrift::HandlerCallback<::std::string>> callback, int64_t p_sessionId, const ::std::string& p_stmt) = 0;
  virtual folly::Future<::std::string> future_executeJson(int64_t p_sessionId, const ::std::string& p_stmt) = 0;
  virtual folly::SemiFuture<::std::string> semifuture_executeJson(int64_t p_sessionId, const ::std::string& p_stmt) = 0;
  virtual void async_tm_executeJsonWithParameter(std::unique_ptr<apache::thrift::HandlerCallback<::std::string>> callback, int64_t p_sessionId, const ::std::string& p_stmt, const std::unordered_map<::std::string, nebula::Value>& p_parameterMap) = 0;
  virtual folly::Future<::std::string> future_executeJsonWithParameter(int64_t p_sessionId, const ::std::string& p_stmt, const std::unordered_map<::std::string, nebula::Value>& p_parameterMap) = 0;
  virtual folly::SemiFuture<::std::string> semifuture_executeJsonWithParameter(int64_t p_sessionId, const ::std::string& p_stmt, const std::unordered_map<::std::string, nebula::Value>& p_parameterMap) = 0;
  virtual void async_tm_verifyClientVersion(std::unique_ptr<apache::thrift::HandlerCallback<nebula::VerifyClientVersionResp>> callback, const nebula::VerifyClientVersionReq& p_req) = 0;
  virtual folly::Future<nebula::VerifyClientVersionResp> future_verifyClientVersion(const nebula::VerifyClientVersionReq& p_req) = 0;
  virtual folly::SemiFuture<nebula::VerifyClientVersionResp> semifuture_verifyClientVersion(const nebula::VerifyClientVersionReq& p_req) = 0;
};

class GraphServiceAsyncProcessor;

class GraphServiceSvIf : public GraphServiceSvAsyncIf, public apache::thrift::ServerInterface {
 public:
  typedef GraphServiceAsyncProcessor ProcessorType;
  std::unique_ptr<apache::thrift::AsyncProcessor> getProcessor() override;


  virtual void authenticate(nebula::AuthResponse& /*_return*/, const ::std::string& /*username*/, const ::std::string& /*password*/);
  folly::Future<nebula::AuthResponse> future_authenticate(const ::std::string& p_username, const ::std::string& p_password) override;
  folly::SemiFuture<nebula::AuthResponse> semifuture_authenticate(const ::std::string& p_username, const ::std::string& p_password) override;
  void async_tm_authenticate(std::unique_ptr<apache::thrift::HandlerCallback<nebula::AuthResponse>> callback, const ::std::string& p_username, const ::std::string& p_password) override;
  virtual void signout(int64_t /*sessionId*/);
  folly::Future<folly::Unit> future_signout(int64_t p_sessionId) override;
  folly::SemiFuture<folly::Unit> semifuture_signout(int64_t p_sessionId) override;
  void async_tm_signout(std::unique_ptr<apache::thrift::HandlerCallbackBase> callback, int64_t p_sessionId) override;
  virtual void execute(nebula::ExecutionResponse& /*_return*/, int64_t /*sessionId*/, const ::std::string& /*stmt*/);
  folly::Future<nebula::ExecutionResponse> future_execute(int64_t p_sessionId, const ::std::string& p_stmt) override;
  folly::SemiFuture<nebula::ExecutionResponse> semifuture_execute(int64_t p_sessionId, const ::std::string& p_stmt) override;
  void async_tm_execute(std::unique_ptr<apache::thrift::HandlerCallback<nebula::ExecutionResponse>> callback, int64_t p_sessionId, const ::std::string& p_stmt) override;
  virtual void executeWithParameter(nebula::ExecutionResponse& /*_return*/, int64_t /*sessionId*/, const ::std::string& /*stmt*/, const std::unordered_map<::std::string, nebula::Value>& /*parameterMap*/);
  folly::Future<nebula::ExecutionResponse> future_executeWithParameter(int64_t p_sessionId, const ::std::string& p_stmt, const std::unordered_map<::std::string, nebula::Value>& p_parameterMap) override;
  folly::SemiFuture<nebula::ExecutionResponse> semifuture_executeWithParameter(int64_t p_sessionId, const ::std::string& p_stmt, const std::unordered_map<::std::string, nebula::Value>& p_parameterMap) override;
  void async_tm_executeWithParameter(std::unique_ptr<apache::thrift::HandlerCallback<nebula::ExecutionResponse>> callback, int64_t p_sessionId, const ::std::string& p_stmt, const std::unordered_map<::std::string, nebula::Value>& p_parameterMap) override;
  virtual void executeJson(::std::string& /*_return*/, int64_t /*sessionId*/, const ::std::string& /*stmt*/);
  folly::Future<::std::string> future_executeJson(int64_t p_sessionId, const ::std::string& p_stmt) override;
  folly::SemiFuture<::std::string> semifuture_executeJson(int64_t p_sessionId, const ::std::string& p_stmt) override;
  void async_tm_executeJson(std::unique_ptr<apache::thrift::HandlerCallback<::std::string>> callback, int64_t p_sessionId, const ::std::string& p_stmt) override;
  virtual void executeJsonWithParameter(::std::string& /*_return*/, int64_t /*sessionId*/, const ::std::string& /*stmt*/, const std::unordered_map<::std::string, nebula::Value>& /*parameterMap*/);
  folly::Future<::std::string> future_executeJsonWithParameter(int64_t p_sessionId, const ::std::string& p_stmt, const std::unordered_map<::std::string, nebula::Value>& p_parameterMap) override;
  folly::SemiFuture<::std::string> semifuture_executeJsonWithParameter(int64_t p_sessionId, const ::std::string& p_stmt, const std::unordered_map<::std::string, nebula::Value>& p_parameterMap) override;
  void async_tm_executeJsonWithParameter(std::unique_ptr<apache::thrift::HandlerCallback<::std::string>> callback, int64_t p_sessionId, const ::std::string& p_stmt, const std::unordered_map<::std::string, nebula::Value>& p_parameterMap) override;
  virtual void verifyClientVersion(nebula::VerifyClientVersionResp& /*_return*/, const nebula::VerifyClientVersionReq& /*req*/);
  folly::Future<nebula::VerifyClientVersionResp> future_verifyClientVersion(const nebula::VerifyClientVersionReq& p_req) override;
  folly::SemiFuture<nebula::VerifyClientVersionResp> semifuture_verifyClientVersion(const nebula::VerifyClientVersionReq& p_req) override;
  void async_tm_verifyClientVersion(std::unique_ptr<apache::thrift::HandlerCallback<nebula::VerifyClientVersionResp>> callback, const nebula::VerifyClientVersionReq& p_req) override;
};

class GraphServiceSvNull : public GraphServiceSvIf {
 public:
  void authenticate(nebula::AuthResponse& /*_return*/, const ::std::string& /*username*/, const ::std::string& /*password*/) override;
  void signout(int64_t /*sessionId*/) override;
  void execute(nebula::ExecutionResponse& /*_return*/, int64_t /*sessionId*/, const ::std::string& /*stmt*/) override;
  void executeWithParameter(nebula::ExecutionResponse& /*_return*/, int64_t /*sessionId*/, const ::std::string& /*stmt*/, const std::unordered_map<::std::string, nebula::Value>& /*parameterMap*/) override;
  void executeJson(::std::string& /*_return*/, int64_t /*sessionId*/, const ::std::string& /*stmt*/) override;
  void executeJsonWithParameter(::std::string& /*_return*/, int64_t /*sessionId*/, const ::std::string& /*stmt*/, const std::unordered_map<::std::string, nebula::Value>& /*parameterMap*/) override;
  void verifyClientVersion(nebula::VerifyClientVersionResp& /*_return*/, const nebula::VerifyClientVersionReq& /*req*/) override;
};

class GraphServiceAsyncProcessor : public ::apache::thrift::GeneratedAsyncProcessor {
 public:
  const char* getServiceName() override;
  void getServiceMetadata(apache::thrift::metadata::ThriftServiceMetadataResponse& response) override;
  using BaseAsyncProcessor = void;
 protected:
  GraphServiceSvIf* iface_;
 public:
  void processSerializedRequest(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::protocol::PROTOCOL_TYPES protType, apache::thrift::Cpp2RequestContext* context, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) override;
 protected:
  std::shared_ptr<folly::RequestContext> getBaseContextForRequest() override;
 public:
  using ProcessFunc = GeneratedAsyncProcessor::ProcessFunc<GraphServiceAsyncProcessor>;
  using ProcessMap = GeneratedAsyncProcessor::ProcessMap<ProcessFunc>;
  static const GraphServiceAsyncProcessor::ProcessMap& getBinaryProtocolProcessMap();
  static const GraphServiceAsyncProcessor::ProcessMap& getCompactProtocolProcessMap();
 private:
  static const GraphServiceAsyncProcessor::ProcessMap binaryProcessMap_;
  static const GraphServiceAsyncProcessor::ProcessMap compactProcessMap_;
 private:
  template <typename ProtocolIn_, typename ProtocolOut_>
  void setUpAndProcess_authenticate(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void process_authenticate(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <class ProtocolIn_, class ProtocolOut_>
  static folly::IOBufQueue return_authenticate(int32_t protoSeqId, apache::thrift::ContextStack* ctx, nebula::AuthResponse const& _return);
  template <class ProtocolIn_, class ProtocolOut_>
  static void throw_wrapped_authenticate(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void setUpAndProcess_signout(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void process_signout(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void setUpAndProcess_execute(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void process_execute(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <class ProtocolIn_, class ProtocolOut_>
  static folly::IOBufQueue return_execute(int32_t protoSeqId, apache::thrift::ContextStack* ctx, nebula::ExecutionResponse const& _return);
  template <class ProtocolIn_, class ProtocolOut_>
  static void throw_wrapped_execute(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void setUpAndProcess_executeWithParameter(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void process_executeWithParameter(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <class ProtocolIn_, class ProtocolOut_>
  static folly::IOBufQueue return_executeWithParameter(int32_t protoSeqId, apache::thrift::ContextStack* ctx, nebula::ExecutionResponse const& _return);
  template <class ProtocolIn_, class ProtocolOut_>
  static void throw_wrapped_executeWithParameter(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void setUpAndProcess_executeJson(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void process_executeJson(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <class ProtocolIn_, class ProtocolOut_>
  static folly::IOBufQueue return_executeJson(int32_t protoSeqId, apache::thrift::ContextStack* ctx, ::std::string const& _return);
  template <class ProtocolIn_, class ProtocolOut_>
  static void throw_wrapped_executeJson(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void setUpAndProcess_executeJsonWithParameter(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void process_executeJsonWithParameter(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <class ProtocolIn_, class ProtocolOut_>
  static folly::IOBufQueue return_executeJsonWithParameter(int32_t protoSeqId, apache::thrift::ContextStack* ctx, ::std::string const& _return);
  template <class ProtocolIn_, class ProtocolOut_>
  static void throw_wrapped_executeJsonWithParameter(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void setUpAndProcess_verifyClientVersion(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void process_verifyClientVersion(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <class ProtocolIn_, class ProtocolOut_>
  static folly::IOBufQueue return_verifyClientVersion(int32_t protoSeqId, apache::thrift::ContextStack* ctx, nebula::VerifyClientVersionResp const& _return);
  template <class ProtocolIn_, class ProtocolOut_>
  static void throw_wrapped_verifyClientVersion(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx);
 public:
  GraphServiceAsyncProcessor(GraphServiceSvIf* iface) :
      iface_(iface) {}

  virtual ~GraphServiceAsyncProcessor() {}
};

}}} // nebula::graph::cpp2
