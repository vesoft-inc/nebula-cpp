/**
 * Autogenerated by Thrift for graph.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/client_h.h>

#include "graph_types.h"
#include "common_types.h"
#include "common/graph/PairOps-inl.h"
#include "common/graph/ProfilingStatsOps-inl.h"
#include "common/graph/PlanNodeBranchInfoOps-inl.h"
#include "common/graph/PlanNodeDescriptionOps-inl.h"
#include "common/graph/PlanDescriptionOps-inl.h"
#include "common/graph/ExecutionResponseOps-inl.h"
#include "common/graph/AuthResponseOps-inl.h"
#include "common/graph/VerifyClientVersionRespOps-inl.h"
#include "common/graph/VerifyClientVersionReqOps-inl.h"

namespace apache { namespace thrift {
  class Cpp2RequestContext;
  namespace detail { namespace ac { struct ClientRequestContext; }}
  namespace transport { class THeader; }
}}

namespace nebula { namespace graph { namespace cpp2 {

class GraphServiceAsyncClient : public apache::thrift::GeneratedAsyncClient {
 public:
  using apache::thrift::GeneratedAsyncClient::GeneratedAsyncClient;

  char const* getServiceName() const noexcept override {
    return "GraphService";
  }


  virtual void authenticate(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::string& p_username, const ::std::string& p_password);
  virtual void authenticate(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::string& p_username, const ::std::string& p_password);
 protected:
  void authenticateImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const ::std::string& p_username, const ::std::string& p_password);
 public:

  virtual void sync_authenticate(nebula::AuthResponse& _return, const ::std::string& p_username, const ::std::string& p_password);
  virtual void sync_authenticate(apache::thrift::RpcOptions& rpcOptions, nebula::AuthResponse& _return, const ::std::string& p_username, const ::std::string& p_password);

  virtual folly::Future<nebula::AuthResponse> future_authenticate(const ::std::string& p_username, const ::std::string& p_password);
  virtual folly::SemiFuture<nebula::AuthResponse> semifuture_authenticate(const ::std::string& p_username, const ::std::string& p_password);
  virtual folly::Future<nebula::AuthResponse> future_authenticate(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_username, const ::std::string& p_password);
  virtual folly::SemiFuture<nebula::AuthResponse> semifuture_authenticate(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_username, const ::std::string& p_password);
  virtual folly::Future<std::pair<nebula::AuthResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_authenticate(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_username, const ::std::string& p_password);
  virtual folly::SemiFuture<std::pair<nebula::AuthResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_authenticate(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_username, const ::std::string& p_password);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task<nebula::AuthResponse> co_authenticate(const ::std::string& p_username, const ::std::string& p_password) {
    return co_authenticate<false>(nullptr, p_username, p_password);
  }
  template <int = 0>
  folly::coro::Task<nebula::AuthResponse> co_authenticate(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_username, const ::std::string& p_password) {
    return co_authenticate<true>(&rpcOptions, p_username, p_password);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task<nebula::AuthResponse> co_authenticate(apache::thrift::RpcOptions* rpcOptions, const ::std::string& p_username, const ::std::string& p_password) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = authenticateCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      authenticateImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_username, p_password);
    } else {
      authenticateImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_username, p_password);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
    nebula::AuthResponse _return;
    if (auto ew = recv_wrapped_authenticate(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void authenticate(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::string& p_username, const ::std::string& p_password);


  static folly::exception_wrapper recv_wrapped_authenticate(nebula::AuthResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_authenticate(nebula::AuthResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_authenticate(nebula::AuthResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_authenticate(nebula::AuthResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void authenticateT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const ::std::string& p_username, const ::std::string& p_password);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> authenticateCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void signout(std::unique_ptr<apache::thrift::RequestCallback> callback, int64_t p_sessionId);
  virtual void signout(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int64_t p_sessionId);
 protected:
  void signoutImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, int64_t p_sessionId);
 public:

  virtual void sync_signout(int64_t p_sessionId);
  virtual void sync_signout(apache::thrift::RpcOptions& rpcOptions, int64_t p_sessionId);

  virtual folly::Future<folly::Unit> future_signout(int64_t p_sessionId);
  virtual folly::SemiFuture<folly::Unit> semifuture_signout(int64_t p_sessionId);
  virtual folly::Future<folly::Unit> future_signout(apache::thrift::RpcOptions& rpcOptions, int64_t p_sessionId);
  virtual folly::SemiFuture<folly::Unit> semifuture_signout(apache::thrift::RpcOptions& rpcOptions, int64_t p_sessionId);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task<void> co_signout(int64_t p_sessionId) {
    return co_signout<false>(nullptr, p_sessionId);
  }
  template <int = 0>
  folly::coro::Task<void> co_signout(apache::thrift::RpcOptions& rpcOptions, int64_t p_sessionId) {
    return co_signout<true>(&rpcOptions, p_sessionId);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task<void> co_signout(apache::thrift::RpcOptions* rpcOptions, int64_t p_sessionId) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<true> callback(&returnState);
    auto ctx = signoutCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<true>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      signoutImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_sessionId);
    } else {
      signoutImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_sessionId);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void signout(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, int64_t p_sessionId);


 private:
  template <typename Protocol_>
  void signoutT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, int64_t p_sessionId);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> signoutCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void execute(std::unique_ptr<apache::thrift::RequestCallback> callback, int64_t p_sessionId, const ::std::string& p_stmt);
  virtual void execute(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int64_t p_sessionId, const ::std::string& p_stmt);
 protected:
  void executeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, int64_t p_sessionId, const ::std::string& p_stmt);
 public:

  virtual void sync_execute(nebula::ExecutionResponse& _return, int64_t p_sessionId, const ::std::string& p_stmt);
  virtual void sync_execute(apache::thrift::RpcOptions& rpcOptions, nebula::ExecutionResponse& _return, int64_t p_sessionId, const ::std::string& p_stmt);

  virtual folly::Future<nebula::ExecutionResponse> future_execute(int64_t p_sessionId, const ::std::string& p_stmt);
  virtual folly::SemiFuture<nebula::ExecutionResponse> semifuture_execute(int64_t p_sessionId, const ::std::string& p_stmt);
  virtual folly::Future<nebula::ExecutionResponse> future_execute(apache::thrift::RpcOptions& rpcOptions, int64_t p_sessionId, const ::std::string& p_stmt);
  virtual folly::SemiFuture<nebula::ExecutionResponse> semifuture_execute(apache::thrift::RpcOptions& rpcOptions, int64_t p_sessionId, const ::std::string& p_stmt);
  virtual folly::Future<std::pair<nebula::ExecutionResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_execute(apache::thrift::RpcOptions& rpcOptions, int64_t p_sessionId, const ::std::string& p_stmt);
  virtual folly::SemiFuture<std::pair<nebula::ExecutionResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_execute(apache::thrift::RpcOptions& rpcOptions, int64_t p_sessionId, const ::std::string& p_stmt);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task<nebula::ExecutionResponse> co_execute(int64_t p_sessionId, const ::std::string& p_stmt) {
    return co_execute<false>(nullptr, p_sessionId, p_stmt);
  }
  template <int = 0>
  folly::coro::Task<nebula::ExecutionResponse> co_execute(apache::thrift::RpcOptions& rpcOptions, int64_t p_sessionId, const ::std::string& p_stmt) {
    return co_execute<true>(&rpcOptions, p_sessionId, p_stmt);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task<nebula::ExecutionResponse> co_execute(apache::thrift::RpcOptions* rpcOptions, int64_t p_sessionId, const ::std::string& p_stmt) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = executeCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      executeImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_sessionId, p_stmt);
    } else {
      executeImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_sessionId, p_stmt);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
    nebula::ExecutionResponse _return;
    if (auto ew = recv_wrapped_execute(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void execute(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, int64_t p_sessionId, const ::std::string& p_stmt);


  static folly::exception_wrapper recv_wrapped_execute(nebula::ExecutionResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_execute(nebula::ExecutionResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_execute(nebula::ExecutionResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_execute(nebula::ExecutionResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void executeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, int64_t p_sessionId, const ::std::string& p_stmt);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> executeCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void executeJson(std::unique_ptr<apache::thrift::RequestCallback> callback, int64_t p_sessionId, const ::std::string& p_stmt);
  virtual void executeJson(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int64_t p_sessionId, const ::std::string& p_stmt);
 protected:
  void executeJsonImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, int64_t p_sessionId, const ::std::string& p_stmt);
 public:

  virtual void sync_executeJson(::std::string& _return, int64_t p_sessionId, const ::std::string& p_stmt);
  virtual void sync_executeJson(apache::thrift::RpcOptions& rpcOptions, ::std::string& _return, int64_t p_sessionId, const ::std::string& p_stmt);

  virtual folly::Future<::std::string> future_executeJson(int64_t p_sessionId, const ::std::string& p_stmt);
  virtual folly::SemiFuture<::std::string> semifuture_executeJson(int64_t p_sessionId, const ::std::string& p_stmt);
  virtual folly::Future<::std::string> future_executeJson(apache::thrift::RpcOptions& rpcOptions, int64_t p_sessionId, const ::std::string& p_stmt);
  virtual folly::SemiFuture<::std::string> semifuture_executeJson(apache::thrift::RpcOptions& rpcOptions, int64_t p_sessionId, const ::std::string& p_stmt);
  virtual folly::Future<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_executeJson(apache::thrift::RpcOptions& rpcOptions, int64_t p_sessionId, const ::std::string& p_stmt);
  virtual folly::SemiFuture<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_executeJson(apache::thrift::RpcOptions& rpcOptions, int64_t p_sessionId, const ::std::string& p_stmt);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task<::std::string> co_executeJson(int64_t p_sessionId, const ::std::string& p_stmt) {
    return co_executeJson<false>(nullptr, p_sessionId, p_stmt);
  }
  template <int = 0>
  folly::coro::Task<::std::string> co_executeJson(apache::thrift::RpcOptions& rpcOptions, int64_t p_sessionId, const ::std::string& p_stmt) {
    return co_executeJson<true>(&rpcOptions, p_sessionId, p_stmt);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task<::std::string> co_executeJson(apache::thrift::RpcOptions* rpcOptions, int64_t p_sessionId, const ::std::string& p_stmt) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = executeJsonCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      executeJsonImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_sessionId, p_stmt);
    } else {
      executeJsonImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_sessionId, p_stmt);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
    ::std::string _return;
    if (auto ew = recv_wrapped_executeJson(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void executeJson(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, int64_t p_sessionId, const ::std::string& p_stmt);


  static folly::exception_wrapper recv_wrapped_executeJson(::std::string& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_executeJson(::std::string& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_executeJson(::std::string& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_executeJson(::std::string& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void executeJsonT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, int64_t p_sessionId, const ::std::string& p_stmt);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> executeJsonCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
  virtual void verifyClientVersion(std::unique_ptr<apache::thrift::RequestCallback> callback, const nebula::VerifyClientVersionReq& p_req);
  virtual void verifyClientVersion(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const nebula::VerifyClientVersionReq& p_req);
 protected:
  void verifyClientVersionImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const nebula::VerifyClientVersionReq& p_req);
 public:

  virtual void sync_verifyClientVersion(nebula::VerifyClientVersionResp& _return, const nebula::VerifyClientVersionReq& p_req);
  virtual void sync_verifyClientVersion(apache::thrift::RpcOptions& rpcOptions, nebula::VerifyClientVersionResp& _return, const nebula::VerifyClientVersionReq& p_req);

  virtual folly::Future<nebula::VerifyClientVersionResp> future_verifyClientVersion(const nebula::VerifyClientVersionReq& p_req);
  virtual folly::SemiFuture<nebula::VerifyClientVersionResp> semifuture_verifyClientVersion(const nebula::VerifyClientVersionReq& p_req);
  virtual folly::Future<nebula::VerifyClientVersionResp> future_verifyClientVersion(apache::thrift::RpcOptions& rpcOptions, const nebula::VerifyClientVersionReq& p_req);
  virtual folly::SemiFuture<nebula::VerifyClientVersionResp> semifuture_verifyClientVersion(apache::thrift::RpcOptions& rpcOptions, const nebula::VerifyClientVersionReq& p_req);
  virtual folly::Future<std::pair<nebula::VerifyClientVersionResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_verifyClientVersion(apache::thrift::RpcOptions& rpcOptions, const nebula::VerifyClientVersionReq& p_req);
  virtual folly::SemiFuture<std::pair<nebula::VerifyClientVersionResp, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_verifyClientVersion(apache::thrift::RpcOptions& rpcOptions, const nebula::VerifyClientVersionReq& p_req);

#if FOLLY_HAS_COROUTINES
  template <int = 0>
  folly::coro::Task<nebula::VerifyClientVersionResp> co_verifyClientVersion(const nebula::VerifyClientVersionReq& p_req) {
    return co_verifyClientVersion<false>(nullptr, p_req);
  }
  template <int = 0>
  folly::coro::Task<nebula::VerifyClientVersionResp> co_verifyClientVersion(apache::thrift::RpcOptions& rpcOptions, const nebula::VerifyClientVersionReq& p_req) {
    return co_verifyClientVersion<true>(&rpcOptions, p_req);
  }
 private:
  template <bool hasRpcOptions>
  folly::coro::Task<nebula::VerifyClientVersionResp> co_verifyClientVersion(apache::thrift::RpcOptions* rpcOptions, const nebula::VerifyClientVersionReq& p_req) {
    const folly::CancellationToken& cancelToken =
        co_await folly::coro::co_current_cancellation_token;
    const bool cancellable = cancelToken.canBeCancelled();
    apache::thrift::ClientReceiveState returnState;
    apache::thrift::ClientSyncCallback<false> callback(&returnState);
    auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
    auto ctx = verifyClientVersionCtx(rpcOptions);
    using CancellableCallback = apache::thrift::CancellableRequestClientCallback<false>;
    auto cancellableCallback = cancellable ? CancellableCallback::create(&callback, channel_) : nullptr;
    static const apache::thrift::RpcOptions defaultRpcOptions;
    auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(cancellableCallback ? (apache::thrift::RequestClientCallback*)cancellableCallback.get() : &callback);
    if constexpr (hasRpcOptions) {
      verifyClientVersionImpl(*rpcOptions, ctx, std::move(wrappedCallback), p_req);
    } else {
      verifyClientVersionImpl(defaultRpcOptions, ctx, std::move(wrappedCallback), p_req);
    }
    if (cancellable) {
      folly::CancellationCallback cb(cancelToken, [&] { CancellableCallback::cancel(std::move(cancellableCallback)); });
      co_await callback.co_waitUntilDone();
    } else {
      co_await callback.co_waitUntilDone();
    }
    if (returnState.isException()) {
      co_yield folly::coro::co_error(std::move(returnState.exception()));
    }
    returnState.resetProtocolId(protocolId);
    returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
    SCOPE_EXIT {
      if (hasRpcOptions && returnState.header() && !returnState.header()->getHeaders().empty()) {
        rpcOptions->setReadHeaders(returnState.header()->releaseHeaders());
      }
    };
    nebula::VerifyClientVersionResp _return;
    if (auto ew = recv_wrapped_verifyClientVersion(_return, returnState)) {
      co_yield folly::coro::co_error(std::move(ew));
    }
    co_return _return;
  }
 public:
#endif // FOLLY_HAS_COROUTINES

  virtual void verifyClientVersion(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const nebula::VerifyClientVersionReq& p_req);


  static folly::exception_wrapper recv_wrapped_verifyClientVersion(nebula::VerifyClientVersionResp& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_verifyClientVersion(nebula::VerifyClientVersionResp& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_verifyClientVersion(nebula::VerifyClientVersionResp& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_verifyClientVersion(nebula::VerifyClientVersionResp& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void verifyClientVersionT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const nebula::VerifyClientVersionReq& p_req);
  std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> verifyClientVersionCtx(apache::thrift::RpcOptions* rpcOptions);
 public:
};

}}} // nebula::graph::cpp2
