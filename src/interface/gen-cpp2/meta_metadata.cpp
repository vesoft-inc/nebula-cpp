/**
 * Autogenerated by Thrift for meta.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include <thrift/lib/cpp2/gen/module_metadata_cpp.h>
#include "meta_metadata.h"

namespace apache {
namespace thrift {
namespace detail {
namespace md {
using ThriftMetadata = ::apache::thrift::metadata::ThriftMetadata;
using ThriftPrimitiveType = ::apache::thrift::metadata::ThriftPrimitiveType;
using ThriftType = ::apache::thrift::metadata::ThriftType;
using ThriftService = ::apache::thrift::metadata::ThriftService;
using ThriftServiceContext = ::apache::thrift::metadata::ThriftServiceContext;
using ThriftFunctionGenerator = void (*)(ThriftMetadata&, ThriftService&);

void EnumMetadata<::nebula::meta::cpp2::AlterSchemaOp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("meta.AlterSchemaOp", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "meta.AlterSchemaOp";
  using EnumTraits = TEnumTraits<::nebula::meta::cpp2::AlterSchemaOp>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::meta::cpp2::RoleType>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("meta.RoleType", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "meta.RoleType";
  using EnumTraits = TEnumTraits<::nebula::meta::cpp2::RoleType>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::meta::cpp2::GeoShape>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("meta.GeoShape", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "meta.GeoShape";
  using EnumTraits = TEnumTraits<::nebula::meta::cpp2::GeoShape>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::meta::cpp2::IsolationLevel>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("meta.IsolationLevel", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "meta.IsolationLevel";
  using EnumTraits = TEnumTraits<::nebula::meta::cpp2::IsolationLevel>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::meta::cpp2::HostStatus>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("meta.HostStatus", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "meta.HostStatus";
  using EnumTraits = TEnumTraits<::nebula::meta::cpp2::HostStatus>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::meta::cpp2::SnapshotStatus>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("meta.SnapshotStatus", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "meta.SnapshotStatus";
  using EnumTraits = TEnumTraits<::nebula::meta::cpp2::SnapshotStatus>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::meta::cpp2::AdminJobOp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("meta.AdminJobOp", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "meta.AdminJobOp";
  using EnumTraits = TEnumTraits<::nebula::meta::cpp2::AdminJobOp>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::meta::cpp2::AdminCmd>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("meta.AdminCmd", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "meta.AdminCmd";
  using EnumTraits = TEnumTraits<::nebula::meta::cpp2::AdminCmd>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::meta::cpp2::JobStatus>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("meta.JobStatus", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "meta.JobStatus";
  using EnumTraits = TEnumTraits<::nebula::meta::cpp2::JobStatus>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::meta::cpp2::ListHostType>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("meta.ListHostType", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "meta.ListHostType";
  using EnumTraits = TEnumTraits<::nebula::meta::cpp2::ListHostType>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::meta::cpp2::HostRole>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("meta.HostRole", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "meta.HostRole";
  using EnumTraits = TEnumTraits<::nebula::meta::cpp2::HostRole>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::meta::cpp2::TaskResult>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("meta.TaskResult", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "meta.TaskResult";
  using EnumTraits = TEnumTraits<::nebula::meta::cpp2::TaskResult>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::meta::cpp2::ConfigModule>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("meta.ConfigModule", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "meta.ConfigModule";
  using EnumTraits = TEnumTraits<::nebula::meta::cpp2::ConfigModule>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::meta::cpp2::ConfigMode>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("meta.ConfigMode", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "meta.ConfigMode";
  using EnumTraits = TEnumTraits<::nebula::meta::cpp2::ConfigMode>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::meta::cpp2::ListenerType>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("meta.ListenerType", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "meta.ListenerType";
  using EnumTraits = TEnumTraits<::nebula::meta::cpp2::ListenerType>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::meta::cpp2::FTServiceType>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("meta.FTServiceType", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "meta.FTServiceType";
  using EnumTraits = TEnumTraits<::nebula::meta::cpp2::FTServiceType>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::meta::cpp2::QueryStatus>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("meta.QueryStatus", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "meta.QueryStatus";
  using EnumTraits = TEnumTraits<::nebula::meta::cpp2::QueryStatus>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}

const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ID>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ID", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ID = res.first->second;
  meta_ID.name_ref() = "meta.ID";
  meta_ID.is_union_ref() = true;
  static const EncodedThriftField
  meta_ID_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "tag_id", false, std::make_unique<Typedef>("common.TagID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "edge_type", false, std::make_unique<Typedef>("common.EdgeType", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "index_id", false, std::make_unique<Typedef>("common.IndexID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "cluster_id", false, std::make_unique<Typedef>("meta.ClusterID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ID_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ID.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ColumnTypeDef>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ColumnTypeDef", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ColumnTypeDef = res.first->second;
  meta_ColumnTypeDef.name_ref() = "meta.ColumnTypeDef";
  meta_ColumnTypeDef.is_union_ref() = false;
  static const EncodedThriftField
  meta_ColumnTypeDef_fields[] = {
    std::make_tuple(1, "type", false, std::make_unique<Enum< ::nebula::cpp2::PropertyType>>("common.PropertyType"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "type_length", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I16_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "geo_shape", true, std::make_unique<Enum< ::nebula::meta::cpp2::GeoShape>>("meta.GeoShape"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ColumnTypeDef_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ColumnTypeDef.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ColumnDef>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ColumnDef", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ColumnDef = res.first->second;
  meta_ColumnDef.name_ref() = "meta.ColumnDef";
  meta_ColumnDef.is_union_ref() = false;
  static const EncodedThriftField
  meta_ColumnDef_fields[] = {
    std::make_tuple(1, "name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "type", false, std::make_unique<Struct< ::nebula::meta::cpp2::ColumnTypeDef>>("meta.ColumnTypeDef"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "default_value", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "nullable", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "comment", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ColumnDef_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ColumnDef.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::SchemaProp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.SchemaProp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_SchemaProp = res.first->second;
  meta_SchemaProp.name_ref() = "meta.SchemaProp";
  meta_SchemaProp.is_union_ref() = false;
  static const EncodedThriftField
  meta_SchemaProp_fields[] = {
    std::make_tuple(1, "ttl_duration", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "ttl_col", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "comment", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_SchemaProp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_SchemaProp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::Schema>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.Schema", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_Schema = res.first->second;
  meta_Schema.name_ref() = "meta.Schema";
  meta_Schema.is_union_ref() = false;
  static const EncodedThriftField
  meta_Schema_fields[] = {
    std::make_tuple(1, "columns", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::ColumnDef>>("meta.ColumnDef")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "schema_prop", false, std::make_unique<Struct< ::nebula::meta::cpp2::SchemaProp>>("meta.SchemaProp"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_Schema_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_Schema.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::IdName>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.IdName", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_IdName = res.first->second;
  meta_IdName.name_ref() = "meta.IdName";
  meta_IdName.is_union_ref() = false;
  static const EncodedThriftField
  meta_IdName_fields[] = {
    std::make_tuple(1, "id", false, std::make_unique<Union< ::nebula::meta::cpp2::ID>>("meta.ID"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_IdName_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_IdName.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::SpaceDesc>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.SpaceDesc", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_SpaceDesc = res.first->second;
  meta_SpaceDesc.name_ref() = "meta.SpaceDesc";
  meta_SpaceDesc.is_union_ref() = false;
  static const EncodedThriftField
  meta_SpaceDesc_fields[] = {
    std::make_tuple(1, "space_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "partition_num", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "replica_factor", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "charset_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "collate_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "vid_type", false, std::make_unique<Struct< ::nebula::meta::cpp2::ColumnTypeDef>>("meta.ColumnTypeDef"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(7, "zone_names", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(8, "isolation_level", true, std::make_unique<Enum< ::nebula::meta::cpp2::IsolationLevel>>("meta.IsolationLevel"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(9, "comment", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_SpaceDesc_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_SpaceDesc.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::SpaceItem>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.SpaceItem", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_SpaceItem = res.first->second;
  meta_SpaceItem.name_ref() = "meta.SpaceItem";
  meta_SpaceItem.is_union_ref() = false;
  static const EncodedThriftField
  meta_SpaceItem_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "properties", false, std::make_unique<Struct< ::nebula::meta::cpp2::SpaceDesc>>("meta.SpaceDesc"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_SpaceItem_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_SpaceItem.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::TagItem>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.TagItem", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_TagItem = res.first->second;
  meta_TagItem.name_ref() = "meta.TagItem";
  meta_TagItem.is_union_ref() = false;
  static const EncodedThriftField
  meta_TagItem_fields[] = {
    std::make_tuple(1, "tag_id", false, std::make_unique<Typedef>("common.TagID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "tag_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "version", false, std::make_unique<Typedef>("meta.SchemaVer", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "schema", false, std::make_unique<Struct< ::nebula::meta::cpp2::Schema>>("meta.Schema"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_TagItem_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_TagItem.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::AlterSchemaItem>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.AlterSchemaItem", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_AlterSchemaItem = res.first->second;
  meta_AlterSchemaItem.name_ref() = "meta.AlterSchemaItem";
  meta_AlterSchemaItem.is_union_ref() = false;
  static const EncodedThriftField
  meta_AlterSchemaItem_fields[] = {
    std::make_tuple(1, "op", false, std::make_unique<Enum< ::nebula::meta::cpp2::AlterSchemaOp>>("meta.AlterSchemaOp"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "schema", false, std::make_unique<Struct< ::nebula::meta::cpp2::Schema>>("meta.Schema"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_AlterSchemaItem_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_AlterSchemaItem.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::EdgeItem>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.EdgeItem", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_EdgeItem = res.first->second;
  meta_EdgeItem.name_ref() = "meta.EdgeItem";
  meta_EdgeItem.is_union_ref() = false;
  static const EncodedThriftField
  meta_EdgeItem_fields[] = {
    std::make_tuple(1, "edge_type", false, std::make_unique<Typedef>("common.EdgeType", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "edge_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "version", false, std::make_unique<Typedef>("meta.SchemaVer", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "schema", false, std::make_unique<Struct< ::nebula::meta::cpp2::Schema>>("meta.Schema"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_EdgeItem_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_EdgeItem.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::IndexItem>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.IndexItem", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_IndexItem = res.first->second;
  meta_IndexItem.name_ref() = "meta.IndexItem";
  meta_IndexItem.is_union_ref() = false;
  static const EncodedThriftField
  meta_IndexItem_fields[] = {
    std::make_tuple(1, "index_id", false, std::make_unique<Typedef>("common.IndexID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "index_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "schema_id", false, std::make_unique<Union< ::nebula::cpp2::SchemaID>>("common.SchemaID"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "schema_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "fields", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::ColumnDef>>("meta.ColumnDef")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "comment", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_IndexItem_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_IndexItem.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::HostItem>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.HostItem", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_HostItem = res.first->second;
  meta_HostItem.name_ref() = "meta.HostItem";
  meta_HostItem.is_union_ref() = false;
  static const EncodedThriftField
  meta_HostItem_fields[] = {
    std::make_tuple(1, "hostAddr", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "status", false, std::make_unique<Enum< ::nebula::meta::cpp2::HostStatus>>("meta.HostStatus"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "leader_parts", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::make_unique<List>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "all_parts", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::make_unique<List>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "role", false, std::make_unique<Typedef>("meta.HostRole", std::make_unique<Enum< ::nebula::meta::cpp2::HostRole>>("meta.HostRole")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "git_info_sha", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(7, "zone_name", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(8, "version", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_HostItem_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_HostItem.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::UserItem>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.UserItem", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_UserItem = res.first->second;
  meta_UserItem.name_ref() = "meta.UserItem";
  meta_UserItem.is_union_ref() = false;
  static const EncodedThriftField
  meta_UserItem_fields[] = {
    std::make_tuple(1, "account", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "is_lock", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "max_queries_per_hour", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "max_updates_per_hour", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "max_connections_per_hour", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "max_user_connections", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_UserItem_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_UserItem.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::RoleItem>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.RoleItem", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_RoleItem = res.first->second;
  meta_RoleItem.name_ref() = "meta.RoleItem";
  meta_RoleItem.is_union_ref() = false;
  static const EncodedThriftField
  meta_RoleItem_fields[] = {
    std::make_tuple(1, "user_id", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "role_type", false, std::make_unique<Enum< ::nebula::meta::cpp2::RoleType>>("meta.RoleType"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_RoleItem_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_RoleItem.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ExecResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ExecResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ExecResp = res.first->second;
  meta_ExecResp.name_ref() = "meta.ExecResp";
  meta_ExecResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ExecResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "id", false, std::make_unique<Union< ::nebula::meta::cpp2::ID>>("meta.ID"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ExecResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ExecResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::AdminJobReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.AdminJobReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_AdminJobReq = res.first->second;
  meta_AdminJobReq.name_ref() = "meta.AdminJobReq";
  meta_AdminJobReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_AdminJobReq_fields[] = {
    std::make_tuple(1, "op", false, std::make_unique<Enum< ::nebula::meta::cpp2::AdminJobOp>>("meta.AdminJobOp"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "cmd", false, std::make_unique<Typedef>("meta.AdminCmd", std::make_unique<Enum< ::nebula::meta::cpp2::AdminCmd>>("meta.AdminCmd")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "paras", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_AdminJobReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_AdminJobReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::JobDesc>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.JobDesc", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_JobDesc = res.first->second;
  meta_JobDesc.name_ref() = "meta.JobDesc";
  meta_JobDesc.is_union_ref() = false;
  static const EncodedThriftField
  meta_JobDesc_fields[] = {
    std::make_tuple(1, "id", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "cmd", false, std::make_unique<Enum< ::nebula::meta::cpp2::AdminCmd>>("meta.AdminCmd"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "paras", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "status", false, std::make_unique<Enum< ::nebula::meta::cpp2::JobStatus>>("meta.JobStatus"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "start_time", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "stop_time", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_JobDesc_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_JobDesc.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::TaskDesc>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.TaskDesc", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_TaskDesc = res.first->second;
  meta_TaskDesc.name_ref() = "meta.TaskDesc";
  meta_TaskDesc.is_union_ref() = false;
  static const EncodedThriftField
  meta_TaskDesc_fields[] = {
    std::make_tuple(1, "task_id", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "host", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "status", false, std::make_unique<Enum< ::nebula::meta::cpp2::JobStatus>>("meta.JobStatus"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "start_time", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "stop_time", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "job_id", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_TaskDesc_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_TaskDesc.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::AdminJobResult>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.AdminJobResult", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_AdminJobResult = res.first->second;
  meta_AdminJobResult.name_ref() = "meta.AdminJobResult";
  meta_AdminJobResult.is_union_ref() = false;
  static const EncodedThriftField
  meta_AdminJobResult_fields[] = {
    std::make_tuple(1, "job_id", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "job_desc", true, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::JobDesc>>("meta.JobDesc")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "task_desc", true, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::TaskDesc>>("meta.TaskDesc")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "recovered_job_num", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_AdminJobResult_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_AdminJobResult.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::AdminJobResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.AdminJobResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_AdminJobResp = res.first->second;
  meta_AdminJobResp.name_ref() = "meta.AdminJobResp";
  meta_AdminJobResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_AdminJobResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "result", false, std::make_unique<Struct< ::nebula::meta::cpp2::AdminJobResult>>("meta.AdminJobResult"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_AdminJobResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_AdminJobResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::Correlativity>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.Correlativity", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_Correlativity = res.first->second;
  meta_Correlativity.name_ref() = "meta.Correlativity";
  meta_Correlativity.is_union_ref() = false;
  static const EncodedThriftField
  meta_Correlativity_fields[] = {
    std::make_tuple(1, "part_id", false, std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "proportion", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_DOUBLE_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_Correlativity_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_Correlativity.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::StatsItem>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.StatsItem", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_StatsItem = res.first->second;
  meta_StatsItem.name_ref() = "meta.StatsItem";
  meta_StatsItem.is_union_ref() = false;
  static const EncodedThriftField
  meta_StatsItem_fields[] = {
    std::make_tuple(1, "tag_vertices", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "edges", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "space_vertices", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "space_edges", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "positive_part_correlativity", false, std::make_unique<Map>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::Correlativity>>("meta.Correlativity"))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "negative_part_correlativity", false, std::make_unique<Map>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::Correlativity>>("meta.Correlativity"))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(7, "status", false, std::make_unique<Enum< ::nebula::meta::cpp2::JobStatus>>("meta.JobStatus"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_StatsItem_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_StatsItem.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::CreateSpaceReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.CreateSpaceReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_CreateSpaceReq = res.first->second;
  meta_CreateSpaceReq.name_ref() = "meta.CreateSpaceReq";
  meta_CreateSpaceReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_CreateSpaceReq_fields[] = {
    std::make_tuple(1, "properties", false, std::make_unique<Struct< ::nebula::meta::cpp2::SpaceDesc>>("meta.SpaceDesc"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "if_not_exists", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_CreateSpaceReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_CreateSpaceReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::CreateSpaceAsReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.CreateSpaceAsReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_CreateSpaceAsReq = res.first->second;
  meta_CreateSpaceAsReq.name_ref() = "meta.CreateSpaceAsReq";
  meta_CreateSpaceAsReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_CreateSpaceAsReq_fields[] = {
    std::make_tuple(1, "old_space_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "new_space_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_CreateSpaceAsReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_CreateSpaceAsReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::DropSpaceReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.DropSpaceReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_DropSpaceReq = res.first->second;
  meta_DropSpaceReq.name_ref() = "meta.DropSpaceReq";
  meta_DropSpaceReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_DropSpaceReq_fields[] = {
    std::make_tuple(1, "space_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "if_exists", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_DropSpaceReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_DropSpaceReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListSpacesReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListSpacesReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListSpacesReq = res.first->second;
  meta_ListSpacesReq.name_ref() = "meta.ListSpacesReq";
  meta_ListSpacesReq.is_union_ref() = false;
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListSpacesResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListSpacesResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListSpacesResp = res.first->second;
  meta_ListSpacesResp.name_ref() = "meta.ListSpacesResp";
  meta_ListSpacesResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListSpacesResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "spaces", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::IdName>>("meta.IdName")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListSpacesResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListSpacesResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetSpaceReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetSpaceReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetSpaceReq = res.first->second;
  meta_GetSpaceReq.name_ref() = "meta.GetSpaceReq";
  meta_GetSpaceReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetSpaceReq_fields[] = {
    std::make_tuple(1, "space_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetSpaceReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetSpaceReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetSpaceResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetSpaceResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetSpaceResp = res.first->second;
  meta_GetSpaceResp.name_ref() = "meta.GetSpaceResp";
  meta_GetSpaceResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetSpaceResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "item", false, std::make_unique<Struct< ::nebula::meta::cpp2::SpaceItem>>("meta.SpaceItem"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetSpaceResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetSpaceResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::CreateTagReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.CreateTagReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_CreateTagReq = res.first->second;
  meta_CreateTagReq.name_ref() = "meta.CreateTagReq";
  meta_CreateTagReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_CreateTagReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "tag_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "schema", false, std::make_unique<Struct< ::nebula::meta::cpp2::Schema>>("meta.Schema"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "if_not_exists", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_CreateTagReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_CreateTagReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::AlterTagReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.AlterTagReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_AlterTagReq = res.first->second;
  meta_AlterTagReq.name_ref() = "meta.AlterTagReq";
  meta_AlterTagReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_AlterTagReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "tag_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "tag_items", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::AlterSchemaItem>>("meta.AlterSchemaItem")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "schema_prop", false, std::make_unique<Struct< ::nebula::meta::cpp2::SchemaProp>>("meta.SchemaProp"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_AlterTagReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_AlterTagReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::DropTagReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.DropTagReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_DropTagReq = res.first->second;
  meta_DropTagReq.name_ref() = "meta.DropTagReq";
  meta_DropTagReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_DropTagReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "tag_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "if_exists", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_DropTagReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_DropTagReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListTagsReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListTagsReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListTagsReq = res.first->second;
  meta_ListTagsReq.name_ref() = "meta.ListTagsReq";
  meta_ListTagsReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListTagsReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListTagsReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListTagsReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListTagsResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListTagsResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListTagsResp = res.first->second;
  meta_ListTagsResp.name_ref() = "meta.ListTagsResp";
  meta_ListTagsResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListTagsResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "tags", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::TagItem>>("meta.TagItem")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListTagsResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListTagsResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetTagReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetTagReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetTagReq = res.first->second;
  meta_GetTagReq.name_ref() = "meta.GetTagReq";
  meta_GetTagReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetTagReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "tag_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "version", false, std::make_unique<Typedef>("meta.SchemaVer", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetTagReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetTagReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetTagResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetTagResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetTagResp = res.first->second;
  meta_GetTagResp.name_ref() = "meta.GetTagResp";
  meta_GetTagResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetTagResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "schema", false, std::make_unique<Struct< ::nebula::meta::cpp2::Schema>>("meta.Schema"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetTagResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetTagResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::CreateEdgeReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.CreateEdgeReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_CreateEdgeReq = res.first->second;
  meta_CreateEdgeReq.name_ref() = "meta.CreateEdgeReq";
  meta_CreateEdgeReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_CreateEdgeReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "edge_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "schema", false, std::make_unique<Struct< ::nebula::meta::cpp2::Schema>>("meta.Schema"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "if_not_exists", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_CreateEdgeReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_CreateEdgeReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::AlterEdgeReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.AlterEdgeReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_AlterEdgeReq = res.first->second;
  meta_AlterEdgeReq.name_ref() = "meta.AlterEdgeReq";
  meta_AlterEdgeReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_AlterEdgeReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "edge_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "edge_items", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::AlterSchemaItem>>("meta.AlterSchemaItem")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "schema_prop", false, std::make_unique<Struct< ::nebula::meta::cpp2::SchemaProp>>("meta.SchemaProp"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_AlterEdgeReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_AlterEdgeReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetEdgeReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetEdgeReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetEdgeReq = res.first->second;
  meta_GetEdgeReq.name_ref() = "meta.GetEdgeReq";
  meta_GetEdgeReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetEdgeReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "edge_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "version", false, std::make_unique<Typedef>("meta.SchemaVer", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetEdgeReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetEdgeReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetEdgeResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetEdgeResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetEdgeResp = res.first->second;
  meta_GetEdgeResp.name_ref() = "meta.GetEdgeResp";
  meta_GetEdgeResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetEdgeResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "schema", false, std::make_unique<Struct< ::nebula::meta::cpp2::Schema>>("meta.Schema"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetEdgeResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetEdgeResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::DropEdgeReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.DropEdgeReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_DropEdgeReq = res.first->second;
  meta_DropEdgeReq.name_ref() = "meta.DropEdgeReq";
  meta_DropEdgeReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_DropEdgeReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "edge_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "if_exists", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_DropEdgeReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_DropEdgeReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListEdgesReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListEdgesReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListEdgesReq = res.first->second;
  meta_ListEdgesReq.name_ref() = "meta.ListEdgesReq";
  meta_ListEdgesReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListEdgesReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListEdgesReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListEdgesReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListEdgesResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListEdgesResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListEdgesResp = res.first->second;
  meta_ListEdgesResp.name_ref() = "meta.ListEdgesResp";
  meta_ListEdgesResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListEdgesResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "edges", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::EdgeItem>>("meta.EdgeItem")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListEdgesResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListEdgesResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::AddHostsReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.AddHostsReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_AddHostsReq = res.first->second;
  meta_AddHostsReq.name_ref() = "meta.AddHostsReq";
  meta_AddHostsReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_AddHostsReq_fields[] = {
    std::make_tuple(1, "hosts", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_AddHostsReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_AddHostsReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::DropHostsReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.DropHostsReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_DropHostsReq = res.first->second;
  meta_DropHostsReq.name_ref() = "meta.DropHostsReq";
  meta_DropHostsReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_DropHostsReq_fields[] = {
    std::make_tuple(1, "hosts", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_DropHostsReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_DropHostsReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListHostsReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListHostsReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListHostsReq = res.first->second;
  meta_ListHostsReq.name_ref() = "meta.ListHostsReq";
  meta_ListHostsReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListHostsReq_fields[] = {
    std::make_tuple(1, "type", false, std::make_unique<Enum< ::nebula::meta::cpp2::ListHostType>>("meta.ListHostType"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListHostsReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListHostsReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListHostsResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListHostsResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListHostsResp = res.first->second;
  meta_ListHostsResp.name_ref() = "meta.ListHostsResp";
  meta_ListHostsResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListHostsResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "hosts", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::HostItem>>("meta.HostItem")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListHostsResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListHostsResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::PartItem>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.PartItem", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_PartItem = res.first->second;
  meta_PartItem.name_ref() = "meta.PartItem";
  meta_PartItem.is_union_ref() = false;
  static const EncodedThriftField
  meta_PartItem_fields[] = {
    std::make_tuple(1, "part_id", false, std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", true, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "peers", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "losts", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_PartItem_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_PartItem.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListPartsReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListPartsReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListPartsReq = res.first->second;
  meta_ListPartsReq.name_ref() = "meta.ListPartsReq";
  meta_ListPartsReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListPartsReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "part_ids", false, std::make_unique<List>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE))), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListPartsReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListPartsReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListPartsResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListPartsResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListPartsResp = res.first->second;
  meta_ListPartsResp.name_ref() = "meta.ListPartsResp";
  meta_ListPartsResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListPartsResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "parts", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::PartItem>>("meta.PartItem")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListPartsResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListPartsResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetPartsAllocReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetPartsAllocReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetPartsAllocReq = res.first->second;
  meta_GetPartsAllocReq.name_ref() = "meta.GetPartsAllocReq";
  meta_GetPartsAllocReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetPartsAllocReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetPartsAllocReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetPartsAllocReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetPartsAllocResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetPartsAllocResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetPartsAllocResp = res.first->second;
  meta_GetPartsAllocResp.name_ref() = "meta.GetPartsAllocResp";
  meta_GetPartsAllocResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetPartsAllocResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "parts", false, std::make_unique<Map>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "terms", true, std::make_unique<Map>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetPartsAllocResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetPartsAllocResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::MultiPutReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.MultiPutReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_MultiPutReq = res.first->second;
  meta_MultiPutReq.name_ref() = "meta.MultiPutReq";
  meta_MultiPutReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_MultiPutReq_fields[] = {
    std::make_tuple(1, "segment", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "pairs", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::KeyValue>>("common.KeyValue")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_MultiPutReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_MultiPutReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetReq = res.first->second;
  meta_GetReq.name_ref() = "meta.GetReq";
  meta_GetReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetReq_fields[] = {
    std::make_tuple(1, "segment", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "key", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetResp = res.first->second;
  meta_GetResp.name_ref() = "meta.GetResp";
  meta_GetResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "value", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::MultiGetReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.MultiGetReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_MultiGetReq = res.first->second;
  meta_MultiGetReq.name_ref() = "meta.MultiGetReq";
  meta_MultiGetReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_MultiGetReq_fields[] = {
    std::make_tuple(1, "segment", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "keys", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_MultiGetReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_MultiGetReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::MultiGetResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.MultiGetResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_MultiGetResp = res.first->second;
  meta_MultiGetResp.name_ref() = "meta.MultiGetResp";
  meta_MultiGetResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_MultiGetResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "values", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_MultiGetResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_MultiGetResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::RemoveReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.RemoveReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_RemoveReq = res.first->second;
  meta_RemoveReq.name_ref() = "meta.RemoveReq";
  meta_RemoveReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_RemoveReq_fields[] = {
    std::make_tuple(1, "segment", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "key", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_RemoveReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_RemoveReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::RemoveRangeReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.RemoveRangeReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_RemoveRangeReq = res.first->second;
  meta_RemoveRangeReq.name_ref() = "meta.RemoveRangeReq";
  meta_RemoveRangeReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_RemoveRangeReq_fields[] = {
    std::make_tuple(1, "segment", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "start", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "end", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_RemoveRangeReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_RemoveRangeReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ScanReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ScanReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ScanReq = res.first->second;
  meta_ScanReq.name_ref() = "meta.ScanReq";
  meta_ScanReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_ScanReq_fields[] = {
    std::make_tuple(1, "segment", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "start", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "end", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ScanReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ScanReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ScanResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ScanResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ScanResp = res.first->second;
  meta_ScanResp.name_ref() = "meta.ScanResp";
  meta_ScanResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ScanResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "values", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ScanResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ScanResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::HBResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.HBResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_HBResp = res.first->second;
  meta_HBResp.name_ref() = "meta.HBResp";
  meta_HBResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_HBResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "cluster_id", false, std::make_unique<Typedef>("meta.ClusterID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "last_update_time_in_ms", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "meta_version", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_HBResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_HBResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::LeaderInfo>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.LeaderInfo", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_LeaderInfo = res.first->second;
  meta_LeaderInfo.name_ref() = "meta.LeaderInfo";
  meta_LeaderInfo.is_union_ref() = false;
  static const EncodedThriftField
  meta_LeaderInfo_fields[] = {
    std::make_tuple(1, "part_id", false, std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "term", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_LeaderInfo_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_LeaderInfo.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::PartitionList>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.PartitionList", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_PartitionList = res.first->second;
  meta_PartitionList.name_ref() = "meta.PartitionList";
  meta_PartitionList.is_union_ref() = false;
  static const EncodedThriftField
  meta_PartitionList_fields[] = {
    std::make_tuple(1, "part_list", false, std::make_unique<List>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE))), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_PartitionList_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_PartitionList.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::HBReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.HBReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_HBReq = res.first->second;
  meta_HBReq.name_ref() = "meta.HBReq";
  meta_HBReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_HBReq_fields[] = {
    std::make_tuple(1, "role", false, std::make_unique<Enum< ::nebula::meta::cpp2::HostRole>>("meta.HostRole"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "host", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "cluster_id", false, std::make_unique<Typedef>("meta.ClusterID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "leader_partIds", true, std::make_unique<Map>(std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::LeaderInfo>>("meta.LeaderInfo"))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "git_info_sha", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "disk_parts", true, std::make_unique<Map>(std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::make_unique<Struct< ::nebula::meta::cpp2::PartitionList>>("meta.PartitionList"))), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_HBReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_HBReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::IndexFieldDef>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.IndexFieldDef", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_IndexFieldDef = res.first->second;
  meta_IndexFieldDef.name_ref() = "meta.IndexFieldDef";
  meta_IndexFieldDef.is_union_ref() = false;
  static const EncodedThriftField
  meta_IndexFieldDef_fields[] = {
    std::make_tuple(1, "name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "type_length", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I16_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_IndexFieldDef_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_IndexFieldDef.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::CreateTagIndexReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.CreateTagIndexReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_CreateTagIndexReq = res.first->second;
  meta_CreateTagIndexReq.name_ref() = "meta.CreateTagIndexReq";
  meta_CreateTagIndexReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_CreateTagIndexReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "index_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "tag_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "fields", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::IndexFieldDef>>("meta.IndexFieldDef")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "if_not_exists", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "comment", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_CreateTagIndexReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_CreateTagIndexReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::DropTagIndexReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.DropTagIndexReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_DropTagIndexReq = res.first->second;
  meta_DropTagIndexReq.name_ref() = "meta.DropTagIndexReq";
  meta_DropTagIndexReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_DropTagIndexReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "index_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "if_exists", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_DropTagIndexReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_DropTagIndexReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetTagIndexReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetTagIndexReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetTagIndexReq = res.first->second;
  meta_GetTagIndexReq.name_ref() = "meta.GetTagIndexReq";
  meta_GetTagIndexReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetTagIndexReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "index_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetTagIndexReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetTagIndexReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetTagIndexResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetTagIndexResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetTagIndexResp = res.first->second;
  meta_GetTagIndexResp.name_ref() = "meta.GetTagIndexResp";
  meta_GetTagIndexResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetTagIndexResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "item", false, std::make_unique<Struct< ::nebula::meta::cpp2::IndexItem>>("meta.IndexItem"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetTagIndexResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetTagIndexResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListTagIndexesReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListTagIndexesReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListTagIndexesReq = res.first->second;
  meta_ListTagIndexesReq.name_ref() = "meta.ListTagIndexesReq";
  meta_ListTagIndexesReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListTagIndexesReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListTagIndexesReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListTagIndexesReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListTagIndexesResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListTagIndexesResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListTagIndexesResp = res.first->second;
  meta_ListTagIndexesResp.name_ref() = "meta.ListTagIndexesResp";
  meta_ListTagIndexesResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListTagIndexesResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "items", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::IndexItem>>("meta.IndexItem")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListTagIndexesResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListTagIndexesResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::CreateEdgeIndexReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.CreateEdgeIndexReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_CreateEdgeIndexReq = res.first->second;
  meta_CreateEdgeIndexReq.name_ref() = "meta.CreateEdgeIndexReq";
  meta_CreateEdgeIndexReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_CreateEdgeIndexReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "index_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "edge_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "fields", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::IndexFieldDef>>("meta.IndexFieldDef")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "if_not_exists", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "comment", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_CreateEdgeIndexReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_CreateEdgeIndexReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::DropEdgeIndexReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.DropEdgeIndexReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_DropEdgeIndexReq = res.first->second;
  meta_DropEdgeIndexReq.name_ref() = "meta.DropEdgeIndexReq";
  meta_DropEdgeIndexReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_DropEdgeIndexReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "index_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "if_exists", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_DropEdgeIndexReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_DropEdgeIndexReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetEdgeIndexReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetEdgeIndexReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetEdgeIndexReq = res.first->second;
  meta_GetEdgeIndexReq.name_ref() = "meta.GetEdgeIndexReq";
  meta_GetEdgeIndexReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetEdgeIndexReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "index_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetEdgeIndexReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetEdgeIndexReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetEdgeIndexResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetEdgeIndexResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetEdgeIndexResp = res.first->second;
  meta_GetEdgeIndexResp.name_ref() = "meta.GetEdgeIndexResp";
  meta_GetEdgeIndexResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetEdgeIndexResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "item", false, std::make_unique<Struct< ::nebula::meta::cpp2::IndexItem>>("meta.IndexItem"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetEdgeIndexResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetEdgeIndexResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListEdgeIndexesReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListEdgeIndexesReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListEdgeIndexesReq = res.first->second;
  meta_ListEdgeIndexesReq.name_ref() = "meta.ListEdgeIndexesReq";
  meta_ListEdgeIndexesReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListEdgeIndexesReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListEdgeIndexesReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListEdgeIndexesReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListEdgeIndexesResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListEdgeIndexesResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListEdgeIndexesResp = res.first->second;
  meta_ListEdgeIndexesResp.name_ref() = "meta.ListEdgeIndexesResp";
  meta_ListEdgeIndexesResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListEdgeIndexesResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "items", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::IndexItem>>("meta.IndexItem")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListEdgeIndexesResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListEdgeIndexesResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::RebuildIndexReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.RebuildIndexReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_RebuildIndexReq = res.first->second;
  meta_RebuildIndexReq.name_ref() = "meta.RebuildIndexReq";
  meta_RebuildIndexReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_RebuildIndexReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "index_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_RebuildIndexReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_RebuildIndexReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::CreateUserReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.CreateUserReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_CreateUserReq = res.first->second;
  meta_CreateUserReq.name_ref() = "meta.CreateUserReq";
  meta_CreateUserReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_CreateUserReq_fields[] = {
    std::make_tuple(1, "account", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "encoded_pwd", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "if_not_exists", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_CreateUserReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_CreateUserReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::DropUserReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.DropUserReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_DropUserReq = res.first->second;
  meta_DropUserReq.name_ref() = "meta.DropUserReq";
  meta_DropUserReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_DropUserReq_fields[] = {
    std::make_tuple(1, "account", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "if_exists", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_DropUserReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_DropUserReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::AlterUserReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.AlterUserReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_AlterUserReq = res.first->second;
  meta_AlterUserReq.name_ref() = "meta.AlterUserReq";
  meta_AlterUserReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_AlterUserReq_fields[] = {
    std::make_tuple(1, "account", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "encoded_pwd", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_AlterUserReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_AlterUserReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GrantRoleReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GrantRoleReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GrantRoleReq = res.first->second;
  meta_GrantRoleReq.name_ref() = "meta.GrantRoleReq";
  meta_GrantRoleReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_GrantRoleReq_fields[] = {
    std::make_tuple(1, "role_item", false, std::make_unique<Struct< ::nebula::meta::cpp2::RoleItem>>("meta.RoleItem"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GrantRoleReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GrantRoleReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::RevokeRoleReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.RevokeRoleReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_RevokeRoleReq = res.first->second;
  meta_RevokeRoleReq.name_ref() = "meta.RevokeRoleReq";
  meta_RevokeRoleReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_RevokeRoleReq_fields[] = {
    std::make_tuple(1, "role_item", false, std::make_unique<Struct< ::nebula::meta::cpp2::RoleItem>>("meta.RoleItem"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_RevokeRoleReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_RevokeRoleReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListUsersReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListUsersReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListUsersReq = res.first->second;
  meta_ListUsersReq.name_ref() = "meta.ListUsersReq";
  meta_ListUsersReq.is_union_ref() = false;
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListUsersResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListUsersResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListUsersResp = res.first->second;
  meta_ListUsersResp.name_ref() = "meta.ListUsersResp";
  meta_ListUsersResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListUsersResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "users", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListUsersResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListUsersResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListRolesReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListRolesReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListRolesReq = res.first->second;
  meta_ListRolesReq.name_ref() = "meta.ListRolesReq";
  meta_ListRolesReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListRolesReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListRolesReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListRolesReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListRolesResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListRolesResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListRolesResp = res.first->second;
  meta_ListRolesResp.name_ref() = "meta.ListRolesResp";
  meta_ListRolesResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListRolesResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "roles", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::RoleItem>>("meta.RoleItem")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListRolesResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListRolesResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetUserRolesReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetUserRolesReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetUserRolesReq = res.first->second;
  meta_GetUserRolesReq.name_ref() = "meta.GetUserRolesReq";
  meta_GetUserRolesReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetUserRolesReq_fields[] = {
    std::make_tuple(1, "account", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetUserRolesReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetUserRolesReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ChangePasswordReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ChangePasswordReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ChangePasswordReq = res.first->second;
  meta_ChangePasswordReq.name_ref() = "meta.ChangePasswordReq";
  meta_ChangePasswordReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_ChangePasswordReq_fields[] = {
    std::make_tuple(1, "account", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "new_encoded_pwd", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "old_encoded_pwd", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ChangePasswordReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ChangePasswordReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::BalanceTask>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.BalanceTask", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_BalanceTask = res.first->second;
  meta_BalanceTask.name_ref() = "meta.BalanceTask";
  meta_BalanceTask.is_union_ref() = false;
  static const EncodedThriftField
  meta_BalanceTask_fields[] = {
    std::make_tuple(1, "id", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "command", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "result", false, std::make_unique<Enum< ::nebula::meta::cpp2::TaskResult>>("meta.TaskResult"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "start_time", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "stop_time", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_BalanceTask_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_BalanceTask.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ConfigItem>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ConfigItem", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ConfigItem = res.first->second;
  meta_ConfigItem.name_ref() = "meta.ConfigItem";
  meta_ConfigItem.is_union_ref() = false;
  static const EncodedThriftField
  meta_ConfigItem_fields[] = {
    std::make_tuple(1, "module", false, std::make_unique<Enum< ::nebula::meta::cpp2::ConfigModule>>("meta.ConfigModule"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "mode", false, std::make_unique<Enum< ::nebula::meta::cpp2::ConfigMode>>("meta.ConfigMode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "value", false, std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ConfigItem_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ConfigItem.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::RegConfigReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.RegConfigReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_RegConfigReq = res.first->second;
  meta_RegConfigReq.name_ref() = "meta.RegConfigReq";
  meta_RegConfigReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_RegConfigReq_fields[] = {
    std::make_tuple(1, "items", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::ConfigItem>>("meta.ConfigItem")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_RegConfigReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_RegConfigReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetConfigReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetConfigReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetConfigReq = res.first->second;
  meta_GetConfigReq.name_ref() = "meta.GetConfigReq";
  meta_GetConfigReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetConfigReq_fields[] = {
    std::make_tuple(1, "item", false, std::make_unique<Struct< ::nebula::meta::cpp2::ConfigItem>>("meta.ConfigItem"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetConfigReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetConfigReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetConfigResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetConfigResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetConfigResp = res.first->second;
  meta_GetConfigResp.name_ref() = "meta.GetConfigResp";
  meta_GetConfigResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetConfigResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "items", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::ConfigItem>>("meta.ConfigItem")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetConfigResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetConfigResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::SetConfigReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.SetConfigReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_SetConfigReq = res.first->second;
  meta_SetConfigReq.name_ref() = "meta.SetConfigReq";
  meta_SetConfigReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_SetConfigReq_fields[] = {
    std::make_tuple(1, "item", false, std::make_unique<Struct< ::nebula::meta::cpp2::ConfigItem>>("meta.ConfigItem"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_SetConfigReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_SetConfigReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListConfigsReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListConfigsReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListConfigsReq = res.first->second;
  meta_ListConfigsReq.name_ref() = "meta.ListConfigsReq";
  meta_ListConfigsReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListConfigsReq_fields[] = {
    std::make_tuple(1, "space", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "module", false, std::make_unique<Enum< ::nebula::meta::cpp2::ConfigModule>>("meta.ConfigModule"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListConfigsReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListConfigsReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListConfigsResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListConfigsResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListConfigsResp = res.first->second;
  meta_ListConfigsResp.name_ref() = "meta.ListConfigsResp";
  meta_ListConfigsResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListConfigsResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "items", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::ConfigItem>>("meta.ConfigItem")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListConfigsResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListConfigsResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::CreateSnapshotReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.CreateSnapshotReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_CreateSnapshotReq = res.first->second;
  meta_CreateSnapshotReq.name_ref() = "meta.CreateSnapshotReq";
  meta_CreateSnapshotReq.is_union_ref() = false;
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::DropSnapshotReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.DropSnapshotReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_DropSnapshotReq = res.first->second;
  meta_DropSnapshotReq.name_ref() = "meta.DropSnapshotReq";
  meta_DropSnapshotReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_DropSnapshotReq_fields[] = {
    std::make_tuple(1, "name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_DropSnapshotReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_DropSnapshotReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListSnapshotsReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListSnapshotsReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListSnapshotsReq = res.first->second;
  meta_ListSnapshotsReq.name_ref() = "meta.ListSnapshotsReq";
  meta_ListSnapshotsReq.is_union_ref() = false;
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::Snapshot>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.Snapshot", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_Snapshot = res.first->second;
  meta_Snapshot.name_ref() = "meta.Snapshot";
  meta_Snapshot.is_union_ref() = false;
  static const EncodedThriftField
  meta_Snapshot_fields[] = {
    std::make_tuple(1, "name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "status", false, std::make_unique<Enum< ::nebula::meta::cpp2::SnapshotStatus>>("meta.SnapshotStatus"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "hosts", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_Snapshot_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_Snapshot.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListSnapshotsResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListSnapshotsResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListSnapshotsResp = res.first->second;
  meta_ListSnapshotsResp.name_ref() = "meta.ListSnapshotsResp";
  meta_ListSnapshotsResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListSnapshotsResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "snapshots", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::Snapshot>>("meta.Snapshot")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListSnapshotsResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListSnapshotsResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListIndexStatusReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListIndexStatusReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListIndexStatusReq = res.first->second;
  meta_ListIndexStatusReq.name_ref() = "meta.ListIndexStatusReq";
  meta_ListIndexStatusReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListIndexStatusReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListIndexStatusReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListIndexStatusReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::IndexStatus>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.IndexStatus", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_IndexStatus = res.first->second;
  meta_IndexStatus.name_ref() = "meta.IndexStatus";
  meta_IndexStatus.is_union_ref() = false;
  static const EncodedThriftField
  meta_IndexStatus_fields[] = {
    std::make_tuple(1, "name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "status", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_IndexStatus_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_IndexStatus.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListIndexStatusResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListIndexStatusResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListIndexStatusResp = res.first->second;
  meta_ListIndexStatusResp.name_ref() = "meta.ListIndexStatusResp";
  meta_ListIndexStatusResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListIndexStatusResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "statuses", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::IndexStatus>>("meta.IndexStatus")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListIndexStatusResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListIndexStatusResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::MergeZoneReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.MergeZoneReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_MergeZoneReq = res.first->second;
  meta_MergeZoneReq.name_ref() = "meta.MergeZoneReq";
  meta_MergeZoneReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_MergeZoneReq_fields[] = {
    std::make_tuple(1, "zones", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "zone_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_MergeZoneReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_MergeZoneReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::DropZoneReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.DropZoneReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_DropZoneReq = res.first->second;
  meta_DropZoneReq.name_ref() = "meta.DropZoneReq";
  meta_DropZoneReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_DropZoneReq_fields[] = {
    std::make_tuple(1, "zone_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_DropZoneReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_DropZoneReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::SplitZoneReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.SplitZoneReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_SplitZoneReq = res.first->second;
  meta_SplitZoneReq.name_ref() = "meta.SplitZoneReq";
  meta_SplitZoneReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_SplitZoneReq_fields[] = {
    std::make_tuple(1, "zone_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_SplitZoneReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_SplitZoneReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::RenameZoneReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.RenameZoneReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_RenameZoneReq = res.first->second;
  meta_RenameZoneReq.name_ref() = "meta.RenameZoneReq";
  meta_RenameZoneReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_RenameZoneReq_fields[] = {
    std::make_tuple(1, "original_zone_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "zone_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_RenameZoneReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_RenameZoneReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::AddHostsIntoZoneReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.AddHostsIntoZoneReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_AddHostsIntoZoneReq = res.first->second;
  meta_AddHostsIntoZoneReq.name_ref() = "meta.AddHostsIntoZoneReq";
  meta_AddHostsIntoZoneReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_AddHostsIntoZoneReq_fields[] = {
    std::make_tuple(1, "hosts", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "zone_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "is_new", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_AddHostsIntoZoneReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_AddHostsIntoZoneReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetZoneReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetZoneReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetZoneReq = res.first->second;
  meta_GetZoneReq.name_ref() = "meta.GetZoneReq";
  meta_GetZoneReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetZoneReq_fields[] = {
    std::make_tuple(1, "zone_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetZoneReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetZoneReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetZoneResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetZoneResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetZoneResp = res.first->second;
  meta_GetZoneResp.name_ref() = "meta.GetZoneResp";
  meta_GetZoneResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetZoneResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "hosts", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetZoneResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetZoneResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListZonesReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListZonesReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListZonesReq = res.first->second;
  meta_ListZonesReq.name_ref() = "meta.ListZonesReq";
  meta_ListZonesReq.is_union_ref() = false;
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::Zone>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.Zone", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_Zone = res.first->second;
  meta_Zone.name_ref() = "meta.Zone";
  meta_Zone.is_union_ref() = false;
  static const EncodedThriftField
  meta_Zone_fields[] = {
    std::make_tuple(1, "zone_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "nodes", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_Zone_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_Zone.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListZonesResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListZonesResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListZonesResp = res.first->second;
  meta_ListZonesResp.name_ref() = "meta.ListZonesResp";
  meta_ListZonesResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListZonesResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "zones", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::Zone>>("meta.Zone")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListZonesResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListZonesResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::AddListenerReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.AddListenerReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_AddListenerReq = res.first->second;
  meta_AddListenerReq.name_ref() = "meta.AddListenerReq";
  meta_AddListenerReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_AddListenerReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "type", false, std::make_unique<Enum< ::nebula::meta::cpp2::ListenerType>>("meta.ListenerType"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "hosts", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_AddListenerReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_AddListenerReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::RemoveListenerReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.RemoveListenerReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_RemoveListenerReq = res.first->second;
  meta_RemoveListenerReq.name_ref() = "meta.RemoveListenerReq";
  meta_RemoveListenerReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_RemoveListenerReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "type", false, std::make_unique<Enum< ::nebula::meta::cpp2::ListenerType>>("meta.ListenerType"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_RemoveListenerReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_RemoveListenerReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListListenerReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListListenerReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListListenerReq = res.first->second;
  meta_ListListenerReq.name_ref() = "meta.ListListenerReq";
  meta_ListListenerReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListListenerReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListListenerReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListListenerReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListenerInfo>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListenerInfo", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListenerInfo = res.first->second;
  meta_ListenerInfo.name_ref() = "meta.ListenerInfo";
  meta_ListenerInfo.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListenerInfo_fields[] = {
    std::make_tuple(1, "type", false, std::make_unique<Enum< ::nebula::meta::cpp2::ListenerType>>("meta.ListenerType"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "host", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "part_id", false, std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "status", false, std::make_unique<Enum< ::nebula::meta::cpp2::HostStatus>>("meta.HostStatus"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListenerInfo_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListenerInfo.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListListenerResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListListenerResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListListenerResp = res.first->second;
  meta_ListListenerResp.name_ref() = "meta.ListListenerResp";
  meta_ListListenerResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListListenerResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "listeners", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::ListenerInfo>>("meta.ListenerInfo")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListListenerResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListListenerResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetStatsReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetStatsReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetStatsReq = res.first->second;
  meta_GetStatsReq.name_ref() = "meta.GetStatsReq";
  meta_GetStatsReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetStatsReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetStatsReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetStatsReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetStatsResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetStatsResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetStatsResp = res.first->second;
  meta_GetStatsResp.name_ref() = "meta.GetStatsResp";
  meta_GetStatsResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetStatsResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "stats", false, std::make_unique<Struct< ::nebula::meta::cpp2::StatsItem>>("meta.StatsItem"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetStatsResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetStatsResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::BackupInfo>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.BackupInfo", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_BackupInfo = res.first->second;
  meta_BackupInfo.name_ref() = "meta.BackupInfo";
  meta_BackupInfo.is_union_ref() = false;
  static const EncodedThriftField
  meta_BackupInfo_fields[] = {
    std::make_tuple(1, "host", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "info", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::CheckpointInfo>>("common.CheckpointInfo")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_BackupInfo_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_BackupInfo.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::SpaceBackupInfo>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.SpaceBackupInfo", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_SpaceBackupInfo = res.first->second;
  meta_SpaceBackupInfo.name_ref() = "meta.SpaceBackupInfo";
  meta_SpaceBackupInfo.is_union_ref() = false;
  static const EncodedThriftField
  meta_SpaceBackupInfo_fields[] = {
    std::make_tuple(1, "space", false, std::make_unique<Struct< ::nebula::meta::cpp2::SpaceDesc>>("meta.SpaceDesc"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "info", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::BackupInfo>>("meta.BackupInfo")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_SpaceBackupInfo_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_SpaceBackupInfo.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::BackupMeta>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.BackupMeta", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_BackupMeta = res.first->second;
  meta_BackupMeta.name_ref() = "meta.BackupMeta";
  meta_BackupMeta.is_union_ref() = false;
  static const EncodedThriftField
  meta_BackupMeta_fields[] = {
    std::make_tuple(1, "backup_info", false, std::make_unique<Map>(std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<Struct< ::nebula::meta::cpp2::SpaceBackupInfo>>("meta.SpaceBackupInfo")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "meta_files", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "backup_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "full", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "include_system_space", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "create_time", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_BackupMeta_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_BackupMeta.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::CreateBackupReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.CreateBackupReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_CreateBackupReq = res.first->second;
  meta_CreateBackupReq.name_ref() = "meta.CreateBackupReq";
  meta_CreateBackupReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_CreateBackupReq_fields[] = {
    std::make_tuple(1, "spaces", true, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_CreateBackupReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_CreateBackupReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::CreateBackupResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.CreateBackupResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_CreateBackupResp = res.first->second;
  meta_CreateBackupResp.name_ref() = "meta.CreateBackupResp";
  meta_CreateBackupResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_CreateBackupResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "meta", false, std::make_unique<Struct< ::nebula::meta::cpp2::BackupMeta>>("meta.BackupMeta"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_CreateBackupResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_CreateBackupResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::HostPair>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.HostPair", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_HostPair = res.first->second;
  meta_HostPair.name_ref() = "meta.HostPair";
  meta_HostPair.is_union_ref() = false;
  static const EncodedThriftField
  meta_HostPair_fields[] = {
    std::make_tuple(1, "from_host", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "to_host", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_HostPair_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_HostPair.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::RestoreMetaReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.RestoreMetaReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_RestoreMetaReq = res.first->second;
  meta_RestoreMetaReq.name_ref() = "meta.RestoreMetaReq";
  meta_RestoreMetaReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_RestoreMetaReq_fields[] = {
    std::make_tuple(1, "files", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "hosts", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::HostPair>>("meta.HostPair")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_RestoreMetaReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_RestoreMetaReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::FTClient>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.FTClient", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_FTClient = res.first->second;
  meta_FTClient.name_ref() = "meta.FTClient";
  meta_FTClient.is_union_ref() = false;
  static const EncodedThriftField
  meta_FTClient_fields[] = {
    std::make_tuple(1, "host", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "user", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "pwd", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "conn_type", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_FTClient_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_FTClient.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::SignInFTServiceReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.SignInFTServiceReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_SignInFTServiceReq = res.first->second;
  meta_SignInFTServiceReq.name_ref() = "meta.SignInFTServiceReq";
  meta_SignInFTServiceReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_SignInFTServiceReq_fields[] = {
    std::make_tuple(1, "type", false, std::make_unique<Enum< ::nebula::meta::cpp2::FTServiceType>>("meta.FTServiceType"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "clients", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::FTClient>>("meta.FTClient")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_SignInFTServiceReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_SignInFTServiceReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::SignOutFTServiceReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.SignOutFTServiceReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_SignOutFTServiceReq = res.first->second;
  meta_SignOutFTServiceReq.name_ref() = "meta.SignOutFTServiceReq";
  meta_SignOutFTServiceReq.is_union_ref() = false;
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListFTClientsReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListFTClientsReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListFTClientsReq = res.first->second;
  meta_ListFTClientsReq.name_ref() = "meta.ListFTClientsReq";
  meta_ListFTClientsReq.is_union_ref() = false;
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListFTClientsResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListFTClientsResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListFTClientsResp = res.first->second;
  meta_ListFTClientsResp.name_ref() = "meta.ListFTClientsResp";
  meta_ListFTClientsResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListFTClientsResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "clients", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::FTClient>>("meta.FTClient")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListFTClientsResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListFTClientsResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::FTIndex>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.FTIndex", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_FTIndex = res.first->second;
  meta_FTIndex.name_ref() = "meta.FTIndex";
  meta_FTIndex.is_union_ref() = false;
  static const EncodedThriftField
  meta_FTIndex_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "depend_schema", false, std::make_unique<Union< ::nebula::cpp2::SchemaID>>("common.SchemaID"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "fields", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_FTIndex_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_FTIndex.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::CreateFTIndexReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.CreateFTIndexReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_CreateFTIndexReq = res.first->second;
  meta_CreateFTIndexReq.name_ref() = "meta.CreateFTIndexReq";
  meta_CreateFTIndexReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_CreateFTIndexReq_fields[] = {
    std::make_tuple(1, "fulltext_index_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "index", false, std::make_unique<Struct< ::nebula::meta::cpp2::FTIndex>>("meta.FTIndex"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_CreateFTIndexReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_CreateFTIndexReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::DropFTIndexReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.DropFTIndexReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_DropFTIndexReq = res.first->second;
  meta_DropFTIndexReq.name_ref() = "meta.DropFTIndexReq";
  meta_DropFTIndexReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_DropFTIndexReq_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "fulltext_index_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_DropFTIndexReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_DropFTIndexReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListFTIndexesReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListFTIndexesReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListFTIndexesReq = res.first->second;
  meta_ListFTIndexesReq.name_ref() = "meta.ListFTIndexesReq";
  meta_ListFTIndexesReq.is_union_ref() = false;
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListFTIndexesResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListFTIndexesResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListFTIndexesResp = res.first->second;
  meta_ListFTIndexesResp.name_ref() = "meta.ListFTIndexesResp";
  meta_ListFTIndexesResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListFTIndexesResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "indexes", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::make_unique<Struct< ::nebula::meta::cpp2::FTIndex>>("meta.FTIndex")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListFTIndexesResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListFTIndexesResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::QueryDesc>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.QueryDesc", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_QueryDesc = res.first->second;
  meta_QueryDesc.name_ref() = "meta.QueryDesc";
  meta_QueryDesc.is_union_ref() = false;
  static const EncodedThriftField
  meta_QueryDesc_fields[] = {
    std::make_tuple(1, "start_time", false, std::make_unique<Typedef>("common.Timestamp", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "status", false, std::make_unique<Enum< ::nebula::meta::cpp2::QueryStatus>>("meta.QueryStatus"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "duration", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "query", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "graph_addr", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_QueryDesc_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_QueryDesc.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::Session>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.Session", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_Session = res.first->second;
  meta_Session.name_ref() = "meta.Session";
  meta_Session.is_union_ref() = false;
  static const EncodedThriftField
  meta_Session_fields[] = {
    std::make_tuple(1, "session_id", false, std::make_unique<Typedef>("common.SessionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "create_time", false, std::make_unique<Typedef>("common.Timestamp", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "update_time", false, std::make_unique<Typedef>("common.Timestamp", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "user_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "space_name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "graph_addr", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(7, "timezone", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(8, "client_ip", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(9, "configs", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(10, "queries", false, std::make_unique<Map>(std::make_unique<Typedef>("common.ExecutionPlanID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::make_unique<Struct< ::nebula::meta::cpp2::QueryDesc>>("meta.QueryDesc")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_Session_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_Session.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::CreateSessionReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.CreateSessionReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_CreateSessionReq = res.first->second;
  meta_CreateSessionReq.name_ref() = "meta.CreateSessionReq";
  meta_CreateSessionReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_CreateSessionReq_fields[] = {
    std::make_tuple(1, "user", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "graph_addr", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "client_ip", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_CreateSessionReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_CreateSessionReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::CreateSessionResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.CreateSessionResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_CreateSessionResp = res.first->second;
  meta_CreateSessionResp.name_ref() = "meta.CreateSessionResp";
  meta_CreateSessionResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_CreateSessionResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "session", false, std::make_unique<Struct< ::nebula::meta::cpp2::Session>>("meta.Session"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_CreateSessionResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_CreateSessionResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::UpdateSessionsReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.UpdateSessionsReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_UpdateSessionsReq = res.first->second;
  meta_UpdateSessionsReq.name_ref() = "meta.UpdateSessionsReq";
  meta_UpdateSessionsReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_UpdateSessionsReq_fields[] = {
    std::make_tuple(1, "sessions", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::Session>>("meta.Session")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_UpdateSessionsReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_UpdateSessionsReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::UpdateSessionsResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.UpdateSessionsResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_UpdateSessionsResp = res.first->second;
  meta_UpdateSessionsResp.name_ref() = "meta.UpdateSessionsResp";
  meta_UpdateSessionsResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_UpdateSessionsResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "killed_queries", false, std::make_unique<Map>(std::make_unique<Typedef>("common.SessionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::make_unique<Map>(std::make_unique<Typedef>("common.ExecutionPlanID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::make_unique<Struct< ::nebula::meta::cpp2::QueryDesc>>("meta.QueryDesc"))), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_UpdateSessionsResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_UpdateSessionsResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListSessionsReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListSessionsReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListSessionsReq = res.first->second;
  meta_ListSessionsReq.name_ref() = "meta.ListSessionsReq";
  meta_ListSessionsReq.is_union_ref() = false;
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListSessionsResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListSessionsResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListSessionsResp = res.first->second;
  meta_ListSessionsResp.name_ref() = "meta.ListSessionsResp";
  meta_ListSessionsResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListSessionsResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "sessions", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::meta::cpp2::Session>>("meta.Session")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListSessionsResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListSessionsResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetSessionReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetSessionReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetSessionReq = res.first->second;
  meta_GetSessionReq.name_ref() = "meta.GetSessionReq";
  meta_GetSessionReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetSessionReq_fields[] = {
    std::make_tuple(1, "session_id", false, std::make_unique<Typedef>("common.SessionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetSessionReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetSessionReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetSessionResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetSessionResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetSessionResp = res.first->second;
  meta_GetSessionResp.name_ref() = "meta.GetSessionResp";
  meta_GetSessionResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetSessionResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "session", false, std::make_unique<Struct< ::nebula::meta::cpp2::Session>>("meta.Session"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetSessionResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetSessionResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::RemoveSessionReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.RemoveSessionReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_RemoveSessionReq = res.first->second;
  meta_RemoveSessionReq.name_ref() = "meta.RemoveSessionReq";
  meta_RemoveSessionReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_RemoveSessionReq_fields[] = {
    std::make_tuple(1, "session_id", false, std::make_unique<Typedef>("common.SessionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_RemoveSessionReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_RemoveSessionReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::KillQueryReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.KillQueryReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_KillQueryReq = res.first->second;
  meta_KillQueryReq.name_ref() = "meta.KillQueryReq";
  meta_KillQueryReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_KillQueryReq_fields[] = {
    std::make_tuple(1, "kill_queries", false, std::make_unique<Map>(std::make_unique<Typedef>("common.SessionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::make_unique<Set>(std::make_unique<Typedef>("common.ExecutionPlanID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)))), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_KillQueryReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_KillQueryReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ReportTaskReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ReportTaskReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ReportTaskReq = res.first->second;
  meta_ReportTaskReq.name_ref() = "meta.ReportTaskReq";
  meta_ReportTaskReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_ReportTaskReq_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "job_id", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "task_id", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "stats", true, std::make_unique<Struct< ::nebula::meta::cpp2::StatsItem>>("meta.StatsItem"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ReportTaskReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ReportTaskReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListClusterInfoResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListClusterInfoResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListClusterInfoResp = res.first->second;
  meta_ListClusterInfoResp.name_ref() = "meta.ListClusterInfoResp";
  meta_ListClusterInfoResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_ListClusterInfoResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "meta_servers", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "storage_servers", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::NodeInfo>>("common.NodeInfo")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_ListClusterInfoResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_ListClusterInfoResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::ListClusterInfoReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.ListClusterInfoReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_ListClusterInfoReq = res.first->second;
  meta_ListClusterInfoReq.name_ref() = "meta.ListClusterInfoReq";
  meta_ListClusterInfoReq.is_union_ref() = false;
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetMetaDirInfoResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetMetaDirInfoResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetMetaDirInfoResp = res.first->second;
  meta_GetMetaDirInfoResp.name_ref() = "meta.GetMetaDirInfoResp";
  meta_GetMetaDirInfoResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_GetMetaDirInfoResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "dir", false, std::make_unique<Struct< ::nebula::cpp2::DirInfo>>("common.DirInfo"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_GetMetaDirInfoResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_GetMetaDirInfoResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::GetMetaDirInfoReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.GetMetaDirInfoReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_GetMetaDirInfoReq = res.first->second;
  meta_GetMetaDirInfoReq.name_ref() = "meta.GetMetaDirInfoReq";
  meta_GetMetaDirInfoReq.is_union_ref() = false;
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::VerifyClientVersionResp>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.VerifyClientVersionResp", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_VerifyClientVersionResp = res.first->second;
  meta_VerifyClientVersionResp.name_ref() = "meta.VerifyClientVersionResp";
  meta_VerifyClientVersionResp.is_union_ref() = false;
  static const EncodedThriftField
  meta_VerifyClientVersionResp_fields[] = {
    std::make_tuple(1, "code", false, std::make_unique<Enum< ::nebula::cpp2::ErrorCode>>("common.ErrorCode"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "leader", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "error_msg", true, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_VerifyClientVersionResp_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_VerifyClientVersionResp.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::meta::cpp2::VerifyClientVersionReq>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("meta.VerifyClientVersionReq", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& meta_VerifyClientVersionReq = res.first->second;
  meta_VerifyClientVersionReq.name_ref() = "meta.VerifyClientVersionReq";
  meta_VerifyClientVersionReq.is_union_ref() = false;
  static const EncodedThriftField
  meta_VerifyClientVersionReq_fields[] = {
    std::make_tuple(1, "version", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "host", false, std::make_unique<Struct< ::nebula::cpp2::HostAddr>>("common.HostAddr"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : meta_VerifyClientVersionReq_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    meta_VerifyClientVersionReq.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}

void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createSpace(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "createSpace";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_createSpace_req_1;
  meta_MetaService_createSpace_req_1.id_ref() = 1;
  meta_MetaService_createSpace_req_1.name_ref() = "req";
  meta_MetaService_createSpace_req_1.is_optional_ref() = false;
  auto meta_MetaService_createSpace_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::CreateSpaceReq>>("meta.CreateSpaceReq");
  meta_MetaService_createSpace_req_1_type->writeAndGenType(*meta_MetaService_createSpace_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_createSpace_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropSpace(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "dropSpace";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_dropSpace_req_1;
  meta_MetaService_dropSpace_req_1.id_ref() = 1;
  meta_MetaService_dropSpace_req_1.name_ref() = "req";
  meta_MetaService_dropSpace_req_1.is_optional_ref() = false;
  auto meta_MetaService_dropSpace_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::DropSpaceReq>>("meta.DropSpaceReq");
  meta_MetaService_dropSpace_req_1_type->writeAndGenType(*meta_MetaService_dropSpace_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_dropSpace_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getSpace(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "getSpace";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetSpaceResp>>("meta.GetSpaceResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_getSpace_req_1;
  meta_MetaService_getSpace_req_1.id_ref() = 1;
  meta_MetaService_getSpace_req_1.name_ref() = "req";
  meta_MetaService_getSpace_req_1.is_optional_ref() = false;
  auto meta_MetaService_getSpace_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetSpaceReq>>("meta.GetSpaceReq");
  meta_MetaService_getSpace_req_1_type->writeAndGenType(*meta_MetaService_getSpace_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_getSpace_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listSpaces(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listSpaces";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListSpacesResp>>("meta.ListSpacesResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_listSpaces_req_1;
  meta_MetaService_listSpaces_req_1.id_ref() = 1;
  meta_MetaService_listSpaces_req_1.name_ref() = "req";
  meta_MetaService_listSpaces_req_1.is_optional_ref() = false;
  auto meta_MetaService_listSpaces_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListSpacesReq>>("meta.ListSpacesReq");
  meta_MetaService_listSpaces_req_1_type->writeAndGenType(*meta_MetaService_listSpaces_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_listSpaces_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createSpaceAs(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "createSpaceAs";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_createSpaceAs_req_1;
  meta_MetaService_createSpaceAs_req_1.id_ref() = 1;
  meta_MetaService_createSpaceAs_req_1.name_ref() = "req";
  meta_MetaService_createSpaceAs_req_1.is_optional_ref() = false;
  auto meta_MetaService_createSpaceAs_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::CreateSpaceAsReq>>("meta.CreateSpaceAsReq");
  meta_MetaService_createSpaceAs_req_1_type->writeAndGenType(*meta_MetaService_createSpaceAs_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_createSpaceAs_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createTag(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "createTag";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_createTag_req_1;
  meta_MetaService_createTag_req_1.id_ref() = 1;
  meta_MetaService_createTag_req_1.name_ref() = "req";
  meta_MetaService_createTag_req_1.is_optional_ref() = false;
  auto meta_MetaService_createTag_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::CreateTagReq>>("meta.CreateTagReq");
  meta_MetaService_createTag_req_1_type->writeAndGenType(*meta_MetaService_createTag_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_createTag_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_alterTag(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "alterTag";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_alterTag_req_1;
  meta_MetaService_alterTag_req_1.id_ref() = 1;
  meta_MetaService_alterTag_req_1.name_ref() = "req";
  meta_MetaService_alterTag_req_1.is_optional_ref() = false;
  auto meta_MetaService_alterTag_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::AlterTagReq>>("meta.AlterTagReq");
  meta_MetaService_alterTag_req_1_type->writeAndGenType(*meta_MetaService_alterTag_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_alterTag_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropTag(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "dropTag";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_dropTag_req_1;
  meta_MetaService_dropTag_req_1.id_ref() = 1;
  meta_MetaService_dropTag_req_1.name_ref() = "req";
  meta_MetaService_dropTag_req_1.is_optional_ref() = false;
  auto meta_MetaService_dropTag_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::DropTagReq>>("meta.DropTagReq");
  meta_MetaService_dropTag_req_1_type->writeAndGenType(*meta_MetaService_dropTag_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_dropTag_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getTag(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "getTag";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetTagResp>>("meta.GetTagResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_getTag_req_1;
  meta_MetaService_getTag_req_1.id_ref() = 1;
  meta_MetaService_getTag_req_1.name_ref() = "req";
  meta_MetaService_getTag_req_1.is_optional_ref() = false;
  auto meta_MetaService_getTag_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetTagReq>>("meta.GetTagReq");
  meta_MetaService_getTag_req_1_type->writeAndGenType(*meta_MetaService_getTag_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_getTag_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listTags(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listTags";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListTagsResp>>("meta.ListTagsResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_listTags_req_1;
  meta_MetaService_listTags_req_1.id_ref() = 1;
  meta_MetaService_listTags_req_1.name_ref() = "req";
  meta_MetaService_listTags_req_1.is_optional_ref() = false;
  auto meta_MetaService_listTags_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListTagsReq>>("meta.ListTagsReq");
  meta_MetaService_listTags_req_1_type->writeAndGenType(*meta_MetaService_listTags_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_listTags_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createEdge(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "createEdge";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_createEdge_req_1;
  meta_MetaService_createEdge_req_1.id_ref() = 1;
  meta_MetaService_createEdge_req_1.name_ref() = "req";
  meta_MetaService_createEdge_req_1.is_optional_ref() = false;
  auto meta_MetaService_createEdge_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::CreateEdgeReq>>("meta.CreateEdgeReq");
  meta_MetaService_createEdge_req_1_type->writeAndGenType(*meta_MetaService_createEdge_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_createEdge_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_alterEdge(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "alterEdge";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_alterEdge_req_1;
  meta_MetaService_alterEdge_req_1.id_ref() = 1;
  meta_MetaService_alterEdge_req_1.name_ref() = "req";
  meta_MetaService_alterEdge_req_1.is_optional_ref() = false;
  auto meta_MetaService_alterEdge_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::AlterEdgeReq>>("meta.AlterEdgeReq");
  meta_MetaService_alterEdge_req_1_type->writeAndGenType(*meta_MetaService_alterEdge_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_alterEdge_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropEdge(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "dropEdge";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_dropEdge_req_1;
  meta_MetaService_dropEdge_req_1.id_ref() = 1;
  meta_MetaService_dropEdge_req_1.name_ref() = "req";
  meta_MetaService_dropEdge_req_1.is_optional_ref() = false;
  auto meta_MetaService_dropEdge_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::DropEdgeReq>>("meta.DropEdgeReq");
  meta_MetaService_dropEdge_req_1_type->writeAndGenType(*meta_MetaService_dropEdge_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_dropEdge_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getEdge(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "getEdge";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetEdgeResp>>("meta.GetEdgeResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_getEdge_req_1;
  meta_MetaService_getEdge_req_1.id_ref() = 1;
  meta_MetaService_getEdge_req_1.name_ref() = "req";
  meta_MetaService_getEdge_req_1.is_optional_ref() = false;
  auto meta_MetaService_getEdge_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetEdgeReq>>("meta.GetEdgeReq");
  meta_MetaService_getEdge_req_1_type->writeAndGenType(*meta_MetaService_getEdge_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_getEdge_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listEdges(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listEdges";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListEdgesResp>>("meta.ListEdgesResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_listEdges_req_1;
  meta_MetaService_listEdges_req_1.id_ref() = 1;
  meta_MetaService_listEdges_req_1.name_ref() = "req";
  meta_MetaService_listEdges_req_1.is_optional_ref() = false;
  auto meta_MetaService_listEdges_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListEdgesReq>>("meta.ListEdgesReq");
  meta_MetaService_listEdges_req_1_type->writeAndGenType(*meta_MetaService_listEdges_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_listEdges_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_addHosts(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "addHosts";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_addHosts_req_1;
  meta_MetaService_addHosts_req_1.id_ref() = 1;
  meta_MetaService_addHosts_req_1.name_ref() = "req";
  meta_MetaService_addHosts_req_1.is_optional_ref() = false;
  auto meta_MetaService_addHosts_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::AddHostsReq>>("meta.AddHostsReq");
  meta_MetaService_addHosts_req_1_type->writeAndGenType(*meta_MetaService_addHosts_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_addHosts_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_addHostsIntoZone(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "addHostsIntoZone";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_addHostsIntoZone_req_1;
  meta_MetaService_addHostsIntoZone_req_1.id_ref() = 1;
  meta_MetaService_addHostsIntoZone_req_1.name_ref() = "req";
  meta_MetaService_addHostsIntoZone_req_1.is_optional_ref() = false;
  auto meta_MetaService_addHostsIntoZone_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::AddHostsIntoZoneReq>>("meta.AddHostsIntoZoneReq");
  meta_MetaService_addHostsIntoZone_req_1_type->writeAndGenType(*meta_MetaService_addHostsIntoZone_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_addHostsIntoZone_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropHosts(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "dropHosts";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_dropHosts_req_1;
  meta_MetaService_dropHosts_req_1.id_ref() = 1;
  meta_MetaService_dropHosts_req_1.name_ref() = "req";
  meta_MetaService_dropHosts_req_1.is_optional_ref() = false;
  auto meta_MetaService_dropHosts_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::DropHostsReq>>("meta.DropHostsReq");
  meta_MetaService_dropHosts_req_1_type->writeAndGenType(*meta_MetaService_dropHosts_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_dropHosts_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listHosts(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listHosts";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListHostsResp>>("meta.ListHostsResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_listHosts_req_1;
  meta_MetaService_listHosts_req_1.id_ref() = 1;
  meta_MetaService_listHosts_req_1.name_ref() = "req";
  meta_MetaService_listHosts_req_1.is_optional_ref() = false;
  auto meta_MetaService_listHosts_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListHostsReq>>("meta.ListHostsReq");
  meta_MetaService_listHosts_req_1_type->writeAndGenType(*meta_MetaService_listHosts_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_listHosts_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getPartsAlloc(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "getPartsAlloc";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetPartsAllocResp>>("meta.GetPartsAllocResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_getPartsAlloc_req_1;
  meta_MetaService_getPartsAlloc_req_1.id_ref() = 1;
  meta_MetaService_getPartsAlloc_req_1.name_ref() = "req";
  meta_MetaService_getPartsAlloc_req_1.is_optional_ref() = false;
  auto meta_MetaService_getPartsAlloc_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetPartsAllocReq>>("meta.GetPartsAllocReq");
  meta_MetaService_getPartsAlloc_req_1_type->writeAndGenType(*meta_MetaService_getPartsAlloc_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_getPartsAlloc_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listParts(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listParts";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListPartsResp>>("meta.ListPartsResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_listParts_req_1;
  meta_MetaService_listParts_req_1.id_ref() = 1;
  meta_MetaService_listParts_req_1.name_ref() = "req";
  meta_MetaService_listParts_req_1.is_optional_ref() = false;
  auto meta_MetaService_listParts_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListPartsReq>>("meta.ListPartsReq");
  meta_MetaService_listParts_req_1_type->writeAndGenType(*meta_MetaService_listParts_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_listParts_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_multiPut(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "multiPut";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_multiPut_req_1;
  meta_MetaService_multiPut_req_1.id_ref() = 1;
  meta_MetaService_multiPut_req_1.name_ref() = "req";
  meta_MetaService_multiPut_req_1.is_optional_ref() = false;
  auto meta_MetaService_multiPut_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::MultiPutReq>>("meta.MultiPutReq");
  meta_MetaService_multiPut_req_1_type->writeAndGenType(*meta_MetaService_multiPut_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_multiPut_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_get(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "get";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetResp>>("meta.GetResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_get_req_1;
  meta_MetaService_get_req_1.id_ref() = 1;
  meta_MetaService_get_req_1.name_ref() = "req";
  meta_MetaService_get_req_1.is_optional_ref() = false;
  auto meta_MetaService_get_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetReq>>("meta.GetReq");
  meta_MetaService_get_req_1_type->writeAndGenType(*meta_MetaService_get_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_get_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_multiGet(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "multiGet";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::MultiGetResp>>("meta.MultiGetResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_multiGet_req_1;
  meta_MetaService_multiGet_req_1.id_ref() = 1;
  meta_MetaService_multiGet_req_1.name_ref() = "req";
  meta_MetaService_multiGet_req_1.is_optional_ref() = false;
  auto meta_MetaService_multiGet_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::MultiGetReq>>("meta.MultiGetReq");
  meta_MetaService_multiGet_req_1_type->writeAndGenType(*meta_MetaService_multiGet_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_multiGet_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_remove(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "remove";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_remove_req_1;
  meta_MetaService_remove_req_1.id_ref() = 1;
  meta_MetaService_remove_req_1.name_ref() = "req";
  meta_MetaService_remove_req_1.is_optional_ref() = false;
  auto meta_MetaService_remove_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::RemoveReq>>("meta.RemoveReq");
  meta_MetaService_remove_req_1_type->writeAndGenType(*meta_MetaService_remove_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_remove_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_removeRange(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "removeRange";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_removeRange_req_1;
  meta_MetaService_removeRange_req_1.id_ref() = 1;
  meta_MetaService_removeRange_req_1.name_ref() = "req";
  meta_MetaService_removeRange_req_1.is_optional_ref() = false;
  auto meta_MetaService_removeRange_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::RemoveRangeReq>>("meta.RemoveRangeReq");
  meta_MetaService_removeRange_req_1_type->writeAndGenType(*meta_MetaService_removeRange_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_removeRange_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_scan(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "scan";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ScanResp>>("meta.ScanResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_scan_req_1;
  meta_MetaService_scan_req_1.id_ref() = 1;
  meta_MetaService_scan_req_1.name_ref() = "req";
  meta_MetaService_scan_req_1.is_optional_ref() = false;
  auto meta_MetaService_scan_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ScanReq>>("meta.ScanReq");
  meta_MetaService_scan_req_1_type->writeAndGenType(*meta_MetaService_scan_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_scan_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createTagIndex(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "createTagIndex";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_createTagIndex_req_1;
  meta_MetaService_createTagIndex_req_1.id_ref() = 1;
  meta_MetaService_createTagIndex_req_1.name_ref() = "req";
  meta_MetaService_createTagIndex_req_1.is_optional_ref() = false;
  auto meta_MetaService_createTagIndex_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::CreateTagIndexReq>>("meta.CreateTagIndexReq");
  meta_MetaService_createTagIndex_req_1_type->writeAndGenType(*meta_MetaService_createTagIndex_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_createTagIndex_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropTagIndex(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "dropTagIndex";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_dropTagIndex_req_1;
  meta_MetaService_dropTagIndex_req_1.id_ref() = 1;
  meta_MetaService_dropTagIndex_req_1.name_ref() = "req";
  meta_MetaService_dropTagIndex_req_1.is_optional_ref() = false;
  auto meta_MetaService_dropTagIndex_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::DropTagIndexReq>>("meta.DropTagIndexReq");
  meta_MetaService_dropTagIndex_req_1_type->writeAndGenType(*meta_MetaService_dropTagIndex_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_dropTagIndex_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getTagIndex(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "getTagIndex";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetTagIndexResp>>("meta.GetTagIndexResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_getTagIndex_req_1;
  meta_MetaService_getTagIndex_req_1.id_ref() = 1;
  meta_MetaService_getTagIndex_req_1.name_ref() = "req";
  meta_MetaService_getTagIndex_req_1.is_optional_ref() = false;
  auto meta_MetaService_getTagIndex_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetTagIndexReq>>("meta.GetTagIndexReq");
  meta_MetaService_getTagIndex_req_1_type->writeAndGenType(*meta_MetaService_getTagIndex_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_getTagIndex_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listTagIndexes(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listTagIndexes";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListTagIndexesResp>>("meta.ListTagIndexesResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_listTagIndexes_req_1;
  meta_MetaService_listTagIndexes_req_1.id_ref() = 1;
  meta_MetaService_listTagIndexes_req_1.name_ref() = "req";
  meta_MetaService_listTagIndexes_req_1.is_optional_ref() = false;
  auto meta_MetaService_listTagIndexes_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListTagIndexesReq>>("meta.ListTagIndexesReq");
  meta_MetaService_listTagIndexes_req_1_type->writeAndGenType(*meta_MetaService_listTagIndexes_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_listTagIndexes_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_rebuildTagIndex(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "rebuildTagIndex";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_rebuildTagIndex_req_1;
  meta_MetaService_rebuildTagIndex_req_1.id_ref() = 1;
  meta_MetaService_rebuildTagIndex_req_1.name_ref() = "req";
  meta_MetaService_rebuildTagIndex_req_1.is_optional_ref() = false;
  auto meta_MetaService_rebuildTagIndex_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::RebuildIndexReq>>("meta.RebuildIndexReq");
  meta_MetaService_rebuildTagIndex_req_1_type->writeAndGenType(*meta_MetaService_rebuildTagIndex_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_rebuildTagIndex_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listTagIndexStatus(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listTagIndexStatus";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListIndexStatusResp>>("meta.ListIndexStatusResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_listTagIndexStatus_req_1;
  meta_MetaService_listTagIndexStatus_req_1.id_ref() = 1;
  meta_MetaService_listTagIndexStatus_req_1.name_ref() = "req";
  meta_MetaService_listTagIndexStatus_req_1.is_optional_ref() = false;
  auto meta_MetaService_listTagIndexStatus_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListIndexStatusReq>>("meta.ListIndexStatusReq");
  meta_MetaService_listTagIndexStatus_req_1_type->writeAndGenType(*meta_MetaService_listTagIndexStatus_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_listTagIndexStatus_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createEdgeIndex(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "createEdgeIndex";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_createEdgeIndex_req_1;
  meta_MetaService_createEdgeIndex_req_1.id_ref() = 1;
  meta_MetaService_createEdgeIndex_req_1.name_ref() = "req";
  meta_MetaService_createEdgeIndex_req_1.is_optional_ref() = false;
  auto meta_MetaService_createEdgeIndex_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::CreateEdgeIndexReq>>("meta.CreateEdgeIndexReq");
  meta_MetaService_createEdgeIndex_req_1_type->writeAndGenType(*meta_MetaService_createEdgeIndex_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_createEdgeIndex_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropEdgeIndex(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "dropEdgeIndex";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_dropEdgeIndex_req_1;
  meta_MetaService_dropEdgeIndex_req_1.id_ref() = 1;
  meta_MetaService_dropEdgeIndex_req_1.name_ref() = "req";
  meta_MetaService_dropEdgeIndex_req_1.is_optional_ref() = false;
  auto meta_MetaService_dropEdgeIndex_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::DropEdgeIndexReq>>("meta.DropEdgeIndexReq");
  meta_MetaService_dropEdgeIndex_req_1_type->writeAndGenType(*meta_MetaService_dropEdgeIndex_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_dropEdgeIndex_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getEdgeIndex(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "getEdgeIndex";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetEdgeIndexResp>>("meta.GetEdgeIndexResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_getEdgeIndex_req_1;
  meta_MetaService_getEdgeIndex_req_1.id_ref() = 1;
  meta_MetaService_getEdgeIndex_req_1.name_ref() = "req";
  meta_MetaService_getEdgeIndex_req_1.is_optional_ref() = false;
  auto meta_MetaService_getEdgeIndex_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetEdgeIndexReq>>("meta.GetEdgeIndexReq");
  meta_MetaService_getEdgeIndex_req_1_type->writeAndGenType(*meta_MetaService_getEdgeIndex_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_getEdgeIndex_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listEdgeIndexes(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listEdgeIndexes";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListEdgeIndexesResp>>("meta.ListEdgeIndexesResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_listEdgeIndexes_req_1;
  meta_MetaService_listEdgeIndexes_req_1.id_ref() = 1;
  meta_MetaService_listEdgeIndexes_req_1.name_ref() = "req";
  meta_MetaService_listEdgeIndexes_req_1.is_optional_ref() = false;
  auto meta_MetaService_listEdgeIndexes_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListEdgeIndexesReq>>("meta.ListEdgeIndexesReq");
  meta_MetaService_listEdgeIndexes_req_1_type->writeAndGenType(*meta_MetaService_listEdgeIndexes_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_listEdgeIndexes_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_rebuildEdgeIndex(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "rebuildEdgeIndex";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_rebuildEdgeIndex_req_1;
  meta_MetaService_rebuildEdgeIndex_req_1.id_ref() = 1;
  meta_MetaService_rebuildEdgeIndex_req_1.name_ref() = "req";
  meta_MetaService_rebuildEdgeIndex_req_1.is_optional_ref() = false;
  auto meta_MetaService_rebuildEdgeIndex_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::RebuildIndexReq>>("meta.RebuildIndexReq");
  meta_MetaService_rebuildEdgeIndex_req_1_type->writeAndGenType(*meta_MetaService_rebuildEdgeIndex_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_rebuildEdgeIndex_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listEdgeIndexStatus(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listEdgeIndexStatus";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListIndexStatusResp>>("meta.ListIndexStatusResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_listEdgeIndexStatus_req_1;
  meta_MetaService_listEdgeIndexStatus_req_1.id_ref() = 1;
  meta_MetaService_listEdgeIndexStatus_req_1.name_ref() = "req";
  meta_MetaService_listEdgeIndexStatus_req_1.is_optional_ref() = false;
  auto meta_MetaService_listEdgeIndexStatus_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListIndexStatusReq>>("meta.ListIndexStatusReq");
  meta_MetaService_listEdgeIndexStatus_req_1_type->writeAndGenType(*meta_MetaService_listEdgeIndexStatus_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_listEdgeIndexStatus_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createUser(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "createUser";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_createUser_req_1;
  meta_MetaService_createUser_req_1.id_ref() = 1;
  meta_MetaService_createUser_req_1.name_ref() = "req";
  meta_MetaService_createUser_req_1.is_optional_ref() = false;
  auto meta_MetaService_createUser_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::CreateUserReq>>("meta.CreateUserReq");
  meta_MetaService_createUser_req_1_type->writeAndGenType(*meta_MetaService_createUser_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_createUser_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropUser(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "dropUser";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_dropUser_req_1;
  meta_MetaService_dropUser_req_1.id_ref() = 1;
  meta_MetaService_dropUser_req_1.name_ref() = "req";
  meta_MetaService_dropUser_req_1.is_optional_ref() = false;
  auto meta_MetaService_dropUser_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::DropUserReq>>("meta.DropUserReq");
  meta_MetaService_dropUser_req_1_type->writeAndGenType(*meta_MetaService_dropUser_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_dropUser_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_alterUser(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "alterUser";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_alterUser_req_1;
  meta_MetaService_alterUser_req_1.id_ref() = 1;
  meta_MetaService_alterUser_req_1.name_ref() = "req";
  meta_MetaService_alterUser_req_1.is_optional_ref() = false;
  auto meta_MetaService_alterUser_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::AlterUserReq>>("meta.AlterUserReq");
  meta_MetaService_alterUser_req_1_type->writeAndGenType(*meta_MetaService_alterUser_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_alterUser_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_grantRole(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "grantRole";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_grantRole_req_1;
  meta_MetaService_grantRole_req_1.id_ref() = 1;
  meta_MetaService_grantRole_req_1.name_ref() = "req";
  meta_MetaService_grantRole_req_1.is_optional_ref() = false;
  auto meta_MetaService_grantRole_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::GrantRoleReq>>("meta.GrantRoleReq");
  meta_MetaService_grantRole_req_1_type->writeAndGenType(*meta_MetaService_grantRole_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_grantRole_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_revokeRole(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "revokeRole";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_revokeRole_req_1;
  meta_MetaService_revokeRole_req_1.id_ref() = 1;
  meta_MetaService_revokeRole_req_1.name_ref() = "req";
  meta_MetaService_revokeRole_req_1.is_optional_ref() = false;
  auto meta_MetaService_revokeRole_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::RevokeRoleReq>>("meta.RevokeRoleReq");
  meta_MetaService_revokeRole_req_1_type->writeAndGenType(*meta_MetaService_revokeRole_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_revokeRole_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listUsers(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listUsers";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListUsersResp>>("meta.ListUsersResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_listUsers_req_1;
  meta_MetaService_listUsers_req_1.id_ref() = 1;
  meta_MetaService_listUsers_req_1.name_ref() = "req";
  meta_MetaService_listUsers_req_1.is_optional_ref() = false;
  auto meta_MetaService_listUsers_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListUsersReq>>("meta.ListUsersReq");
  meta_MetaService_listUsers_req_1_type->writeAndGenType(*meta_MetaService_listUsers_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_listUsers_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listRoles(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listRoles";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListRolesResp>>("meta.ListRolesResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_listRoles_req_1;
  meta_MetaService_listRoles_req_1.id_ref() = 1;
  meta_MetaService_listRoles_req_1.name_ref() = "req";
  meta_MetaService_listRoles_req_1.is_optional_ref() = false;
  auto meta_MetaService_listRoles_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListRolesReq>>("meta.ListRolesReq");
  meta_MetaService_listRoles_req_1_type->writeAndGenType(*meta_MetaService_listRoles_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_listRoles_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getUserRoles(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "getUserRoles";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListRolesResp>>("meta.ListRolesResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_getUserRoles_req_1;
  meta_MetaService_getUserRoles_req_1.id_ref() = 1;
  meta_MetaService_getUserRoles_req_1.name_ref() = "req";
  meta_MetaService_getUserRoles_req_1.is_optional_ref() = false;
  auto meta_MetaService_getUserRoles_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetUserRolesReq>>("meta.GetUserRolesReq");
  meta_MetaService_getUserRoles_req_1_type->writeAndGenType(*meta_MetaService_getUserRoles_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_getUserRoles_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_changePassword(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "changePassword";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_changePassword_req_1;
  meta_MetaService_changePassword_req_1.id_ref() = 1;
  meta_MetaService_changePassword_req_1.name_ref() = "req";
  meta_MetaService_changePassword_req_1.is_optional_ref() = false;
  auto meta_MetaService_changePassword_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ChangePasswordReq>>("meta.ChangePasswordReq");
  meta_MetaService_changePassword_req_1_type->writeAndGenType(*meta_MetaService_changePassword_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_changePassword_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_heartBeat(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "heartBeat";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::HBResp>>("meta.HBResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_heartBeat_req_1;
  meta_MetaService_heartBeat_req_1.id_ref() = 1;
  meta_MetaService_heartBeat_req_1.name_ref() = "req";
  meta_MetaService_heartBeat_req_1.is_optional_ref() = false;
  auto meta_MetaService_heartBeat_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::HBReq>>("meta.HBReq");
  meta_MetaService_heartBeat_req_1_type->writeAndGenType(*meta_MetaService_heartBeat_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_heartBeat_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_regConfig(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "regConfig";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_regConfig_req_1;
  meta_MetaService_regConfig_req_1.id_ref() = 1;
  meta_MetaService_regConfig_req_1.name_ref() = "req";
  meta_MetaService_regConfig_req_1.is_optional_ref() = false;
  auto meta_MetaService_regConfig_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::RegConfigReq>>("meta.RegConfigReq");
  meta_MetaService_regConfig_req_1_type->writeAndGenType(*meta_MetaService_regConfig_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_regConfig_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getConfig(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "getConfig";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetConfigResp>>("meta.GetConfigResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_getConfig_req_1;
  meta_MetaService_getConfig_req_1.id_ref() = 1;
  meta_MetaService_getConfig_req_1.name_ref() = "req";
  meta_MetaService_getConfig_req_1.is_optional_ref() = false;
  auto meta_MetaService_getConfig_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetConfigReq>>("meta.GetConfigReq");
  meta_MetaService_getConfig_req_1_type->writeAndGenType(*meta_MetaService_getConfig_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_getConfig_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_setConfig(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "setConfig";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_setConfig_req_1;
  meta_MetaService_setConfig_req_1.id_ref() = 1;
  meta_MetaService_setConfig_req_1.name_ref() = "req";
  meta_MetaService_setConfig_req_1.is_optional_ref() = false;
  auto meta_MetaService_setConfig_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::SetConfigReq>>("meta.SetConfigReq");
  meta_MetaService_setConfig_req_1_type->writeAndGenType(*meta_MetaService_setConfig_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_setConfig_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listConfigs(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listConfigs";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListConfigsResp>>("meta.ListConfigsResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_listConfigs_req_1;
  meta_MetaService_listConfigs_req_1.id_ref() = 1;
  meta_MetaService_listConfigs_req_1.name_ref() = "req";
  meta_MetaService_listConfigs_req_1.is_optional_ref() = false;
  auto meta_MetaService_listConfigs_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListConfigsReq>>("meta.ListConfigsReq");
  meta_MetaService_listConfigs_req_1_type->writeAndGenType(*meta_MetaService_listConfigs_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_listConfigs_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createSnapshot(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "createSnapshot";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_createSnapshot_req_1;
  meta_MetaService_createSnapshot_req_1.id_ref() = 1;
  meta_MetaService_createSnapshot_req_1.name_ref() = "req";
  meta_MetaService_createSnapshot_req_1.is_optional_ref() = false;
  auto meta_MetaService_createSnapshot_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::CreateSnapshotReq>>("meta.CreateSnapshotReq");
  meta_MetaService_createSnapshot_req_1_type->writeAndGenType(*meta_MetaService_createSnapshot_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_createSnapshot_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropSnapshot(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "dropSnapshot";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_dropSnapshot_req_1;
  meta_MetaService_dropSnapshot_req_1.id_ref() = 1;
  meta_MetaService_dropSnapshot_req_1.name_ref() = "req";
  meta_MetaService_dropSnapshot_req_1.is_optional_ref() = false;
  auto meta_MetaService_dropSnapshot_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::DropSnapshotReq>>("meta.DropSnapshotReq");
  meta_MetaService_dropSnapshot_req_1_type->writeAndGenType(*meta_MetaService_dropSnapshot_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_dropSnapshot_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listSnapshots(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listSnapshots";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListSnapshotsResp>>("meta.ListSnapshotsResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_listSnapshots_req_1;
  meta_MetaService_listSnapshots_req_1.id_ref() = 1;
  meta_MetaService_listSnapshots_req_1.name_ref() = "req";
  meta_MetaService_listSnapshots_req_1.is_optional_ref() = false;
  auto meta_MetaService_listSnapshots_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListSnapshotsReq>>("meta.ListSnapshotsReq");
  meta_MetaService_listSnapshots_req_1_type->writeAndGenType(*meta_MetaService_listSnapshots_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_listSnapshots_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_runAdminJob(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "runAdminJob";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::AdminJobResp>>("meta.AdminJobResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_runAdminJob_req_1;
  meta_MetaService_runAdminJob_req_1.id_ref() = 1;
  meta_MetaService_runAdminJob_req_1.name_ref() = "req";
  meta_MetaService_runAdminJob_req_1.is_optional_ref() = false;
  auto meta_MetaService_runAdminJob_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::AdminJobReq>>("meta.AdminJobReq");
  meta_MetaService_runAdminJob_req_1_type->writeAndGenType(*meta_MetaService_runAdminJob_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_runAdminJob_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_mergeZone(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "mergeZone";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_mergeZone_req_1;
  meta_MetaService_mergeZone_req_1.id_ref() = 1;
  meta_MetaService_mergeZone_req_1.name_ref() = "req";
  meta_MetaService_mergeZone_req_1.is_optional_ref() = false;
  auto meta_MetaService_mergeZone_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::MergeZoneReq>>("meta.MergeZoneReq");
  meta_MetaService_mergeZone_req_1_type->writeAndGenType(*meta_MetaService_mergeZone_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_mergeZone_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropZone(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "dropZone";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_dropZone_req_1;
  meta_MetaService_dropZone_req_1.id_ref() = 1;
  meta_MetaService_dropZone_req_1.name_ref() = "req";
  meta_MetaService_dropZone_req_1.is_optional_ref() = false;
  auto meta_MetaService_dropZone_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::DropZoneReq>>("meta.DropZoneReq");
  meta_MetaService_dropZone_req_1_type->writeAndGenType(*meta_MetaService_dropZone_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_dropZone_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_splitZone(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "splitZone";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_splitZone_req_1;
  meta_MetaService_splitZone_req_1.id_ref() = 1;
  meta_MetaService_splitZone_req_1.name_ref() = "req";
  meta_MetaService_splitZone_req_1.is_optional_ref() = false;
  auto meta_MetaService_splitZone_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::SplitZoneReq>>("meta.SplitZoneReq");
  meta_MetaService_splitZone_req_1_type->writeAndGenType(*meta_MetaService_splitZone_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_splitZone_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_renameZone(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "renameZone";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_renameZone_req_1;
  meta_MetaService_renameZone_req_1.id_ref() = 1;
  meta_MetaService_renameZone_req_1.name_ref() = "req";
  meta_MetaService_renameZone_req_1.is_optional_ref() = false;
  auto meta_MetaService_renameZone_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::RenameZoneReq>>("meta.RenameZoneReq");
  meta_MetaService_renameZone_req_1_type->writeAndGenType(*meta_MetaService_renameZone_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_renameZone_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getZone(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "getZone";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetZoneResp>>("meta.GetZoneResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_getZone_req_1;
  meta_MetaService_getZone_req_1.id_ref() = 1;
  meta_MetaService_getZone_req_1.name_ref() = "req";
  meta_MetaService_getZone_req_1.is_optional_ref() = false;
  auto meta_MetaService_getZone_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetZoneReq>>("meta.GetZoneReq");
  meta_MetaService_getZone_req_1_type->writeAndGenType(*meta_MetaService_getZone_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_getZone_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listZones(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listZones";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListZonesResp>>("meta.ListZonesResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_listZones_req_1;
  meta_MetaService_listZones_req_1.id_ref() = 1;
  meta_MetaService_listZones_req_1.name_ref() = "req";
  meta_MetaService_listZones_req_1.is_optional_ref() = false;
  auto meta_MetaService_listZones_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListZonesReq>>("meta.ListZonesReq");
  meta_MetaService_listZones_req_1_type->writeAndGenType(*meta_MetaService_listZones_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_listZones_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createBackup(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "createBackup";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::CreateBackupResp>>("meta.CreateBackupResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_createBackup_req_1;
  meta_MetaService_createBackup_req_1.id_ref() = 1;
  meta_MetaService_createBackup_req_1.name_ref() = "req";
  meta_MetaService_createBackup_req_1.is_optional_ref() = false;
  auto meta_MetaService_createBackup_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::CreateBackupReq>>("meta.CreateBackupReq");
  meta_MetaService_createBackup_req_1_type->writeAndGenType(*meta_MetaService_createBackup_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_createBackup_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_restoreMeta(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "restoreMeta";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_restoreMeta_req_1;
  meta_MetaService_restoreMeta_req_1.id_ref() = 1;
  meta_MetaService_restoreMeta_req_1.name_ref() = "req";
  meta_MetaService_restoreMeta_req_1.is_optional_ref() = false;
  auto meta_MetaService_restoreMeta_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::RestoreMetaReq>>("meta.RestoreMetaReq");
  meta_MetaService_restoreMeta_req_1_type->writeAndGenType(*meta_MetaService_restoreMeta_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_restoreMeta_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_addListener(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "addListener";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_addListener_req_1;
  meta_MetaService_addListener_req_1.id_ref() = 1;
  meta_MetaService_addListener_req_1.name_ref() = "req";
  meta_MetaService_addListener_req_1.is_optional_ref() = false;
  auto meta_MetaService_addListener_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::AddListenerReq>>("meta.AddListenerReq");
  meta_MetaService_addListener_req_1_type->writeAndGenType(*meta_MetaService_addListener_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_addListener_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_removeListener(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "removeListener";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_removeListener_req_1;
  meta_MetaService_removeListener_req_1.id_ref() = 1;
  meta_MetaService_removeListener_req_1.name_ref() = "req";
  meta_MetaService_removeListener_req_1.is_optional_ref() = false;
  auto meta_MetaService_removeListener_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::RemoveListenerReq>>("meta.RemoveListenerReq");
  meta_MetaService_removeListener_req_1_type->writeAndGenType(*meta_MetaService_removeListener_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_removeListener_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listListener(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listListener";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListListenerResp>>("meta.ListListenerResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_listListener_req_1;
  meta_MetaService_listListener_req_1.id_ref() = 1;
  meta_MetaService_listListener_req_1.name_ref() = "req";
  meta_MetaService_listListener_req_1.is_optional_ref() = false;
  auto meta_MetaService_listListener_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListListenerReq>>("meta.ListListenerReq");
  meta_MetaService_listListener_req_1_type->writeAndGenType(*meta_MetaService_listListener_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_listListener_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getStats(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "getStats";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetStatsResp>>("meta.GetStatsResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_getStats_req_1;
  meta_MetaService_getStats_req_1.id_ref() = 1;
  meta_MetaService_getStats_req_1.name_ref() = "req";
  meta_MetaService_getStats_req_1.is_optional_ref() = false;
  auto meta_MetaService_getStats_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetStatsReq>>("meta.GetStatsReq");
  meta_MetaService_getStats_req_1_type->writeAndGenType(*meta_MetaService_getStats_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_getStats_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_signInFTService(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "signInFTService";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_signInFTService_req_1;
  meta_MetaService_signInFTService_req_1.id_ref() = 1;
  meta_MetaService_signInFTService_req_1.name_ref() = "req";
  meta_MetaService_signInFTService_req_1.is_optional_ref() = false;
  auto meta_MetaService_signInFTService_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::SignInFTServiceReq>>("meta.SignInFTServiceReq");
  meta_MetaService_signInFTService_req_1_type->writeAndGenType(*meta_MetaService_signInFTService_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_signInFTService_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_signOutFTService(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "signOutFTService";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_signOutFTService_req_1;
  meta_MetaService_signOutFTService_req_1.id_ref() = 1;
  meta_MetaService_signOutFTService_req_1.name_ref() = "req";
  meta_MetaService_signOutFTService_req_1.is_optional_ref() = false;
  auto meta_MetaService_signOutFTService_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::SignOutFTServiceReq>>("meta.SignOutFTServiceReq");
  meta_MetaService_signOutFTService_req_1_type->writeAndGenType(*meta_MetaService_signOutFTService_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_signOutFTService_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listFTClients(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listFTClients";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListFTClientsResp>>("meta.ListFTClientsResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_listFTClients_req_1;
  meta_MetaService_listFTClients_req_1.id_ref() = 1;
  meta_MetaService_listFTClients_req_1.name_ref() = "req";
  meta_MetaService_listFTClients_req_1.is_optional_ref() = false;
  auto meta_MetaService_listFTClients_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListFTClientsReq>>("meta.ListFTClientsReq");
  meta_MetaService_listFTClients_req_1_type->writeAndGenType(*meta_MetaService_listFTClients_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_listFTClients_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createFTIndex(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "createFTIndex";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_createFTIndex_req_1;
  meta_MetaService_createFTIndex_req_1.id_ref() = 1;
  meta_MetaService_createFTIndex_req_1.name_ref() = "req";
  meta_MetaService_createFTIndex_req_1.is_optional_ref() = false;
  auto meta_MetaService_createFTIndex_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::CreateFTIndexReq>>("meta.CreateFTIndexReq");
  meta_MetaService_createFTIndex_req_1_type->writeAndGenType(*meta_MetaService_createFTIndex_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_createFTIndex_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropFTIndex(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "dropFTIndex";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_dropFTIndex_req_1;
  meta_MetaService_dropFTIndex_req_1.id_ref() = 1;
  meta_MetaService_dropFTIndex_req_1.name_ref() = "req";
  meta_MetaService_dropFTIndex_req_1.is_optional_ref() = false;
  auto meta_MetaService_dropFTIndex_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::DropFTIndexReq>>("meta.DropFTIndexReq");
  meta_MetaService_dropFTIndex_req_1_type->writeAndGenType(*meta_MetaService_dropFTIndex_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_dropFTIndex_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listFTIndexes(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listFTIndexes";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListFTIndexesResp>>("meta.ListFTIndexesResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_listFTIndexes_req_1;
  meta_MetaService_listFTIndexes_req_1.id_ref() = 1;
  meta_MetaService_listFTIndexes_req_1.name_ref() = "req";
  meta_MetaService_listFTIndexes_req_1.is_optional_ref() = false;
  auto meta_MetaService_listFTIndexes_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListFTIndexesReq>>("meta.ListFTIndexesReq");
  meta_MetaService_listFTIndexes_req_1_type->writeAndGenType(*meta_MetaService_listFTIndexes_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_listFTIndexes_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createSession(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "createSession";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::CreateSessionResp>>("meta.CreateSessionResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_createSession_req_1;
  meta_MetaService_createSession_req_1.id_ref() = 1;
  meta_MetaService_createSession_req_1.name_ref() = "req";
  meta_MetaService_createSession_req_1.is_optional_ref() = false;
  auto meta_MetaService_createSession_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::CreateSessionReq>>("meta.CreateSessionReq");
  meta_MetaService_createSession_req_1_type->writeAndGenType(*meta_MetaService_createSession_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_createSession_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_updateSessions(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "updateSessions";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::UpdateSessionsResp>>("meta.UpdateSessionsResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_updateSessions_req_1;
  meta_MetaService_updateSessions_req_1.id_ref() = 1;
  meta_MetaService_updateSessions_req_1.name_ref() = "req";
  meta_MetaService_updateSessions_req_1.is_optional_ref() = false;
  auto meta_MetaService_updateSessions_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::UpdateSessionsReq>>("meta.UpdateSessionsReq");
  meta_MetaService_updateSessions_req_1_type->writeAndGenType(*meta_MetaService_updateSessions_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_updateSessions_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listSessions(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listSessions";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListSessionsResp>>("meta.ListSessionsResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_listSessions_req_1;
  meta_MetaService_listSessions_req_1.id_ref() = 1;
  meta_MetaService_listSessions_req_1.name_ref() = "req";
  meta_MetaService_listSessions_req_1.is_optional_ref() = false;
  auto meta_MetaService_listSessions_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListSessionsReq>>("meta.ListSessionsReq");
  meta_MetaService_listSessions_req_1_type->writeAndGenType(*meta_MetaService_listSessions_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_listSessions_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getSession(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "getSession";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetSessionResp>>("meta.GetSessionResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_getSession_req_1;
  meta_MetaService_getSession_req_1.id_ref() = 1;
  meta_MetaService_getSession_req_1.name_ref() = "req";
  meta_MetaService_getSession_req_1.is_optional_ref() = false;
  auto meta_MetaService_getSession_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetSessionReq>>("meta.GetSessionReq");
  meta_MetaService_getSession_req_1_type->writeAndGenType(*meta_MetaService_getSession_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_getSession_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_removeSession(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "removeSession";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_removeSession_req_1;
  meta_MetaService_removeSession_req_1.id_ref() = 1;
  meta_MetaService_removeSession_req_1.name_ref() = "req";
  meta_MetaService_removeSession_req_1.is_optional_ref() = false;
  auto meta_MetaService_removeSession_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::RemoveSessionReq>>("meta.RemoveSessionReq");
  meta_MetaService_removeSession_req_1_type->writeAndGenType(*meta_MetaService_removeSession_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_removeSession_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_killQuery(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "killQuery";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_killQuery_req_1;
  meta_MetaService_killQuery_req_1.id_ref() = 1;
  meta_MetaService_killQuery_req_1.name_ref() = "req";
  meta_MetaService_killQuery_req_1.is_optional_ref() = false;
  auto meta_MetaService_killQuery_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::KillQueryReq>>("meta.KillQueryReq");
  meta_MetaService_killQuery_req_1_type->writeAndGenType(*meta_MetaService_killQuery_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_killQuery_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_reportTaskFinish(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "reportTaskFinish";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ExecResp>>("meta.ExecResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_reportTaskFinish_req_1;
  meta_MetaService_reportTaskFinish_req_1.id_ref() = 1;
  meta_MetaService_reportTaskFinish_req_1.name_ref() = "req";
  meta_MetaService_reportTaskFinish_req_1.is_optional_ref() = false;
  auto meta_MetaService_reportTaskFinish_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ReportTaskReq>>("meta.ReportTaskReq");
  meta_MetaService_reportTaskFinish_req_1_type->writeAndGenType(*meta_MetaService_reportTaskFinish_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_reportTaskFinish_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listCluster(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "listCluster";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListClusterInfoResp>>("meta.ListClusterInfoResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_listCluster_req_1;
  meta_MetaService_listCluster_req_1.id_ref() = 1;
  meta_MetaService_listCluster_req_1.name_ref() = "req";
  meta_MetaService_listCluster_req_1.is_optional_ref() = false;
  auto meta_MetaService_listCluster_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::ListClusterInfoReq>>("meta.ListClusterInfoReq");
  meta_MetaService_listCluster_req_1_type->writeAndGenType(*meta_MetaService_listCluster_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_listCluster_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getMetaDirInfo(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "getMetaDirInfo";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetMetaDirInfoResp>>("meta.GetMetaDirInfoResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_getMetaDirInfo_req_1;
  meta_MetaService_getMetaDirInfo_req_1.id_ref() = 1;
  meta_MetaService_getMetaDirInfo_req_1.name_ref() = "req";
  meta_MetaService_getMetaDirInfo_req_1.is_optional_ref() = false;
  auto meta_MetaService_getMetaDirInfo_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::GetMetaDirInfoReq>>("meta.GetMetaDirInfoReq");
  meta_MetaService_getMetaDirInfo_req_1_type->writeAndGenType(*meta_MetaService_getMetaDirInfo_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_getMetaDirInfo_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_verifyClientVersion(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "verifyClientVersion";
  auto func_ret_type = std::make_unique<Struct< ::nebula::meta::cpp2::VerifyClientVersionResp>>("meta.VerifyClientVersionResp");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField meta_MetaService_verifyClientVersion_req_1;
  meta_MetaService_verifyClientVersion_req_1.id_ref() = 1;
  meta_MetaService_verifyClientVersion_req_1.name_ref() = "req";
  meta_MetaService_verifyClientVersion_req_1.is_optional_ref() = false;
  auto meta_MetaService_verifyClientVersion_req_1_type = std::make_unique<Struct< ::nebula::meta::cpp2::VerifyClientVersionReq>>("meta.VerifyClientVersionReq");
  meta_MetaService_verifyClientVersion_req_1_type->writeAndGenType(*meta_MetaService_verifyClientVersion_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(meta_MetaService_verifyClientVersion_req_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}

void ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen(ThriftMetadata& metadata, ThriftServiceContext& context) {
  (void) metadata;
  ::apache::thrift::metadata::ThriftService meta_MetaService;
  meta_MetaService.name_ref() = "meta.MetaService";
  static const ThriftFunctionGenerator functions[] = {
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createSpace,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropSpace,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getSpace,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listSpaces,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createSpaceAs,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createTag,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_alterTag,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropTag,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getTag,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listTags,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createEdge,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_alterEdge,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropEdge,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getEdge,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listEdges,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_addHosts,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_addHostsIntoZone,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropHosts,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listHosts,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getPartsAlloc,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listParts,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_multiPut,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_get,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_multiGet,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_remove,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_removeRange,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_scan,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createTagIndex,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropTagIndex,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getTagIndex,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listTagIndexes,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_rebuildTagIndex,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listTagIndexStatus,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createEdgeIndex,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropEdgeIndex,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getEdgeIndex,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listEdgeIndexes,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_rebuildEdgeIndex,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listEdgeIndexStatus,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createUser,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropUser,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_alterUser,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_grantRole,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_revokeRole,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listUsers,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listRoles,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getUserRoles,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_changePassword,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_heartBeat,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_regConfig,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getConfig,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_setConfig,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listConfigs,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createSnapshot,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropSnapshot,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listSnapshots,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_runAdminJob,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_mergeZone,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropZone,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_splitZone,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_renameZone,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getZone,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listZones,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createBackup,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_restoreMeta,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_addListener,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_removeListener,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listListener,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getStats,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_signInFTService,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_signOutFTService,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listFTClients,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createFTIndex,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_dropFTIndex,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listFTIndexes,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_createSession,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_updateSessions,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listSessions,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getSession,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_removeSession,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_killQuery,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_reportTaskFinish,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_listCluster,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_getMetaDirInfo,
    ServiceMetadata<::nebula::meta::cpp2::MetaServiceSvIf>::gen_verifyClientVersion,
  };
  for (auto& function_gen : functions) {
    function_gen(metadata, meta_MetaService);
  }
  context.service_info_ref() = std::move(meta_MetaService);
  ::apache::thrift::metadata::ThriftModuleContext module;
  module.name_ref() = "meta";
  context.module_ref() = std::move(module);
}
} // namespace md
} // namespace detail
} // namespace thrift
} // namespace apache
