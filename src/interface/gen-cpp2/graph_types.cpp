/**
 * Autogenerated by Thrift for graph.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "graph_types.h"
#include "graph_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "graph_data.h"


namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::graph::cpp2::ProfilingStats>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::graph::cpp2::ProfilingStats>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace graph { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ProfilingStats::ProfilingStats(apache::thrift::FragileConstructor, int64_t rows__arg, int64_t exec_duration_in_us__arg, int64_t total_duration_in_us__arg, std::unordered_map<::std::string, ::std::string> other_stats__arg) :
    rows(std::move(rows__arg)),
    exec_duration_in_us(std::move(exec_duration_in_us__arg)),
    total_duration_in_us(std::move(total_duration_in_us__arg)),
    other_stats(std::move(other_stats__arg)) {
  __isset.other_stats = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ProfilingStats::__clear() {
  // clear all fields
  rows = 0;
  exec_duration_in_us = 0;
  total_duration_in_us = 0;
  other_stats.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ProfilingStats::operator==(const ProfilingStats& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.rows == rhs.rows)) {
    return false;
  }
  if (!(lhs.exec_duration_in_us == rhs.exec_duration_in_us)) {
    return false;
  }
  if (!(lhs.total_duration_in_us == rhs.total_duration_in_us)) {
    return false;
  }
  if (lhs.other_stats_ref() != rhs.other_stats_ref()) {
    return false;
  }
  return true;
}

const std::unordered_map<::std::string, ::std::string>* ProfilingStats::get_other_stats() const& {
  return other_stats_ref().has_value() ? std::addressof(other_stats) : nullptr;
}

std::unordered_map<::std::string, ::std::string>* ProfilingStats::get_other_stats() & {
  return other_stats_ref().has_value() ? std::addressof(other_stats) : nullptr;
}


void swap(ProfilingStats& a, ProfilingStats& b) {
  using ::std::swap;
  swap(a.rows_ref().value(), b.rows_ref().value());
  swap(a.exec_duration_in_us_ref().value(), b.exec_duration_in_us_ref().value());
  swap(a.total_duration_in_us_ref().value(), b.total_duration_in_us_ref().value());
  swap(a.other_stats_ref().value_unchecked(), b.other_stats_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ProfilingStats::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ProfilingStats::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ProfilingStats::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ProfilingStats::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ProfilingStats::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ProfilingStats::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ProfilingStats::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ProfilingStats::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::graph::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::graph::cpp2::PlanNodeBranchInfo>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::graph::cpp2::PlanNodeBranchInfo>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace graph { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PlanNodeBranchInfo::PlanNodeBranchInfo(apache::thrift::FragileConstructor, bool is_do_branch__arg, int64_t condition_node_id__arg) :
    is_do_branch(std::move(is_do_branch__arg)),
    condition_node_id(std::move(condition_node_id__arg)) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void PlanNodeBranchInfo::__clear() {
  // clear all fields
  is_do_branch = 0;
  condition_node_id = 0;
}

bool PlanNodeBranchInfo::operator==(const PlanNodeBranchInfo& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.is_do_branch == rhs.is_do_branch)) {
    return false;
  }
  if (!(lhs.condition_node_id == rhs.condition_node_id)) {
    return false;
  }
  return true;
}

bool PlanNodeBranchInfo::operator<(const PlanNodeBranchInfo& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.is_do_branch == rhs.is_do_branch)) {
    return lhs.is_do_branch < rhs.is_do_branch;
  }
  if (!(lhs.condition_node_id == rhs.condition_node_id)) {
    return lhs.condition_node_id < rhs.condition_node_id;
  }
  return false;
}


void swap(PlanNodeBranchInfo& a, PlanNodeBranchInfo& b) {
  using ::std::swap;
  swap(a.is_do_branch_ref().value(), b.is_do_branch_ref().value());
  swap(a.condition_node_id_ref().value(), b.condition_node_id_ref().value());
}

template void PlanNodeBranchInfo::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PlanNodeBranchInfo::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PlanNodeBranchInfo::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PlanNodeBranchInfo::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PlanNodeBranchInfo::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PlanNodeBranchInfo::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PlanNodeBranchInfo::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PlanNodeBranchInfo::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::graph::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::graph::cpp2::Pair>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::graph::cpp2::Pair>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace graph { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Pair::Pair(apache::thrift::FragileConstructor, ::std::string key__arg, ::std::string value__arg) :
    key(std::move(key__arg)),
    value(std::move(value__arg)) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Pair::__clear() {
  // clear all fields
  key = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  value = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
}

bool Pair::operator==(const Pair& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.key, rhs.key)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.value, rhs.value)) {
    return false;
  }
  return true;
}

bool Pair::operator<(const Pair& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.key, rhs.key)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.key, rhs.key);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.value, rhs.value)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.value, rhs.value);
  }
  return false;
}


void swap(Pair& a, Pair& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.value_ref().value(), b.value_ref().value());
}

template void Pair::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Pair::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Pair::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Pair::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Pair::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Pair::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Pair::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Pair::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::graph::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::graph::cpp2::PlanNodeDescription>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::graph::cpp2::PlanNodeDescription>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace graph { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PlanNodeDescription::PlanNodeDescription() :
      id(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


PlanNodeDescription::~PlanNodeDescription() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PlanNodeDescription::PlanNodeDescription(apache::thrift::FragileConstructor, ::std::string name__arg, int64_t id__arg, ::std::string output_var__arg, ::std::vector<nebula::Pair> description__arg, ::std::vector<nebula::ProfilingStats> profiles__arg, nebula::PlanNodeBranchInfo branch_info__arg, ::std::vector<int64_t> dependencies__arg) :
    name(std::move(name__arg)),
    id(std::move(id__arg)),
    output_var(std::move(output_var__arg)),
    description(std::move(description__arg)),
    profiles(std::move(profiles__arg)),
    branch_info(std::move(branch_info__arg)),
    dependencies(std::move(dependencies__arg)) {
  __isset.description = true;
  __isset.profiles = true;
  __isset.branch_info = true;
  __isset.dependencies = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void PlanNodeDescription::__clear() {
  // clear all fields
  name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  id = 0;
  output_var = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  description.clear();
  profiles.clear();
  branch_info.__clear();
  dependencies.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool PlanNodeDescription::operator==(const PlanNodeDescription& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return false;
  }
  if (!(lhs.id == rhs.id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.output_var, rhs.output_var)) {
    return false;
  }
  if (lhs.description_ref() != rhs.description_ref()) {
    return false;
  }
  if (lhs.profiles_ref() != rhs.profiles_ref()) {
    return false;
  }
  if (lhs.branch_info_ref() != rhs.branch_info_ref()) {
    return false;
  }
  if (lhs.dependencies_ref() != rhs.dependencies_ref()) {
    return false;
  }
  return true;
}

const ::std::vector<nebula::Pair>* PlanNodeDescription::get_description() const& {
  return description_ref().has_value() ? std::addressof(description) : nullptr;
}

::std::vector<nebula::Pair>* PlanNodeDescription::get_description() & {
  return description_ref().has_value() ? std::addressof(description) : nullptr;
}

const ::std::vector<nebula::ProfilingStats>* PlanNodeDescription::get_profiles() const& {
  return profiles_ref().has_value() ? std::addressof(profiles) : nullptr;
}

::std::vector<nebula::ProfilingStats>* PlanNodeDescription::get_profiles() & {
  return profiles_ref().has_value() ? std::addressof(profiles) : nullptr;
}

const nebula::PlanNodeBranchInfo* PlanNodeDescription::get_branch_info() const& {
  return branch_info_ref().has_value() ? std::addressof(branch_info) : nullptr;
}

nebula::PlanNodeBranchInfo* PlanNodeDescription::get_branch_info() & {
  return branch_info_ref().has_value() ? std::addressof(branch_info) : nullptr;
}

const ::std::vector<int64_t>* PlanNodeDescription::get_dependencies() const& {
  return dependencies_ref().has_value() ? std::addressof(dependencies) : nullptr;
}

::std::vector<int64_t>* PlanNodeDescription::get_dependencies() & {
  return dependencies_ref().has_value() ? std::addressof(dependencies) : nullptr;
}


void swap(PlanNodeDescription& a, PlanNodeDescription& b) {
  using ::std::swap;
  swap(a.name_ref().value(), b.name_ref().value());
  swap(a.id_ref().value(), b.id_ref().value());
  swap(a.output_var_ref().value(), b.output_var_ref().value());
  swap(a.description_ref().value_unchecked(), b.description_ref().value_unchecked());
  swap(a.profiles_ref().value_unchecked(), b.profiles_ref().value_unchecked());
  swap(a.branch_info_ref().value_unchecked(), b.branch_info_ref().value_unchecked());
  swap(a.dependencies_ref().value_unchecked(), b.dependencies_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void PlanNodeDescription::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PlanNodeDescription::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PlanNodeDescription::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PlanNodeDescription::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PlanNodeDescription::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PlanNodeDescription::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PlanNodeDescription::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PlanNodeDescription::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PlanNodeDescription,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::Pair>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PlanNodeDescription,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::ProfilingStats>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PlanNodeDescription,
        ::apache::thrift::type_class::structure,
        nebula::PlanNodeBranchInfo>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PlanNodeDescription,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::Pair>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PlanNodeDescription,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::ProfilingStats>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PlanNodeDescription,
        ::apache::thrift::type_class::structure,
        nebula::PlanNodeBranchInfo>,
    "inconsistent use of nimble option");

}}} // nebula::graph::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::graph::cpp2::PlanDescription>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::graph::cpp2::PlanDescription>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace graph { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PlanDescription::PlanDescription(apache::thrift::FragileConstructor, ::std::vector<nebula::PlanNodeDescription> plan_node_descs__arg, std::unordered_map<int64_t, int64_t> node_index_map__arg, ::std::string format__arg, int32_t optimize_time_in_us__arg) :
    plan_node_descs(std::move(plan_node_descs__arg)),
    node_index_map(std::move(node_index_map__arg)),
    format(std::move(format__arg)),
    optimize_time_in_us(std::move(optimize_time_in_us__arg)) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void PlanDescription::__clear() {
  // clear all fields
  plan_node_descs.clear();
  node_index_map.clear();
  format = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  optimize_time_in_us = 0;
}

bool PlanDescription::operator==(const PlanDescription& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.plan_node_descs == rhs.plan_node_descs)) {
    return false;
  }
  if (!(lhs.node_index_map == rhs.node_index_map)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.format, rhs.format)) {
    return false;
  }
  if (!(lhs.optimize_time_in_us == rhs.optimize_time_in_us)) {
    return false;
  }
  return true;
}

const ::std::vector<nebula::PlanNodeDescription>& PlanDescription::get_plan_node_descs() const& {
  return plan_node_descs;
}

::std::vector<nebula::PlanNodeDescription> PlanDescription::get_plan_node_descs() && {
  return std::move(plan_node_descs);
}

const std::unordered_map<int64_t, int64_t>& PlanDescription::get_node_index_map() const& {
  return node_index_map;
}

std::unordered_map<int64_t, int64_t> PlanDescription::get_node_index_map() && {
  return std::move(node_index_map);
}


void swap(PlanDescription& a, PlanDescription& b) {
  using ::std::swap;
  swap(a.plan_node_descs_ref().value(), b.plan_node_descs_ref().value());
  swap(a.node_index_map_ref().value(), b.node_index_map_ref().value());
  swap(a.format_ref().value(), b.format_ref().value());
  swap(a.optimize_time_in_us_ref().value(), b.optimize_time_in_us_ref().value());
}

template void PlanDescription::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PlanDescription::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PlanDescription::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PlanDescription::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PlanDescription::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PlanDescription::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PlanDescription::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PlanDescription::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PlanDescription,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::PlanNodeDescription>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PlanDescription,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::PlanNodeDescription>>,
    "inconsistent use of nimble option");

}}} // nebula::graph::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::graph::cpp2::ExecutionResponse>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::graph::cpp2::ExecutionResponse>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace graph { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ExecutionResponse::ExecutionResponse() :
      error_code( ::nebula::cpp2::ErrorCode::SUCCEEDED),
      latency_in_us(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


ExecutionResponse::~ExecutionResponse() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ExecutionResponse::ExecutionResponse(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode error_code__arg, int32_t latency_in_us__arg, nebula::DataSet data__arg, ::std::string space_name__arg, ::std::string error_msg__arg, nebula::PlanDescription plan_desc__arg, ::std::string comment__arg) :
    error_code(std::move(error_code__arg)),
    latency_in_us(std::move(latency_in_us__arg)),
    data(std::move(data__arg)),
    space_name(std::move(space_name__arg)),
    error_msg(std::move(error_msg__arg)),
    plan_desc(std::move(plan_desc__arg)),
    comment(std::move(comment__arg)) {
  __isset.data = true;
  __isset.space_name = true;
  __isset.error_msg = true;
  __isset.plan_desc = true;
  __isset.comment = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ExecutionResponse::__clear() {
  // clear all fields
  error_code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  latency_in_us = 0;
  data.__clear();
  space_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  error_msg = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  plan_desc.__clear();
  comment = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ExecutionResponse::operator==(const ExecutionResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.error_code == rhs.error_code)) {
    return false;
  }
  if (!(lhs.latency_in_us == rhs.latency_in_us)) {
    return false;
  }
  if (lhs.data_ref() != rhs.data_ref()) {
    return false;
  }
  if (lhs.space_name_ref().has_value() != rhs.space_name_ref().has_value()) {
    return false;
  }
  if (lhs.space_name_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.space_name, rhs.space_name)) {
      return false;
    }
  }
  if (lhs.error_msg_ref().has_value() != rhs.error_msg_ref().has_value()) {
    return false;
  }
  if (lhs.error_msg_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.error_msg, rhs.error_msg)) {
      return false;
    }
  }
  if (lhs.plan_desc_ref() != rhs.plan_desc_ref()) {
    return false;
  }
  if (lhs.comment_ref().has_value() != rhs.comment_ref().has_value()) {
    return false;
  }
  if (lhs.comment_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.comment, rhs.comment)) {
      return false;
    }
  }
  return true;
}

const nebula::DataSet* ExecutionResponse::get_data() const& {
  return data_ref().has_value() ? std::addressof(data) : nullptr;
}

nebula::DataSet* ExecutionResponse::get_data() & {
  return data_ref().has_value() ? std::addressof(data) : nullptr;
}

const nebula::PlanDescription* ExecutionResponse::get_plan_desc() const& {
  return plan_desc_ref().has_value() ? std::addressof(plan_desc) : nullptr;
}

nebula::PlanDescription* ExecutionResponse::get_plan_desc() & {
  return plan_desc_ref().has_value() ? std::addressof(plan_desc) : nullptr;
}


void swap(ExecutionResponse& a, ExecutionResponse& b) {
  using ::std::swap;
  swap(a.error_code_ref().value(), b.error_code_ref().value());
  swap(a.latency_in_us_ref().value(), b.latency_in_us_ref().value());
  swap(a.data_ref().value_unchecked(), b.data_ref().value_unchecked());
  swap(a.space_name_ref().value_unchecked(), b.space_name_ref().value_unchecked());
  swap(a.error_msg_ref().value_unchecked(), b.error_msg_ref().value_unchecked());
  swap(a.plan_desc_ref().value_unchecked(), b.plan_desc_ref().value_unchecked());
  swap(a.comment_ref().value_unchecked(), b.comment_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ExecutionResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ExecutionResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ExecutionResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ExecutionResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ExecutionResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ExecutionResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ExecutionResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ExecutionResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ExecutionResponse,
        ::apache::thrift::type_class::structure,
        nebula::DataSet>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ExecutionResponse,
        ::apache::thrift::type_class::structure,
        nebula::PlanDescription>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ExecutionResponse,
        ::apache::thrift::type_class::structure,
        nebula::DataSet>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ExecutionResponse,
        ::apache::thrift::type_class::structure,
        nebula::PlanDescription>,
    "inconsistent use of nimble option");

}}} // nebula::graph::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::graph::cpp2::AuthResponse>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::graph::cpp2::AuthResponse>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace graph { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AuthResponse::AuthResponse() :
      error_code( ::nebula::cpp2::ErrorCode::SUCCEEDED),
      session_id(0),
      time_zone_offset_seconds(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


AuthResponse::~AuthResponse() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AuthResponse::AuthResponse(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode error_code__arg, ::std::string error_msg__arg, int64_t session_id__arg, int32_t time_zone_offset_seconds__arg, ::std::string time_zone_name__arg) :
    error_code(std::move(error_code__arg)),
    error_msg(std::move(error_msg__arg)),
    session_id(std::move(session_id__arg)),
    time_zone_offset_seconds(std::move(time_zone_offset_seconds__arg)),
    time_zone_name(std::move(time_zone_name__arg)) {
  __isset.error_msg = true;
  __isset.session_id = true;
  __isset.time_zone_offset_seconds = true;
  __isset.time_zone_name = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AuthResponse::__clear() {
  // clear all fields
  error_code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  error_msg = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  session_id = 0;
  time_zone_offset_seconds = 0;
  time_zone_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AuthResponse::operator==(const AuthResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.error_code == rhs.error_code)) {
    return false;
  }
  if (lhs.error_msg_ref().has_value() != rhs.error_msg_ref().has_value()) {
    return false;
  }
  if (lhs.error_msg_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.error_msg, rhs.error_msg)) {
      return false;
    }
  }
  if (lhs.session_id_ref() != rhs.session_id_ref()) {
    return false;
  }
  if (lhs.time_zone_offset_seconds_ref() != rhs.time_zone_offset_seconds_ref()) {
    return false;
  }
  if (lhs.time_zone_name_ref().has_value() != rhs.time_zone_name_ref().has_value()) {
    return false;
  }
  if (lhs.time_zone_name_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.time_zone_name, rhs.time_zone_name)) {
      return false;
    }
  }
  return true;
}

bool AuthResponse::operator<(const AuthResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.error_code == rhs.error_code)) {
    return lhs.error_code < rhs.error_code;
  }
  if (lhs.error_msg_ref().has_value() != rhs.error_msg_ref().has_value()) {
    return lhs.error_msg_ref().has_value() < rhs.error_msg_ref().has_value();
  }
  if (lhs.error_msg_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.error_msg, rhs.error_msg)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.error_msg, rhs.error_msg);
    }
  }
  if (lhs.session_id_ref() != rhs.session_id_ref()) {
    return lhs.session_id_ref() < rhs.session_id_ref();
  }
  if (lhs.time_zone_offset_seconds_ref() != rhs.time_zone_offset_seconds_ref()) {
    return lhs.time_zone_offset_seconds_ref() < rhs.time_zone_offset_seconds_ref();
  }
  if (lhs.time_zone_name_ref().has_value() != rhs.time_zone_name_ref().has_value()) {
    return lhs.time_zone_name_ref().has_value() < rhs.time_zone_name_ref().has_value();
  }
  if (lhs.time_zone_name_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.time_zone_name, rhs.time_zone_name)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.time_zone_name, rhs.time_zone_name);
    }
  }
  return false;
}


void swap(AuthResponse& a, AuthResponse& b) {
  using ::std::swap;
  swap(a.error_code_ref().value(), b.error_code_ref().value());
  swap(a.error_msg_ref().value_unchecked(), b.error_msg_ref().value_unchecked());
  swap(a.session_id_ref().value_unchecked(), b.session_id_ref().value_unchecked());
  swap(a.time_zone_offset_seconds_ref().value_unchecked(), b.time_zone_offset_seconds_ref().value_unchecked());
  swap(a.time_zone_name_ref().value_unchecked(), b.time_zone_name_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AuthResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AuthResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AuthResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AuthResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AuthResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AuthResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AuthResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AuthResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::graph::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::graph::cpp2::VerifyClientVersionResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::graph::cpp2::VerifyClientVersionResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace graph { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
VerifyClientVersionResp::VerifyClientVersionResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode error_code__arg, ::std::string error_msg__arg) :
    error_code(std::move(error_code__arg)),
    error_msg(std::move(error_msg__arg)) {
  __isset.error_msg = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void VerifyClientVersionResp::__clear() {
  // clear all fields
  error_code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  error_msg = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool VerifyClientVersionResp::operator==(const VerifyClientVersionResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.error_code == rhs.error_code)) {
    return false;
  }
  if (lhs.error_msg_ref().has_value() != rhs.error_msg_ref().has_value()) {
    return false;
  }
  if (lhs.error_msg_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.error_msg, rhs.error_msg)) {
      return false;
    }
  }
  return true;
}

bool VerifyClientVersionResp::operator<(const VerifyClientVersionResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.error_code == rhs.error_code)) {
    return lhs.error_code < rhs.error_code;
  }
  if (lhs.error_msg_ref().has_value() != rhs.error_msg_ref().has_value()) {
    return lhs.error_msg_ref().has_value() < rhs.error_msg_ref().has_value();
  }
  if (lhs.error_msg_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.error_msg, rhs.error_msg)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.error_msg, rhs.error_msg);
    }
  }
  return false;
}


void swap(VerifyClientVersionResp& a, VerifyClientVersionResp& b) {
  using ::std::swap;
  swap(a.error_code_ref().value(), b.error_code_ref().value());
  swap(a.error_msg_ref().value_unchecked(), b.error_msg_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void VerifyClientVersionResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t VerifyClientVersionResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t VerifyClientVersionResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t VerifyClientVersionResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void VerifyClientVersionResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t VerifyClientVersionResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t VerifyClientVersionResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t VerifyClientVersionResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::graph::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::graph::cpp2::VerifyClientVersionReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::graph::cpp2::VerifyClientVersionReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace graph { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
VerifyClientVersionReq::VerifyClientVersionReq(apache::thrift::FragileConstructor, ::std::string version__arg) :
    version(std::move(version__arg)) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void VerifyClientVersionReq::__clear() {
  // clear all fields
  version = apache::thrift::StringTraits< std::string>::fromStringLiteral("2.6.0");
}

bool VerifyClientVersionReq::operator==(const VerifyClientVersionReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.version, rhs.version)) {
    return false;
  }
  return true;
}

bool VerifyClientVersionReq::operator<(const VerifyClientVersionReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.version, rhs.version)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.version, rhs.version);
  }
  return false;
}


void swap(VerifyClientVersionReq& a, VerifyClientVersionReq& b) {
  using ::std::swap;
  swap(a.version_ref().value(), b.version_ref().value());
}

template void VerifyClientVersionReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t VerifyClientVersionReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t VerifyClientVersionReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t VerifyClientVersionReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void VerifyClientVersionReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t VerifyClientVersionReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t VerifyClientVersionReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t VerifyClientVersionReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::graph::cpp2
