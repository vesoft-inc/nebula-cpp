/**
 * Autogenerated by Thrift for graph.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>


#include "common_types.h"
#include "common/graph/PairOps-inl.h"
#include "common/graph/ProfilingStatsOps-inl.h"
#include "common/graph/PlanNodeBranchInfoOps-inl.h"
#include "common/graph/PlanNodeDescriptionOps-inl.h"
#include "common/graph/PlanDescriptionOps-inl.h"
#include "common/graph/ExecutionResponseOps-inl.h"
#include "common/graph/AuthResponseOps-inl.h"

namespace apache {
namespace thrift {
namespace tag {
struct rows;
struct exec_duration_in_us;
struct total_duration_in_us;
struct other_stats;
struct is_do_branch;
struct condition_node_id;
struct key;
struct value;
struct name;
struct id;
struct output_var;
struct description;
struct profiles;
struct branch_info;
struct dependencies;
struct plan_node_descs;
struct node_index_map;
struct format;
struct optimize_time_in_us;
struct error_code;
struct latency_in_us;
struct data;
struct space_name;
struct error_msg;
struct plan_desc;
struct comment;
struct error_code;
struct error_msg;
struct session_id;
struct time_zone_offset_seconds;
struct time_zone_name;
struct error_code;
struct error_msg;
struct version;
} // namespace tag
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_rows
#define APACHE_THRIFT_ACCESSOR_rows
APACHE_THRIFT_DEFINE_ACCESSOR(rows);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_exec_duration_in_us
#define APACHE_THRIFT_ACCESSOR_exec_duration_in_us
APACHE_THRIFT_DEFINE_ACCESSOR(exec_duration_in_us);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_total_duration_in_us
#define APACHE_THRIFT_ACCESSOR_total_duration_in_us
APACHE_THRIFT_DEFINE_ACCESSOR(total_duration_in_us);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_other_stats
#define APACHE_THRIFT_ACCESSOR_other_stats
APACHE_THRIFT_DEFINE_ACCESSOR(other_stats);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_is_do_branch
#define APACHE_THRIFT_ACCESSOR_is_do_branch
APACHE_THRIFT_DEFINE_ACCESSOR(is_do_branch);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_condition_node_id
#define APACHE_THRIFT_ACCESSOR_condition_node_id
APACHE_THRIFT_DEFINE_ACCESSOR(condition_node_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_key
#define APACHE_THRIFT_ACCESSOR_key
APACHE_THRIFT_DEFINE_ACCESSOR(key);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_value
#define APACHE_THRIFT_ACCESSOR_value
APACHE_THRIFT_DEFINE_ACCESSOR(value);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_id
#define APACHE_THRIFT_ACCESSOR_id
APACHE_THRIFT_DEFINE_ACCESSOR(id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_output_var
#define APACHE_THRIFT_ACCESSOR_output_var
APACHE_THRIFT_DEFINE_ACCESSOR(output_var);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_description
#define APACHE_THRIFT_ACCESSOR_description
APACHE_THRIFT_DEFINE_ACCESSOR(description);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_profiles
#define APACHE_THRIFT_ACCESSOR_profiles
APACHE_THRIFT_DEFINE_ACCESSOR(profiles);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_branch_info
#define APACHE_THRIFT_ACCESSOR_branch_info
APACHE_THRIFT_DEFINE_ACCESSOR(branch_info);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_dependencies
#define APACHE_THRIFT_ACCESSOR_dependencies
APACHE_THRIFT_DEFINE_ACCESSOR(dependencies);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_plan_node_descs
#define APACHE_THRIFT_ACCESSOR_plan_node_descs
APACHE_THRIFT_DEFINE_ACCESSOR(plan_node_descs);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_node_index_map
#define APACHE_THRIFT_ACCESSOR_node_index_map
APACHE_THRIFT_DEFINE_ACCESSOR(node_index_map);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_format
#define APACHE_THRIFT_ACCESSOR_format
APACHE_THRIFT_DEFINE_ACCESSOR(format);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_optimize_time_in_us
#define APACHE_THRIFT_ACCESSOR_optimize_time_in_us
APACHE_THRIFT_DEFINE_ACCESSOR(optimize_time_in_us);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_error_code
#define APACHE_THRIFT_ACCESSOR_error_code
APACHE_THRIFT_DEFINE_ACCESSOR(error_code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_latency_in_us
#define APACHE_THRIFT_ACCESSOR_latency_in_us
APACHE_THRIFT_DEFINE_ACCESSOR(latency_in_us);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_data
#define APACHE_THRIFT_ACCESSOR_data
APACHE_THRIFT_DEFINE_ACCESSOR(data);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_name
#define APACHE_THRIFT_ACCESSOR_space_name
APACHE_THRIFT_DEFINE_ACCESSOR(space_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_error_msg
#define APACHE_THRIFT_ACCESSOR_error_msg
APACHE_THRIFT_DEFINE_ACCESSOR(error_msg);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_plan_desc
#define APACHE_THRIFT_ACCESSOR_plan_desc
APACHE_THRIFT_DEFINE_ACCESSOR(plan_desc);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_comment
#define APACHE_THRIFT_ACCESSOR_comment
APACHE_THRIFT_DEFINE_ACCESSOR(comment);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_error_code
#define APACHE_THRIFT_ACCESSOR_error_code
APACHE_THRIFT_DEFINE_ACCESSOR(error_code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_error_msg
#define APACHE_THRIFT_ACCESSOR_error_msg
APACHE_THRIFT_DEFINE_ACCESSOR(error_msg);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_session_id
#define APACHE_THRIFT_ACCESSOR_session_id
APACHE_THRIFT_DEFINE_ACCESSOR(session_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_time_zone_offset_seconds
#define APACHE_THRIFT_ACCESSOR_time_zone_offset_seconds
APACHE_THRIFT_DEFINE_ACCESSOR(time_zone_offset_seconds);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_time_zone_name
#define APACHE_THRIFT_ACCESSOR_time_zone_name
APACHE_THRIFT_DEFINE_ACCESSOR(time_zone_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_error_code
#define APACHE_THRIFT_ACCESSOR_error_code
APACHE_THRIFT_DEFINE_ACCESSOR(error_code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_error_msg
#define APACHE_THRIFT_ACCESSOR_error_msg
APACHE_THRIFT_DEFINE_ACCESSOR(error_msg);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_version
#define APACHE_THRIFT_ACCESSOR_version
APACHE_THRIFT_DEFINE_ACCESSOR(version);
#endif
} // namespace detail
} // namespace thrift
} // namespace apache

// BEGIN declare_enums

// END declare_enums
// BEGIN forward_declare
namespace nebula { namespace graph { namespace cpp2 {
class ProfilingStats;
class PlanNodeBranchInfo;
class Pair;
class PlanNodeDescription;
class PlanDescription;
class ExecutionResponse;
class AuthResponse;
class VerifyClientVersionResp;
class VerifyClientVersionReq;
}}} // nebula::graph::cpp2
// END forward_declare
// BEGIN typedefs

// END typedefs
// BEGIN hash_and_equal_to
// END hash_and_equal_to
namespace nebula { namespace graph { namespace cpp2 {
class ProfilingStats final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ProfilingStats;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ProfilingStats() :
      rows(0),
      exec_duration_in_us(0),
      total_duration_in_us(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ProfilingStats(apache::thrift::FragileConstructor, int64_t rows__arg, int64_t exec_duration_in_us__arg, int64_t total_duration_in_us__arg, std::unordered_map<::std::string, ::std::string> other_stats__arg);

  ProfilingStats(ProfilingStats&&) = default;

  ProfilingStats(const ProfilingStats&) = default;


  ProfilingStats& operator=(ProfilingStats&&) = default;

  ProfilingStats& operator=(const ProfilingStats&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
  int64_t rows;
 public:
  int64_t exec_duration_in_us;
 public:
  int64_t total_duration_in_us;
 private:
  std::unordered_map<::std::string, ::std::string> other_stats;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool other_stats;
  } __isset = {};
  bool operator==(const ProfilingStats& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ProfilingStats& __x, const ProfilingStats& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ProfilingStats& rhs) const;
#ifndef SWIG
  friend bool operator>(const ProfilingStats& __x, const ProfilingStats& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ProfilingStats& __x, const ProfilingStats& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ProfilingStats& __x, const ProfilingStats& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> rows_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->rows};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> rows_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->rows)};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> rows_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->rows};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> rows_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->rows)};
  }
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> exec_duration_in_us_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->exec_duration_in_us};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> exec_duration_in_us_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->exec_duration_in_us)};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> exec_duration_in_us_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->exec_duration_in_us};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> exec_duration_in_us_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->exec_duration_in_us)};
  }
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> total_duration_in_us_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->total_duration_in_us};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> total_duration_in_us_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->total_duration_in_us)};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> total_duration_in_us_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->total_duration_in_us};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> total_duration_in_us_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->total_duration_in_us)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> other_stats_ref() const& {
    return {this->other_stats, __isset.other_stats};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> other_stats_ref() const&& {
    return {std::move(this->other_stats), __isset.other_stats};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> other_stats_ref() & {
    return {this->other_stats, __isset.other_stats};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> other_stats_ref() && {
    return {std::move(this->other_stats), __isset.other_stats};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  int64_t get_rows() const {
    return rows;
  }

  int64_t& set_rows(int64_t rows_) {
    rows = rows_;
    return rows;
  }

  int64_t get_exec_duration_in_us() const {
    return exec_duration_in_us;
  }

  int64_t& set_exec_duration_in_us(int64_t exec_duration_in_us_) {
    exec_duration_in_us = exec_duration_in_us_;
    return exec_duration_in_us;
  }

  int64_t get_total_duration_in_us() const {
    return total_duration_in_us;
  }

  int64_t& set_total_duration_in_us(int64_t total_duration_in_us_) {
    total_duration_in_us = total_duration_in_us_;
    return total_duration_in_us;
  }
  const std::unordered_map<::std::string, ::std::string>* get_other_stats() const&;
  std::unordered_map<::std::string, ::std::string>* get_other_stats() &;
  std::unordered_map<::std::string, ::std::string>* get_other_stats() && = delete;

  template <typename T_ProfilingStats_other_stats_struct_setter = std::unordered_map<::std::string, ::std::string>>
  std::unordered_map<::std::string, ::std::string>& set_other_stats(T_ProfilingStats_other_stats_struct_setter&& other_stats_) {
    other_stats = std::forward<T_ProfilingStats_other_stats_struct_setter>(other_stats_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.other_stats = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return other_stats;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ProfilingStats >;
  friend void swap(ProfilingStats& a, ProfilingStats& b);
};

template <class Protocol_>
uint32_t ProfilingStats::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::graph::cpp2
namespace nebula { namespace graph { namespace cpp2 {
class PlanNodeBranchInfo final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = PlanNodeBranchInfo;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  PlanNodeBranchInfo() :
      is_do_branch(0),
      condition_node_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  PlanNodeBranchInfo(apache::thrift::FragileConstructor, bool is_do_branch__arg, int64_t condition_node_id__arg);

  PlanNodeBranchInfo(PlanNodeBranchInfo&&) = default;

  PlanNodeBranchInfo(const PlanNodeBranchInfo&) = default;


  PlanNodeBranchInfo& operator=(PlanNodeBranchInfo&&) = default;

  PlanNodeBranchInfo& operator=(const PlanNodeBranchInfo&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
  bool is_do_branch;
 public:
  int64_t condition_node_id;

 public:
  bool operator==(const PlanNodeBranchInfo& rhs) const;
#ifndef SWIG
  friend bool operator!=(const PlanNodeBranchInfo& __x, const PlanNodeBranchInfo& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const PlanNodeBranchInfo& rhs) const;
#ifndef SWIG
  friend bool operator>(const PlanNodeBranchInfo& __x, const PlanNodeBranchInfo& __y) {
    return __y < __x;
  }
  friend bool operator<=(const PlanNodeBranchInfo& __x, const PlanNodeBranchInfo& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const PlanNodeBranchInfo& __x, const PlanNodeBranchInfo& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> is_do_branch_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->is_do_branch};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> is_do_branch_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->is_do_branch)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> is_do_branch_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->is_do_branch};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> is_do_branch_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->is_do_branch)};
  }
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> condition_node_id_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->condition_node_id};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> condition_node_id_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->condition_node_id)};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> condition_node_id_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->condition_node_id};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> condition_node_id_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->condition_node_id)};
  }

  bool get_is_do_branch() const {
    return is_do_branch;
  }

  bool& set_is_do_branch(bool is_do_branch_) {
    is_do_branch = is_do_branch_;
    return is_do_branch;
  }

  int64_t get_condition_node_id() const {
    return condition_node_id;
  }

  int64_t& set_condition_node_id(int64_t condition_node_id_) {
    condition_node_id = condition_node_id_;
    return condition_node_id;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< PlanNodeBranchInfo >;
  friend void swap(PlanNodeBranchInfo& a, PlanNodeBranchInfo& b);
};

template <class Protocol_>
uint32_t PlanNodeBranchInfo::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::graph::cpp2
namespace nebula { namespace graph { namespace cpp2 {
class Pair final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Pair;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  Pair() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Pair(apache::thrift::FragileConstructor, ::std::string key__arg, ::std::string value__arg);

  Pair(Pair&&) = default;

  Pair(const Pair&) = default;


  Pair& operator=(Pair&&) = default;

  Pair& operator=(const Pair&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
  ::std::string key;
 public:
  ::std::string value;

 public:
  bool operator==(const Pair& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Pair& __x, const Pair& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Pair& rhs) const;
#ifndef SWIG
  friend bool operator>(const Pair& __x, const Pair& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Pair& __x, const Pair& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Pair& __x, const Pair& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> key_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->key};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> key_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->key)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> key_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->key};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> key_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->key)};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> value_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->value};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> value_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->value)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> value_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->value};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> value_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->value)};
  }

  const ::std::string& get_key() const& {
    return key;
  }

  ::std::string get_key() && {
    return std::move(key);
  }

  template <typename T_Pair_key_struct_setter = ::std::string>
  ::std::string& set_key(T_Pair_key_struct_setter&& key_) {
    key = std::forward<T_Pair_key_struct_setter>(key_);
    return key;
  }

  const ::std::string& get_value() const& {
    return value;
  }

  ::std::string get_value() && {
    return std::move(value);
  }

  template <typename T_Pair_value_struct_setter = ::std::string>
  ::std::string& set_value(T_Pair_value_struct_setter&& value_) {
    value = std::forward<T_Pair_value_struct_setter>(value_);
    return value;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Pair >;
  friend void swap(Pair& a, Pair& b);
};

template <class Protocol_>
uint32_t Pair::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::graph::cpp2
namespace nebula { namespace graph { namespace cpp2 {
class PlanNodeDescription final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = PlanNodeDescription;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  PlanNodeDescription();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  PlanNodeDescription(apache::thrift::FragileConstructor, ::std::string name__arg, int64_t id__arg, ::std::string output_var__arg, ::std::vector<nebula::Pair> description__arg, ::std::vector<nebula::ProfilingStats> profiles__arg, nebula::PlanNodeBranchInfo branch_info__arg, ::std::vector<int64_t> dependencies__arg);

  PlanNodeDescription(PlanNodeDescription&&) = default;

  PlanNodeDescription(const PlanNodeDescription&) = default;


  PlanNodeDescription& operator=(PlanNodeDescription&&) = default;

  PlanNodeDescription& operator=(const PlanNodeDescription&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~PlanNodeDescription();

 public:
  ::std::string name;
 public:
  int64_t id;
 public:
  ::std::string output_var;
 private:
  ::std::vector<nebula::Pair> description;
 private:
  ::std::vector<nebula::ProfilingStats> profiles;
 private:
  nebula::PlanNodeBranchInfo branch_info;
 private:
  ::std::vector<int64_t> dependencies;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool description;
    bool profiles;
    bool branch_info;
    bool dependencies;
  } __isset = {};
  bool operator==(const PlanNodeDescription& rhs) const;
#ifndef SWIG
  friend bool operator!=(const PlanNodeDescription& __x, const PlanNodeDescription& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const PlanNodeDescription& rhs) const;
#ifndef SWIG
  friend bool operator>(const PlanNodeDescription& __x, const PlanNodeDescription& __y) {
    return __y < __x;
  }
  friend bool operator<=(const PlanNodeDescription& __x, const PlanNodeDescription& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const PlanNodeDescription& __x, const PlanNodeDescription& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> name_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> name_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->name)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> name_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> name_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->name)};
  }
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> id_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->id};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> id_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->id)};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> id_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->id};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> id_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->id)};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> output_var_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->output_var};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> output_var_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->output_var)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> output_var_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->output_var};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> output_var_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->output_var)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::Pair>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> description_ref() const& {
    return {this->description, __isset.description};
  }

  template <typename..., typename T = ::std::vector<nebula::Pair>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> description_ref() const&& {
    return {std::move(this->description), __isset.description};
  }

  template <typename..., typename T = ::std::vector<nebula::Pair>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> description_ref() & {
    return {this->description, __isset.description};
  }

  template <typename..., typename T = ::std::vector<nebula::Pair>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> description_ref() && {
    return {std::move(this->description), __isset.description};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::ProfilingStats>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> profiles_ref() const& {
    return {this->profiles, __isset.profiles};
  }

  template <typename..., typename T = ::std::vector<nebula::ProfilingStats>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> profiles_ref() const&& {
    return {std::move(this->profiles), __isset.profiles};
  }

  template <typename..., typename T = ::std::vector<nebula::ProfilingStats>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> profiles_ref() & {
    return {this->profiles, __isset.profiles};
  }

  template <typename..., typename T = ::std::vector<nebula::ProfilingStats>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> profiles_ref() && {
    return {std::move(this->profiles), __isset.profiles};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::PlanNodeBranchInfo>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> branch_info_ref() const& {
    return {this->branch_info, __isset.branch_info};
  }

  template <typename..., typename T = nebula::PlanNodeBranchInfo>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> branch_info_ref() const&& {
    return {std::move(this->branch_info), __isset.branch_info};
  }

  template <typename..., typename T = nebula::PlanNodeBranchInfo>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> branch_info_ref() & {
    return {this->branch_info, __isset.branch_info};
  }

  template <typename..., typename T = nebula::PlanNodeBranchInfo>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> branch_info_ref() && {
    return {std::move(this->branch_info), __isset.branch_info};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<int64_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> dependencies_ref() const& {
    return {this->dependencies, __isset.dependencies};
  }

  template <typename..., typename T = ::std::vector<int64_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> dependencies_ref() const&& {
    return {std::move(this->dependencies), __isset.dependencies};
  }

  template <typename..., typename T = ::std::vector<int64_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> dependencies_ref() & {
    return {this->dependencies, __isset.dependencies};
  }

  template <typename..., typename T = ::std::vector<int64_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> dependencies_ref() && {
    return {std::move(this->dependencies), __isset.dependencies};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_PlanNodeDescription_name_struct_setter = ::std::string>
  ::std::string& set_name(T_PlanNodeDescription_name_struct_setter&& name_) {
    name = std::forward<T_PlanNodeDescription_name_struct_setter>(name_);
    return name;
  }

  int64_t get_id() const {
    return id;
  }

  int64_t& set_id(int64_t id_) {
    id = id_;
    return id;
  }

  const ::std::string& get_output_var() const& {
    return output_var;
  }

  ::std::string get_output_var() && {
    return std::move(output_var);
  }

  template <typename T_PlanNodeDescription_output_var_struct_setter = ::std::string>
  ::std::string& set_output_var(T_PlanNodeDescription_output_var_struct_setter&& output_var_) {
    output_var = std::forward<T_PlanNodeDescription_output_var_struct_setter>(output_var_);
    return output_var;
  }
  const ::std::vector<nebula::Pair>* get_description() const&;
  ::std::vector<nebula::Pair>* get_description() &;
  ::std::vector<nebula::Pair>* get_description() && = delete;

  template <typename T_PlanNodeDescription_description_struct_setter = ::std::vector<nebula::Pair>>
  ::std::vector<nebula::Pair>& set_description(T_PlanNodeDescription_description_struct_setter&& description_) {
    description = std::forward<T_PlanNodeDescription_description_struct_setter>(description_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.description = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return description;
  }
  const ::std::vector<nebula::ProfilingStats>* get_profiles() const&;
  ::std::vector<nebula::ProfilingStats>* get_profiles() &;
  ::std::vector<nebula::ProfilingStats>* get_profiles() && = delete;

  template <typename T_PlanNodeDescription_profiles_struct_setter = ::std::vector<nebula::ProfilingStats>>
  ::std::vector<nebula::ProfilingStats>& set_profiles(T_PlanNodeDescription_profiles_struct_setter&& profiles_) {
    profiles = std::forward<T_PlanNodeDescription_profiles_struct_setter>(profiles_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.profiles = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return profiles;
  }
  const nebula::PlanNodeBranchInfo* get_branch_info() const&;
  nebula::PlanNodeBranchInfo* get_branch_info() &;
  nebula::PlanNodeBranchInfo* get_branch_info() && = delete;

  template <typename T_PlanNodeDescription_branch_info_struct_setter = nebula::PlanNodeBranchInfo>
  nebula::PlanNodeBranchInfo& set_branch_info(T_PlanNodeDescription_branch_info_struct_setter&& branch_info_) {
    branch_info = std::forward<T_PlanNodeDescription_branch_info_struct_setter>(branch_info_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.branch_info = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return branch_info;
  }
  const ::std::vector<int64_t>* get_dependencies() const&;
  ::std::vector<int64_t>* get_dependencies() &;
  ::std::vector<int64_t>* get_dependencies() && = delete;

  template <typename T_PlanNodeDescription_dependencies_struct_setter = ::std::vector<int64_t>>
  ::std::vector<int64_t>& set_dependencies(T_PlanNodeDescription_dependencies_struct_setter&& dependencies_) {
    dependencies = std::forward<T_PlanNodeDescription_dependencies_struct_setter>(dependencies_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.dependencies = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return dependencies;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< PlanNodeDescription >;
  friend void swap(PlanNodeDescription& a, PlanNodeDescription& b);
};

template <class Protocol_>
uint32_t PlanNodeDescription::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::graph::cpp2
namespace nebula { namespace graph { namespace cpp2 {
class PlanDescription final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = PlanDescription;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  PlanDescription() :
      optimize_time_in_us(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  PlanDescription(apache::thrift::FragileConstructor, ::std::vector<nebula::PlanNodeDescription> plan_node_descs__arg, std::unordered_map<int64_t, int64_t> node_index_map__arg, ::std::string format__arg, int32_t optimize_time_in_us__arg);

  PlanDescription(PlanDescription&&) = default;

  PlanDescription(const PlanDescription&) = default;


  PlanDescription& operator=(PlanDescription&&) = default;

  PlanDescription& operator=(const PlanDescription&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
  ::std::vector<nebula::PlanNodeDescription> plan_node_descs;
 public:
  std::unordered_map<int64_t, int64_t> node_index_map;
 public:
  ::std::string format;
 public:
  int32_t optimize_time_in_us;

 public:
  bool operator==(const PlanDescription& rhs) const;
#ifndef SWIG
  friend bool operator!=(const PlanDescription& __x, const PlanDescription& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const PlanDescription& rhs) const;
#ifndef SWIG
  friend bool operator>(const PlanDescription& __x, const PlanDescription& __y) {
    return __y < __x;
  }
  friend bool operator<=(const PlanDescription& __x, const PlanDescription& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const PlanDescription& __x, const PlanDescription& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T = ::std::vector<nebula::PlanNodeDescription>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> plan_node_descs_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->plan_node_descs};
  }

  template <typename..., typename T = ::std::vector<nebula::PlanNodeDescription>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> plan_node_descs_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->plan_node_descs)};
  }

  template <typename..., typename T = ::std::vector<nebula::PlanNodeDescription>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> plan_node_descs_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->plan_node_descs};
  }

  template <typename..., typename T = ::std::vector<nebula::PlanNodeDescription>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> plan_node_descs_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->plan_node_descs)};
  }
  template <typename..., typename T = std::unordered_map<int64_t, int64_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> node_index_map_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->node_index_map};
  }

  template <typename..., typename T = std::unordered_map<int64_t, int64_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> node_index_map_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->node_index_map)};
  }

  template <typename..., typename T = std::unordered_map<int64_t, int64_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> node_index_map_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->node_index_map};
  }

  template <typename..., typename T = std::unordered_map<int64_t, int64_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> node_index_map_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->node_index_map)};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> format_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->format};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> format_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->format)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> format_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->format};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> format_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->format)};
  }
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> optimize_time_in_us_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->optimize_time_in_us};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> optimize_time_in_us_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->optimize_time_in_us)};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> optimize_time_in_us_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->optimize_time_in_us};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> optimize_time_in_us_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->optimize_time_in_us)};
  }
  const ::std::vector<nebula::PlanNodeDescription>& get_plan_node_descs() const&;
  ::std::vector<nebula::PlanNodeDescription> get_plan_node_descs() &&;

  template <typename T_PlanDescription_plan_node_descs_struct_setter = ::std::vector<nebula::PlanNodeDescription>>
  ::std::vector<nebula::PlanNodeDescription>& set_plan_node_descs(T_PlanDescription_plan_node_descs_struct_setter&& plan_node_descs_) {
    plan_node_descs = std::forward<T_PlanDescription_plan_node_descs_struct_setter>(plan_node_descs_);
    return plan_node_descs;
  }
  const std::unordered_map<int64_t, int64_t>& get_node_index_map() const&;
  std::unordered_map<int64_t, int64_t> get_node_index_map() &&;

  template <typename T_PlanDescription_node_index_map_struct_setter = std::unordered_map<int64_t, int64_t>>
  std::unordered_map<int64_t, int64_t>& set_node_index_map(T_PlanDescription_node_index_map_struct_setter&& node_index_map_) {
    node_index_map = std::forward<T_PlanDescription_node_index_map_struct_setter>(node_index_map_);
    return node_index_map;
  }

  const ::std::string& get_format() const& {
    return format;
  }

  ::std::string get_format() && {
    return std::move(format);
  }

  template <typename T_PlanDescription_format_struct_setter = ::std::string>
  ::std::string& set_format(T_PlanDescription_format_struct_setter&& format_) {
    format = std::forward<T_PlanDescription_format_struct_setter>(format_);
    return format;
  }

  int32_t get_optimize_time_in_us() const {
    return optimize_time_in_us;
  }

  int32_t& set_optimize_time_in_us(int32_t optimize_time_in_us_) {
    optimize_time_in_us = optimize_time_in_us_;
    return optimize_time_in_us;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< PlanDescription >;
  friend void swap(PlanDescription& a, PlanDescription& b);
};

template <class Protocol_>
uint32_t PlanDescription::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::graph::cpp2
namespace nebula { namespace graph { namespace cpp2 {
class ExecutionResponse final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ExecutionResponse;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ExecutionResponse();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ExecutionResponse(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode error_code__arg, int64_t latency_in_us__arg, nebula::DataSet data__arg, ::std::string space_name__arg, ::std::string error_msg__arg, nebula::PlanDescription plan_desc__arg, ::std::string comment__arg);

  ExecutionResponse(ExecutionResponse&&) = default;

  ExecutionResponse(const ExecutionResponse&) = default;


  ExecutionResponse& operator=(ExecutionResponse&&) = default;

  ExecutionResponse& operator=(const ExecutionResponse&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~ExecutionResponse();

 public:
   ::nebula::cpp2::ErrorCode error_code;
 public:
  int64_t latency_in_us;
 private:
  nebula::DataSet data;
 private:
  ::std::string space_name;
 private:
  ::std::string error_msg;
 private:
  nebula::PlanDescription plan_desc;
 private:
  ::std::string comment;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool data;
    bool space_name;
    bool error_msg;
    bool plan_desc;
    bool comment;
  } __isset = {};
  bool operator==(const ExecutionResponse& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ExecutionResponse& __x, const ExecutionResponse& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ExecutionResponse& rhs) const;
#ifndef SWIG
  friend bool operator>(const ExecutionResponse& __x, const ExecutionResponse& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ExecutionResponse& __x, const ExecutionResponse& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ExecutionResponse& __x, const ExecutionResponse& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> error_code_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->error_code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> error_code_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->error_code)};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> error_code_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->error_code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> error_code_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->error_code)};
  }
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> latency_in_us_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->latency_in_us};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> latency_in_us_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->latency_in_us)};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> latency_in_us_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->latency_in_us};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> latency_in_us_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->latency_in_us)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> data_ref() const& {
    return {this->data, __isset.data};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> data_ref() const&& {
    return {std::move(this->data), __isset.data};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> data_ref() & {
    return {this->data, __isset.data};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> data_ref() && {
    return {std::move(this->data), __isset.data};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> space_name_ref() const& {
    return {this->space_name, __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> space_name_ref() const&& {
    return {std::move(this->space_name), __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> space_name_ref() & {
    return {this->space_name, __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> space_name_ref() && {
    return {std::move(this->space_name), __isset.space_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> error_msg_ref() const& {
    return {this->error_msg, __isset.error_msg};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> error_msg_ref() const&& {
    return {std::move(this->error_msg), __isset.error_msg};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> error_msg_ref() & {
    return {this->error_msg, __isset.error_msg};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> error_msg_ref() && {
    return {std::move(this->error_msg), __isset.error_msg};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::PlanDescription>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> plan_desc_ref() const& {
    return {this->plan_desc, __isset.plan_desc};
  }

  template <typename..., typename T = nebula::PlanDescription>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> plan_desc_ref() const&& {
    return {std::move(this->plan_desc), __isset.plan_desc};
  }

  template <typename..., typename T = nebula::PlanDescription>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> plan_desc_ref() & {
    return {this->plan_desc, __isset.plan_desc};
  }

  template <typename..., typename T = nebula::PlanDescription>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> plan_desc_ref() && {
    return {std::move(this->plan_desc), __isset.plan_desc};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> comment_ref() const& {
    return {this->comment, __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> comment_ref() const&& {
    return {std::move(this->comment), __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> comment_ref() & {
    return {this->comment, __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> comment_ref() && {
    return {std::move(this->comment), __isset.comment};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_error_code() const {
    return error_code;
  }

   ::nebula::cpp2::ErrorCode& set_error_code( ::nebula::cpp2::ErrorCode error_code_) {
    error_code = error_code_;
    return error_code;
  }

  int64_t get_latency_in_us() const {
    return latency_in_us;
  }

  int64_t& set_latency_in_us(int64_t latency_in_us_) {
    latency_in_us = latency_in_us_;
    return latency_in_us;
  }
  const nebula::DataSet* get_data() const&;
  nebula::DataSet* get_data() &;
  nebula::DataSet* get_data() && = delete;

  template <typename T_ExecutionResponse_data_struct_setter = nebula::DataSet>
  nebula::DataSet& set_data(T_ExecutionResponse_data_struct_setter&& data_) {
    data = std::forward<T_ExecutionResponse_data_struct_setter>(data_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.data = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return data;
  }

  const ::std::string* get_space_name() const& {
    return space_name_ref() ? std::addressof(space_name) : nullptr;
  }

  ::std::string* get_space_name() & {
    return space_name_ref() ? std::addressof(space_name) : nullptr;
  }
  ::std::string* get_space_name() && = delete;

  template <typename T_ExecutionResponse_space_name_struct_setter = ::std::string>
  ::std::string& set_space_name(T_ExecutionResponse_space_name_struct_setter&& space_name_) {
    space_name = std::forward<T_ExecutionResponse_space_name_struct_setter>(space_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_name;
  }

  const ::std::string* get_error_msg() const& {
    return error_msg_ref() ? std::addressof(error_msg) : nullptr;
  }

  ::std::string* get_error_msg() & {
    return error_msg_ref() ? std::addressof(error_msg) : nullptr;
  }
  ::std::string* get_error_msg() && = delete;

  template <typename T_ExecutionResponse_error_msg_struct_setter = ::std::string>
  ::std::string& set_error_msg(T_ExecutionResponse_error_msg_struct_setter&& error_msg_) {
    error_msg = std::forward<T_ExecutionResponse_error_msg_struct_setter>(error_msg_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.error_msg = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return error_msg;
  }
  const nebula::PlanDescription* get_plan_desc() const&;
  nebula::PlanDescription* get_plan_desc() &;
  nebula::PlanDescription* get_plan_desc() && = delete;

  template <typename T_ExecutionResponse_plan_desc_struct_setter = nebula::PlanDescription>
  nebula::PlanDescription& set_plan_desc(T_ExecutionResponse_plan_desc_struct_setter&& plan_desc_) {
    plan_desc = std::forward<T_ExecutionResponse_plan_desc_struct_setter>(plan_desc_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.plan_desc = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return plan_desc;
  }

  const ::std::string* get_comment() const& {
    return comment_ref() ? std::addressof(comment) : nullptr;
  }

  ::std::string* get_comment() & {
    return comment_ref() ? std::addressof(comment) : nullptr;
  }
  ::std::string* get_comment() && = delete;

  template <typename T_ExecutionResponse_comment_struct_setter = ::std::string>
  ::std::string& set_comment(T_ExecutionResponse_comment_struct_setter&& comment_) {
    comment = std::forward<T_ExecutionResponse_comment_struct_setter>(comment_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.comment = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return comment;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ExecutionResponse >;
  friend void swap(ExecutionResponse& a, ExecutionResponse& b);
};

template <class Protocol_>
uint32_t ExecutionResponse::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::graph::cpp2
namespace nebula { namespace graph { namespace cpp2 {
class AuthResponse final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AuthResponse;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  AuthResponse();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AuthResponse(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode error_code__arg, ::std::string error_msg__arg, int64_t session_id__arg, int32_t time_zone_offset_seconds__arg, ::std::string time_zone_name__arg);

  AuthResponse(AuthResponse&&) = default;

  AuthResponse(const AuthResponse&) = default;


  AuthResponse& operator=(AuthResponse&&) = default;

  AuthResponse& operator=(const AuthResponse&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~AuthResponse();

 public:
   ::nebula::cpp2::ErrorCode error_code;
 private:
  ::std::string error_msg;
 private:
  int64_t session_id;
 private:
  int32_t time_zone_offset_seconds;
 private:
  ::std::string time_zone_name;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool error_msg;
    bool session_id;
    bool time_zone_offset_seconds;
    bool time_zone_name;
  } __isset = {};
  bool operator==(const AuthResponse& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AuthResponse& __x, const AuthResponse& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AuthResponse& rhs) const;
#ifndef SWIG
  friend bool operator>(const AuthResponse& __x, const AuthResponse& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AuthResponse& __x, const AuthResponse& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AuthResponse& __x, const AuthResponse& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> error_code_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->error_code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> error_code_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->error_code)};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> error_code_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->error_code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> error_code_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->error_code)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> error_msg_ref() const& {
    return {this->error_msg, __isset.error_msg};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> error_msg_ref() const&& {
    return {std::move(this->error_msg), __isset.error_msg};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> error_msg_ref() & {
    return {this->error_msg, __isset.error_msg};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> error_msg_ref() && {
    return {std::move(this->error_msg), __isset.error_msg};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> session_id_ref() const& {
    return {this->session_id, __isset.session_id};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> session_id_ref() const&& {
    return {std::move(this->session_id), __isset.session_id};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> session_id_ref() & {
    return {this->session_id, __isset.session_id};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> session_id_ref() && {
    return {std::move(this->session_id), __isset.session_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> time_zone_offset_seconds_ref() const& {
    return {this->time_zone_offset_seconds, __isset.time_zone_offset_seconds};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> time_zone_offset_seconds_ref() const&& {
    return {std::move(this->time_zone_offset_seconds), __isset.time_zone_offset_seconds};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> time_zone_offset_seconds_ref() & {
    return {this->time_zone_offset_seconds, __isset.time_zone_offset_seconds};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> time_zone_offset_seconds_ref() && {
    return {std::move(this->time_zone_offset_seconds), __isset.time_zone_offset_seconds};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> time_zone_name_ref() const& {
    return {this->time_zone_name, __isset.time_zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> time_zone_name_ref() const&& {
    return {std::move(this->time_zone_name), __isset.time_zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> time_zone_name_ref() & {
    return {this->time_zone_name, __isset.time_zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> time_zone_name_ref() && {
    return {std::move(this->time_zone_name), __isset.time_zone_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_error_code() const {
    return error_code;
  }

   ::nebula::cpp2::ErrorCode& set_error_code( ::nebula::cpp2::ErrorCode error_code_) {
    error_code = error_code_;
    return error_code;
  }

  const ::std::string* get_error_msg() const& {
    return error_msg_ref() ? std::addressof(error_msg) : nullptr;
  }

  ::std::string* get_error_msg() & {
    return error_msg_ref() ? std::addressof(error_msg) : nullptr;
  }
  ::std::string* get_error_msg() && = delete;

  template <typename T_AuthResponse_error_msg_struct_setter = ::std::string>
  ::std::string& set_error_msg(T_AuthResponse_error_msg_struct_setter&& error_msg_) {
    error_msg = std::forward<T_AuthResponse_error_msg_struct_setter>(error_msg_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.error_msg = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return error_msg;
  }

  const int64_t* get_session_id() const& {
    return session_id_ref() ? std::addressof(session_id) : nullptr;
  }

  int64_t* get_session_id() & {
    return session_id_ref() ? std::addressof(session_id) : nullptr;
  }
  int64_t* get_session_id() && = delete;

  int64_t& set_session_id(int64_t session_id_) {
    session_id = session_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.session_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return session_id;
  }

  const int32_t* get_time_zone_offset_seconds() const& {
    return time_zone_offset_seconds_ref() ? std::addressof(time_zone_offset_seconds) : nullptr;
  }

  int32_t* get_time_zone_offset_seconds() & {
    return time_zone_offset_seconds_ref() ? std::addressof(time_zone_offset_seconds) : nullptr;
  }
  int32_t* get_time_zone_offset_seconds() && = delete;

  int32_t& set_time_zone_offset_seconds(int32_t time_zone_offset_seconds_) {
    time_zone_offset_seconds = time_zone_offset_seconds_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.time_zone_offset_seconds = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return time_zone_offset_seconds;
  }

  const ::std::string* get_time_zone_name() const& {
    return time_zone_name_ref() ? std::addressof(time_zone_name) : nullptr;
  }

  ::std::string* get_time_zone_name() & {
    return time_zone_name_ref() ? std::addressof(time_zone_name) : nullptr;
  }
  ::std::string* get_time_zone_name() && = delete;

  template <typename T_AuthResponse_time_zone_name_struct_setter = ::std::string>
  ::std::string& set_time_zone_name(T_AuthResponse_time_zone_name_struct_setter&& time_zone_name_) {
    time_zone_name = std::forward<T_AuthResponse_time_zone_name_struct_setter>(time_zone_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.time_zone_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return time_zone_name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AuthResponse >;
  friend void swap(AuthResponse& a, AuthResponse& b);
};

template <class Protocol_>
uint32_t AuthResponse::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::graph::cpp2
namespace nebula { namespace graph { namespace cpp2 {
class VerifyClientVersionResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = VerifyClientVersionResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  VerifyClientVersionResp() :
      error_code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  VerifyClientVersionResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode error_code__arg, ::std::string error_msg__arg);

  VerifyClientVersionResp(VerifyClientVersionResp&&) = default;

  VerifyClientVersionResp(const VerifyClientVersionResp&) = default;


  VerifyClientVersionResp& operator=(VerifyClientVersionResp&&) = default;

  VerifyClientVersionResp& operator=(const VerifyClientVersionResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
   ::nebula::cpp2::ErrorCode error_code;
 private:
  ::std::string error_msg;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool error_msg;
  } __isset = {};
  bool operator==(const VerifyClientVersionResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const VerifyClientVersionResp& __x, const VerifyClientVersionResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const VerifyClientVersionResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const VerifyClientVersionResp& __x, const VerifyClientVersionResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const VerifyClientVersionResp& __x, const VerifyClientVersionResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const VerifyClientVersionResp& __x, const VerifyClientVersionResp& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> error_code_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->error_code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> error_code_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->error_code)};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> error_code_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->error_code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> error_code_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->error_code)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> error_msg_ref() const& {
    return {this->error_msg, __isset.error_msg};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> error_msg_ref() const&& {
    return {std::move(this->error_msg), __isset.error_msg};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> error_msg_ref() & {
    return {this->error_msg, __isset.error_msg};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> error_msg_ref() && {
    return {std::move(this->error_msg), __isset.error_msg};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_error_code() const {
    return error_code;
  }

   ::nebula::cpp2::ErrorCode& set_error_code( ::nebula::cpp2::ErrorCode error_code_) {
    error_code = error_code_;
    return error_code;
  }

  const ::std::string* get_error_msg() const& {
    return error_msg_ref() ? std::addressof(error_msg) : nullptr;
  }

  ::std::string* get_error_msg() & {
    return error_msg_ref() ? std::addressof(error_msg) : nullptr;
  }
  ::std::string* get_error_msg() && = delete;

  template <typename T_VerifyClientVersionResp_error_msg_struct_setter = ::std::string>
  ::std::string& set_error_msg(T_VerifyClientVersionResp_error_msg_struct_setter&& error_msg_) {
    error_msg = std::forward<T_VerifyClientVersionResp_error_msg_struct_setter>(error_msg_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.error_msg = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return error_msg;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< VerifyClientVersionResp >;
  friend void swap(VerifyClientVersionResp& a, VerifyClientVersionResp& b);
};

template <class Protocol_>
uint32_t VerifyClientVersionResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::graph::cpp2
namespace nebula { namespace graph { namespace cpp2 {
class VerifyClientVersionReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = VerifyClientVersionReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  VerifyClientVersionReq() :
      version(apache::thrift::StringTraits< std::string>::fromStringLiteral("2.6.0")) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  VerifyClientVersionReq(apache::thrift::FragileConstructor, ::std::string version__arg);

  VerifyClientVersionReq(VerifyClientVersionReq&&) = default;

  VerifyClientVersionReq(const VerifyClientVersionReq&) = default;


  VerifyClientVersionReq& operator=(VerifyClientVersionReq&&) = default;

  VerifyClientVersionReq& operator=(const VerifyClientVersionReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
  ::std::string version;

 public:
  bool operator==(const VerifyClientVersionReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const VerifyClientVersionReq& __x, const VerifyClientVersionReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const VerifyClientVersionReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const VerifyClientVersionReq& __x, const VerifyClientVersionReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const VerifyClientVersionReq& __x, const VerifyClientVersionReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const VerifyClientVersionReq& __x, const VerifyClientVersionReq& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> version_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> version_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->version)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> version_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> version_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->version)};
  }

  const ::std::string& get_version() const& {
    return version;
  }

  ::std::string get_version() && {
    return std::move(version);
  }

  template <typename T_VerifyClientVersionReq_version_struct_setter = ::std::string>
  ::std::string& set_version(T_VerifyClientVersionReq_version_struct_setter&& version_) {
    version = std::forward<T_VerifyClientVersionReq_version_struct_setter>(version_);
    return version;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< VerifyClientVersionReq >;
  friend void swap(VerifyClientVersionReq& a, VerifyClientVersionReq& b);
};

template <class Protocol_>
uint32_t VerifyClientVersionReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::graph::cpp2
