/**
 * Autogenerated by Thrift for storage.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include "GraphStorageServiceAsyncClient.h"

#include <thrift/lib/cpp2/gen/client_cpp.h>

namespace nebula { namespace storage { namespace cpp2 {
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::GetNeighborsRequest*>> GraphStorageService_getNeighbors_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::GetNeighborsResponse*>> GraphStorageService_getNeighbors_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::GetPropRequest*>> GraphStorageService_getProps_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::GetPropResponse*>> GraphStorageService_getProps_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AddVerticesRequest*>> GraphStorageService_addVertices_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ExecResponse*>> GraphStorageService_addVertices_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AddEdgesRequest*>> GraphStorageService_addEdges_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ExecResponse*>> GraphStorageService_addEdges_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::DeleteEdgesRequest*>> GraphStorageService_deleteEdges_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ExecResponse*>> GraphStorageService_deleteEdges_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::DeleteVerticesRequest*>> GraphStorageService_deleteVertices_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ExecResponse*>> GraphStorageService_deleteVertices_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::DeleteTagsRequest*>> GraphStorageService_deleteTags_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ExecResponse*>> GraphStorageService_deleteTags_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::UpdateVertexRequest*>> GraphStorageService_updateVertex_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::UpdateResponse*>> GraphStorageService_updateVertex_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::UpdateEdgeRequest*>> GraphStorageService_updateEdge_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::UpdateResponse*>> GraphStorageService_updateEdge_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ScanVertexRequest*>> GraphStorageService_scanVertex_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ScanResponse*>> GraphStorageService_scanVertex_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ScanEdgeRequest*>> GraphStorageService_scanEdge_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ScanResponse*>> GraphStorageService_scanEdge_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::GetUUIDReq*>> GraphStorageService_getUUID_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::GetUUIDResp*>> GraphStorageService_getUUID_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::LookupIndexRequest*>> GraphStorageService_lookupIndex_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::LookupIndexResp*>> GraphStorageService_lookupIndex_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::LookupAndTraverseRequest*>> GraphStorageService_lookupAndTraverse_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::GetNeighborsResponse*>> GraphStorageService_lookupAndTraverse_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::UpdateEdgeRequest*>> GraphStorageService_chainUpdateEdge_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::UpdateResponse*>> GraphStorageService_chainUpdateEdge_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::AddEdgesRequest*>> GraphStorageService_chainAddEdges_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ExecResponse*>> GraphStorageService_chainAddEdges_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::DeleteEdgesRequest*>> GraphStorageService_chainDeleteEdges_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ExecResponse*>> GraphStorageService_chainDeleteEdges_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::KVGetRequest*>> GraphStorageService_get_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::KVGetResponse*>> GraphStorageService_get_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::KVPutRequest*>> GraphStorageService_put_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ExecResponse*>> GraphStorageService_put_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::KVRemoveRequest*>> GraphStorageService_remove_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure,  ::nebula::storage::cpp2::ExecResponse*>> GraphStorageService_remove_presult;

template <typename Protocol_>
void GraphStorageServiceAsyncClient::getNeighborsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_getNeighbors_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::GetNeighborsRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "getNeighbors";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void GraphStorageServiceAsyncClient::getPropsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::GetPropRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_getProps_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::GetPropRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "getProps";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void GraphStorageServiceAsyncClient::addVerticesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_addVertices_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::AddVerticesRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "addVertices";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void GraphStorageServiceAsyncClient::addEdgesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_addEdges_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::AddEdgesRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "addEdges";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void GraphStorageServiceAsyncClient::deleteEdgesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_deleteEdges_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::DeleteEdgesRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "deleteEdges";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void GraphStorageServiceAsyncClient::deleteVerticesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_deleteVertices_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::DeleteVerticesRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "deleteVertices";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void GraphStorageServiceAsyncClient::deleteTagsT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_deleteTags_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::DeleteTagsRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "deleteTags";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void GraphStorageServiceAsyncClient::updateVertexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_updateVertex_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::UpdateVertexRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "updateVertex";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void GraphStorageServiceAsyncClient::updateEdgeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_updateEdge_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::UpdateEdgeRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "updateEdge";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void GraphStorageServiceAsyncClient::scanVertexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_scanVertex_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::ScanVertexRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "scanVertex";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void GraphStorageServiceAsyncClient::scanEdgeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_scanEdge_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::ScanEdgeRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "scanEdge";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void GraphStorageServiceAsyncClient::getUUIDT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::GetUUIDReq& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_getUUID_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::GetUUIDReq*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "getUUID";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void GraphStorageServiceAsyncClient::lookupIndexT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_lookupIndex_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::LookupIndexRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "lookupIndex";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void GraphStorageServiceAsyncClient::lookupAndTraverseT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_lookupAndTraverse_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::LookupAndTraverseRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "lookupAndTraverse";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void GraphStorageServiceAsyncClient::chainUpdateEdgeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_chainUpdateEdge_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::UpdateEdgeRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "chainUpdateEdge";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void GraphStorageServiceAsyncClient::chainAddEdgesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_chainAddEdges_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::AddEdgesRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "chainAddEdges";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void GraphStorageServiceAsyncClient::chainDeleteEdgesT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_chainDeleteEdges_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::DeleteEdgesRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "chainDeleteEdges";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void GraphStorageServiceAsyncClient::getT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::KVGetRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_get_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::KVGetRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "get";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void GraphStorageServiceAsyncClient::putT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::KVPutRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_put_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::KVPutRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "put";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void GraphStorageServiceAsyncClient::removeT(Protocol_* prot, apache::thrift::RpcOptions rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req) {

  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  GraphStorageService_remove_pargs args;
  args.get<0>().value = const_cast< ::nebula::storage::cpp2::KVRemoveRequest*>(&p_req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  static constexpr const folly::StringPiece methodName = "remove";
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, std::move(rpcOptions), std::move(callback), ctx->ctx, std::move(header), channel_.get(), apache::thrift::ManagedStringView(methodName, false), writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}



void GraphStorageServiceAsyncClient::getNeighbors(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  getNeighbors(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::getNeighbors(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req) {
  auto ctx = getNeighborsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  getNeighborsImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::getNeighborsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getNeighborsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getNeighborsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::getNeighborsCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.getNeighbors");
}

void GraphStorageServiceAsyncClient::sync_getNeighbors( ::nebula::storage::cpp2::GetNeighborsResponse& _return, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getNeighbors(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_getNeighbors(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::GetNeighborsResponse& _return, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = getNeighborsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  getNeighborsImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_getNeighbors(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::GetNeighborsResponse> GraphStorageServiceAsyncClient::future_getNeighbors(const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getNeighbors(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::GetNeighborsResponse> GraphStorageServiceAsyncClient::semifuture_getNeighbors(const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getNeighbors(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::GetNeighborsResponse> GraphStorageServiceAsyncClient::future_getNeighbors(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::GetNeighborsResponse> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::GetNeighborsResponse>>(std::move(promise), recv_wrapped_getNeighbors, channel_);
  getNeighbors(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::GetNeighborsResponse> GraphStorageServiceAsyncClient::semifuture_getNeighbors(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getNeighbors, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getNeighbors(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::GetNeighborsResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_getNeighbors(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::GetNeighborsResponse, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::GetNeighborsResponse>>(std::move(promise), recv_wrapped_getNeighbors, channel_);
  getNeighbors(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::GetNeighborsResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_getNeighbors(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getNeighbors, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getNeighbors(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::getNeighbors(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::GetNeighborsRequest& p_req) {
  getNeighbors(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_getNeighbors( ::nebula::storage::cpp2::GetNeighborsResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_getNeighbors_presult;
  constexpr auto const fname = "getNeighbors";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_getNeighbors( ::nebula::storage::cpp2::GetNeighborsResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getNeighbors(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_getNeighbors( ::nebula::storage::cpp2::GetNeighborsResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getNeighbors(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_getNeighbors( ::nebula::storage::cpp2::GetNeighborsResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getNeighbors(_return, state);
}

void GraphStorageServiceAsyncClient::getProps(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::GetPropRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  getProps(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::getProps(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::GetPropRequest& p_req) {
  auto ctx = getPropsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  getPropsImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::getPropsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::GetPropRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getPropsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getPropsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::getPropsCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.getProps");
}

void GraphStorageServiceAsyncClient::sync_getProps( ::nebula::storage::cpp2::GetPropResponse& _return, const  ::nebula::storage::cpp2::GetPropRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getProps(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_getProps(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::GetPropResponse& _return, const  ::nebula::storage::cpp2::GetPropRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = getPropsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  getPropsImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_getProps(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::GetPropResponse> GraphStorageServiceAsyncClient::future_getProps(const  ::nebula::storage::cpp2::GetPropRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getProps(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::GetPropResponse> GraphStorageServiceAsyncClient::semifuture_getProps(const  ::nebula::storage::cpp2::GetPropRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getProps(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::GetPropResponse> GraphStorageServiceAsyncClient::future_getProps(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetPropRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::GetPropResponse> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::GetPropResponse>>(std::move(promise), recv_wrapped_getProps, channel_);
  getProps(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::GetPropResponse> GraphStorageServiceAsyncClient::semifuture_getProps(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetPropRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getProps, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getProps(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::GetPropResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_getProps(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetPropRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::GetPropResponse, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::GetPropResponse>>(std::move(promise), recv_wrapped_getProps, channel_);
  getProps(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::GetPropResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_getProps(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetPropRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getProps, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getProps(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::getProps(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::GetPropRequest& p_req) {
  getProps(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_getProps( ::nebula::storage::cpp2::GetPropResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_getProps_presult;
  constexpr auto const fname = "getProps";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_getProps( ::nebula::storage::cpp2::GetPropResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getProps(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_getProps( ::nebula::storage::cpp2::GetPropResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getProps(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_getProps( ::nebula::storage::cpp2::GetPropResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getProps(_return, state);
}

void GraphStorageServiceAsyncClient::addVertices(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  addVertices(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::addVertices(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req) {
  auto ctx = addVerticesCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  addVerticesImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::addVerticesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      addVerticesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      addVerticesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::addVerticesCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.addVertices");
}

void GraphStorageServiceAsyncClient::sync_addVertices( ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_addVertices(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_addVertices(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = addVerticesCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  addVerticesImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_addVertices(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::future_addVertices(const  ::nebula::storage::cpp2::AddVerticesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_addVertices(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::semifuture_addVertices(const  ::nebula::storage::cpp2::AddVerticesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_addVertices(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::future_addVertices(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::ExecResponse> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::ExecResponse>>(std::move(promise), recv_wrapped_addVertices, channel_);
  addVertices(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::semifuture_addVertices(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_addVertices, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addVertices(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_addVertices(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::ExecResponse>>(std::move(promise), recv_wrapped_addVertices, channel_);
  addVertices(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_addVertices(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_addVertices, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addVertices(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::addVertices(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::AddVerticesRequest& p_req) {
  addVertices(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_addVertices( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_addVertices_presult;
  constexpr auto const fname = "addVertices";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_addVertices( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_addVertices(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_addVertices( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_addVertices(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_addVertices( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_addVertices(_return, state);
}

void GraphStorageServiceAsyncClient::addEdges(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  addEdges(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::addEdges(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  auto ctx = addEdgesCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  addEdgesImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::addEdgesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      addEdgesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      addEdgesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::addEdgesCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.addEdges");
}

void GraphStorageServiceAsyncClient::sync_addEdges( ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_addEdges(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_addEdges(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = addEdgesCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  addEdgesImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_addEdges(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::future_addEdges(const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_addEdges(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::semifuture_addEdges(const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_addEdges(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::future_addEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::ExecResponse> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::ExecResponse>>(std::move(promise), recv_wrapped_addEdges, channel_);
  addEdges(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::semifuture_addEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_addEdges, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addEdges(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_addEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::ExecResponse>>(std::move(promise), recv_wrapped_addEdges, channel_);
  addEdges(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_addEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_addEdges, channel_);
  auto callback = std::move(callbackAndFuture.first);
  addEdges(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::addEdges(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  addEdges(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_addEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_addEdges_presult;
  constexpr auto const fname = "addEdges";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_addEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_addEdges(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_addEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_addEdges(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_addEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_addEdges(_return, state);
}

void GraphStorageServiceAsyncClient::deleteEdges(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  deleteEdges(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::deleteEdges(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  auto ctx = deleteEdgesCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  deleteEdgesImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::deleteEdgesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      deleteEdgesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      deleteEdgesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::deleteEdgesCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.deleteEdges");
}

void GraphStorageServiceAsyncClient::sync_deleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_deleteEdges(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_deleteEdges(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = deleteEdgesCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  deleteEdgesImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_deleteEdges(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::future_deleteEdges(const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_deleteEdges(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::semifuture_deleteEdges(const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_deleteEdges(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::future_deleteEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::ExecResponse> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::ExecResponse>>(std::move(promise), recv_wrapped_deleteEdges, channel_);
  deleteEdges(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::semifuture_deleteEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_deleteEdges, channel_);
  auto callback = std::move(callbackAndFuture.first);
  deleteEdges(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_deleteEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::ExecResponse>>(std::move(promise), recv_wrapped_deleteEdges, channel_);
  deleteEdges(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_deleteEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_deleteEdges, channel_);
  auto callback = std::move(callbackAndFuture.first);
  deleteEdges(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::deleteEdges(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  deleteEdges(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_deleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_deleteEdges_presult;
  constexpr auto const fname = "deleteEdges";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_deleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_deleteEdges(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_deleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_deleteEdges(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_deleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_deleteEdges(_return, state);
}

void GraphStorageServiceAsyncClient::deleteVertices(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  deleteVertices(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::deleteVertices(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req) {
  auto ctx = deleteVerticesCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  deleteVerticesImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::deleteVerticesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      deleteVerticesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      deleteVerticesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::deleteVerticesCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.deleteVertices");
}

void GraphStorageServiceAsyncClient::sync_deleteVertices( ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_deleteVertices(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_deleteVertices(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = deleteVerticesCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  deleteVerticesImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_deleteVertices(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::future_deleteVertices(const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_deleteVertices(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::semifuture_deleteVertices(const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_deleteVertices(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::future_deleteVertices(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::ExecResponse> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::ExecResponse>>(std::move(promise), recv_wrapped_deleteVertices, channel_);
  deleteVertices(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::semifuture_deleteVertices(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_deleteVertices, channel_);
  auto callback = std::move(callbackAndFuture.first);
  deleteVertices(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_deleteVertices(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::ExecResponse>>(std::move(promise), recv_wrapped_deleteVertices, channel_);
  deleteVertices(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_deleteVertices(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_deleteVertices, channel_);
  auto callback = std::move(callbackAndFuture.first);
  deleteVertices(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::deleteVertices(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::DeleteVerticesRequest& p_req) {
  deleteVertices(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_deleteVertices( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_deleteVertices_presult;
  constexpr auto const fname = "deleteVertices";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_deleteVertices( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_deleteVertices(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_deleteVertices( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_deleteVertices(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_deleteVertices( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_deleteVertices(_return, state);
}

void GraphStorageServiceAsyncClient::deleteTags(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  deleteTags(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::deleteTags(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req) {
  auto ctx = deleteTagsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  deleteTagsImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::deleteTagsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      deleteTagsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      deleteTagsT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::deleteTagsCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.deleteTags");
}

void GraphStorageServiceAsyncClient::sync_deleteTags( ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_deleteTags(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_deleteTags(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = deleteTagsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  deleteTagsImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_deleteTags(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::future_deleteTags(const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_deleteTags(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::semifuture_deleteTags(const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_deleteTags(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::future_deleteTags(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::ExecResponse> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::ExecResponse>>(std::move(promise), recv_wrapped_deleteTags, channel_);
  deleteTags(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::semifuture_deleteTags(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_deleteTags, channel_);
  auto callback = std::move(callbackAndFuture.first);
  deleteTags(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_deleteTags(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::ExecResponse>>(std::move(promise), recv_wrapped_deleteTags, channel_);
  deleteTags(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_deleteTags(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_deleteTags, channel_);
  auto callback = std::move(callbackAndFuture.first);
  deleteTags(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::deleteTags(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::DeleteTagsRequest& p_req) {
  deleteTags(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_deleteTags( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_deleteTags_presult;
  constexpr auto const fname = "deleteTags";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_deleteTags( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_deleteTags(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_deleteTags( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_deleteTags(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_deleteTags( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_deleteTags(_return, state);
}

void GraphStorageServiceAsyncClient::updateVertex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  updateVertex(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::updateVertex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req) {
  auto ctx = updateVertexCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  updateVertexImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::updateVertexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      updateVertexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      updateVertexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::updateVertexCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.updateVertex");
}

void GraphStorageServiceAsyncClient::sync_updateVertex( ::nebula::storage::cpp2::UpdateResponse& _return, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_updateVertex(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_updateVertex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::UpdateResponse& _return, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = updateVertexCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  updateVertexImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_updateVertex(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::UpdateResponse> GraphStorageServiceAsyncClient::future_updateVertex(const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_updateVertex(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::UpdateResponse> GraphStorageServiceAsyncClient::semifuture_updateVertex(const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_updateVertex(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::UpdateResponse> GraphStorageServiceAsyncClient::future_updateVertex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::UpdateResponse> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::UpdateResponse>>(std::move(promise), recv_wrapped_updateVertex, channel_);
  updateVertex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::UpdateResponse> GraphStorageServiceAsyncClient::semifuture_updateVertex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_updateVertex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  updateVertex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::UpdateResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_updateVertex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::UpdateResponse, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::UpdateResponse>>(std::move(promise), recv_wrapped_updateVertex, channel_);
  updateVertex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::UpdateResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_updateVertex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_updateVertex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  updateVertex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::updateVertex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::UpdateVertexRequest& p_req) {
  updateVertex(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_updateVertex( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_updateVertex_presult;
  constexpr auto const fname = "updateVertex";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_updateVertex( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_updateVertex(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_updateVertex( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_updateVertex(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_updateVertex( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_updateVertex(_return, state);
}

void GraphStorageServiceAsyncClient::updateEdge(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  updateEdge(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::updateEdge(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  auto ctx = updateEdgeCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  updateEdgeImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::updateEdgeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      updateEdgeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      updateEdgeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::updateEdgeCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.updateEdge");
}

void GraphStorageServiceAsyncClient::sync_updateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_updateEdge(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_updateEdge(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::UpdateResponse& _return, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = updateEdgeCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  updateEdgeImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_updateEdge(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::UpdateResponse> GraphStorageServiceAsyncClient::future_updateEdge(const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_updateEdge(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::UpdateResponse> GraphStorageServiceAsyncClient::semifuture_updateEdge(const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_updateEdge(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::UpdateResponse> GraphStorageServiceAsyncClient::future_updateEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::UpdateResponse> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::UpdateResponse>>(std::move(promise), recv_wrapped_updateEdge, channel_);
  updateEdge(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::UpdateResponse> GraphStorageServiceAsyncClient::semifuture_updateEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_updateEdge, channel_);
  auto callback = std::move(callbackAndFuture.first);
  updateEdge(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::UpdateResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_updateEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::UpdateResponse, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::UpdateResponse>>(std::move(promise), recv_wrapped_updateEdge, channel_);
  updateEdge(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::UpdateResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_updateEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_updateEdge, channel_);
  auto callback = std::move(callbackAndFuture.first);
  updateEdge(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::updateEdge(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  updateEdge(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_updateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_updateEdge_presult;
  constexpr auto const fname = "updateEdge";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_updateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_updateEdge(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_updateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_updateEdge(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_updateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_updateEdge(_return, state);
}

void GraphStorageServiceAsyncClient::scanVertex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  scanVertex(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::scanVertex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req) {
  auto ctx = scanVertexCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  scanVertexImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::scanVertexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      scanVertexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      scanVertexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::scanVertexCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.scanVertex");
}

void GraphStorageServiceAsyncClient::sync_scanVertex( ::nebula::storage::cpp2::ScanResponse& _return, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_scanVertex(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_scanVertex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ScanResponse& _return, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = scanVertexCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  scanVertexImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_scanVertex(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::ScanResponse> GraphStorageServiceAsyncClient::future_scanVertex(const  ::nebula::storage::cpp2::ScanVertexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_scanVertex(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::ScanResponse> GraphStorageServiceAsyncClient::semifuture_scanVertex(const  ::nebula::storage::cpp2::ScanVertexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_scanVertex(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::ScanResponse> GraphStorageServiceAsyncClient::future_scanVertex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::ScanResponse> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::ScanResponse>>(std::move(promise), recv_wrapped_scanVertex, channel_);
  scanVertex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::ScanResponse> GraphStorageServiceAsyncClient::semifuture_scanVertex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_scanVertex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  scanVertex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::ScanResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_scanVertex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::ScanResponse, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::ScanResponse>>(std::move(promise), recv_wrapped_scanVertex, channel_);
  scanVertex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ScanResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_scanVertex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_scanVertex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  scanVertex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::scanVertex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::ScanVertexRequest& p_req) {
  scanVertex(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_scanVertex( ::nebula::storage::cpp2::ScanResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_scanVertex_presult;
  constexpr auto const fname = "scanVertex";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_scanVertex( ::nebula::storage::cpp2::ScanResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_scanVertex(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_scanVertex( ::nebula::storage::cpp2::ScanResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_scanVertex(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_scanVertex( ::nebula::storage::cpp2::ScanResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_scanVertex(_return, state);
}

void GraphStorageServiceAsyncClient::scanEdge(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  scanEdge(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::scanEdge(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req) {
  auto ctx = scanEdgeCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  scanEdgeImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::scanEdgeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      scanEdgeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      scanEdgeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::scanEdgeCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.scanEdge");
}

void GraphStorageServiceAsyncClient::sync_scanEdge( ::nebula::storage::cpp2::ScanResponse& _return, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_scanEdge(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_scanEdge(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ScanResponse& _return, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = scanEdgeCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  scanEdgeImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_scanEdge(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::ScanResponse> GraphStorageServiceAsyncClient::future_scanEdge(const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_scanEdge(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::ScanResponse> GraphStorageServiceAsyncClient::semifuture_scanEdge(const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_scanEdge(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::ScanResponse> GraphStorageServiceAsyncClient::future_scanEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::ScanResponse> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::ScanResponse>>(std::move(promise), recv_wrapped_scanEdge, channel_);
  scanEdge(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::ScanResponse> GraphStorageServiceAsyncClient::semifuture_scanEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_scanEdge, channel_);
  auto callback = std::move(callbackAndFuture.first);
  scanEdge(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::ScanResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_scanEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::ScanResponse, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::ScanResponse>>(std::move(promise), recv_wrapped_scanEdge, channel_);
  scanEdge(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ScanResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_scanEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_scanEdge, channel_);
  auto callback = std::move(callbackAndFuture.first);
  scanEdge(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::scanEdge(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::ScanEdgeRequest& p_req) {
  scanEdge(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_scanEdge( ::nebula::storage::cpp2::ScanResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_scanEdge_presult;
  constexpr auto const fname = "scanEdge";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_scanEdge( ::nebula::storage::cpp2::ScanResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_scanEdge(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_scanEdge( ::nebula::storage::cpp2::ScanResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_scanEdge(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_scanEdge( ::nebula::storage::cpp2::ScanResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_scanEdge(_return, state);
}

void GraphStorageServiceAsyncClient::getUUID(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::GetUUIDReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  getUUID(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::getUUID(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::GetUUIDReq& p_req) {
  auto ctx = getUUIDCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  getUUIDImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::getUUIDImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::GetUUIDReq& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getUUIDT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getUUIDT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::getUUIDCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.getUUID");
}

void GraphStorageServiceAsyncClient::sync_getUUID( ::nebula::storage::cpp2::GetUUIDResp& _return, const  ::nebula::storage::cpp2::GetUUIDReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getUUID(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_getUUID(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::GetUUIDResp& _return, const  ::nebula::storage::cpp2::GetUUIDReq& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = getUUIDCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  getUUIDImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_getUUID(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::GetUUIDResp> GraphStorageServiceAsyncClient::future_getUUID(const  ::nebula::storage::cpp2::GetUUIDReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getUUID(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::GetUUIDResp> GraphStorageServiceAsyncClient::semifuture_getUUID(const  ::nebula::storage::cpp2::GetUUIDReq& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getUUID(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::GetUUIDResp> GraphStorageServiceAsyncClient::future_getUUID(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetUUIDReq& p_req) {
  folly::Promise< ::nebula::storage::cpp2::GetUUIDResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::GetUUIDResp>>(std::move(promise), recv_wrapped_getUUID, channel_);
  getUUID(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::GetUUIDResp> GraphStorageServiceAsyncClient::semifuture_getUUID(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetUUIDReq& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getUUID, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getUUID(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::GetUUIDResp, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_getUUID(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetUUIDReq& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::GetUUIDResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::GetUUIDResp>>(std::move(promise), recv_wrapped_getUUID, channel_);
  getUUID(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::GetUUIDResp, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_getUUID(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::GetUUIDReq& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getUUID, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getUUID(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::getUUID(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::GetUUIDReq& p_req) {
  getUUID(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_getUUID( ::nebula::storage::cpp2::GetUUIDResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_getUUID_presult;
  constexpr auto const fname = "getUUID";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_getUUID( ::nebula::storage::cpp2::GetUUIDResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getUUID(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_getUUID( ::nebula::storage::cpp2::GetUUIDResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getUUID(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_getUUID( ::nebula::storage::cpp2::GetUUIDResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getUUID(_return, state);
}

void GraphStorageServiceAsyncClient::lookupIndex(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  lookupIndex(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::lookupIndex(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req) {
  auto ctx = lookupIndexCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  lookupIndexImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::lookupIndexImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      lookupIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      lookupIndexT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::lookupIndexCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.lookupIndex");
}

void GraphStorageServiceAsyncClient::sync_lookupIndex( ::nebula::storage::cpp2::LookupIndexResp& _return, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_lookupIndex(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_lookupIndex(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::LookupIndexResp& _return, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = lookupIndexCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  lookupIndexImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_lookupIndex(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::LookupIndexResp> GraphStorageServiceAsyncClient::future_lookupIndex(const  ::nebula::storage::cpp2::LookupIndexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_lookupIndex(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::LookupIndexResp> GraphStorageServiceAsyncClient::semifuture_lookupIndex(const  ::nebula::storage::cpp2::LookupIndexRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_lookupIndex(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::LookupIndexResp> GraphStorageServiceAsyncClient::future_lookupIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::LookupIndexResp> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::LookupIndexResp>>(std::move(promise), recv_wrapped_lookupIndex, channel_);
  lookupIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::LookupIndexResp> GraphStorageServiceAsyncClient::semifuture_lookupIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_lookupIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  lookupIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::LookupIndexResp, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_lookupIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::LookupIndexResp, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::LookupIndexResp>>(std::move(promise), recv_wrapped_lookupIndex, channel_);
  lookupIndex(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::LookupIndexResp, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_lookupIndex(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_lookupIndex, channel_);
  auto callback = std::move(callbackAndFuture.first);
  lookupIndex(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::lookupIndex(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::LookupIndexRequest& p_req) {
  lookupIndex(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_lookupIndex( ::nebula::storage::cpp2::LookupIndexResp& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_lookupIndex_presult;
  constexpr auto const fname = "lookupIndex";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_lookupIndex( ::nebula::storage::cpp2::LookupIndexResp& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_lookupIndex(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_lookupIndex( ::nebula::storage::cpp2::LookupIndexResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_lookupIndex(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_lookupIndex( ::nebula::storage::cpp2::LookupIndexResp& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_lookupIndex(_return, state);
}

void GraphStorageServiceAsyncClient::lookupAndTraverse(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  lookupAndTraverse(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::lookupAndTraverse(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req) {
  auto ctx = lookupAndTraverseCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  lookupAndTraverseImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::lookupAndTraverseImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      lookupAndTraverseT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      lookupAndTraverseT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::lookupAndTraverseCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.lookupAndTraverse");
}

void GraphStorageServiceAsyncClient::sync_lookupAndTraverse( ::nebula::storage::cpp2::GetNeighborsResponse& _return, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_lookupAndTraverse(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_lookupAndTraverse(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::GetNeighborsResponse& _return, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = lookupAndTraverseCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  lookupAndTraverseImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_lookupAndTraverse(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::GetNeighborsResponse> GraphStorageServiceAsyncClient::future_lookupAndTraverse(const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_lookupAndTraverse(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::GetNeighborsResponse> GraphStorageServiceAsyncClient::semifuture_lookupAndTraverse(const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_lookupAndTraverse(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::GetNeighborsResponse> GraphStorageServiceAsyncClient::future_lookupAndTraverse(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::GetNeighborsResponse> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::GetNeighborsResponse>>(std::move(promise), recv_wrapped_lookupAndTraverse, channel_);
  lookupAndTraverse(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::GetNeighborsResponse> GraphStorageServiceAsyncClient::semifuture_lookupAndTraverse(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_lookupAndTraverse, channel_);
  auto callback = std::move(callbackAndFuture.first);
  lookupAndTraverse(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::GetNeighborsResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_lookupAndTraverse(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::GetNeighborsResponse, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::GetNeighborsResponse>>(std::move(promise), recv_wrapped_lookupAndTraverse, channel_);
  lookupAndTraverse(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::GetNeighborsResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_lookupAndTraverse(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_lookupAndTraverse, channel_);
  auto callback = std::move(callbackAndFuture.first);
  lookupAndTraverse(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::lookupAndTraverse(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::LookupAndTraverseRequest& p_req) {
  lookupAndTraverse(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_lookupAndTraverse( ::nebula::storage::cpp2::GetNeighborsResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_lookupAndTraverse_presult;
  constexpr auto const fname = "lookupAndTraverse";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_lookupAndTraverse( ::nebula::storage::cpp2::GetNeighborsResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_lookupAndTraverse(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_lookupAndTraverse( ::nebula::storage::cpp2::GetNeighborsResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_lookupAndTraverse(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_lookupAndTraverse( ::nebula::storage::cpp2::GetNeighborsResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_lookupAndTraverse(_return, state);
}

void GraphStorageServiceAsyncClient::chainUpdateEdge(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  chainUpdateEdge(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::chainUpdateEdge(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  auto ctx = chainUpdateEdgeCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  chainUpdateEdgeImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::chainUpdateEdgeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      chainUpdateEdgeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      chainUpdateEdgeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::chainUpdateEdgeCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.chainUpdateEdge");
}

void GraphStorageServiceAsyncClient::sync_chainUpdateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_chainUpdateEdge(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_chainUpdateEdge(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::UpdateResponse& _return, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = chainUpdateEdgeCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  chainUpdateEdgeImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_chainUpdateEdge(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::UpdateResponse> GraphStorageServiceAsyncClient::future_chainUpdateEdge(const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_chainUpdateEdge(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::UpdateResponse> GraphStorageServiceAsyncClient::semifuture_chainUpdateEdge(const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_chainUpdateEdge(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::UpdateResponse> GraphStorageServiceAsyncClient::future_chainUpdateEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::UpdateResponse> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::UpdateResponse>>(std::move(promise), recv_wrapped_chainUpdateEdge, channel_);
  chainUpdateEdge(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::UpdateResponse> GraphStorageServiceAsyncClient::semifuture_chainUpdateEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_chainUpdateEdge, channel_);
  auto callback = std::move(callbackAndFuture.first);
  chainUpdateEdge(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::UpdateResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_chainUpdateEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::UpdateResponse, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::UpdateResponse>>(std::move(promise), recv_wrapped_chainUpdateEdge, channel_);
  chainUpdateEdge(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::UpdateResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_chainUpdateEdge(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_chainUpdateEdge, channel_);
  auto callback = std::move(callbackAndFuture.first);
  chainUpdateEdge(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::chainUpdateEdge(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::UpdateEdgeRequest& p_req) {
  chainUpdateEdge(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_chainUpdateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_chainUpdateEdge_presult;
  constexpr auto const fname = "chainUpdateEdge";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_chainUpdateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_chainUpdateEdge(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_chainUpdateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_chainUpdateEdge(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_chainUpdateEdge( ::nebula::storage::cpp2::UpdateResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_chainUpdateEdge(_return, state);
}

void GraphStorageServiceAsyncClient::chainAddEdges(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  chainAddEdges(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::chainAddEdges(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  auto ctx = chainAddEdgesCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  chainAddEdgesImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::chainAddEdgesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      chainAddEdgesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      chainAddEdgesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::chainAddEdgesCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.chainAddEdges");
}

void GraphStorageServiceAsyncClient::sync_chainAddEdges( ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_chainAddEdges(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_chainAddEdges(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = chainAddEdgesCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  chainAddEdgesImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_chainAddEdges(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::future_chainAddEdges(const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_chainAddEdges(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::semifuture_chainAddEdges(const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_chainAddEdges(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::future_chainAddEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::ExecResponse> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::ExecResponse>>(std::move(promise), recv_wrapped_chainAddEdges, channel_);
  chainAddEdges(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::semifuture_chainAddEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_chainAddEdges, channel_);
  auto callback = std::move(callbackAndFuture.first);
  chainAddEdges(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_chainAddEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::ExecResponse>>(std::move(promise), recv_wrapped_chainAddEdges, channel_);
  chainAddEdges(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_chainAddEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_chainAddEdges, channel_);
  auto callback = std::move(callbackAndFuture.first);
  chainAddEdges(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::chainAddEdges(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::AddEdgesRequest& p_req) {
  chainAddEdges(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_chainAddEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_chainAddEdges_presult;
  constexpr auto const fname = "chainAddEdges";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_chainAddEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_chainAddEdges(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_chainAddEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_chainAddEdges(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_chainAddEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_chainAddEdges(_return, state);
}

void GraphStorageServiceAsyncClient::chainDeleteEdges(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  chainDeleteEdges(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::chainDeleteEdges(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  auto ctx = chainDeleteEdgesCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  chainDeleteEdgesImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::chainDeleteEdgesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      chainDeleteEdgesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      chainDeleteEdgesT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::chainDeleteEdgesCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.chainDeleteEdges");
}

void GraphStorageServiceAsyncClient::sync_chainDeleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_chainDeleteEdges(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_chainDeleteEdges(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = chainDeleteEdgesCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  chainDeleteEdgesImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_chainDeleteEdges(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::future_chainDeleteEdges(const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_chainDeleteEdges(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::semifuture_chainDeleteEdges(const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_chainDeleteEdges(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::future_chainDeleteEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::ExecResponse> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::ExecResponse>>(std::move(promise), recv_wrapped_chainDeleteEdges, channel_);
  chainDeleteEdges(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::semifuture_chainDeleteEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_chainDeleteEdges, channel_);
  auto callback = std::move(callbackAndFuture.first);
  chainDeleteEdges(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_chainDeleteEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::ExecResponse>>(std::move(promise), recv_wrapped_chainDeleteEdges, channel_);
  chainDeleteEdges(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_chainDeleteEdges(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_chainDeleteEdges, channel_);
  auto callback = std::move(callbackAndFuture.first);
  chainDeleteEdges(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::chainDeleteEdges(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::DeleteEdgesRequest& p_req) {
  chainDeleteEdges(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_chainDeleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_chainDeleteEdges_presult;
  constexpr auto const fname = "chainDeleteEdges";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_chainDeleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_chainDeleteEdges(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_chainDeleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_chainDeleteEdges(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_chainDeleteEdges( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_chainDeleteEdges(_return, state);
}

void GraphStorageServiceAsyncClient::get(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::KVGetRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  get(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::get(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::KVGetRequest& p_req) {
  auto ctx = getCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  getImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::getImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::KVGetRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::getCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.get");
}

void GraphStorageServiceAsyncClient::sync_get( ::nebula::storage::cpp2::KVGetResponse& _return, const  ::nebula::storage::cpp2::KVGetRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_get(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_get(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::KVGetResponse& _return, const  ::nebula::storage::cpp2::KVGetRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = getCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  getImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_get(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::KVGetResponse> GraphStorageServiceAsyncClient::future_get(const  ::nebula::storage::cpp2::KVGetRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_get(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::KVGetResponse> GraphStorageServiceAsyncClient::semifuture_get(const  ::nebula::storage::cpp2::KVGetRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_get(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::KVGetResponse> GraphStorageServiceAsyncClient::future_get(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVGetRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::KVGetResponse> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::KVGetResponse>>(std::move(promise), recv_wrapped_get, channel_);
  get(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::KVGetResponse> GraphStorageServiceAsyncClient::semifuture_get(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVGetRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_get, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::KVGetResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_get(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVGetRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::KVGetResponse, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::KVGetResponse>>(std::move(promise), recv_wrapped_get, channel_);
  get(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::KVGetResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_get(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVGetRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_get, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::get(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::KVGetRequest& p_req) {
  get(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_get( ::nebula::storage::cpp2::KVGetResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_get_presult;
  constexpr auto const fname = "get";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_get( ::nebula::storage::cpp2::KVGetResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_get(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_get( ::nebula::storage::cpp2::KVGetResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_get(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_get( ::nebula::storage::cpp2::KVGetResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_get(_return, state);
}

void GraphStorageServiceAsyncClient::put(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::KVPutRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  put(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::put(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::KVPutRequest& p_req) {
  auto ctx = putCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  putImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::putImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::KVPutRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      putT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      putT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::putCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.put");
}

void GraphStorageServiceAsyncClient::sync_put( ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::KVPutRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_put(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_put(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::KVPutRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = putCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  putImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_put(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::future_put(const  ::nebula::storage::cpp2::KVPutRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_put(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::semifuture_put(const  ::nebula::storage::cpp2::KVPutRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_put(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::future_put(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVPutRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::ExecResponse> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::ExecResponse>>(std::move(promise), recv_wrapped_put, channel_);
  put(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::semifuture_put(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVPutRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_put, channel_);
  auto callback = std::move(callbackAndFuture.first);
  put(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_put(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVPutRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::ExecResponse>>(std::move(promise), recv_wrapped_put, channel_);
  put(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_put(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVPutRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_put, channel_);
  auto callback = std::move(callbackAndFuture.first);
  put(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::put(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::KVPutRequest& p_req) {
  put(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_put( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_put_presult;
  constexpr auto const fname = "put";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_put( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_put(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_put( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_put(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_put( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_put(_return, state);
}

void GraphStorageServiceAsyncClient::remove(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  remove(rpcOptions, std::move(callback), p_req);
}

void GraphStorageServiceAsyncClient::remove(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req) {
  auto ctx = removeCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  removeImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), p_req);
}

void GraphStorageServiceAsyncClient::removeImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx, apache::thrift::RequestClientCallback::Ptr callback, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      removeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      removeT(&writer, rpcOptions, std::move(ctx), std::move(callback), p_req);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::shared_ptr<::apache::thrift::detail::ac::ClientRequestContext> GraphStorageServiceAsyncClient::removeCtx(apache::thrift::RpcOptions* rpcOptions) {
  return std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      channel_->getProtocolId(),
      rpcOptions ? rpcOptions->releaseWriteHeaders() : std::map<std::string, std::string>{},
      handlers_,
      getServiceName(),
      "GraphStorageService.remove");
}

void GraphStorageServiceAsyncClient::sync_remove( ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_remove(rpcOptions, _return, p_req);
}

void GraphStorageServiceAsyncClient::sync_remove(apache::thrift::RpcOptions& rpcOptions,  ::nebula::storage::cpp2::ExecResponse& _return, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = removeCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  removeImpl(rpcOptions, ctx, std::move(wrappedCallback), p_req);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_remove(_return, returnState);
  });
}


folly::Future< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::future_remove(const  ::nebula::storage::cpp2::KVRemoveRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_remove(rpcOptions, p_req);
}

folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::semifuture_remove(const  ::nebula::storage::cpp2::KVRemoveRequest& p_req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_remove(rpcOptions, p_req);
}

folly::Future< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::future_remove(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req) {
  folly::Promise< ::nebula::storage::cpp2::ExecResponse> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::nebula::storage::cpp2::ExecResponse>>(std::move(promise), recv_wrapped_remove, channel_);
  remove(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture< ::nebula::storage::cpp2::ExecResponse> GraphStorageServiceAsyncClient::semifuture_remove(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_remove, channel_);
  auto callback = std::move(callbackAndFuture.first);
  remove(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_future_remove(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req) {
  folly::Promise<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::nebula::storage::cpp2::ExecResponse>>(std::move(promise), recv_wrapped_remove, channel_);
  remove(rpcOptions, std::move(callback), p_req);
  return future;
}

folly::SemiFuture<std::pair< ::nebula::storage::cpp2::ExecResponse, std::unique_ptr<apache::thrift::transport::THeader>>> GraphStorageServiceAsyncClient::header_semifuture_remove(apache::thrift::RpcOptions& rpcOptions, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_remove, channel_);
  auto callback = std::move(callbackAndFuture.first);
  remove(rpcOptions, std::move(callback), p_req);
  return std::move(callbackAndFuture.second);
}

void GraphStorageServiceAsyncClient::remove(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::nebula::storage::cpp2::KVRemoveRequest& p_req) {
  remove(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_req);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper GraphStorageServiceAsyncClient::recv_wrapped_remove( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = GraphStorageService_remove_presult;
  constexpr auto const fname = "remove";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void GraphStorageServiceAsyncClient::recv_remove( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_remove(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void GraphStorageServiceAsyncClient::recv_instance_remove( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_remove(_return, state);
}

folly::exception_wrapper GraphStorageServiceAsyncClient::recv_instance_wrapped_remove( ::nebula::storage::cpp2::ExecResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_remove(_return, state);
}


}}} // nebula::storage::cpp2
