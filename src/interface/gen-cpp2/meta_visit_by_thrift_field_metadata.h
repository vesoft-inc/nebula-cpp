/**
 * Autogenerated by Thrift for meta.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/visitation/visit_by_thrift_field_metadata.h>
#include "meta_metadata.h"

namespace apache {
namespace thrift {
namespace detail {

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ID> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).tag_id_ref());
    case 3:
      return f(2, static_cast<T&&>(t).edge_type_ref());
    case 4:
      return f(3, static_cast<T&&>(t).index_id_ref());
    case 5:
      return f(4, static_cast<T&&>(t).cluster_id_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ID");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ColumnTypeDef> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).type_ref());
    case 2:
      return f(1, static_cast<T&&>(t).type_length_ref());
    case 3:
      return f(2, static_cast<T&&>(t).geo_shape_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ColumnTypeDef");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ColumnDef> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).name_ref());
    case 2:
      return f(1, static_cast<T&&>(t).type_ref());
    case 3:
      return f(2, static_cast<T&&>(t).default_value_ref());
    case 4:
      return f(3, static_cast<T&&>(t).nullable_ref());
    case 5:
      return f(4, static_cast<T&&>(t).comment_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ColumnDef");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::SchemaProp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).ttl_duration_ref());
    case 2:
      return f(1, static_cast<T&&>(t).ttl_col_ref());
    case 3:
      return f(2, static_cast<T&&>(t).comment_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::SchemaProp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::Schema> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).columns_ref());
    case 2:
      return f(1, static_cast<T&&>(t).schema_prop_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::Schema");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::IdName> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).name_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::IdName");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::SpaceDesc> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_name_ref());
    case 2:
      return f(1, static_cast<T&&>(t).partition_num_ref());
    case 3:
      return f(2, static_cast<T&&>(t).replica_factor_ref());
    case 4:
      return f(3, static_cast<T&&>(t).charset_name_ref());
    case 5:
      return f(4, static_cast<T&&>(t).collate_name_ref());
    case 6:
      return f(5, static_cast<T&&>(t).vid_type_ref());
    case 7:
      return f(6, static_cast<T&&>(t).group_name_ref());
    case 8:
      return f(7, static_cast<T&&>(t).isolation_level_ref());
    case 9:
      return f(8, static_cast<T&&>(t).comment_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::SpaceDesc");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::SpaceItem> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).properties_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::SpaceItem");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::TagItem> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).tag_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).tag_name_ref());
    case 3:
      return f(2, static_cast<T&&>(t).version_ref());
    case 4:
      return f(3, static_cast<T&&>(t).schema_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::TagItem");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::AlterSchemaItem> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).op_ref());
    case 2:
      return f(1, static_cast<T&&>(t).schema_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::AlterSchemaItem");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::EdgeItem> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).edge_type_ref());
    case 2:
      return f(1, static_cast<T&&>(t).edge_name_ref());
    case 3:
      return f(2, static_cast<T&&>(t).version_ref());
    case 4:
      return f(3, static_cast<T&&>(t).schema_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::EdgeItem");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::IndexItem> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).index_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).index_name_ref());
    case 3:
      return f(2, static_cast<T&&>(t).schema_id_ref());
    case 4:
      return f(3, static_cast<T&&>(t).schema_name_ref());
    case 5:
      return f(4, static_cast<T&&>(t).fields_ref());
    case 6:
      return f(5, static_cast<T&&>(t).comment_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::IndexItem");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::HostItem> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).hostAddr_ref());
    case 2:
      return f(1, static_cast<T&&>(t).status_ref());
    case 3:
      return f(2, static_cast<T&&>(t).leader_parts_ref());
    case 4:
      return f(3, static_cast<T&&>(t).all_parts_ref());
    case 5:
      return f(4, static_cast<T&&>(t).role_ref());
    case 6:
      return f(5, static_cast<T&&>(t).git_info_sha_ref());
    case 7:
      return f(6, static_cast<T&&>(t).zone_name_ref());
    case 8:
      return f(7, static_cast<T&&>(t).version_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::HostItem");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::UserItem> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).account_ref());
    case 2:
      return f(1, static_cast<T&&>(t).is_lock_ref());
    case 3:
      return f(2, static_cast<T&&>(t).max_queries_per_hour_ref());
    case 4:
      return f(3, static_cast<T&&>(t).max_updates_per_hour_ref());
    case 5:
      return f(4, static_cast<T&&>(t).max_connections_per_hour_ref());
    case 6:
      return f(5, static_cast<T&&>(t).max_user_connections_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::UserItem");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::RoleItem> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).user_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).space_id_ref());
    case 3:
      return f(2, static_cast<T&&>(t).role_type_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::RoleItem");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ExecResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).id_ref());
    case 3:
      return f(2, static_cast<T&&>(t).leader_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ExecResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::AdminJobReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).op_ref());
    case 2:
      return f(1, static_cast<T&&>(t).cmd_ref());
    case 3:
      return f(2, static_cast<T&&>(t).paras_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::AdminJobReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::JobDesc> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).cmd_ref());
    case 3:
      return f(2, static_cast<T&&>(t).paras_ref());
    case 4:
      return f(3, static_cast<T&&>(t).status_ref());
    case 5:
      return f(4, static_cast<T&&>(t).start_time_ref());
    case 6:
      return f(5, static_cast<T&&>(t).stop_time_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::JobDesc");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::TaskDesc> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).task_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).host_ref());
    case 3:
      return f(2, static_cast<T&&>(t).status_ref());
    case 4:
      return f(3, static_cast<T&&>(t).start_time_ref());
    case 5:
      return f(4, static_cast<T&&>(t).stop_time_ref());
    case 6:
      return f(5, static_cast<T&&>(t).job_id_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::TaskDesc");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::AdminJobResult> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).job_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).job_desc_ref());
    case 3:
      return f(2, static_cast<T&&>(t).task_desc_ref());
    case 4:
      return f(3, static_cast<T&&>(t).recovered_job_num_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::AdminJobResult");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::AdminJobResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).result_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::AdminJobResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::Correlativity> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).part_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).proportion_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::Correlativity");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::StatsItem> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).tag_vertices_ref());
    case 2:
      return f(1, static_cast<T&&>(t).edges_ref());
    case 3:
      return f(2, static_cast<T&&>(t).space_vertices_ref());
    case 4:
      return f(3, static_cast<T&&>(t).space_edges_ref());
    case 5:
      return f(4, static_cast<T&&>(t).positive_part_correlativity_ref());
    case 6:
      return f(5, static_cast<T&&>(t).negative_part_correlativity_ref());
    case 7:
      return f(6, static_cast<T&&>(t).status_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::StatsItem");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::CreateSpaceReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).properties_ref());
    case 2:
      return f(1, static_cast<T&&>(t).if_not_exists_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::CreateSpaceReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::CreateSpaceAsReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).old_space_name_ref());
    case 2:
      return f(1, static_cast<T&&>(t).new_space_name_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::CreateSpaceAsReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::DropSpaceReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_name_ref());
    case 2:
      return f(1, static_cast<T&&>(t).if_exists_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::DropSpaceReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListSpacesReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListSpacesReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListSpacesResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).spaces_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListSpacesResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetSpaceReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_name_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetSpaceReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetSpaceResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).item_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetSpaceResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::CreateTagReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).tag_name_ref());
    case 3:
      return f(2, static_cast<T&&>(t).schema_ref());
    case 4:
      return f(3, static_cast<T&&>(t).if_not_exists_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::CreateTagReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::AlterTagReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).tag_name_ref());
    case 3:
      return f(2, static_cast<T&&>(t).tag_items_ref());
    case 4:
      return f(3, static_cast<T&&>(t).schema_prop_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::AlterTagReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::DropTagReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).tag_name_ref());
    case 3:
      return f(2, static_cast<T&&>(t).if_exists_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::DropTagReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListTagsReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListTagsReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListTagsResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).tags_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListTagsResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetTagReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).tag_name_ref());
    case 3:
      return f(2, static_cast<T&&>(t).version_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetTagReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetTagResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).schema_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetTagResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::CreateEdgeReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).edge_name_ref());
    case 3:
      return f(2, static_cast<T&&>(t).schema_ref());
    case 4:
      return f(3, static_cast<T&&>(t).if_not_exists_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::CreateEdgeReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::AlterEdgeReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).edge_name_ref());
    case 3:
      return f(2, static_cast<T&&>(t).edge_items_ref());
    case 4:
      return f(3, static_cast<T&&>(t).schema_prop_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::AlterEdgeReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetEdgeReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).edge_name_ref());
    case 3:
      return f(2, static_cast<T&&>(t).version_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetEdgeReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetEdgeResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).schema_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetEdgeResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::DropEdgeReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).edge_name_ref());
    case 3:
      return f(2, static_cast<T&&>(t).if_exists_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::DropEdgeReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListEdgesReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListEdgesReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListEdgesResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).edges_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListEdgesResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListHostsReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).type_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListHostsReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListHostsResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).hosts_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListHostsResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::PartItem> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).part_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).peers_ref());
    case 4:
      return f(3, static_cast<T&&>(t).losts_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::PartItem");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListPartsReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).part_ids_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListPartsReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListPartsResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).parts_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListPartsResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetPartsAllocReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetPartsAllocReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetPartsAllocResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).parts_ref());
    case 4:
      return f(3, static_cast<T&&>(t).terms_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetPartsAllocResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::MultiPutReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).segment_ref());
    case 2:
      return f(1, static_cast<T&&>(t).pairs_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::MultiPutReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).segment_ref());
    case 2:
      return f(1, static_cast<T&&>(t).key_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).value_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::MultiGetReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).segment_ref());
    case 2:
      return f(1, static_cast<T&&>(t).keys_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::MultiGetReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::MultiGetResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).values_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::MultiGetResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::RemoveReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).segment_ref());
    case 2:
      return f(1, static_cast<T&&>(t).key_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::RemoveReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::RemoveRangeReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).segment_ref());
    case 2:
      return f(1, static_cast<T&&>(t).start_ref());
    case 3:
      return f(2, static_cast<T&&>(t).end_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::RemoveRangeReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ScanReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).segment_ref());
    case 2:
      return f(1, static_cast<T&&>(t).start_ref());
    case 3:
      return f(2, static_cast<T&&>(t).end_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ScanReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ScanResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).values_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ScanResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::HBResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).cluster_id_ref());
    case 4:
      return f(3, static_cast<T&&>(t).last_update_time_in_ms_ref());
    case 5:
      return f(4, static_cast<T&&>(t).meta_version_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::HBResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::LeaderInfo> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).part_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).term_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::LeaderInfo");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::PartitionList> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).part_list_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::PartitionList");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::HBReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).role_ref());
    case 2:
      return f(1, static_cast<T&&>(t).host_ref());
    case 3:
      return f(2, static_cast<T&&>(t).cluster_id_ref());
    case 4:
      return f(3, static_cast<T&&>(t).leader_partIds_ref());
    case 5:
      return f(4, static_cast<T&&>(t).git_info_sha_ref());
    case 6:
      return f(5, static_cast<T&&>(t).disk_parts_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::HBReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::IndexFieldDef> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).name_ref());
    case 2:
      return f(1, static_cast<T&&>(t).type_length_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::IndexFieldDef");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::CreateTagIndexReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).index_name_ref());
    case 3:
      return f(2, static_cast<T&&>(t).tag_name_ref());
    case 4:
      return f(3, static_cast<T&&>(t).fields_ref());
    case 5:
      return f(4, static_cast<T&&>(t).if_not_exists_ref());
    case 6:
      return f(5, static_cast<T&&>(t).comment_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::CreateTagIndexReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::DropTagIndexReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).index_name_ref());
    case 3:
      return f(2, static_cast<T&&>(t).if_exists_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::DropTagIndexReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetTagIndexReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).index_name_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetTagIndexReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetTagIndexResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).item_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetTagIndexResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListTagIndexesReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListTagIndexesReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListTagIndexesResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).items_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListTagIndexesResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::CreateEdgeIndexReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).index_name_ref());
    case 3:
      return f(2, static_cast<T&&>(t).edge_name_ref());
    case 4:
      return f(3, static_cast<T&&>(t).fields_ref());
    case 5:
      return f(4, static_cast<T&&>(t).if_not_exists_ref());
    case 6:
      return f(5, static_cast<T&&>(t).comment_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::CreateEdgeIndexReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::DropEdgeIndexReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).index_name_ref());
    case 3:
      return f(2, static_cast<T&&>(t).if_exists_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::DropEdgeIndexReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetEdgeIndexReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).index_name_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetEdgeIndexReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetEdgeIndexResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).item_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetEdgeIndexResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListEdgeIndexesReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListEdgeIndexesReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListEdgeIndexesResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).items_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListEdgeIndexesResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::RebuildIndexReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).index_name_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::RebuildIndexReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::CreateUserReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).account_ref());
    case 2:
      return f(1, static_cast<T&&>(t).encoded_pwd_ref());
    case 3:
      return f(2, static_cast<T&&>(t).if_not_exists_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::CreateUserReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::DropUserReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).account_ref());
    case 2:
      return f(1, static_cast<T&&>(t).if_exists_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::DropUserReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::AlterUserReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).account_ref());
    case 2:
      return f(1, static_cast<T&&>(t).encoded_pwd_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::AlterUserReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GrantRoleReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).role_item_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GrantRoleReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::RevokeRoleReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).role_item_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::RevokeRoleReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListUsersReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListUsersReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListUsersResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).users_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListUsersResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListRolesReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListRolesReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListRolesResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).roles_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListRolesResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetUserRolesReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).account_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetUserRolesReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ChangePasswordReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).account_ref());
    case 2:
      return f(1, static_cast<T&&>(t).new_encoded_pwd_ref());
    case 3:
      return f(2, static_cast<T&&>(t).old_encoded_pwd_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ChangePasswordReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::BalanceTask> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).command_ref());
    case 3:
      return f(2, static_cast<T&&>(t).result_ref());
    case 4:
      return f(3, static_cast<T&&>(t).start_time_ref());
    case 5:
      return f(4, static_cast<T&&>(t).stop_time_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::BalanceTask");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ConfigItem> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).module_ref());
    case 2:
      return f(1, static_cast<T&&>(t).name_ref());
    case 3:
      return f(2, static_cast<T&&>(t).mode_ref());
    case 4:
      return f(3, static_cast<T&&>(t).value_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ConfigItem");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::RegConfigReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).items_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::RegConfigReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetConfigReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).item_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetConfigReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetConfigResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).items_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetConfigResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::SetConfigReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).item_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::SetConfigReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListConfigsReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_ref());
    case 2:
      return f(1, static_cast<T&&>(t).module_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListConfigsReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListConfigsResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).items_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListConfigsResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::CreateSnapshotReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::CreateSnapshotReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::DropSnapshotReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).name_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::DropSnapshotReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListSnapshotsReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListSnapshotsReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::Snapshot> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).name_ref());
    case 2:
      return f(1, static_cast<T&&>(t).status_ref());
    case 3:
      return f(2, static_cast<T&&>(t).hosts_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::Snapshot");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListSnapshotsResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).snapshots_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListSnapshotsResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListIndexStatusReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListIndexStatusReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::IndexStatus> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).name_ref());
    case 2:
      return f(1, static_cast<T&&>(t).status_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::IndexStatus");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListIndexStatusResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).statuses_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListIndexStatusResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::AddZoneReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).zone_name_ref());
    case 2:
      return f(1, static_cast<T&&>(t).nodes_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::AddZoneReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::DropZoneReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).zone_name_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::DropZoneReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::AddHostIntoZoneReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).node_ref());
    case 2:
      return f(1, static_cast<T&&>(t).zone_name_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::AddHostIntoZoneReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::DropHostFromZoneReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).node_ref());
    case 2:
      return f(1, static_cast<T&&>(t).zone_name_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::DropHostFromZoneReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetZoneReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).zone_name_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetZoneReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetZoneResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).hosts_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetZoneResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListZonesReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListZonesReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::Zone> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).zone_name_ref());
    case 2:
      return f(1, static_cast<T&&>(t).nodes_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::Zone");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListZonesResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).zones_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListZonesResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::AddListenerReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).type_ref());
    case 3:
      return f(2, static_cast<T&&>(t).hosts_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::AddListenerReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::RemoveListenerReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).type_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::RemoveListenerReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListListenerReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListListenerReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListenerInfo> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).type_ref());
    case 2:
      return f(1, static_cast<T&&>(t).host_ref());
    case 3:
      return f(2, static_cast<T&&>(t).part_id_ref());
    case 4:
      return f(3, static_cast<T&&>(t).status_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListenerInfo");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListListenerResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).listeners_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListListenerResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetStatsReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetStatsReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetStatsResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).stats_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetStatsResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::BackupInfo> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).host_ref());
    case 2:
      return f(1, static_cast<T&&>(t).info_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::BackupInfo");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::SpaceBackupInfo> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_ref());
    case 2:
      return f(1, static_cast<T&&>(t).info_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::SpaceBackupInfo");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::BackupMeta> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).backup_info_ref());
    case 2:
      return f(1, static_cast<T&&>(t).meta_files_ref());
    case 3:
      return f(2, static_cast<T&&>(t).backup_name_ref());
    case 4:
      return f(3, static_cast<T&&>(t).full_ref());
    case 5:
      return f(4, static_cast<T&&>(t).include_system_space_ref());
    case 6:
      return f(5, static_cast<T&&>(t).create_time_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::BackupMeta");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::CreateBackupReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).spaces_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::CreateBackupReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::CreateBackupResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).meta_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::CreateBackupResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::HostPair> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).from_host_ref());
    case 2:
      return f(1, static_cast<T&&>(t).to_host_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::HostPair");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::RestoreMetaReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).files_ref());
    case 2:
      return f(1, static_cast<T&&>(t).hosts_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::RestoreMetaReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::FTClient> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).host_ref());
    case 2:
      return f(1, static_cast<T&&>(t).user_ref());
    case 3:
      return f(2, static_cast<T&&>(t).pwd_ref());
    case 4:
      return f(3, static_cast<T&&>(t).conn_type_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::FTClient");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::SignInFTServiceReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).type_ref());
    case 2:
      return f(1, static_cast<T&&>(t).clients_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::SignInFTServiceReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::SignOutFTServiceReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::SignOutFTServiceReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListFTClientsReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListFTClientsReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListFTClientsResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).clients_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListFTClientsResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::FTIndex> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).depend_schema_ref());
    case 3:
      return f(2, static_cast<T&&>(t).fields_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::FTIndex");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::CreateFTIndexReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).fulltext_index_name_ref());
    case 2:
      return f(1, static_cast<T&&>(t).index_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::CreateFTIndexReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::DropFTIndexReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).space_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).fulltext_index_name_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::DropFTIndexReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListFTIndexesReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListFTIndexesReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListFTIndexesResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).indexes_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListFTIndexesResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::QueryDesc> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).start_time_ref());
    case 2:
      return f(1, static_cast<T&&>(t).status_ref());
    case 3:
      return f(2, static_cast<T&&>(t).duration_ref());
    case 4:
      return f(3, static_cast<T&&>(t).query_ref());
    case 5:
      return f(4, static_cast<T&&>(t).graph_addr_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::QueryDesc");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::Session> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).session_id_ref());
    case 2:
      return f(1, static_cast<T&&>(t).create_time_ref());
    case 3:
      return f(2, static_cast<T&&>(t).update_time_ref());
    case 4:
      return f(3, static_cast<T&&>(t).user_name_ref());
    case 5:
      return f(4, static_cast<T&&>(t).space_name_ref());
    case 6:
      return f(5, static_cast<T&&>(t).graph_addr_ref());
    case 7:
      return f(6, static_cast<T&&>(t).timezone_ref());
    case 8:
      return f(7, static_cast<T&&>(t).client_ip_ref());
    case 9:
      return f(8, static_cast<T&&>(t).configs_ref());
    case 10:
      return f(9, static_cast<T&&>(t).queries_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::Session");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::CreateSessionReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).user_ref());
    case 2:
      return f(1, static_cast<T&&>(t).graph_addr_ref());
    case 3:
      return f(2, static_cast<T&&>(t).client_ip_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::CreateSessionReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::CreateSessionResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).session_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::CreateSessionResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::UpdateSessionsReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).sessions_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::UpdateSessionsReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::UpdateSessionsResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).killed_queries_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::UpdateSessionsResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListSessionsReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListSessionsReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListSessionsResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).sessions_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListSessionsResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetSessionReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).session_id_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetSessionReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetSessionResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).session_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetSessionResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::RemoveSessionReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).session_id_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::RemoveSessionReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::KillQueryReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).kill_queries_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::KillQueryReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ReportTaskReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).job_id_ref());
    case 3:
      return f(2, static_cast<T&&>(t).task_id_ref());
    case 4:
      return f(3, static_cast<T&&>(t).stats_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ReportTaskReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListClusterInfoResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).meta_servers_ref());
    case 4:
      return f(3, static_cast<T&&>(t).storage_servers_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListClusterInfoResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::ListClusterInfoReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::ListClusterInfoReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetMetaDirInfoResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).dir_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetMetaDirInfoResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::GetMetaDirInfoReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::GetMetaDirInfoReq");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::VerifyClientVersionResp> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 2:
      return f(1, static_cast<T&&>(t).leader_ref());
    case 3:
      return f(2, static_cast<T&&>(t).error_msg_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::VerifyClientVersionResp");
    }
  }
};

template <>
struct VisitByThriftId<::nebula::meta::cpp2::VerifyClientVersionReq> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, size_t id, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (id) {
    case 1:
      return f(0, static_cast<T&&>(t).version_ref());
    case 2:
      return f(1, static_cast<T&&>(t).host_ref());
    default:
      throwInvalidThriftId(id, "::nebula::meta::cpp2::VerifyClientVersionReq");
    }
  }
};
} // namespace detail
} // namespace thrift
} // namespace apache
