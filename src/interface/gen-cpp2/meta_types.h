/**
 * Autogenerated by Thrift for meta.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>


#include "common_types.h"

namespace apache {
namespace thrift {
namespace tag {
struct space_id;
struct tag_id;
struct edge_type;
struct index_id;
struct cluster_id;
struct type;
struct type_length;
struct geo_shape;
struct name;
struct type;
struct default_value;
struct nullable;
struct comment;
struct ttl_duration;
struct ttl_col;
struct comment;
struct columns;
struct schema_prop;
struct id;
struct name;
struct space_name;
struct partition_num;
struct replica_factor;
struct charset_name;
struct collate_name;
struct vid_type;
struct zone_names;
struct isolation_level;
struct comment;
struct space_id;
struct properties;
struct tag_id;
struct tag_name;
struct version;
struct schema;
struct op;
struct schema;
struct edge_type;
struct edge_name;
struct version;
struct schema;
struct s2_max_level;
struct s2_max_cells;
struct index_id;
struct index_name;
struct schema_id;
struct schema_name;
struct fields;
struct comment;
struct index_params;
struct hostAddr;
struct status;
struct leader_parts;
struct all_parts;
struct role;
struct git_info_sha;
struct zone_name;
struct version;
struct account;
struct is_lock;
struct max_queries_per_hour;
struct max_updates_per_hour;
struct max_connections_per_hour;
struct max_user_connections;
struct user_id;
struct space_id;
struct role_type;
struct code;
struct id;
struct leader;
struct space_name;
struct op;
struct paras;
struct space_id;
struct op;
struct type;
struct paras;
struct space_id;
struct job_id;
struct type;
struct paras;
struct status;
struct start_time;
struct stop_time;
struct code;
struct space_id;
struct job_id;
struct task_id;
struct host;
struct status;
struct start_time;
struct stop_time;
struct code;
struct job_id;
struct job_desc;
struct task_desc;
struct recovered_job_num;
struct code;
struct leader;
struct result;
struct part_id;
struct proportion;
struct tag_vertices;
struct edges;
struct space_vertices;
struct space_edges;
struct positive_part_correlativity;
struct negative_part_correlativity;
struct status;
struct properties;
struct if_not_exists;
struct old_space_name;
struct new_space_name;
struct space_name;
struct if_exists;
struct space_name;
struct if_exists;
struct code;
struct leader;
struct spaces;
struct space_name;
struct code;
struct leader;
struct item;
struct space_id;
struct tag_name;
struct schema;
struct if_not_exists;
struct space_id;
struct tag_name;
struct tag_items;
struct schema_prop;
struct space_id;
struct tag_name;
struct if_exists;
struct space_id;
struct code;
struct leader;
struct tags;
struct space_id;
struct tag_name;
struct version;
struct code;
struct leader;
struct schema;
struct space_id;
struct edge_name;
struct schema;
struct if_not_exists;
struct space_id;
struct edge_name;
struct edge_items;
struct schema_prop;
struct space_id;
struct edge_name;
struct version;
struct code;
struct leader;
struct schema;
struct space_id;
struct edge_name;
struct if_exists;
struct space_id;
struct code;
struct leader;
struct edges;
struct hosts;
struct hosts;
struct type;
struct code;
struct leader;
struct hosts;
struct part_id;
struct leader;
struct peers;
struct losts;
struct space_id;
struct part_ids;
struct code;
struct leader;
struct parts;
struct space_id;
struct code;
struct leader;
struct parts;
struct terms;
struct host;
struct code;
struct leader;
struct workerid;
struct length;
struct code;
struct leader;
struct segment_id;
struct code;
struct leader;
struct cluster_id;
struct last_update_time_in_ms;
struct meta_version;
struct part_id;
struct term;
struct part_list;
struct role;
struct host;
struct cluster_id;
struct leader_partIds;
struct git_info_sha;
struct disk_parts;
struct dir;
struct version;
struct dir;
struct addr;
struct role;
struct host;
struct git_info_sha;
struct version;
struct code;
struct leader;
struct service_list;
struct name;
struct type_length;
struct space_id;
struct index_name;
struct tag_name;
struct fields;
struct if_not_exists;
struct comment;
struct index_params;
struct space_id;
struct index_name;
struct if_exists;
struct space_id;
struct index_name;
struct code;
struct leader;
struct item;
struct space_id;
struct code;
struct leader;
struct items;
struct space_id;
struct index_name;
struct edge_name;
struct fields;
struct if_not_exists;
struct comment;
struct index_params;
struct space_id;
struct index_name;
struct if_exists;
struct space_id;
struct index_name;
struct code;
struct leader;
struct item;
struct space_id;
struct code;
struct leader;
struct items;
struct space_id;
struct index_name;
struct account;
struct encoded_pwd;
struct if_not_exists;
struct account;
struct if_exists;
struct account;
struct encoded_pwd;
struct role_item;
struct role_item;
struct code;
struct leader;
struct users;
struct space_id;
struct code;
struct leader;
struct roles;
struct account;
struct account;
struct new_encoded_pwd;
struct old_encoded_pwd;
struct id;
struct command;
struct result;
struct start_time;
struct stop_time;
struct module;
struct name;
struct mode;
struct value;
struct items;
struct item;
struct code;
struct leader;
struct items;
struct item;
struct space;
struct module;
struct code;
struct leader;
struct items;
struct names;
struct name;
struct status;
struct hosts;
struct code;
struct leader;
struct snapshots;
struct space_id;
struct name;
struct status;
struct code;
struct leader;
struct statuses;
struct zones;
struct zone_name;
struct zone_name;
struct zone_name;
struct zone_items;
struct original_zone_name;
struct zone_name;
struct hosts;
struct zone_name;
struct is_new;
struct zone_name;
struct code;
struct leader;
struct hosts;
struct zone_name;
struct nodes;
struct code;
struct leader;
struct zones;
struct space_id;
struct type;
struct hosts;
struct space_id;
struct type;
struct space_id;
struct type;
struct host;
struct part_id;
struct status;
struct code;
struct leader;
struct listeners;
struct space_id;
struct code;
struct leader;
struct stats;
struct host;
struct checkpoints;
struct space;
struct host_backups;
struct space_backups;
struct meta_files;
struct backup_name;
struct full;
struct all_spaces;
struct create_time;
struct base_backup_name;
struct storage_hosts;
struct cluster_id;
struct spaces;
struct base_backup_name;
struct cluster_id;
struct code;
struct leader;
struct meta;
struct from_host;
struct to_host;
struct files;
struct hosts;
struct part_id;
struct hosts;
struct code;
struct leader;
struct part_hosts;
struct host;
struct user;
struct pwd;
struct conn_type;
struct type;
struct clients;
struct type;
struct type;
struct code;
struct leader;
struct clients;
struct space_id;
struct depend_schema;
struct fields;
struct fulltext_index_name;
struct index;
struct space_id;
struct fulltext_index_name;
struct code;
struct leader;
struct indexes;
struct start_time;
struct status;
struct duration;
struct query;
struct graph_addr;
struct session_id;
struct create_time;
struct update_time;
struct user_name;
struct space_name;
struct graph_addr;
struct timezone;
struct client_ip;
struct configs;
struct queries;
struct user;
struct graph_addr;
struct client_ip;
struct code;
struct leader;
struct session;
struct sessions;
struct code;
struct leader;
struct killed_queries;
struct killed_sessions;
struct code;
struct leader;
struct sessions;
struct session_id;
struct code;
struct leader;
struct session;
struct session_ids;
struct code;
struct leader;
struct removed_session_ids;
struct kill_queries;
struct code;
struct space_id;
struct job_id;
struct task_id;
struct stats;
struct code;
struct leader;
struct host_services;
struct code;
struct dir;
struct code;
struct leader;
struct error_msg;
struct client_version;
struct host;
struct build_version;
struct code;
struct leader;
struct error_msg;
struct client_version;
struct host;
struct build_version;
} // namespace tag
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tag_id
#define APACHE_THRIFT_ACCESSOR_tag_id
APACHE_THRIFT_DEFINE_ACCESSOR(tag_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edge_type
#define APACHE_THRIFT_ACCESSOR_edge_type
APACHE_THRIFT_DEFINE_ACCESSOR(edge_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_index_id
#define APACHE_THRIFT_ACCESSOR_index_id
APACHE_THRIFT_DEFINE_ACCESSOR(index_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cluster_id
#define APACHE_THRIFT_ACCESSOR_cluster_id
APACHE_THRIFT_DEFINE_ACCESSOR(cluster_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type_length
#define APACHE_THRIFT_ACCESSOR_type_length
APACHE_THRIFT_DEFINE_ACCESSOR(type_length);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_geo_shape
#define APACHE_THRIFT_ACCESSOR_geo_shape
APACHE_THRIFT_DEFINE_ACCESSOR(geo_shape);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_default_value
#define APACHE_THRIFT_ACCESSOR_default_value
APACHE_THRIFT_DEFINE_ACCESSOR(default_value);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_nullable
#define APACHE_THRIFT_ACCESSOR_nullable
APACHE_THRIFT_DEFINE_ACCESSOR(nullable);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_comment
#define APACHE_THRIFT_ACCESSOR_comment
APACHE_THRIFT_DEFINE_ACCESSOR(comment);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ttl_duration
#define APACHE_THRIFT_ACCESSOR_ttl_duration
APACHE_THRIFT_DEFINE_ACCESSOR(ttl_duration);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ttl_col
#define APACHE_THRIFT_ACCESSOR_ttl_col
APACHE_THRIFT_DEFINE_ACCESSOR(ttl_col);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_comment
#define APACHE_THRIFT_ACCESSOR_comment
APACHE_THRIFT_DEFINE_ACCESSOR(comment);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_columns
#define APACHE_THRIFT_ACCESSOR_columns
APACHE_THRIFT_DEFINE_ACCESSOR(columns);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_schema_prop
#define APACHE_THRIFT_ACCESSOR_schema_prop
APACHE_THRIFT_DEFINE_ACCESSOR(schema_prop);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_id
#define APACHE_THRIFT_ACCESSOR_id
APACHE_THRIFT_DEFINE_ACCESSOR(id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_name
#define APACHE_THRIFT_ACCESSOR_space_name
APACHE_THRIFT_DEFINE_ACCESSOR(space_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_partition_num
#define APACHE_THRIFT_ACCESSOR_partition_num
APACHE_THRIFT_DEFINE_ACCESSOR(partition_num);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_replica_factor
#define APACHE_THRIFT_ACCESSOR_replica_factor
APACHE_THRIFT_DEFINE_ACCESSOR(replica_factor);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_charset_name
#define APACHE_THRIFT_ACCESSOR_charset_name
APACHE_THRIFT_DEFINE_ACCESSOR(charset_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_collate_name
#define APACHE_THRIFT_ACCESSOR_collate_name
APACHE_THRIFT_DEFINE_ACCESSOR(collate_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_vid_type
#define APACHE_THRIFT_ACCESSOR_vid_type
APACHE_THRIFT_DEFINE_ACCESSOR(vid_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_zone_names
#define APACHE_THRIFT_ACCESSOR_zone_names
APACHE_THRIFT_DEFINE_ACCESSOR(zone_names);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_isolation_level
#define APACHE_THRIFT_ACCESSOR_isolation_level
APACHE_THRIFT_DEFINE_ACCESSOR(isolation_level);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_comment
#define APACHE_THRIFT_ACCESSOR_comment
APACHE_THRIFT_DEFINE_ACCESSOR(comment);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_properties
#define APACHE_THRIFT_ACCESSOR_properties
APACHE_THRIFT_DEFINE_ACCESSOR(properties);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tag_id
#define APACHE_THRIFT_ACCESSOR_tag_id
APACHE_THRIFT_DEFINE_ACCESSOR(tag_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tag_name
#define APACHE_THRIFT_ACCESSOR_tag_name
APACHE_THRIFT_DEFINE_ACCESSOR(tag_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_version
#define APACHE_THRIFT_ACCESSOR_version
APACHE_THRIFT_DEFINE_ACCESSOR(version);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_schema
#define APACHE_THRIFT_ACCESSOR_schema
APACHE_THRIFT_DEFINE_ACCESSOR(schema);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_op
#define APACHE_THRIFT_ACCESSOR_op
APACHE_THRIFT_DEFINE_ACCESSOR(op);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_schema
#define APACHE_THRIFT_ACCESSOR_schema
APACHE_THRIFT_DEFINE_ACCESSOR(schema);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edge_type
#define APACHE_THRIFT_ACCESSOR_edge_type
APACHE_THRIFT_DEFINE_ACCESSOR(edge_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edge_name
#define APACHE_THRIFT_ACCESSOR_edge_name
APACHE_THRIFT_DEFINE_ACCESSOR(edge_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_version
#define APACHE_THRIFT_ACCESSOR_version
APACHE_THRIFT_DEFINE_ACCESSOR(version);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_schema
#define APACHE_THRIFT_ACCESSOR_schema
APACHE_THRIFT_DEFINE_ACCESSOR(schema);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_s2_max_level
#define APACHE_THRIFT_ACCESSOR_s2_max_level
APACHE_THRIFT_DEFINE_ACCESSOR(s2_max_level);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_s2_max_cells
#define APACHE_THRIFT_ACCESSOR_s2_max_cells
APACHE_THRIFT_DEFINE_ACCESSOR(s2_max_cells);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_index_id
#define APACHE_THRIFT_ACCESSOR_index_id
APACHE_THRIFT_DEFINE_ACCESSOR(index_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_index_name
#define APACHE_THRIFT_ACCESSOR_index_name
APACHE_THRIFT_DEFINE_ACCESSOR(index_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_schema_id
#define APACHE_THRIFT_ACCESSOR_schema_id
APACHE_THRIFT_DEFINE_ACCESSOR(schema_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_schema_name
#define APACHE_THRIFT_ACCESSOR_schema_name
APACHE_THRIFT_DEFINE_ACCESSOR(schema_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fields
#define APACHE_THRIFT_ACCESSOR_fields
APACHE_THRIFT_DEFINE_ACCESSOR(fields);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_comment
#define APACHE_THRIFT_ACCESSOR_comment
APACHE_THRIFT_DEFINE_ACCESSOR(comment);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_index_params
#define APACHE_THRIFT_ACCESSOR_index_params
APACHE_THRIFT_DEFINE_ACCESSOR(index_params);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_hostAddr
#define APACHE_THRIFT_ACCESSOR_hostAddr
APACHE_THRIFT_DEFINE_ACCESSOR(hostAddr);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_status
#define APACHE_THRIFT_ACCESSOR_status
APACHE_THRIFT_DEFINE_ACCESSOR(status);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader_parts
#define APACHE_THRIFT_ACCESSOR_leader_parts
APACHE_THRIFT_DEFINE_ACCESSOR(leader_parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_all_parts
#define APACHE_THRIFT_ACCESSOR_all_parts
APACHE_THRIFT_DEFINE_ACCESSOR(all_parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_role
#define APACHE_THRIFT_ACCESSOR_role
APACHE_THRIFT_DEFINE_ACCESSOR(role);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_git_info_sha
#define APACHE_THRIFT_ACCESSOR_git_info_sha
APACHE_THRIFT_DEFINE_ACCESSOR(git_info_sha);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_zone_name
#define APACHE_THRIFT_ACCESSOR_zone_name
APACHE_THRIFT_DEFINE_ACCESSOR(zone_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_version
#define APACHE_THRIFT_ACCESSOR_version
APACHE_THRIFT_DEFINE_ACCESSOR(version);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_account
#define APACHE_THRIFT_ACCESSOR_account
APACHE_THRIFT_DEFINE_ACCESSOR(account);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_is_lock
#define APACHE_THRIFT_ACCESSOR_is_lock
APACHE_THRIFT_DEFINE_ACCESSOR(is_lock);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_max_queries_per_hour
#define APACHE_THRIFT_ACCESSOR_max_queries_per_hour
APACHE_THRIFT_DEFINE_ACCESSOR(max_queries_per_hour);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_max_updates_per_hour
#define APACHE_THRIFT_ACCESSOR_max_updates_per_hour
APACHE_THRIFT_DEFINE_ACCESSOR(max_updates_per_hour);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_max_connections_per_hour
#define APACHE_THRIFT_ACCESSOR_max_connections_per_hour
APACHE_THRIFT_DEFINE_ACCESSOR(max_connections_per_hour);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_max_user_connections
#define APACHE_THRIFT_ACCESSOR_max_user_connections
APACHE_THRIFT_DEFINE_ACCESSOR(max_user_connections);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_user_id
#define APACHE_THRIFT_ACCESSOR_user_id
APACHE_THRIFT_DEFINE_ACCESSOR(user_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_role_type
#define APACHE_THRIFT_ACCESSOR_role_type
APACHE_THRIFT_DEFINE_ACCESSOR(role_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_id
#define APACHE_THRIFT_ACCESSOR_id
APACHE_THRIFT_DEFINE_ACCESSOR(id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_name
#define APACHE_THRIFT_ACCESSOR_space_name
APACHE_THRIFT_DEFINE_ACCESSOR(space_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_op
#define APACHE_THRIFT_ACCESSOR_op
APACHE_THRIFT_DEFINE_ACCESSOR(op);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_paras
#define APACHE_THRIFT_ACCESSOR_paras
APACHE_THRIFT_DEFINE_ACCESSOR(paras);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_op
#define APACHE_THRIFT_ACCESSOR_op
APACHE_THRIFT_DEFINE_ACCESSOR(op);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_paras
#define APACHE_THRIFT_ACCESSOR_paras
APACHE_THRIFT_DEFINE_ACCESSOR(paras);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_job_id
#define APACHE_THRIFT_ACCESSOR_job_id
APACHE_THRIFT_DEFINE_ACCESSOR(job_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_paras
#define APACHE_THRIFT_ACCESSOR_paras
APACHE_THRIFT_DEFINE_ACCESSOR(paras);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_status
#define APACHE_THRIFT_ACCESSOR_status
APACHE_THRIFT_DEFINE_ACCESSOR(status);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_start_time
#define APACHE_THRIFT_ACCESSOR_start_time
APACHE_THRIFT_DEFINE_ACCESSOR(start_time);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stop_time
#define APACHE_THRIFT_ACCESSOR_stop_time
APACHE_THRIFT_DEFINE_ACCESSOR(stop_time);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_job_id
#define APACHE_THRIFT_ACCESSOR_job_id
APACHE_THRIFT_DEFINE_ACCESSOR(job_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_task_id
#define APACHE_THRIFT_ACCESSOR_task_id
APACHE_THRIFT_DEFINE_ACCESSOR(task_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_host
#define APACHE_THRIFT_ACCESSOR_host
APACHE_THRIFT_DEFINE_ACCESSOR(host);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_status
#define APACHE_THRIFT_ACCESSOR_status
APACHE_THRIFT_DEFINE_ACCESSOR(status);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_start_time
#define APACHE_THRIFT_ACCESSOR_start_time
APACHE_THRIFT_DEFINE_ACCESSOR(start_time);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stop_time
#define APACHE_THRIFT_ACCESSOR_stop_time
APACHE_THRIFT_DEFINE_ACCESSOR(stop_time);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_job_id
#define APACHE_THRIFT_ACCESSOR_job_id
APACHE_THRIFT_DEFINE_ACCESSOR(job_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_job_desc
#define APACHE_THRIFT_ACCESSOR_job_desc
APACHE_THRIFT_DEFINE_ACCESSOR(job_desc);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_task_desc
#define APACHE_THRIFT_ACCESSOR_task_desc
APACHE_THRIFT_DEFINE_ACCESSOR(task_desc);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_recovered_job_num
#define APACHE_THRIFT_ACCESSOR_recovered_job_num
APACHE_THRIFT_DEFINE_ACCESSOR(recovered_job_num);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_result
#define APACHE_THRIFT_ACCESSOR_result
APACHE_THRIFT_DEFINE_ACCESSOR(result);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_part_id
#define APACHE_THRIFT_ACCESSOR_part_id
APACHE_THRIFT_DEFINE_ACCESSOR(part_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_proportion
#define APACHE_THRIFT_ACCESSOR_proportion
APACHE_THRIFT_DEFINE_ACCESSOR(proportion);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tag_vertices
#define APACHE_THRIFT_ACCESSOR_tag_vertices
APACHE_THRIFT_DEFINE_ACCESSOR(tag_vertices);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edges
#define APACHE_THRIFT_ACCESSOR_edges
APACHE_THRIFT_DEFINE_ACCESSOR(edges);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_vertices
#define APACHE_THRIFT_ACCESSOR_space_vertices
APACHE_THRIFT_DEFINE_ACCESSOR(space_vertices);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_edges
#define APACHE_THRIFT_ACCESSOR_space_edges
APACHE_THRIFT_DEFINE_ACCESSOR(space_edges);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_positive_part_correlativity
#define APACHE_THRIFT_ACCESSOR_positive_part_correlativity
APACHE_THRIFT_DEFINE_ACCESSOR(positive_part_correlativity);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_negative_part_correlativity
#define APACHE_THRIFT_ACCESSOR_negative_part_correlativity
APACHE_THRIFT_DEFINE_ACCESSOR(negative_part_correlativity);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_status
#define APACHE_THRIFT_ACCESSOR_status
APACHE_THRIFT_DEFINE_ACCESSOR(status);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_properties
#define APACHE_THRIFT_ACCESSOR_properties
APACHE_THRIFT_DEFINE_ACCESSOR(properties);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_if_not_exists
#define APACHE_THRIFT_ACCESSOR_if_not_exists
APACHE_THRIFT_DEFINE_ACCESSOR(if_not_exists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_old_space_name
#define APACHE_THRIFT_ACCESSOR_old_space_name
APACHE_THRIFT_DEFINE_ACCESSOR(old_space_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_new_space_name
#define APACHE_THRIFT_ACCESSOR_new_space_name
APACHE_THRIFT_DEFINE_ACCESSOR(new_space_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_name
#define APACHE_THRIFT_ACCESSOR_space_name
APACHE_THRIFT_DEFINE_ACCESSOR(space_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_if_exists
#define APACHE_THRIFT_ACCESSOR_if_exists
APACHE_THRIFT_DEFINE_ACCESSOR(if_exists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_name
#define APACHE_THRIFT_ACCESSOR_space_name
APACHE_THRIFT_DEFINE_ACCESSOR(space_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_if_exists
#define APACHE_THRIFT_ACCESSOR_if_exists
APACHE_THRIFT_DEFINE_ACCESSOR(if_exists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_spaces
#define APACHE_THRIFT_ACCESSOR_spaces
APACHE_THRIFT_DEFINE_ACCESSOR(spaces);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_name
#define APACHE_THRIFT_ACCESSOR_space_name
APACHE_THRIFT_DEFINE_ACCESSOR(space_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_item
#define APACHE_THRIFT_ACCESSOR_item
APACHE_THRIFT_DEFINE_ACCESSOR(item);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tag_name
#define APACHE_THRIFT_ACCESSOR_tag_name
APACHE_THRIFT_DEFINE_ACCESSOR(tag_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_schema
#define APACHE_THRIFT_ACCESSOR_schema
APACHE_THRIFT_DEFINE_ACCESSOR(schema);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_if_not_exists
#define APACHE_THRIFT_ACCESSOR_if_not_exists
APACHE_THRIFT_DEFINE_ACCESSOR(if_not_exists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tag_name
#define APACHE_THRIFT_ACCESSOR_tag_name
APACHE_THRIFT_DEFINE_ACCESSOR(tag_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tag_items
#define APACHE_THRIFT_ACCESSOR_tag_items
APACHE_THRIFT_DEFINE_ACCESSOR(tag_items);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_schema_prop
#define APACHE_THRIFT_ACCESSOR_schema_prop
APACHE_THRIFT_DEFINE_ACCESSOR(schema_prop);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tag_name
#define APACHE_THRIFT_ACCESSOR_tag_name
APACHE_THRIFT_DEFINE_ACCESSOR(tag_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_if_exists
#define APACHE_THRIFT_ACCESSOR_if_exists
APACHE_THRIFT_DEFINE_ACCESSOR(if_exists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tags
#define APACHE_THRIFT_ACCESSOR_tags
APACHE_THRIFT_DEFINE_ACCESSOR(tags);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tag_name
#define APACHE_THRIFT_ACCESSOR_tag_name
APACHE_THRIFT_DEFINE_ACCESSOR(tag_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_version
#define APACHE_THRIFT_ACCESSOR_version
APACHE_THRIFT_DEFINE_ACCESSOR(version);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_schema
#define APACHE_THRIFT_ACCESSOR_schema
APACHE_THRIFT_DEFINE_ACCESSOR(schema);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edge_name
#define APACHE_THRIFT_ACCESSOR_edge_name
APACHE_THRIFT_DEFINE_ACCESSOR(edge_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_schema
#define APACHE_THRIFT_ACCESSOR_schema
APACHE_THRIFT_DEFINE_ACCESSOR(schema);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_if_not_exists
#define APACHE_THRIFT_ACCESSOR_if_not_exists
APACHE_THRIFT_DEFINE_ACCESSOR(if_not_exists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edge_name
#define APACHE_THRIFT_ACCESSOR_edge_name
APACHE_THRIFT_DEFINE_ACCESSOR(edge_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edge_items
#define APACHE_THRIFT_ACCESSOR_edge_items
APACHE_THRIFT_DEFINE_ACCESSOR(edge_items);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_schema_prop
#define APACHE_THRIFT_ACCESSOR_schema_prop
APACHE_THRIFT_DEFINE_ACCESSOR(schema_prop);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edge_name
#define APACHE_THRIFT_ACCESSOR_edge_name
APACHE_THRIFT_DEFINE_ACCESSOR(edge_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_version
#define APACHE_THRIFT_ACCESSOR_version
APACHE_THRIFT_DEFINE_ACCESSOR(version);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_schema
#define APACHE_THRIFT_ACCESSOR_schema
APACHE_THRIFT_DEFINE_ACCESSOR(schema);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edge_name
#define APACHE_THRIFT_ACCESSOR_edge_name
APACHE_THRIFT_DEFINE_ACCESSOR(edge_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_if_exists
#define APACHE_THRIFT_ACCESSOR_if_exists
APACHE_THRIFT_DEFINE_ACCESSOR(if_exists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edges
#define APACHE_THRIFT_ACCESSOR_edges
APACHE_THRIFT_DEFINE_ACCESSOR(edges);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_hosts
#define APACHE_THRIFT_ACCESSOR_hosts
APACHE_THRIFT_DEFINE_ACCESSOR(hosts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_hosts
#define APACHE_THRIFT_ACCESSOR_hosts
APACHE_THRIFT_DEFINE_ACCESSOR(hosts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_hosts
#define APACHE_THRIFT_ACCESSOR_hosts
APACHE_THRIFT_DEFINE_ACCESSOR(hosts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_part_id
#define APACHE_THRIFT_ACCESSOR_part_id
APACHE_THRIFT_DEFINE_ACCESSOR(part_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_peers
#define APACHE_THRIFT_ACCESSOR_peers
APACHE_THRIFT_DEFINE_ACCESSOR(peers);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_losts
#define APACHE_THRIFT_ACCESSOR_losts
APACHE_THRIFT_DEFINE_ACCESSOR(losts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_part_ids
#define APACHE_THRIFT_ACCESSOR_part_ids
APACHE_THRIFT_DEFINE_ACCESSOR(part_ids);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_terms
#define APACHE_THRIFT_ACCESSOR_terms
APACHE_THRIFT_DEFINE_ACCESSOR(terms);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_host
#define APACHE_THRIFT_ACCESSOR_host
APACHE_THRIFT_DEFINE_ACCESSOR(host);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_workerid
#define APACHE_THRIFT_ACCESSOR_workerid
APACHE_THRIFT_DEFINE_ACCESSOR(workerid);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_length
#define APACHE_THRIFT_ACCESSOR_length
APACHE_THRIFT_DEFINE_ACCESSOR(length);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_segment_id
#define APACHE_THRIFT_ACCESSOR_segment_id
APACHE_THRIFT_DEFINE_ACCESSOR(segment_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cluster_id
#define APACHE_THRIFT_ACCESSOR_cluster_id
APACHE_THRIFT_DEFINE_ACCESSOR(cluster_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_last_update_time_in_ms
#define APACHE_THRIFT_ACCESSOR_last_update_time_in_ms
APACHE_THRIFT_DEFINE_ACCESSOR(last_update_time_in_ms);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_meta_version
#define APACHE_THRIFT_ACCESSOR_meta_version
APACHE_THRIFT_DEFINE_ACCESSOR(meta_version);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_part_id
#define APACHE_THRIFT_ACCESSOR_part_id
APACHE_THRIFT_DEFINE_ACCESSOR(part_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_term
#define APACHE_THRIFT_ACCESSOR_term
APACHE_THRIFT_DEFINE_ACCESSOR(term);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_part_list
#define APACHE_THRIFT_ACCESSOR_part_list
APACHE_THRIFT_DEFINE_ACCESSOR(part_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_role
#define APACHE_THRIFT_ACCESSOR_role
APACHE_THRIFT_DEFINE_ACCESSOR(role);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_host
#define APACHE_THRIFT_ACCESSOR_host
APACHE_THRIFT_DEFINE_ACCESSOR(host);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cluster_id
#define APACHE_THRIFT_ACCESSOR_cluster_id
APACHE_THRIFT_DEFINE_ACCESSOR(cluster_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader_partIds
#define APACHE_THRIFT_ACCESSOR_leader_partIds
APACHE_THRIFT_DEFINE_ACCESSOR(leader_partIds);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_git_info_sha
#define APACHE_THRIFT_ACCESSOR_git_info_sha
APACHE_THRIFT_DEFINE_ACCESSOR(git_info_sha);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_disk_parts
#define APACHE_THRIFT_ACCESSOR_disk_parts
APACHE_THRIFT_DEFINE_ACCESSOR(disk_parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_dir
#define APACHE_THRIFT_ACCESSOR_dir
APACHE_THRIFT_DEFINE_ACCESSOR(dir);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_version
#define APACHE_THRIFT_ACCESSOR_version
APACHE_THRIFT_DEFINE_ACCESSOR(version);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_dir
#define APACHE_THRIFT_ACCESSOR_dir
APACHE_THRIFT_DEFINE_ACCESSOR(dir);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_addr
#define APACHE_THRIFT_ACCESSOR_addr
APACHE_THRIFT_DEFINE_ACCESSOR(addr);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_role
#define APACHE_THRIFT_ACCESSOR_role
APACHE_THRIFT_DEFINE_ACCESSOR(role);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_host
#define APACHE_THRIFT_ACCESSOR_host
APACHE_THRIFT_DEFINE_ACCESSOR(host);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_git_info_sha
#define APACHE_THRIFT_ACCESSOR_git_info_sha
APACHE_THRIFT_DEFINE_ACCESSOR(git_info_sha);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_version
#define APACHE_THRIFT_ACCESSOR_version
APACHE_THRIFT_DEFINE_ACCESSOR(version);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_service_list
#define APACHE_THRIFT_ACCESSOR_service_list
APACHE_THRIFT_DEFINE_ACCESSOR(service_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type_length
#define APACHE_THRIFT_ACCESSOR_type_length
APACHE_THRIFT_DEFINE_ACCESSOR(type_length);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_index_name
#define APACHE_THRIFT_ACCESSOR_index_name
APACHE_THRIFT_DEFINE_ACCESSOR(index_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tag_name
#define APACHE_THRIFT_ACCESSOR_tag_name
APACHE_THRIFT_DEFINE_ACCESSOR(tag_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fields
#define APACHE_THRIFT_ACCESSOR_fields
APACHE_THRIFT_DEFINE_ACCESSOR(fields);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_if_not_exists
#define APACHE_THRIFT_ACCESSOR_if_not_exists
APACHE_THRIFT_DEFINE_ACCESSOR(if_not_exists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_comment
#define APACHE_THRIFT_ACCESSOR_comment
APACHE_THRIFT_DEFINE_ACCESSOR(comment);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_index_params
#define APACHE_THRIFT_ACCESSOR_index_params
APACHE_THRIFT_DEFINE_ACCESSOR(index_params);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_index_name
#define APACHE_THRIFT_ACCESSOR_index_name
APACHE_THRIFT_DEFINE_ACCESSOR(index_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_if_exists
#define APACHE_THRIFT_ACCESSOR_if_exists
APACHE_THRIFT_DEFINE_ACCESSOR(if_exists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_index_name
#define APACHE_THRIFT_ACCESSOR_index_name
APACHE_THRIFT_DEFINE_ACCESSOR(index_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_item
#define APACHE_THRIFT_ACCESSOR_item
APACHE_THRIFT_DEFINE_ACCESSOR(item);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_items
#define APACHE_THRIFT_ACCESSOR_items
APACHE_THRIFT_DEFINE_ACCESSOR(items);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_index_name
#define APACHE_THRIFT_ACCESSOR_index_name
APACHE_THRIFT_DEFINE_ACCESSOR(index_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edge_name
#define APACHE_THRIFT_ACCESSOR_edge_name
APACHE_THRIFT_DEFINE_ACCESSOR(edge_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fields
#define APACHE_THRIFT_ACCESSOR_fields
APACHE_THRIFT_DEFINE_ACCESSOR(fields);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_if_not_exists
#define APACHE_THRIFT_ACCESSOR_if_not_exists
APACHE_THRIFT_DEFINE_ACCESSOR(if_not_exists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_comment
#define APACHE_THRIFT_ACCESSOR_comment
APACHE_THRIFT_DEFINE_ACCESSOR(comment);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_index_params
#define APACHE_THRIFT_ACCESSOR_index_params
APACHE_THRIFT_DEFINE_ACCESSOR(index_params);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_index_name
#define APACHE_THRIFT_ACCESSOR_index_name
APACHE_THRIFT_DEFINE_ACCESSOR(index_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_if_exists
#define APACHE_THRIFT_ACCESSOR_if_exists
APACHE_THRIFT_DEFINE_ACCESSOR(if_exists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_index_name
#define APACHE_THRIFT_ACCESSOR_index_name
APACHE_THRIFT_DEFINE_ACCESSOR(index_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_item
#define APACHE_THRIFT_ACCESSOR_item
APACHE_THRIFT_DEFINE_ACCESSOR(item);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_items
#define APACHE_THRIFT_ACCESSOR_items
APACHE_THRIFT_DEFINE_ACCESSOR(items);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_index_name
#define APACHE_THRIFT_ACCESSOR_index_name
APACHE_THRIFT_DEFINE_ACCESSOR(index_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_account
#define APACHE_THRIFT_ACCESSOR_account
APACHE_THRIFT_DEFINE_ACCESSOR(account);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_encoded_pwd
#define APACHE_THRIFT_ACCESSOR_encoded_pwd
APACHE_THRIFT_DEFINE_ACCESSOR(encoded_pwd);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_if_not_exists
#define APACHE_THRIFT_ACCESSOR_if_not_exists
APACHE_THRIFT_DEFINE_ACCESSOR(if_not_exists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_account
#define APACHE_THRIFT_ACCESSOR_account
APACHE_THRIFT_DEFINE_ACCESSOR(account);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_if_exists
#define APACHE_THRIFT_ACCESSOR_if_exists
APACHE_THRIFT_DEFINE_ACCESSOR(if_exists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_account
#define APACHE_THRIFT_ACCESSOR_account
APACHE_THRIFT_DEFINE_ACCESSOR(account);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_encoded_pwd
#define APACHE_THRIFT_ACCESSOR_encoded_pwd
APACHE_THRIFT_DEFINE_ACCESSOR(encoded_pwd);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_role_item
#define APACHE_THRIFT_ACCESSOR_role_item
APACHE_THRIFT_DEFINE_ACCESSOR(role_item);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_role_item
#define APACHE_THRIFT_ACCESSOR_role_item
APACHE_THRIFT_DEFINE_ACCESSOR(role_item);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_users
#define APACHE_THRIFT_ACCESSOR_users
APACHE_THRIFT_DEFINE_ACCESSOR(users);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_roles
#define APACHE_THRIFT_ACCESSOR_roles
APACHE_THRIFT_DEFINE_ACCESSOR(roles);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_account
#define APACHE_THRIFT_ACCESSOR_account
APACHE_THRIFT_DEFINE_ACCESSOR(account);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_account
#define APACHE_THRIFT_ACCESSOR_account
APACHE_THRIFT_DEFINE_ACCESSOR(account);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_new_encoded_pwd
#define APACHE_THRIFT_ACCESSOR_new_encoded_pwd
APACHE_THRIFT_DEFINE_ACCESSOR(new_encoded_pwd);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_old_encoded_pwd
#define APACHE_THRIFT_ACCESSOR_old_encoded_pwd
APACHE_THRIFT_DEFINE_ACCESSOR(old_encoded_pwd);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_id
#define APACHE_THRIFT_ACCESSOR_id
APACHE_THRIFT_DEFINE_ACCESSOR(id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_command
#define APACHE_THRIFT_ACCESSOR_command
APACHE_THRIFT_DEFINE_ACCESSOR(command);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_result
#define APACHE_THRIFT_ACCESSOR_result
APACHE_THRIFT_DEFINE_ACCESSOR(result);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_start_time
#define APACHE_THRIFT_ACCESSOR_start_time
APACHE_THRIFT_DEFINE_ACCESSOR(start_time);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stop_time
#define APACHE_THRIFT_ACCESSOR_stop_time
APACHE_THRIFT_DEFINE_ACCESSOR(stop_time);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_module
#define APACHE_THRIFT_ACCESSOR_module
APACHE_THRIFT_DEFINE_ACCESSOR(module);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_mode
#define APACHE_THRIFT_ACCESSOR_mode
APACHE_THRIFT_DEFINE_ACCESSOR(mode);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_value
#define APACHE_THRIFT_ACCESSOR_value
APACHE_THRIFT_DEFINE_ACCESSOR(value);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_items
#define APACHE_THRIFT_ACCESSOR_items
APACHE_THRIFT_DEFINE_ACCESSOR(items);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_item
#define APACHE_THRIFT_ACCESSOR_item
APACHE_THRIFT_DEFINE_ACCESSOR(item);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_items
#define APACHE_THRIFT_ACCESSOR_items
APACHE_THRIFT_DEFINE_ACCESSOR(items);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_item
#define APACHE_THRIFT_ACCESSOR_item
APACHE_THRIFT_DEFINE_ACCESSOR(item);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space
#define APACHE_THRIFT_ACCESSOR_space
APACHE_THRIFT_DEFINE_ACCESSOR(space);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_module
#define APACHE_THRIFT_ACCESSOR_module
APACHE_THRIFT_DEFINE_ACCESSOR(module);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_items
#define APACHE_THRIFT_ACCESSOR_items
APACHE_THRIFT_DEFINE_ACCESSOR(items);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_names
#define APACHE_THRIFT_ACCESSOR_names
APACHE_THRIFT_DEFINE_ACCESSOR(names);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_status
#define APACHE_THRIFT_ACCESSOR_status
APACHE_THRIFT_DEFINE_ACCESSOR(status);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_hosts
#define APACHE_THRIFT_ACCESSOR_hosts
APACHE_THRIFT_DEFINE_ACCESSOR(hosts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_snapshots
#define APACHE_THRIFT_ACCESSOR_snapshots
APACHE_THRIFT_DEFINE_ACCESSOR(snapshots);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_status
#define APACHE_THRIFT_ACCESSOR_status
APACHE_THRIFT_DEFINE_ACCESSOR(status);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_statuses
#define APACHE_THRIFT_ACCESSOR_statuses
APACHE_THRIFT_DEFINE_ACCESSOR(statuses);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_zones
#define APACHE_THRIFT_ACCESSOR_zones
APACHE_THRIFT_DEFINE_ACCESSOR(zones);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_zone_name
#define APACHE_THRIFT_ACCESSOR_zone_name
APACHE_THRIFT_DEFINE_ACCESSOR(zone_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_zone_name
#define APACHE_THRIFT_ACCESSOR_zone_name
APACHE_THRIFT_DEFINE_ACCESSOR(zone_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_zone_name
#define APACHE_THRIFT_ACCESSOR_zone_name
APACHE_THRIFT_DEFINE_ACCESSOR(zone_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_zone_items
#define APACHE_THRIFT_ACCESSOR_zone_items
APACHE_THRIFT_DEFINE_ACCESSOR(zone_items);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_original_zone_name
#define APACHE_THRIFT_ACCESSOR_original_zone_name
APACHE_THRIFT_DEFINE_ACCESSOR(original_zone_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_zone_name
#define APACHE_THRIFT_ACCESSOR_zone_name
APACHE_THRIFT_DEFINE_ACCESSOR(zone_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_hosts
#define APACHE_THRIFT_ACCESSOR_hosts
APACHE_THRIFT_DEFINE_ACCESSOR(hosts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_zone_name
#define APACHE_THRIFT_ACCESSOR_zone_name
APACHE_THRIFT_DEFINE_ACCESSOR(zone_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_is_new
#define APACHE_THRIFT_ACCESSOR_is_new
APACHE_THRIFT_DEFINE_ACCESSOR(is_new);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_zone_name
#define APACHE_THRIFT_ACCESSOR_zone_name
APACHE_THRIFT_DEFINE_ACCESSOR(zone_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_hosts
#define APACHE_THRIFT_ACCESSOR_hosts
APACHE_THRIFT_DEFINE_ACCESSOR(hosts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_zone_name
#define APACHE_THRIFT_ACCESSOR_zone_name
APACHE_THRIFT_DEFINE_ACCESSOR(zone_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_nodes
#define APACHE_THRIFT_ACCESSOR_nodes
APACHE_THRIFT_DEFINE_ACCESSOR(nodes);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_zones
#define APACHE_THRIFT_ACCESSOR_zones
APACHE_THRIFT_DEFINE_ACCESSOR(zones);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_hosts
#define APACHE_THRIFT_ACCESSOR_hosts
APACHE_THRIFT_DEFINE_ACCESSOR(hosts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_host
#define APACHE_THRIFT_ACCESSOR_host
APACHE_THRIFT_DEFINE_ACCESSOR(host);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_part_id
#define APACHE_THRIFT_ACCESSOR_part_id
APACHE_THRIFT_DEFINE_ACCESSOR(part_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_status
#define APACHE_THRIFT_ACCESSOR_status
APACHE_THRIFT_DEFINE_ACCESSOR(status);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_listeners
#define APACHE_THRIFT_ACCESSOR_listeners
APACHE_THRIFT_DEFINE_ACCESSOR(listeners);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stats
#define APACHE_THRIFT_ACCESSOR_stats
APACHE_THRIFT_DEFINE_ACCESSOR(stats);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_host
#define APACHE_THRIFT_ACCESSOR_host
APACHE_THRIFT_DEFINE_ACCESSOR(host);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_checkpoints
#define APACHE_THRIFT_ACCESSOR_checkpoints
APACHE_THRIFT_DEFINE_ACCESSOR(checkpoints);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space
#define APACHE_THRIFT_ACCESSOR_space
APACHE_THRIFT_DEFINE_ACCESSOR(space);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_host_backups
#define APACHE_THRIFT_ACCESSOR_host_backups
APACHE_THRIFT_DEFINE_ACCESSOR(host_backups);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_backups
#define APACHE_THRIFT_ACCESSOR_space_backups
APACHE_THRIFT_DEFINE_ACCESSOR(space_backups);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_meta_files
#define APACHE_THRIFT_ACCESSOR_meta_files
APACHE_THRIFT_DEFINE_ACCESSOR(meta_files);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_backup_name
#define APACHE_THRIFT_ACCESSOR_backup_name
APACHE_THRIFT_DEFINE_ACCESSOR(backup_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_full
#define APACHE_THRIFT_ACCESSOR_full
APACHE_THRIFT_DEFINE_ACCESSOR(full);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_all_spaces
#define APACHE_THRIFT_ACCESSOR_all_spaces
APACHE_THRIFT_DEFINE_ACCESSOR(all_spaces);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_create_time
#define APACHE_THRIFT_ACCESSOR_create_time
APACHE_THRIFT_DEFINE_ACCESSOR(create_time);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_base_backup_name
#define APACHE_THRIFT_ACCESSOR_base_backup_name
APACHE_THRIFT_DEFINE_ACCESSOR(base_backup_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_storage_hosts
#define APACHE_THRIFT_ACCESSOR_storage_hosts
APACHE_THRIFT_DEFINE_ACCESSOR(storage_hosts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cluster_id
#define APACHE_THRIFT_ACCESSOR_cluster_id
APACHE_THRIFT_DEFINE_ACCESSOR(cluster_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_spaces
#define APACHE_THRIFT_ACCESSOR_spaces
APACHE_THRIFT_DEFINE_ACCESSOR(spaces);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_base_backup_name
#define APACHE_THRIFT_ACCESSOR_base_backup_name
APACHE_THRIFT_DEFINE_ACCESSOR(base_backup_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cluster_id
#define APACHE_THRIFT_ACCESSOR_cluster_id
APACHE_THRIFT_DEFINE_ACCESSOR(cluster_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_meta
#define APACHE_THRIFT_ACCESSOR_meta
APACHE_THRIFT_DEFINE_ACCESSOR(meta);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_from_host
#define APACHE_THRIFT_ACCESSOR_from_host
APACHE_THRIFT_DEFINE_ACCESSOR(from_host);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_to_host
#define APACHE_THRIFT_ACCESSOR_to_host
APACHE_THRIFT_DEFINE_ACCESSOR(to_host);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_files
#define APACHE_THRIFT_ACCESSOR_files
APACHE_THRIFT_DEFINE_ACCESSOR(files);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_hosts
#define APACHE_THRIFT_ACCESSOR_hosts
APACHE_THRIFT_DEFINE_ACCESSOR(hosts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_part_id
#define APACHE_THRIFT_ACCESSOR_part_id
APACHE_THRIFT_DEFINE_ACCESSOR(part_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_hosts
#define APACHE_THRIFT_ACCESSOR_hosts
APACHE_THRIFT_DEFINE_ACCESSOR(hosts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_part_hosts
#define APACHE_THRIFT_ACCESSOR_part_hosts
APACHE_THRIFT_DEFINE_ACCESSOR(part_hosts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_host
#define APACHE_THRIFT_ACCESSOR_host
APACHE_THRIFT_DEFINE_ACCESSOR(host);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_user
#define APACHE_THRIFT_ACCESSOR_user
APACHE_THRIFT_DEFINE_ACCESSOR(user);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_pwd
#define APACHE_THRIFT_ACCESSOR_pwd
APACHE_THRIFT_DEFINE_ACCESSOR(pwd);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_conn_type
#define APACHE_THRIFT_ACCESSOR_conn_type
APACHE_THRIFT_DEFINE_ACCESSOR(conn_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_clients
#define APACHE_THRIFT_ACCESSOR_clients
APACHE_THRIFT_DEFINE_ACCESSOR(clients);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_clients
#define APACHE_THRIFT_ACCESSOR_clients
APACHE_THRIFT_DEFINE_ACCESSOR(clients);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_depend_schema
#define APACHE_THRIFT_ACCESSOR_depend_schema
APACHE_THRIFT_DEFINE_ACCESSOR(depend_schema);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fields
#define APACHE_THRIFT_ACCESSOR_fields
APACHE_THRIFT_DEFINE_ACCESSOR(fields);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fulltext_index_name
#define APACHE_THRIFT_ACCESSOR_fulltext_index_name
APACHE_THRIFT_DEFINE_ACCESSOR(fulltext_index_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_index
#define APACHE_THRIFT_ACCESSOR_index
APACHE_THRIFT_DEFINE_ACCESSOR(index);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fulltext_index_name
#define APACHE_THRIFT_ACCESSOR_fulltext_index_name
APACHE_THRIFT_DEFINE_ACCESSOR(fulltext_index_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_indexes
#define APACHE_THRIFT_ACCESSOR_indexes
APACHE_THRIFT_DEFINE_ACCESSOR(indexes);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_start_time
#define APACHE_THRIFT_ACCESSOR_start_time
APACHE_THRIFT_DEFINE_ACCESSOR(start_time);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_status
#define APACHE_THRIFT_ACCESSOR_status
APACHE_THRIFT_DEFINE_ACCESSOR(status);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_duration
#define APACHE_THRIFT_ACCESSOR_duration
APACHE_THRIFT_DEFINE_ACCESSOR(duration);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_query
#define APACHE_THRIFT_ACCESSOR_query
APACHE_THRIFT_DEFINE_ACCESSOR(query);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_graph_addr
#define APACHE_THRIFT_ACCESSOR_graph_addr
APACHE_THRIFT_DEFINE_ACCESSOR(graph_addr);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_session_id
#define APACHE_THRIFT_ACCESSOR_session_id
APACHE_THRIFT_DEFINE_ACCESSOR(session_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_create_time
#define APACHE_THRIFT_ACCESSOR_create_time
APACHE_THRIFT_DEFINE_ACCESSOR(create_time);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_update_time
#define APACHE_THRIFT_ACCESSOR_update_time
APACHE_THRIFT_DEFINE_ACCESSOR(update_time);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_user_name
#define APACHE_THRIFT_ACCESSOR_user_name
APACHE_THRIFT_DEFINE_ACCESSOR(user_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_name
#define APACHE_THRIFT_ACCESSOR_space_name
APACHE_THRIFT_DEFINE_ACCESSOR(space_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_graph_addr
#define APACHE_THRIFT_ACCESSOR_graph_addr
APACHE_THRIFT_DEFINE_ACCESSOR(graph_addr);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_timezone
#define APACHE_THRIFT_ACCESSOR_timezone
APACHE_THRIFT_DEFINE_ACCESSOR(timezone);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_client_ip
#define APACHE_THRIFT_ACCESSOR_client_ip
APACHE_THRIFT_DEFINE_ACCESSOR(client_ip);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_configs
#define APACHE_THRIFT_ACCESSOR_configs
APACHE_THRIFT_DEFINE_ACCESSOR(configs);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_queries
#define APACHE_THRIFT_ACCESSOR_queries
APACHE_THRIFT_DEFINE_ACCESSOR(queries);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_user
#define APACHE_THRIFT_ACCESSOR_user
APACHE_THRIFT_DEFINE_ACCESSOR(user);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_graph_addr
#define APACHE_THRIFT_ACCESSOR_graph_addr
APACHE_THRIFT_DEFINE_ACCESSOR(graph_addr);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_client_ip
#define APACHE_THRIFT_ACCESSOR_client_ip
APACHE_THRIFT_DEFINE_ACCESSOR(client_ip);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_session
#define APACHE_THRIFT_ACCESSOR_session
APACHE_THRIFT_DEFINE_ACCESSOR(session);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_sessions
#define APACHE_THRIFT_ACCESSOR_sessions
APACHE_THRIFT_DEFINE_ACCESSOR(sessions);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_killed_queries
#define APACHE_THRIFT_ACCESSOR_killed_queries
APACHE_THRIFT_DEFINE_ACCESSOR(killed_queries);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_killed_sessions
#define APACHE_THRIFT_ACCESSOR_killed_sessions
APACHE_THRIFT_DEFINE_ACCESSOR(killed_sessions);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_sessions
#define APACHE_THRIFT_ACCESSOR_sessions
APACHE_THRIFT_DEFINE_ACCESSOR(sessions);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_session_id
#define APACHE_THRIFT_ACCESSOR_session_id
APACHE_THRIFT_DEFINE_ACCESSOR(session_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_session
#define APACHE_THRIFT_ACCESSOR_session
APACHE_THRIFT_DEFINE_ACCESSOR(session);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_session_ids
#define APACHE_THRIFT_ACCESSOR_session_ids
APACHE_THRIFT_DEFINE_ACCESSOR(session_ids);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_removed_session_ids
#define APACHE_THRIFT_ACCESSOR_removed_session_ids
APACHE_THRIFT_DEFINE_ACCESSOR(removed_session_ids);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_kill_queries
#define APACHE_THRIFT_ACCESSOR_kill_queries
APACHE_THRIFT_DEFINE_ACCESSOR(kill_queries);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_job_id
#define APACHE_THRIFT_ACCESSOR_job_id
APACHE_THRIFT_DEFINE_ACCESSOR(job_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_task_id
#define APACHE_THRIFT_ACCESSOR_task_id
APACHE_THRIFT_DEFINE_ACCESSOR(task_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stats
#define APACHE_THRIFT_ACCESSOR_stats
APACHE_THRIFT_DEFINE_ACCESSOR(stats);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_host_services
#define APACHE_THRIFT_ACCESSOR_host_services
APACHE_THRIFT_DEFINE_ACCESSOR(host_services);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_dir
#define APACHE_THRIFT_ACCESSOR_dir
APACHE_THRIFT_DEFINE_ACCESSOR(dir);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_error_msg
#define APACHE_THRIFT_ACCESSOR_error_msg
APACHE_THRIFT_DEFINE_ACCESSOR(error_msg);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_client_version
#define APACHE_THRIFT_ACCESSOR_client_version
APACHE_THRIFT_DEFINE_ACCESSOR(client_version);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_host
#define APACHE_THRIFT_ACCESSOR_host
APACHE_THRIFT_DEFINE_ACCESSOR(host);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_build_version
#define APACHE_THRIFT_ACCESSOR_build_version
APACHE_THRIFT_DEFINE_ACCESSOR(build_version);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_error_msg
#define APACHE_THRIFT_ACCESSOR_error_msg
APACHE_THRIFT_DEFINE_ACCESSOR(error_msg);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_client_version
#define APACHE_THRIFT_ACCESSOR_client_version
APACHE_THRIFT_DEFINE_ACCESSOR(client_version);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_host
#define APACHE_THRIFT_ACCESSOR_host
APACHE_THRIFT_DEFINE_ACCESSOR(host);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_build_version
#define APACHE_THRIFT_ACCESSOR_build_version
APACHE_THRIFT_DEFINE_ACCESSOR(build_version);
#endif
} // namespace detail
} // namespace thrift
} // namespace apache

// BEGIN declare_enums
namespace nebula { namespace meta { namespace cpp2 {

enum class AlterSchemaOp {
  ADD = 1,
  CHANGE = 2,
  DROP = 3,
  UNKNOWN = 4,
};




enum class RoleType {
  GOD = 1,
  ADMIN = 2,
  DBA = 3,
  USER = 4,
  GUEST = 5,
};




enum class GeoShape {
  ANY = 0,
  POINT = 1,
  LINESTRING = 2,
  POLYGON = 3,
};




enum class IsolationLevel {
  DEFAULT = 0,
  TOSS = 1,
};




enum class HostStatus {
  ONLINE = 0,
  OFFLINE = 1,
  UNKNOWN = 2,
};




enum class SnapshotStatus {
  VALID = 0,
  INVALID = 1,
};




enum class AlterSpaceOp {
  ADD_ZONE = 1,
};




enum class JobOp {
  ADD = 1,
  SHOW_All = 2,
  SHOW = 3,
  STOP = 4,
  RECOVER = 5,
};




enum class JobType {
  COMPACT = 0,
  FLUSH = 1,
  REBUILD_TAG_INDEX = 2,
  REBUILD_EDGE_INDEX = 3,
  REBUILD_FULLTEXT_INDEX = 4,
  STATS = 5,
  DATA_BALANCE = 6,
  DOWNLOAD = 7,
  INGEST = 8,
  LEADER_BALANCE = 9,
  ZONE_BALANCE = 10,
  UNKNOWN = 99,
};




enum class JobStatus {
  QUEUE = 1,
  RUNNING = 2,
  FINISHED = 3,
  FAILED = 4,
  STOPPED = 5,
  INVALID = 255,
};




enum class ListHostType {
  ALLOC = 0,
  GRAPH = 1,
  META = 2,
  STORAGE = 3,
  AGENT = 4,
  STORAGE_LISTENER = 5,
};




enum class HostRole {
  GRAPH = 0,
  META = 1,
  STORAGE = 2,
  STORAGE_LISTENER = 3,
  AGENT = 4,
  UNKNOWN = 5,
};




enum class TaskResult {
  SUCCEEDED = 0,
  FAILED = 1,
  IN_PROGRESS = 2,
  INVALID = 3,
};




enum class ConfigModule {
  UNKNOWN = 0,
  ALL = 1,
  GRAPH = 2,
  META = 3,
  STORAGE = 4,
};




enum class ConfigMode {
  IMMUTABLE = 0,
  REBOOT = 1,
  MUTABLE = 2,
  IGNORED = 3,
};




enum class ListenerType {
  UNKNOWN = 0,
  ELASTICSEARCH = 1,
};




enum class ExternalServiceType {
  ELASTICSEARCH = 1,
};




enum class QueryStatus {
  RUNNING = 1,
  KILLING = 2,
};




}}} // nebula::meta::cpp2
namespace std {


template<> struct hash<typename ::nebula::meta::cpp2::AlterSchemaOp> : public apache::thrift::detail::enum_hash<typename ::nebula::meta::cpp2::AlterSchemaOp> {};
template<> struct equal_to<typename ::nebula::meta::cpp2::AlterSchemaOp> : public apache::thrift::detail::enum_equal_to<typename ::nebula::meta::cpp2::AlterSchemaOp> {};


template<> struct hash<typename ::nebula::meta::cpp2::RoleType> : public apache::thrift::detail::enum_hash<typename ::nebula::meta::cpp2::RoleType> {};
template<> struct equal_to<typename ::nebula::meta::cpp2::RoleType> : public apache::thrift::detail::enum_equal_to<typename ::nebula::meta::cpp2::RoleType> {};


template<> struct hash<typename ::nebula::meta::cpp2::GeoShape> : public apache::thrift::detail::enum_hash<typename ::nebula::meta::cpp2::GeoShape> {};
template<> struct equal_to<typename ::nebula::meta::cpp2::GeoShape> : public apache::thrift::detail::enum_equal_to<typename ::nebula::meta::cpp2::GeoShape> {};


template<> struct hash<typename ::nebula::meta::cpp2::IsolationLevel> : public apache::thrift::detail::enum_hash<typename ::nebula::meta::cpp2::IsolationLevel> {};
template<> struct equal_to<typename ::nebula::meta::cpp2::IsolationLevel> : public apache::thrift::detail::enum_equal_to<typename ::nebula::meta::cpp2::IsolationLevel> {};


template<> struct hash<typename ::nebula::meta::cpp2::HostStatus> : public apache::thrift::detail::enum_hash<typename ::nebula::meta::cpp2::HostStatus> {};
template<> struct equal_to<typename ::nebula::meta::cpp2::HostStatus> : public apache::thrift::detail::enum_equal_to<typename ::nebula::meta::cpp2::HostStatus> {};


template<> struct hash<typename ::nebula::meta::cpp2::SnapshotStatus> : public apache::thrift::detail::enum_hash<typename ::nebula::meta::cpp2::SnapshotStatus> {};
template<> struct equal_to<typename ::nebula::meta::cpp2::SnapshotStatus> : public apache::thrift::detail::enum_equal_to<typename ::nebula::meta::cpp2::SnapshotStatus> {};


template<> struct hash<typename ::nebula::meta::cpp2::AlterSpaceOp> : public apache::thrift::detail::enum_hash<typename ::nebula::meta::cpp2::AlterSpaceOp> {};
template<> struct equal_to<typename ::nebula::meta::cpp2::AlterSpaceOp> : public apache::thrift::detail::enum_equal_to<typename ::nebula::meta::cpp2::AlterSpaceOp> {};


template<> struct hash<typename ::nebula::meta::cpp2::JobOp> : public apache::thrift::detail::enum_hash<typename ::nebula::meta::cpp2::JobOp> {};
template<> struct equal_to<typename ::nebula::meta::cpp2::JobOp> : public apache::thrift::detail::enum_equal_to<typename ::nebula::meta::cpp2::JobOp> {};


template<> struct hash<typename ::nebula::meta::cpp2::JobType> : public apache::thrift::detail::enum_hash<typename ::nebula::meta::cpp2::JobType> {};
template<> struct equal_to<typename ::nebula::meta::cpp2::JobType> : public apache::thrift::detail::enum_equal_to<typename ::nebula::meta::cpp2::JobType> {};


template<> struct hash<typename ::nebula::meta::cpp2::JobStatus> : public apache::thrift::detail::enum_hash<typename ::nebula::meta::cpp2::JobStatus> {};
template<> struct equal_to<typename ::nebula::meta::cpp2::JobStatus> : public apache::thrift::detail::enum_equal_to<typename ::nebula::meta::cpp2::JobStatus> {};


template<> struct hash<typename ::nebula::meta::cpp2::ListHostType> : public apache::thrift::detail::enum_hash<typename ::nebula::meta::cpp2::ListHostType> {};
template<> struct equal_to<typename ::nebula::meta::cpp2::ListHostType> : public apache::thrift::detail::enum_equal_to<typename ::nebula::meta::cpp2::ListHostType> {};


template<> struct hash<typename ::nebula::meta::cpp2::HostRole> : public apache::thrift::detail::enum_hash<typename ::nebula::meta::cpp2::HostRole> {};
template<> struct equal_to<typename ::nebula::meta::cpp2::HostRole> : public apache::thrift::detail::enum_equal_to<typename ::nebula::meta::cpp2::HostRole> {};


template<> struct hash<typename ::nebula::meta::cpp2::TaskResult> : public apache::thrift::detail::enum_hash<typename ::nebula::meta::cpp2::TaskResult> {};
template<> struct equal_to<typename ::nebula::meta::cpp2::TaskResult> : public apache::thrift::detail::enum_equal_to<typename ::nebula::meta::cpp2::TaskResult> {};


template<> struct hash<typename ::nebula::meta::cpp2::ConfigModule> : public apache::thrift::detail::enum_hash<typename ::nebula::meta::cpp2::ConfigModule> {};
template<> struct equal_to<typename ::nebula::meta::cpp2::ConfigModule> : public apache::thrift::detail::enum_equal_to<typename ::nebula::meta::cpp2::ConfigModule> {};


template<> struct hash<typename ::nebula::meta::cpp2::ConfigMode> : public apache::thrift::detail::enum_hash<typename ::nebula::meta::cpp2::ConfigMode> {};
template<> struct equal_to<typename ::nebula::meta::cpp2::ConfigMode> : public apache::thrift::detail::enum_equal_to<typename ::nebula::meta::cpp2::ConfigMode> {};


template<> struct hash<typename ::nebula::meta::cpp2::ListenerType> : public apache::thrift::detail::enum_hash<typename ::nebula::meta::cpp2::ListenerType> {};
template<> struct equal_to<typename ::nebula::meta::cpp2::ListenerType> : public apache::thrift::detail::enum_equal_to<typename ::nebula::meta::cpp2::ListenerType> {};


template<> struct hash<typename ::nebula::meta::cpp2::ExternalServiceType> : public apache::thrift::detail::enum_hash<typename ::nebula::meta::cpp2::ExternalServiceType> {};
template<> struct equal_to<typename ::nebula::meta::cpp2::ExternalServiceType> : public apache::thrift::detail::enum_equal_to<typename ::nebula::meta::cpp2::ExternalServiceType> {};


template<> struct hash<typename ::nebula::meta::cpp2::QueryStatus> : public apache::thrift::detail::enum_hash<typename ::nebula::meta::cpp2::QueryStatus> {};
template<> struct equal_to<typename ::nebula::meta::cpp2::QueryStatus> : public apache::thrift::detail::enum_equal_to<typename ::nebula::meta::cpp2::QueryStatus> {};


} // std

namespace apache { namespace thrift {


template <> struct TEnumDataStorage<::nebula::meta::cpp2::AlterSchemaOp>;

template <> struct TEnumTraits<::nebula::meta::cpp2::AlterSchemaOp> {
  using type = ::nebula::meta::cpp2::AlterSchemaOp;

  static constexpr std::size_t const size = 4;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::ADD; }
  static constexpr type max() { return type::UNKNOWN; }
};


template <> struct TEnumDataStorage<::nebula::meta::cpp2::RoleType>;

template <> struct TEnumTraits<::nebula::meta::cpp2::RoleType> {
  using type = ::nebula::meta::cpp2::RoleType;

  static constexpr std::size_t const size = 5;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::GOD; }
  static constexpr type max() { return type::GUEST; }
};


template <> struct TEnumDataStorage<::nebula::meta::cpp2::GeoShape>;

template <> struct TEnumTraits<::nebula::meta::cpp2::GeoShape> {
  using type = ::nebula::meta::cpp2::GeoShape;

  static constexpr std::size_t const size = 4;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::ANY; }
  static constexpr type max() { return type::POLYGON; }
};


template <> struct TEnumDataStorage<::nebula::meta::cpp2::IsolationLevel>;

template <> struct TEnumTraits<::nebula::meta::cpp2::IsolationLevel> {
  using type = ::nebula::meta::cpp2::IsolationLevel;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::DEFAULT; }
  static constexpr type max() { return type::TOSS; }
};


template <> struct TEnumDataStorage<::nebula::meta::cpp2::HostStatus>;

template <> struct TEnumTraits<::nebula::meta::cpp2::HostStatus> {
  using type = ::nebula::meta::cpp2::HostStatus;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::ONLINE; }
  static constexpr type max() { return type::UNKNOWN; }
};


template <> struct TEnumDataStorage<::nebula::meta::cpp2::SnapshotStatus>;

template <> struct TEnumTraits<::nebula::meta::cpp2::SnapshotStatus> {
  using type = ::nebula::meta::cpp2::SnapshotStatus;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::VALID; }
  static constexpr type max() { return type::INVALID; }
};


template <> struct TEnumDataStorage<::nebula::meta::cpp2::AlterSpaceOp>;

template <> struct TEnumTraits<::nebula::meta::cpp2::AlterSpaceOp> {
  using type = ::nebula::meta::cpp2::AlterSpaceOp;

  static constexpr std::size_t const size = 1;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::ADD_ZONE; }
  static constexpr type max() { return type::ADD_ZONE; }
};


template <> struct TEnumDataStorage<::nebula::meta::cpp2::JobOp>;

template <> struct TEnumTraits<::nebula::meta::cpp2::JobOp> {
  using type = ::nebula::meta::cpp2::JobOp;

  static constexpr std::size_t const size = 5;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::ADD; }
  static constexpr type max() { return type::RECOVER; }
};


template <> struct TEnumDataStorage<::nebula::meta::cpp2::JobType>;

template <> struct TEnumTraits<::nebula::meta::cpp2::JobType> {
  using type = ::nebula::meta::cpp2::JobType;

  static constexpr std::size_t const size = 12;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::COMPACT; }
  static constexpr type max() { return type::UNKNOWN; }
};


template <> struct TEnumDataStorage<::nebula::meta::cpp2::JobStatus>;

template <> struct TEnumTraits<::nebula::meta::cpp2::JobStatus> {
  using type = ::nebula::meta::cpp2::JobStatus;

  static constexpr std::size_t const size = 6;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::QUEUE; }
  static constexpr type max() { return type::INVALID; }
};


template <> struct TEnumDataStorage<::nebula::meta::cpp2::ListHostType>;

template <> struct TEnumTraits<::nebula::meta::cpp2::ListHostType> {
  using type = ::nebula::meta::cpp2::ListHostType;

  static constexpr std::size_t const size = 6;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::ALLOC; }
  static constexpr type max() { return type::STORAGE_LISTENER; }
};


template <> struct TEnumDataStorage<::nebula::meta::cpp2::HostRole>;

template <> struct TEnumTraits<::nebula::meta::cpp2::HostRole> {
  using type = ::nebula::meta::cpp2::HostRole;

  static constexpr std::size_t const size = 6;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::GRAPH; }
  static constexpr type max() { return type::UNKNOWN; }
};


template <> struct TEnumDataStorage<::nebula::meta::cpp2::TaskResult>;

template <> struct TEnumTraits<::nebula::meta::cpp2::TaskResult> {
  using type = ::nebula::meta::cpp2::TaskResult;

  static constexpr std::size_t const size = 4;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::SUCCEEDED; }
  static constexpr type max() { return type::INVALID; }
};


template <> struct TEnumDataStorage<::nebula::meta::cpp2::ConfigModule>;

template <> struct TEnumTraits<::nebula::meta::cpp2::ConfigModule> {
  using type = ::nebula::meta::cpp2::ConfigModule;

  static constexpr std::size_t const size = 5;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::UNKNOWN; }
  static constexpr type max() { return type::STORAGE; }
};


template <> struct TEnumDataStorage<::nebula::meta::cpp2::ConfigMode>;

template <> struct TEnumTraits<::nebula::meta::cpp2::ConfigMode> {
  using type = ::nebula::meta::cpp2::ConfigMode;

  static constexpr std::size_t const size = 4;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::IMMUTABLE; }
  static constexpr type max() { return type::IGNORED; }
};


template <> struct TEnumDataStorage<::nebula::meta::cpp2::ListenerType>;

template <> struct TEnumTraits<::nebula::meta::cpp2::ListenerType> {
  using type = ::nebula::meta::cpp2::ListenerType;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::UNKNOWN; }
  static constexpr type max() { return type::ELASTICSEARCH; }
};


template <> struct TEnumDataStorage<::nebula::meta::cpp2::ExternalServiceType>;

template <> struct TEnumTraits<::nebula::meta::cpp2::ExternalServiceType> {
  using type = ::nebula::meta::cpp2::ExternalServiceType;

  static constexpr std::size_t const size = 1;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::ELASTICSEARCH; }
  static constexpr type max() { return type::ELASTICSEARCH; }
};


template <> struct TEnumDataStorage<::nebula::meta::cpp2::QueryStatus>;

template <> struct TEnumTraits<::nebula::meta::cpp2::QueryStatus> {
  using type = ::nebula::meta::cpp2::QueryStatus;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::RUNNING; }
  static constexpr type max() { return type::KILLING; }
};


}} // apache::thrift

namespace nebula { namespace meta { namespace cpp2 {

using _AlterSchemaOp_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<AlterSchemaOp>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _AlterSchemaOp_EnumMapFactory::ValuesToNamesMapType _AlterSchemaOp_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _AlterSchemaOp_EnumMapFactory::NamesToValuesMapType _AlterSchemaOp_NAMES_TO_VALUES;

using _RoleType_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<RoleType>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _RoleType_EnumMapFactory::ValuesToNamesMapType _RoleType_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _RoleType_EnumMapFactory::NamesToValuesMapType _RoleType_NAMES_TO_VALUES;

using _GeoShape_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<GeoShape>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _GeoShape_EnumMapFactory::ValuesToNamesMapType _GeoShape_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _GeoShape_EnumMapFactory::NamesToValuesMapType _GeoShape_NAMES_TO_VALUES;

using _IsolationLevel_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<IsolationLevel>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _IsolationLevel_EnumMapFactory::ValuesToNamesMapType _IsolationLevel_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _IsolationLevel_EnumMapFactory::NamesToValuesMapType _IsolationLevel_NAMES_TO_VALUES;

using _HostStatus_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<HostStatus>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _HostStatus_EnumMapFactory::ValuesToNamesMapType _HostStatus_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _HostStatus_EnumMapFactory::NamesToValuesMapType _HostStatus_NAMES_TO_VALUES;

using _SnapshotStatus_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<SnapshotStatus>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _SnapshotStatus_EnumMapFactory::ValuesToNamesMapType _SnapshotStatus_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _SnapshotStatus_EnumMapFactory::NamesToValuesMapType _SnapshotStatus_NAMES_TO_VALUES;

using _AlterSpaceOp_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<AlterSpaceOp>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _AlterSpaceOp_EnumMapFactory::ValuesToNamesMapType _AlterSpaceOp_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _AlterSpaceOp_EnumMapFactory::NamesToValuesMapType _AlterSpaceOp_NAMES_TO_VALUES;

using _JobOp_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<JobOp>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _JobOp_EnumMapFactory::ValuesToNamesMapType _JobOp_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _JobOp_EnumMapFactory::NamesToValuesMapType _JobOp_NAMES_TO_VALUES;

using _JobType_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<JobType>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _JobType_EnumMapFactory::ValuesToNamesMapType _JobType_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _JobType_EnumMapFactory::NamesToValuesMapType _JobType_NAMES_TO_VALUES;

using _JobStatus_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<JobStatus>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _JobStatus_EnumMapFactory::ValuesToNamesMapType _JobStatus_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _JobStatus_EnumMapFactory::NamesToValuesMapType _JobStatus_NAMES_TO_VALUES;

using _ListHostType_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<ListHostType>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _ListHostType_EnumMapFactory::ValuesToNamesMapType _ListHostType_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _ListHostType_EnumMapFactory::NamesToValuesMapType _ListHostType_NAMES_TO_VALUES;

using _HostRole_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<HostRole>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _HostRole_EnumMapFactory::ValuesToNamesMapType _HostRole_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _HostRole_EnumMapFactory::NamesToValuesMapType _HostRole_NAMES_TO_VALUES;

using _TaskResult_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<TaskResult>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _TaskResult_EnumMapFactory::ValuesToNamesMapType _TaskResult_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _TaskResult_EnumMapFactory::NamesToValuesMapType _TaskResult_NAMES_TO_VALUES;

using _ConfigModule_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<ConfigModule>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _ConfigModule_EnumMapFactory::ValuesToNamesMapType _ConfigModule_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _ConfigModule_EnumMapFactory::NamesToValuesMapType _ConfigModule_NAMES_TO_VALUES;

using _ConfigMode_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<ConfigMode>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _ConfigMode_EnumMapFactory::ValuesToNamesMapType _ConfigMode_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _ConfigMode_EnumMapFactory::NamesToValuesMapType _ConfigMode_NAMES_TO_VALUES;

using _ListenerType_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<ListenerType>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _ListenerType_EnumMapFactory::ValuesToNamesMapType _ListenerType_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _ListenerType_EnumMapFactory::NamesToValuesMapType _ListenerType_NAMES_TO_VALUES;

using _ExternalServiceType_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<ExternalServiceType>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _ExternalServiceType_EnumMapFactory::ValuesToNamesMapType _ExternalServiceType_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _ExternalServiceType_EnumMapFactory::NamesToValuesMapType _ExternalServiceType_NAMES_TO_VALUES;

using _QueryStatus_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<QueryStatus>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _QueryStatus_EnumMapFactory::ValuesToNamesMapType _QueryStatus_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _QueryStatus_EnumMapFactory::NamesToValuesMapType _QueryStatus_NAMES_TO_VALUES;

}}} // nebula::meta::cpp2

// END declare_enums
// BEGIN forward_declare
namespace nebula { namespace meta { namespace cpp2 {
class ID;
class ColumnTypeDef;
class ColumnDef;
class SchemaProp;
class Schema;
class IdName;
class SpaceDesc;
class SpaceItem;
class TagItem;
class AlterSchemaItem;
class EdgeItem;
class IndexParams;
class IndexItem;
class HostItem;
class UserItem;
class RoleItem;
class ExecResp;
class AlterSpaceReq;
class AdminJobReq;
class JobDesc;
class TaskDesc;
class AdminJobResult;
class AdminJobResp;
class Correlativity;
class StatsItem;
class CreateSpaceReq;
class CreateSpaceAsReq;
class DropSpaceReq;
class ClearSpaceReq;
class ListSpacesReq;
class ListSpacesResp;
class GetSpaceReq;
class GetSpaceResp;
class CreateTagReq;
class AlterTagReq;
class DropTagReq;
class ListTagsReq;
class ListTagsResp;
class GetTagReq;
class GetTagResp;
class CreateEdgeReq;
class AlterEdgeReq;
class GetEdgeReq;
class GetEdgeResp;
class DropEdgeReq;
class ListEdgesReq;
class ListEdgesResp;
class AddHostsReq;
class DropHostsReq;
class ListHostsReq;
class ListHostsResp;
class PartItem;
class ListPartsReq;
class ListPartsResp;
class GetPartsAllocReq;
class GetPartsAllocResp;
class GetWorkerIdReq;
class GetWorkerIdResp;
class GetSegmentIdReq;
class GetSegmentIdResp;
class HBResp;
class LeaderInfo;
class PartitionList;
class HBReq;
class ServiceInfo;
class AgentHBReq;
class AgentHBResp;
class IndexFieldDef;
class CreateTagIndexReq;
class DropTagIndexReq;
class GetTagIndexReq;
class GetTagIndexResp;
class ListTagIndexesReq;
class ListTagIndexesResp;
class CreateEdgeIndexReq;
class DropEdgeIndexReq;
class GetEdgeIndexReq;
class GetEdgeIndexResp;
class ListEdgeIndexesReq;
class ListEdgeIndexesResp;
class RebuildIndexReq;
class CreateUserReq;
class DropUserReq;
class AlterUserReq;
class GrantRoleReq;
class RevokeRoleReq;
class ListUsersReq;
class ListUsersResp;
class ListRolesReq;
class ListRolesResp;
class GetUserRolesReq;
class ChangePasswordReq;
class BalanceTask;
class ConfigItem;
class RegConfigReq;
class GetConfigReq;
class GetConfigResp;
class SetConfigReq;
class ListConfigsReq;
class ListConfigsResp;
class CreateSnapshotReq;
class DropSnapshotReq;
class ListSnapshotsReq;
class Snapshot;
class ListSnapshotsResp;
class ListIndexStatusReq;
class IndexStatus;
class ListIndexStatusResp;
class MergeZoneReq;
class DropZoneReq;
class DivideZoneReq;
class RenameZoneReq;
class AddHostsIntoZoneReq;
class GetZoneReq;
class GetZoneResp;
class ListZonesReq;
class Zone;
class ListZonesResp;
class AddListenerReq;
class RemoveListenerReq;
class ListListenerReq;
class ListenerInfo;
class ListListenerResp;
class GetStatsReq;
class GetStatsResp;
class HostBackupInfo;
class SpaceBackupInfo;
class BackupMeta;
class CreateBackupReq;
class CreateBackupResp;
class HostPair;
class RestoreMetaReq;
class PartInfo;
class RestoreMetaResp;
class ServiceClient;
class SignInServiceReq;
class SignOutServiceReq;
class ListServiceClientsReq;
class ListServiceClientsResp;
class FTIndex;
class CreateFTIndexReq;
class DropFTIndexReq;
class ListFTIndexesReq;
class ListFTIndexesResp;
class QueryDesc;
class Session;
class CreateSessionReq;
class CreateSessionResp;
class UpdateSessionsReq;
class UpdateSessionsResp;
class ListSessionsReq;
class ListSessionsResp;
class GetSessionReq;
class GetSessionResp;
class RemoveSessionReq;
class RemoveSessionResp;
class KillQueryReq;
class ReportTaskReq;
class ListClusterInfoResp;
class ListClusterInfoReq;
class GetMetaDirInfoResp;
class GetMetaDirInfoReq;
class VerifyClientVersionResp;
class VerifyClientVersionReq;
class SaveGraphVersionResp;
class SaveGraphVersionReq;
}}} // nebula::meta::cpp2
// END forward_declare
// BEGIN typedefs
namespace nebula { namespace meta { namespace cpp2 {
typedef nebula::SchemaVer SchemaVer;
typedef nebula::ClusterID ClusterID;

}}} // nebula::meta::cpp2
// END typedefs
// BEGIN hash_and_equal_to
// END hash_and_equal_to
namespace nebula { namespace meta { namespace cpp2 {
class ID final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ID;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    space_id = 1,
    tag_id = 2,
    edge_type = 3,
    index_id = 4,
    cluster_id = 5,
  } ;

  ID()
      : type_(Type::__EMPTY__) {}

  ID(ID&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::space_id:
      {
        set_space_id(std::move(rhs.value_.space_id));
        break;
      }
      case Type::tag_id:
      {
        set_tag_id(std::move(rhs.value_.tag_id));
        break;
      }
      case Type::edge_type:
      {
        set_edge_type(std::move(rhs.value_.edge_type));
        break;
      }
      case Type::index_id:
      {
        set_index_id(std::move(rhs.value_.index_id));
        break;
      }
      case Type::cluster_id:
      {
        set_cluster_id(std::move(rhs.value_.cluster_id));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  ID(const ID& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::space_id:
      {
        set_space_id(rhs.value_.space_id);
        break;
      }
      case Type::tag_id:
      {
        set_tag_id(rhs.value_.tag_id);
        break;
      }
      case Type::edge_type:
      {
        set_edge_type(rhs.value_.edge_type);
        break;
      }
      case Type::index_id:
      {
        set_index_id(rhs.value_.index_id);
        break;
      }
      case Type::cluster_id:
      {
        set_cluster_id(rhs.value_.cluster_id);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  ID& operator=(ID&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::space_id:
      {
        set_space_id(std::move(rhs.value_.space_id));
        break;
      }
      case Type::tag_id:
      {
        set_tag_id(std::move(rhs.value_.tag_id));
        break;
      }
      case Type::edge_type:
      {
        set_edge_type(std::move(rhs.value_.edge_type));
        break;
      }
      case Type::index_id:
      {
        set_index_id(std::move(rhs.value_.index_id));
        break;
      }
      case Type::cluster_id:
      {
        set_cluster_id(std::move(rhs.value_.cluster_id));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  ID& operator=(const ID& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::space_id:
      {
        set_space_id(rhs.value_.space_id);
        break;
      }
      case Type::tag_id:
      {
        set_tag_id(rhs.value_.tag_id);
        break;
      }
      case Type::edge_type:
      {
        set_edge_type(rhs.value_.edge_type);
        break;
      }
      case Type::index_id:
      {
        set_index_id(rhs.value_.index_id);
        break;
      }
      case Type::cluster_id:
      {
        set_cluster_id(rhs.value_.cluster_id);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~ID() {
    __clear();
  }
  union storage_type {
     ::nebula::cpp2::GraphSpaceID space_id;
     ::nebula::cpp2::TagID tag_id;
     ::nebula::cpp2::EdgeType edge_type;
     ::nebula::cpp2::IndexID index_id;
     ::nebula::meta::cpp2::ClusterID cluster_id;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const ID& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ID& __x, const ID& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ID& rhs) const;
#ifndef SWIG
  friend bool operator>(const ID& __x, const ID& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ID& __x, const ID& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ID& __x, const ID& __y) {
    return !(__x < __y);
  }
#endif

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID t =  ::nebula::cpp2::GraphSpaceID()) {
    __clear();
    type_ = Type::space_id;
    ::new (std::addressof(value_.space_id))  ::nebula::cpp2::GraphSpaceID(t);
    return value_.space_id;
  }

   ::nebula::cpp2::TagID& set_tag_id( ::nebula::cpp2::TagID t =  ::nebula::cpp2::TagID()) {
    __clear();
    type_ = Type::tag_id;
    ::new (std::addressof(value_.tag_id))  ::nebula::cpp2::TagID(t);
    return value_.tag_id;
  }

   ::nebula::cpp2::EdgeType& set_edge_type( ::nebula::cpp2::EdgeType t =  ::nebula::cpp2::EdgeType()) {
    __clear();
    type_ = Type::edge_type;
    ::new (std::addressof(value_.edge_type))  ::nebula::cpp2::EdgeType(t);
    return value_.edge_type;
  }

   ::nebula::cpp2::IndexID& set_index_id( ::nebula::cpp2::IndexID t =  ::nebula::cpp2::IndexID()) {
    __clear();
    type_ = Type::index_id;
    ::new (std::addressof(value_.index_id))  ::nebula::cpp2::IndexID(t);
    return value_.index_id;
  }

   ::nebula::meta::cpp2::ClusterID& set_cluster_id( ::nebula::meta::cpp2::ClusterID t =  ::nebula::meta::cpp2::ClusterID()) {
    __clear();
    type_ = Type::cluster_id;
    ::new (std::addressof(value_.cluster_id))  ::nebula::meta::cpp2::ClusterID(t);
    return value_.cluster_id;
  }

   ::nebula::cpp2::GraphSpaceID const & get_space_id() const {
    assert(type_ == Type::space_id);
    return value_.space_id;
  }

   ::nebula::cpp2::TagID const & get_tag_id() const {
    assert(type_ == Type::tag_id);
    return value_.tag_id;
  }

   ::nebula::cpp2::EdgeType const & get_edge_type() const {
    assert(type_ == Type::edge_type);
    return value_.edge_type;
  }

   ::nebula::cpp2::IndexID const & get_index_id() const {
    assert(type_ == Type::index_id);
    return value_.index_id;
  }

   ::nebula::meta::cpp2::ClusterID const & get_cluster_id() const {
    assert(type_ == Type::cluster_id);
    return value_.cluster_id;
  }

   ::nebula::cpp2::GraphSpaceID & mutable_space_id() {
    assert(type_ == Type::space_id);
    return value_.space_id;
  }

   ::nebula::cpp2::TagID & mutable_tag_id() {
    assert(type_ == Type::tag_id);
    return value_.tag_id;
  }

   ::nebula::cpp2::EdgeType & mutable_edge_type() {
    assert(type_ == Type::edge_type);
    return value_.edge_type;
  }

   ::nebula::cpp2::IndexID & mutable_index_id() {
    assert(type_ == Type::index_id);
    return value_.index_id;
  }

   ::nebula::meta::cpp2::ClusterID & mutable_cluster_id() {
    assert(type_ == Type::cluster_id);
    return value_.cluster_id;
  }

   ::nebula::cpp2::GraphSpaceID move_space_id() {
    assert(type_ == Type::space_id);
    return std::move(value_.space_id);
  }

   ::nebula::cpp2::TagID move_tag_id() {
    assert(type_ == Type::tag_id);
    return std::move(value_.tag_id);
  }

   ::nebula::cpp2::EdgeType move_edge_type() {
    assert(type_ == Type::edge_type);
    return std::move(value_.edge_type);
  }

   ::nebula::cpp2::IndexID move_index_id() {
    assert(type_ == Type::index_id);
    return std::move(value_.index_id);
  }

   ::nebula::meta::cpp2::ClusterID move_cluster_id() {
    assert(type_ == Type::cluster_id);
    return std::move(value_.cluster_id);
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> space_id_ref() const& {
    return {value_.space_id, type_, space_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> space_id_ref() const&& {
    return {std::move(value_.space_id), type_, space_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> space_id_ref() & {
    return {value_.space_id, type_, space_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> space_id_ref() && {
    return {std::move(value_.space_id), type_, space_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> tag_id_ref() const& {
    return {value_.tag_id, type_, tag_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> tag_id_ref() const&& {
    return {std::move(value_.tag_id), type_, tag_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> tag_id_ref() & {
    return {value_.tag_id, type_, tag_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> tag_id_ref() && {
    return {std::move(value_.tag_id), type_, tag_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> edge_type_ref() const& {
    return {value_.edge_type, type_, edge_type, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> edge_type_ref() const&& {
    return {std::move(value_.edge_type), type_, edge_type, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> edge_type_ref() & {
    return {value_.edge_type, type_, edge_type, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> edge_type_ref() && {
    return {std::move(value_.edge_type), type_, edge_type, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T =  ::nebula::cpp2::IndexID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> index_id_ref() const& {
    return {value_.index_id, type_, index_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::cpp2::IndexID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> index_id_ref() const&& {
    return {std::move(value_.index_id), type_, index_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::cpp2::IndexID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> index_id_ref() & {
    return {value_.index_id, type_, index_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::cpp2::IndexID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> index_id_ref() && {
    return {std::move(value_.index_id), type_, index_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> cluster_id_ref() const& {
    return {value_.cluster_id, type_, cluster_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> cluster_id_ref() const&& {
    return {std::move(value_.cluster_id), type_, cluster_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> cluster_id_ref() & {
    return {value_.cluster_id, type_, cluster_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> cluster_id_ref() && {
    return {std::move(value_.cluster_id), type_, cluster_id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ID >;
  friend void swap(ID& a, ID& b);
};

template <class Protocol_>
uint32_t ID::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ColumnTypeDef final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ColumnTypeDef;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ColumnTypeDef() :
      type( ::nebula::cpp2::PropertyType::UNKNOWN),
      type_length(static_cast<int16_t>(0)),
      geo_shape( ::nebula::meta::cpp2::GeoShape::ANY) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ColumnTypeDef(apache::thrift::FragileConstructor,  ::nebula::cpp2::PropertyType type__arg, int16_t type_length__arg,  ::nebula::meta::cpp2::GeoShape geo_shape__arg);

  ColumnTypeDef(ColumnTypeDef&&) = default;

  ColumnTypeDef(const ColumnTypeDef&) = default;


  ColumnTypeDef& operator=(ColumnTypeDef&&) = default;

  ColumnTypeDef& operator=(const ColumnTypeDef&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
   ::nebula::cpp2::PropertyType type;
 private:
  int16_t type_length;
 private:
   ::nebula::meta::cpp2::GeoShape geo_shape;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool type_length;
    bool geo_shape;
  } __isset = {};
  bool operator==(const ColumnTypeDef& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ColumnTypeDef& __x, const ColumnTypeDef& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ColumnTypeDef& rhs) const;
#ifndef SWIG
  friend bool operator>(const ColumnTypeDef& __x, const ColumnTypeDef& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ColumnTypeDef& __x, const ColumnTypeDef& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ColumnTypeDef& __x, const ColumnTypeDef& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T =  ::nebula::cpp2::PropertyType>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> type_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->type};
  }

  template <typename..., typename T =  ::nebula::cpp2::PropertyType>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> type_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->type)};
  }

  template <typename..., typename T =  ::nebula::cpp2::PropertyType>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> type_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->type};
  }

  template <typename..., typename T =  ::nebula::cpp2::PropertyType>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> type_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->type)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> type_length_ref() const& {
    return {this->type_length, __isset.type_length};
  }

  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> type_length_ref() const&& {
    return {std::move(this->type_length), __isset.type_length};
  }

  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> type_length_ref() & {
    return {this->type_length, __isset.type_length};
  }

  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> type_length_ref() && {
    return {std::move(this->type_length), __isset.type_length};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::GeoShape>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> geo_shape_ref() const& {
    return {this->geo_shape, __isset.geo_shape};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::GeoShape>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> geo_shape_ref() const&& {
    return {std::move(this->geo_shape), __isset.geo_shape};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::GeoShape>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> geo_shape_ref() & {
    return {this->geo_shape, __isset.geo_shape};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::GeoShape>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> geo_shape_ref() && {
    return {std::move(this->geo_shape), __isset.geo_shape};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::PropertyType get_type() const {
    return type;
  }

   ::nebula::cpp2::PropertyType& set_type( ::nebula::cpp2::PropertyType type_) {
    type = type_;
    return type;
  }

  const int16_t* get_type_length() const& {
    return type_length_ref() ? std::addressof(type_length) : nullptr;
  }

  int16_t* get_type_length() & {
    return type_length_ref() ? std::addressof(type_length) : nullptr;
  }
  int16_t* get_type_length() && = delete;

  int16_t& set_type_length(int16_t type_length_) {
    type_length = type_length_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.type_length = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return type_length;
  }

  const  ::nebula::meta::cpp2::GeoShape* get_geo_shape() const& {
    return geo_shape_ref() ? std::addressof(geo_shape) : nullptr;
  }

   ::nebula::meta::cpp2::GeoShape* get_geo_shape() & {
    return geo_shape_ref() ? std::addressof(geo_shape) : nullptr;
  }
   ::nebula::meta::cpp2::GeoShape* get_geo_shape() && = delete;

   ::nebula::meta::cpp2::GeoShape& set_geo_shape( ::nebula::meta::cpp2::GeoShape geo_shape_) {
    geo_shape = geo_shape_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.geo_shape = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return geo_shape;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ColumnTypeDef >;
  friend void swap(ColumnTypeDef& a, ColumnTypeDef& b);
};

template <class Protocol_>
uint32_t ColumnTypeDef::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ColumnDef final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ColumnDef;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ColumnDef();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ColumnDef(apache::thrift::FragileConstructor, ::std::string name__arg,  ::nebula::meta::cpp2::ColumnTypeDef type__arg, ::std::string default_value__arg, bool nullable__arg, ::std::string comment__arg);

  ColumnDef(ColumnDef&&) = default;

  ColumnDef(const ColumnDef&) = default;


  ColumnDef& operator=(ColumnDef&&) = default;

  ColumnDef& operator=(const ColumnDef&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~ColumnDef();

 public:
  ::std::string name;
 public:
   ::nebula::meta::cpp2::ColumnTypeDef type;
 private:
  ::std::string default_value;
 private:
  bool nullable;
 private:
  ::std::string comment;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool default_value;
    bool nullable;
    bool comment;
  } __isset = {};
  bool operator==(const ColumnDef& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ColumnDef& __x, const ColumnDef& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ColumnDef& rhs) const;
#ifndef SWIG
  friend bool operator>(const ColumnDef& __x, const ColumnDef& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ColumnDef& __x, const ColumnDef& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ColumnDef& __x, const ColumnDef& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> name_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> name_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->name)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> name_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> name_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->name)};
  }
  template <typename..., typename T =  ::nebula::meta::cpp2::ColumnTypeDef>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> type_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ColumnTypeDef>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> type_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->type)};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ColumnTypeDef>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> type_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ColumnTypeDef>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> type_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->type)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> default_value_ref() const& {
    return {this->default_value, __isset.default_value};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> default_value_ref() const&& {
    return {std::move(this->default_value), __isset.default_value};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> default_value_ref() & {
    return {this->default_value, __isset.default_value};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> default_value_ref() && {
    return {std::move(this->default_value), __isset.default_value};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> nullable_ref() const& {
    return {this->nullable, __isset.nullable};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> nullable_ref() const&& {
    return {std::move(this->nullable), __isset.nullable};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> nullable_ref() & {
    return {this->nullable, __isset.nullable};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> nullable_ref() && {
    return {std::move(this->nullable), __isset.nullable};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> comment_ref() const& {
    return {this->comment, __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> comment_ref() const&& {
    return {std::move(this->comment), __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> comment_ref() & {
    return {this->comment, __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> comment_ref() && {
    return {std::move(this->comment), __isset.comment};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ColumnDef_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ColumnDef_name_struct_setter&& name_) {
    name = std::forward<T_ColumnDef_name_struct_setter>(name_);
    return name;
  }
  const  ::nebula::meta::cpp2::ColumnTypeDef& get_type() const&;
   ::nebula::meta::cpp2::ColumnTypeDef get_type() &&;

  template <typename T_ColumnDef_type_struct_setter =  ::nebula::meta::cpp2::ColumnTypeDef>
   ::nebula::meta::cpp2::ColumnTypeDef& set_type(T_ColumnDef_type_struct_setter&& type_) {
    type = std::forward<T_ColumnDef_type_struct_setter>(type_);
    return type;
  }

  const ::std::string* get_default_value() const& {
    return default_value_ref() ? std::addressof(default_value) : nullptr;
  }

  ::std::string* get_default_value() & {
    return default_value_ref() ? std::addressof(default_value) : nullptr;
  }
  ::std::string* get_default_value() && = delete;

  template <typename T_ColumnDef_default_value_struct_setter = ::std::string>
  ::std::string& set_default_value(T_ColumnDef_default_value_struct_setter&& default_value_) {
    default_value = std::forward<T_ColumnDef_default_value_struct_setter>(default_value_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.default_value = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return default_value;
  }

  const bool* get_nullable() const& {
    return nullable_ref() ? std::addressof(nullable) : nullptr;
  }

  bool* get_nullable() & {
    return nullable_ref() ? std::addressof(nullable) : nullptr;
  }
  bool* get_nullable() && = delete;

  bool& set_nullable(bool nullable_) {
    nullable = nullable_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.nullable = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return nullable;
  }

  const ::std::string* get_comment() const& {
    return comment_ref() ? std::addressof(comment) : nullptr;
  }

  ::std::string* get_comment() & {
    return comment_ref() ? std::addressof(comment) : nullptr;
  }
  ::std::string* get_comment() && = delete;

  template <typename T_ColumnDef_comment_struct_setter = ::std::string>
  ::std::string& set_comment(T_ColumnDef_comment_struct_setter&& comment_) {
    comment = std::forward<T_ColumnDef_comment_struct_setter>(comment_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.comment = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return comment;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ColumnDef >;
  friend void swap(ColumnDef& a, ColumnDef& b);
};

template <class Protocol_>
uint32_t ColumnDef::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class SchemaProp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = SchemaProp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  SchemaProp() :
      ttl_duration(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  SchemaProp(apache::thrift::FragileConstructor, int64_t ttl_duration__arg, ::std::string ttl_col__arg, ::std::string comment__arg);

  SchemaProp(SchemaProp&&) = default;

  SchemaProp(const SchemaProp&) = default;


  SchemaProp& operator=(SchemaProp&&) = default;

  SchemaProp& operator=(const SchemaProp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  int64_t ttl_duration;
 private:
  ::std::string ttl_col;
 private:
  ::std::string comment;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool ttl_duration;
    bool ttl_col;
    bool comment;
  } __isset = {};
  bool operator==(const SchemaProp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const SchemaProp& __x, const SchemaProp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const SchemaProp& rhs) const;
#ifndef SWIG
  friend bool operator>(const SchemaProp& __x, const SchemaProp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const SchemaProp& __x, const SchemaProp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const SchemaProp& __x, const SchemaProp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> ttl_duration_ref() const& {
    return {this->ttl_duration, __isset.ttl_duration};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> ttl_duration_ref() const&& {
    return {std::move(this->ttl_duration), __isset.ttl_duration};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> ttl_duration_ref() & {
    return {this->ttl_duration, __isset.ttl_duration};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> ttl_duration_ref() && {
    return {std::move(this->ttl_duration), __isset.ttl_duration};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> ttl_col_ref() const& {
    return {this->ttl_col, __isset.ttl_col};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> ttl_col_ref() const&& {
    return {std::move(this->ttl_col), __isset.ttl_col};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> ttl_col_ref() & {
    return {this->ttl_col, __isset.ttl_col};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> ttl_col_ref() && {
    return {std::move(this->ttl_col), __isset.ttl_col};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> comment_ref() const& {
    return {this->comment, __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> comment_ref() const&& {
    return {std::move(this->comment), __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> comment_ref() & {
    return {this->comment, __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> comment_ref() && {
    return {std::move(this->comment), __isset.comment};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const int64_t* get_ttl_duration() const& {
    return ttl_duration_ref() ? std::addressof(ttl_duration) : nullptr;
  }

  int64_t* get_ttl_duration() & {
    return ttl_duration_ref() ? std::addressof(ttl_duration) : nullptr;
  }
  int64_t* get_ttl_duration() && = delete;

  int64_t& set_ttl_duration(int64_t ttl_duration_) {
    ttl_duration = ttl_duration_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.ttl_duration = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return ttl_duration;
  }

  const ::std::string* get_ttl_col() const& {
    return ttl_col_ref() ? std::addressof(ttl_col) : nullptr;
  }

  ::std::string* get_ttl_col() & {
    return ttl_col_ref() ? std::addressof(ttl_col) : nullptr;
  }
  ::std::string* get_ttl_col() && = delete;

  template <typename T_SchemaProp_ttl_col_struct_setter = ::std::string>
  ::std::string& set_ttl_col(T_SchemaProp_ttl_col_struct_setter&& ttl_col_) {
    ttl_col = std::forward<T_SchemaProp_ttl_col_struct_setter>(ttl_col_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.ttl_col = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return ttl_col;
  }

  const ::std::string* get_comment() const& {
    return comment_ref() ? std::addressof(comment) : nullptr;
  }

  ::std::string* get_comment() & {
    return comment_ref() ? std::addressof(comment) : nullptr;
  }
  ::std::string* get_comment() && = delete;

  template <typename T_SchemaProp_comment_struct_setter = ::std::string>
  ::std::string& set_comment(T_SchemaProp_comment_struct_setter&& comment_) {
    comment = std::forward<T_SchemaProp_comment_struct_setter>(comment_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.comment = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return comment;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< SchemaProp >;
  friend void swap(SchemaProp& a, SchemaProp& b);
};

template <class Protocol_>
uint32_t SchemaProp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class Schema final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Schema;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  Schema() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Schema(apache::thrift::FragileConstructor, ::std::vector< ::nebula::meta::cpp2::ColumnDef> columns__arg,  ::nebula::meta::cpp2::SchemaProp schema_prop__arg);

  Schema(Schema&&) = default;

  Schema(const Schema&) = default;


  Schema& operator=(Schema&&) = default;

  Schema& operator=(const Schema&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector< ::nebula::meta::cpp2::ColumnDef> columns;
 private:
   ::nebula::meta::cpp2::SchemaProp schema_prop;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool columns;
    bool schema_prop;
  } __isset = {};
  bool operator==(const Schema& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Schema& __x, const Schema& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Schema& rhs) const;
#ifndef SWIG
  friend bool operator>(const Schema& __x, const Schema& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Schema& __x, const Schema& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Schema& __x, const Schema& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ColumnDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> columns_ref() const& {
    return {this->columns, __isset.columns};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ColumnDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> columns_ref() const&& {
    return {std::move(this->columns), __isset.columns};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ColumnDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> columns_ref() & {
    return {this->columns, __isset.columns};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ColumnDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> columns_ref() && {
    return {std::move(this->columns), __isset.columns};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaProp>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> schema_prop_ref() const& {
    return {this->schema_prop, __isset.schema_prop};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaProp>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> schema_prop_ref() const&& {
    return {std::move(this->schema_prop), __isset.schema_prop};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaProp>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> schema_prop_ref() & {
    return {this->schema_prop, __isset.schema_prop};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaProp>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> schema_prop_ref() && {
    return {std::move(this->schema_prop), __isset.schema_prop};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector< ::nebula::meta::cpp2::ColumnDef>& get_columns() const&;
  ::std::vector< ::nebula::meta::cpp2::ColumnDef> get_columns() &&;

  template <typename T_Schema_columns_struct_setter = ::std::vector< ::nebula::meta::cpp2::ColumnDef>>
  ::std::vector< ::nebula::meta::cpp2::ColumnDef>& set_columns(T_Schema_columns_struct_setter&& columns_) {
    columns = std::forward<T_Schema_columns_struct_setter>(columns_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.columns = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return columns;
  }
  const  ::nebula::meta::cpp2::SchemaProp& get_schema_prop() const&;
   ::nebula::meta::cpp2::SchemaProp get_schema_prop() &&;

  template <typename T_Schema_schema_prop_struct_setter =  ::nebula::meta::cpp2::SchemaProp>
   ::nebula::meta::cpp2::SchemaProp& set_schema_prop(T_Schema_schema_prop_struct_setter&& schema_prop_) {
    schema_prop = std::forward<T_Schema_schema_prop_struct_setter>(schema_prop_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.schema_prop = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return schema_prop;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Schema >;
  friend void swap(Schema& a, Schema& b);
};

template <class Protocol_>
uint32_t Schema::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class IdName final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = IdName;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  IdName() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  IdName(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::ID id__arg, ::std::string name__arg);

  IdName(IdName&&) = default;

  IdName(const IdName&) = default;


  IdName& operator=(IdName&&) = default;

  IdName& operator=(const IdName&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::meta::cpp2::ID id;
 private:
  ::std::string name;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool id;
    bool name;
  } __isset = {};
  bool operator==(const IdName& rhs) const;
#ifndef SWIG
  friend bool operator!=(const IdName& __x, const IdName& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const IdName& rhs) const;
#ifndef SWIG
  friend bool operator>(const IdName& __x, const IdName& __y) {
    return __y < __x;
  }
  friend bool operator<=(const IdName& __x, const IdName& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const IdName& __x, const IdName& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::ID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> id_ref() const& {
    return {this->id, __isset.id};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> id_ref() const&& {
    return {std::move(this->id), __isset.id};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> id_ref() & {
    return {this->id, __isset.id};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> id_ref() && {
    return {std::move(this->id), __isset.id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::meta::cpp2::ID& get_id() const&;
   ::nebula::meta::cpp2::ID get_id() &&;

  template <typename T_IdName_id_struct_setter =  ::nebula::meta::cpp2::ID>
   ::nebula::meta::cpp2::ID& set_id(T_IdName_id_struct_setter&& id_) {
    id = std::forward<T_IdName_id_struct_setter>(id_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return id;
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_IdName_name_struct_setter = ::std::string>
  ::std::string& set_name(T_IdName_name_struct_setter&& name_) {
    name = std::forward<T_IdName_name_struct_setter>(name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< IdName >;
  friend void swap(IdName& a, IdName& b);
};

template <class Protocol_>
uint32_t IdName::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class SpaceDesc final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = SpaceDesc;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  SpaceDesc();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  SpaceDesc(apache::thrift::FragileConstructor, ::std::string space_name__arg, int32_t partition_num__arg, int32_t replica_factor__arg, ::std::string charset_name__arg, ::std::string collate_name__arg,  ::nebula::meta::cpp2::ColumnTypeDef vid_type__arg, ::std::vector<::std::string> zone_names__arg,  ::nebula::meta::cpp2::IsolationLevel isolation_level__arg, ::std::string comment__arg);

  SpaceDesc(SpaceDesc&&) = default;

  SpaceDesc(const SpaceDesc&) = default;


  SpaceDesc& operator=(SpaceDesc&&) = default;

  SpaceDesc& operator=(const SpaceDesc&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~SpaceDesc();

 private:
  ::std::string space_name;
 private:
  int32_t partition_num;
 private:
  int32_t replica_factor;
 private:
  ::std::string charset_name;
 private:
  ::std::string collate_name;
 private:
   ::nebula::meta::cpp2::ColumnTypeDef vid_type;
 private:
  ::std::vector<::std::string> zone_names;
 private:
   ::nebula::meta::cpp2::IsolationLevel isolation_level;
 private:
  ::std::string comment;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_name;
    bool partition_num;
    bool replica_factor;
    bool charset_name;
    bool collate_name;
    bool vid_type;
    bool zone_names;
    bool isolation_level;
    bool comment;
  } __isset = {};
  bool operator==(const SpaceDesc& rhs) const;
#ifndef SWIG
  friend bool operator!=(const SpaceDesc& __x, const SpaceDesc& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const SpaceDesc& rhs) const;
#ifndef SWIG
  friend bool operator>(const SpaceDesc& __x, const SpaceDesc& __y) {
    return __y < __x;
  }
  friend bool operator<=(const SpaceDesc& __x, const SpaceDesc& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const SpaceDesc& __x, const SpaceDesc& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_name_ref() const& {
    return {this->space_name, __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_name_ref() const&& {
    return {std::move(this->space_name), __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_name_ref() & {
    return {this->space_name, __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_name_ref() && {
    return {std::move(this->space_name), __isset.space_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> partition_num_ref() const& {
    return {this->partition_num, __isset.partition_num};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> partition_num_ref() const&& {
    return {std::move(this->partition_num), __isset.partition_num};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> partition_num_ref() & {
    return {this->partition_num, __isset.partition_num};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> partition_num_ref() && {
    return {std::move(this->partition_num), __isset.partition_num};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> replica_factor_ref() const& {
    return {this->replica_factor, __isset.replica_factor};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> replica_factor_ref() const&& {
    return {std::move(this->replica_factor), __isset.replica_factor};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> replica_factor_ref() & {
    return {this->replica_factor, __isset.replica_factor};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> replica_factor_ref() && {
    return {std::move(this->replica_factor), __isset.replica_factor};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> charset_name_ref() const& {
    return {this->charset_name, __isset.charset_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> charset_name_ref() const&& {
    return {std::move(this->charset_name), __isset.charset_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> charset_name_ref() & {
    return {this->charset_name, __isset.charset_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> charset_name_ref() && {
    return {std::move(this->charset_name), __isset.charset_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> collate_name_ref() const& {
    return {this->collate_name, __isset.collate_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> collate_name_ref() const&& {
    return {std::move(this->collate_name), __isset.collate_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> collate_name_ref() & {
    return {this->collate_name, __isset.collate_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> collate_name_ref() && {
    return {std::move(this->collate_name), __isset.collate_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::ColumnTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> vid_type_ref() const& {
    return {this->vid_type, __isset.vid_type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ColumnTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> vid_type_ref() const&& {
    return {std::move(this->vid_type), __isset.vid_type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ColumnTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> vid_type_ref() & {
    return {this->vid_type, __isset.vid_type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ColumnTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> vid_type_ref() && {
    return {std::move(this->vid_type), __isset.vid_type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> zone_names_ref() const& {
    return {this->zone_names, __isset.zone_names};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> zone_names_ref() const&& {
    return {std::move(this->zone_names), __isset.zone_names};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> zone_names_ref() & {
    return {this->zone_names, __isset.zone_names};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> zone_names_ref() && {
    return {std::move(this->zone_names), __isset.zone_names};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::IsolationLevel>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> isolation_level_ref() const& {
    return {this->isolation_level, __isset.isolation_level};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::IsolationLevel>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> isolation_level_ref() const&& {
    return {std::move(this->isolation_level), __isset.isolation_level};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::IsolationLevel>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> isolation_level_ref() & {
    return {this->isolation_level, __isset.isolation_level};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::IsolationLevel>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> isolation_level_ref() && {
    return {std::move(this->isolation_level), __isset.isolation_level};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> comment_ref() const& {
    return {this->comment, __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> comment_ref() const&& {
    return {std::move(this->comment), __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> comment_ref() & {
    return {this->comment, __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> comment_ref() && {
    return {std::move(this->comment), __isset.comment};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_space_name() const& {
    return space_name;
  }

  ::std::string get_space_name() && {
    return std::move(space_name);
  }

  template <typename T_SpaceDesc_space_name_struct_setter = ::std::string>
  ::std::string& set_space_name(T_SpaceDesc_space_name_struct_setter&& space_name_) {
    space_name = std::forward<T_SpaceDesc_space_name_struct_setter>(space_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_name;
  }

  int32_t get_partition_num() const {
    return partition_num;
  }

  int32_t& set_partition_num(int32_t partition_num_) {
    partition_num = partition_num_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.partition_num = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return partition_num;
  }

  int32_t get_replica_factor() const {
    return replica_factor;
  }

  int32_t& set_replica_factor(int32_t replica_factor_) {
    replica_factor = replica_factor_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.replica_factor = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return replica_factor;
  }

  const ::std::string& get_charset_name() const& {
    return charset_name;
  }

  ::std::string get_charset_name() && {
    return std::move(charset_name);
  }

  template <typename T_SpaceDesc_charset_name_struct_setter = ::std::string>
  ::std::string& set_charset_name(T_SpaceDesc_charset_name_struct_setter&& charset_name_) {
    charset_name = std::forward<T_SpaceDesc_charset_name_struct_setter>(charset_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.charset_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return charset_name;
  }

  const ::std::string& get_collate_name() const& {
    return collate_name;
  }

  ::std::string get_collate_name() && {
    return std::move(collate_name);
  }

  template <typename T_SpaceDesc_collate_name_struct_setter = ::std::string>
  ::std::string& set_collate_name(T_SpaceDesc_collate_name_struct_setter&& collate_name_) {
    collate_name = std::forward<T_SpaceDesc_collate_name_struct_setter>(collate_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.collate_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return collate_name;
  }
  const  ::nebula::meta::cpp2::ColumnTypeDef& get_vid_type() const&;
   ::nebula::meta::cpp2::ColumnTypeDef get_vid_type() &&;

  template <typename T_SpaceDesc_vid_type_struct_setter =  ::nebula::meta::cpp2::ColumnTypeDef>
   ::nebula::meta::cpp2::ColumnTypeDef& set_vid_type(T_SpaceDesc_vid_type_struct_setter&& vid_type_) {
    vid_type = std::forward<T_SpaceDesc_vid_type_struct_setter>(vid_type_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.vid_type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return vid_type;
  }
  const ::std::vector<::std::string>& get_zone_names() const&;
  ::std::vector<::std::string> get_zone_names() &&;

  template <typename T_SpaceDesc_zone_names_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_zone_names(T_SpaceDesc_zone_names_struct_setter&& zone_names_) {
    zone_names = std::forward<T_SpaceDesc_zone_names_struct_setter>(zone_names_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.zone_names = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return zone_names;
  }

  const  ::nebula::meta::cpp2::IsolationLevel* get_isolation_level() const& {
    return isolation_level_ref() ? std::addressof(isolation_level) : nullptr;
  }

   ::nebula::meta::cpp2::IsolationLevel* get_isolation_level() & {
    return isolation_level_ref() ? std::addressof(isolation_level) : nullptr;
  }
   ::nebula::meta::cpp2::IsolationLevel* get_isolation_level() && = delete;

   ::nebula::meta::cpp2::IsolationLevel& set_isolation_level( ::nebula::meta::cpp2::IsolationLevel isolation_level_) {
    isolation_level = isolation_level_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.isolation_level = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return isolation_level;
  }

  const ::std::string* get_comment() const& {
    return comment_ref() ? std::addressof(comment) : nullptr;
  }

  ::std::string* get_comment() & {
    return comment_ref() ? std::addressof(comment) : nullptr;
  }
  ::std::string* get_comment() && = delete;

  template <typename T_SpaceDesc_comment_struct_setter = ::std::string>
  ::std::string& set_comment(T_SpaceDesc_comment_struct_setter&& comment_) {
    comment = std::forward<T_SpaceDesc_comment_struct_setter>(comment_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.comment = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return comment;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< SpaceDesc >;
  friend void swap(SpaceDesc& a, SpaceDesc& b);
};

template <class Protocol_>
uint32_t SpaceDesc::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class SpaceItem final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = SpaceItem;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  SpaceItem() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  SpaceItem(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::meta::cpp2::SpaceDesc properties__arg);

  SpaceItem(SpaceItem&&) = default;

  SpaceItem(const SpaceItem&) = default;


  SpaceItem& operator=(SpaceItem&&) = default;

  SpaceItem& operator=(const SpaceItem&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
   ::nebula::meta::cpp2::SpaceDesc properties;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool properties;
  } __isset = {};
  bool operator==(const SpaceItem& rhs) const;
#ifndef SWIG
  friend bool operator!=(const SpaceItem& __x, const SpaceItem& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const SpaceItem& rhs) const;
#ifndef SWIG
  friend bool operator>(const SpaceItem& __x, const SpaceItem& __y) {
    return __y < __x;
  }
  friend bool operator<=(const SpaceItem& __x, const SpaceItem& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const SpaceItem& __x, const SpaceItem& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::SpaceDesc>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> properties_ref() const& {
    return {this->properties, __isset.properties};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SpaceDesc>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> properties_ref() const&& {
    return {std::move(this->properties), __isset.properties};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SpaceDesc>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> properties_ref() & {
    return {this->properties, __isset.properties};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SpaceDesc>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> properties_ref() && {
    return {std::move(this->properties), __isset.properties};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const  ::nebula::meta::cpp2::SpaceDesc& get_properties() const&;
   ::nebula::meta::cpp2::SpaceDesc get_properties() &&;

  template <typename T_SpaceItem_properties_struct_setter =  ::nebula::meta::cpp2::SpaceDesc>
   ::nebula::meta::cpp2::SpaceDesc& set_properties(T_SpaceItem_properties_struct_setter&& properties_) {
    properties = std::forward<T_SpaceItem_properties_struct_setter>(properties_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.properties = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return properties;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< SpaceItem >;
  friend void swap(SpaceItem& a, SpaceItem& b);
};

template <class Protocol_>
uint32_t SpaceItem::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class TagItem final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = TagItem;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  TagItem() :
      tag_id(0),
      version(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  TagItem(apache::thrift::FragileConstructor,  ::nebula::cpp2::TagID tag_id__arg, ::std::string tag_name__arg,  ::nebula::meta::cpp2::SchemaVer version__arg,  ::nebula::meta::cpp2::Schema schema__arg);

  TagItem(TagItem&&) = default;

  TagItem(const TagItem&) = default;


  TagItem& operator=(TagItem&&) = default;

  TagItem& operator=(const TagItem&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::TagID tag_id;
 private:
  ::std::string tag_name;
 private:
   ::nebula::meta::cpp2::SchemaVer version;
 private:
   ::nebula::meta::cpp2::Schema schema;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool tag_id;
    bool tag_name;
    bool version;
    bool schema;
  } __isset = {};
  bool operator==(const TagItem& rhs) const;
#ifndef SWIG
  friend bool operator!=(const TagItem& __x, const TagItem& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const TagItem& rhs) const;
#ifndef SWIG
  friend bool operator>(const TagItem& __x, const TagItem& __y) {
    return __y < __x;
  }
  friend bool operator<=(const TagItem& __x, const TagItem& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const TagItem& __x, const TagItem& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> tag_id_ref() const& {
    return {this->tag_id, __isset.tag_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> tag_id_ref() const&& {
    return {std::move(this->tag_id), __isset.tag_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> tag_id_ref() & {
    return {this->tag_id, __isset.tag_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> tag_id_ref() && {
    return {std::move(this->tag_id), __isset.tag_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> tag_name_ref() const& {
    return {this->tag_name, __isset.tag_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> tag_name_ref() const&& {
    return {std::move(this->tag_name), __isset.tag_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> tag_name_ref() & {
    return {this->tag_name, __isset.tag_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> tag_name_ref() && {
    return {std::move(this->tag_name), __isset.tag_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaVer>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> version_ref() const& {
    return {this->version, __isset.version};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaVer>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> version_ref() const&& {
    return {std::move(this->version), __isset.version};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaVer>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> version_ref() & {
    return {this->version, __isset.version};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaVer>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> version_ref() && {
    return {std::move(this->version), __isset.version};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> schema_ref() const& {
    return {this->schema, __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> schema_ref() const&& {
    return {std::move(this->schema), __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> schema_ref() & {
    return {this->schema, __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> schema_ref() && {
    return {std::move(this->schema), __isset.schema};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::TagID get_tag_id() const {
    return tag_id;
  }

   ::nebula::cpp2::TagID& set_tag_id( ::nebula::cpp2::TagID tag_id_) {
    tag_id = tag_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.tag_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return tag_id;
  }

  const ::std::string& get_tag_name() const& {
    return tag_name;
  }

  ::std::string get_tag_name() && {
    return std::move(tag_name);
  }

  template <typename T_TagItem_tag_name_struct_setter = ::std::string>
  ::std::string& set_tag_name(T_TagItem_tag_name_struct_setter&& tag_name_) {
    tag_name = std::forward<T_TagItem_tag_name_struct_setter>(tag_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.tag_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return tag_name;
  }

   ::nebula::meta::cpp2::SchemaVer get_version() const {
    return version;
  }

   ::nebula::meta::cpp2::SchemaVer& set_version( ::nebula::meta::cpp2::SchemaVer version_) {
    version = version_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.version = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return version;
  }
  const  ::nebula::meta::cpp2::Schema& get_schema() const&;
   ::nebula::meta::cpp2::Schema get_schema() &&;

  template <typename T_TagItem_schema_struct_setter =  ::nebula::meta::cpp2::Schema>
   ::nebula::meta::cpp2::Schema& set_schema(T_TagItem_schema_struct_setter&& schema_) {
    schema = std::forward<T_TagItem_schema_struct_setter>(schema_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.schema = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return schema;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< TagItem >;
  friend void swap(TagItem& a, TagItem& b);
};

template <class Protocol_>
uint32_t TagItem::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class AlterSchemaItem final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AlterSchemaItem;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  AlterSchemaItem() :
      op(static_cast< ::nebula::meta::cpp2::AlterSchemaOp>(0)) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AlterSchemaItem(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::AlterSchemaOp op__arg,  ::nebula::meta::cpp2::Schema schema__arg);

  AlterSchemaItem(AlterSchemaItem&&) = default;

  AlterSchemaItem(const AlterSchemaItem&) = default;


  AlterSchemaItem& operator=(AlterSchemaItem&&) = default;

  AlterSchemaItem& operator=(const AlterSchemaItem&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::meta::cpp2::AlterSchemaOp op;
 private:
   ::nebula::meta::cpp2::Schema schema;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool op;
    bool schema;
  } __isset = {};
  bool operator==(const AlterSchemaItem& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AlterSchemaItem& __x, const AlterSchemaItem& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AlterSchemaItem& rhs) const;
#ifndef SWIG
  friend bool operator>(const AlterSchemaItem& __x, const AlterSchemaItem& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AlterSchemaItem& __x, const AlterSchemaItem& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AlterSchemaItem& __x, const AlterSchemaItem& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::AlterSchemaOp>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> op_ref() const& {
    return {this->op, __isset.op};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::AlterSchemaOp>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> op_ref() const&& {
    return {std::move(this->op), __isset.op};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::AlterSchemaOp>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> op_ref() & {
    return {this->op, __isset.op};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::AlterSchemaOp>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> op_ref() && {
    return {std::move(this->op), __isset.op};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> schema_ref() const& {
    return {this->schema, __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> schema_ref() const&& {
    return {std::move(this->schema), __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> schema_ref() & {
    return {this->schema, __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> schema_ref() && {
    return {std::move(this->schema), __isset.schema};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::meta::cpp2::AlterSchemaOp get_op() const {
    return op;
  }

   ::nebula::meta::cpp2::AlterSchemaOp& set_op( ::nebula::meta::cpp2::AlterSchemaOp op_) {
    op = op_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.op = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return op;
  }
  const  ::nebula::meta::cpp2::Schema& get_schema() const&;
   ::nebula::meta::cpp2::Schema get_schema() &&;

  template <typename T_AlterSchemaItem_schema_struct_setter =  ::nebula::meta::cpp2::Schema>
   ::nebula::meta::cpp2::Schema& set_schema(T_AlterSchemaItem_schema_struct_setter&& schema_) {
    schema = std::forward<T_AlterSchemaItem_schema_struct_setter>(schema_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.schema = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return schema;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AlterSchemaItem >;
  friend void swap(AlterSchemaItem& a, AlterSchemaItem& b);
};

template <class Protocol_>
uint32_t AlterSchemaItem::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class EdgeItem final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = EdgeItem;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  EdgeItem() :
      edge_type(0),
      version(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  EdgeItem(apache::thrift::FragileConstructor,  ::nebula::cpp2::EdgeType edge_type__arg, ::std::string edge_name__arg,  ::nebula::meta::cpp2::SchemaVer version__arg,  ::nebula::meta::cpp2::Schema schema__arg);

  EdgeItem(EdgeItem&&) = default;

  EdgeItem(const EdgeItem&) = default;


  EdgeItem& operator=(EdgeItem&&) = default;

  EdgeItem& operator=(const EdgeItem&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::EdgeType edge_type;
 private:
  ::std::string edge_name;
 private:
   ::nebula::meta::cpp2::SchemaVer version;
 private:
   ::nebula::meta::cpp2::Schema schema;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool edge_type;
    bool edge_name;
    bool version;
    bool schema;
  } __isset = {};
  bool operator==(const EdgeItem& rhs) const;
#ifndef SWIG
  friend bool operator!=(const EdgeItem& __x, const EdgeItem& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const EdgeItem& rhs) const;
#ifndef SWIG
  friend bool operator>(const EdgeItem& __x, const EdgeItem& __y) {
    return __y < __x;
  }
  friend bool operator<=(const EdgeItem& __x, const EdgeItem& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const EdgeItem& __x, const EdgeItem& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> edge_type_ref() const& {
    return {this->edge_type, __isset.edge_type};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> edge_type_ref() const&& {
    return {std::move(this->edge_type), __isset.edge_type};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> edge_type_ref() & {
    return {this->edge_type, __isset.edge_type};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> edge_type_ref() && {
    return {std::move(this->edge_type), __isset.edge_type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> edge_name_ref() const& {
    return {this->edge_name, __isset.edge_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> edge_name_ref() const&& {
    return {std::move(this->edge_name), __isset.edge_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> edge_name_ref() & {
    return {this->edge_name, __isset.edge_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> edge_name_ref() && {
    return {std::move(this->edge_name), __isset.edge_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaVer>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> version_ref() const& {
    return {this->version, __isset.version};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaVer>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> version_ref() const&& {
    return {std::move(this->version), __isset.version};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaVer>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> version_ref() & {
    return {this->version, __isset.version};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaVer>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> version_ref() && {
    return {std::move(this->version), __isset.version};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> schema_ref() const& {
    return {this->schema, __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> schema_ref() const&& {
    return {std::move(this->schema), __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> schema_ref() & {
    return {this->schema, __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> schema_ref() && {
    return {std::move(this->schema), __isset.schema};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::EdgeType get_edge_type() const {
    return edge_type;
  }

   ::nebula::cpp2::EdgeType& set_edge_type( ::nebula::cpp2::EdgeType edge_type_) {
    edge_type = edge_type_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.edge_type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return edge_type;
  }

  const ::std::string& get_edge_name() const& {
    return edge_name;
  }

  ::std::string get_edge_name() && {
    return std::move(edge_name);
  }

  template <typename T_EdgeItem_edge_name_struct_setter = ::std::string>
  ::std::string& set_edge_name(T_EdgeItem_edge_name_struct_setter&& edge_name_) {
    edge_name = std::forward<T_EdgeItem_edge_name_struct_setter>(edge_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.edge_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return edge_name;
  }

   ::nebula::meta::cpp2::SchemaVer get_version() const {
    return version;
  }

   ::nebula::meta::cpp2::SchemaVer& set_version( ::nebula::meta::cpp2::SchemaVer version_) {
    version = version_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.version = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return version;
  }
  const  ::nebula::meta::cpp2::Schema& get_schema() const&;
   ::nebula::meta::cpp2::Schema get_schema() &&;

  template <typename T_EdgeItem_schema_struct_setter =  ::nebula::meta::cpp2::Schema>
   ::nebula::meta::cpp2::Schema& set_schema(T_EdgeItem_schema_struct_setter&& schema_) {
    schema = std::forward<T_EdgeItem_schema_struct_setter>(schema_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.schema = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return schema;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< EdgeItem >;
  friend void swap(EdgeItem& a, EdgeItem& b);
};

template <class Protocol_>
uint32_t EdgeItem::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class IndexParams final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = IndexParams;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  IndexParams() :
      s2_max_level(0),
      s2_max_cells(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  IndexParams(apache::thrift::FragileConstructor, int32_t s2_max_level__arg, int32_t s2_max_cells__arg);

  IndexParams(IndexParams&&) = default;

  IndexParams(const IndexParams&) = default;


  IndexParams& operator=(IndexParams&&) = default;

  IndexParams& operator=(const IndexParams&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  int32_t s2_max_level;
 private:
  int32_t s2_max_cells;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool s2_max_level;
    bool s2_max_cells;
  } __isset = {};
  bool operator==(const IndexParams& rhs) const;
#ifndef SWIG
  friend bool operator!=(const IndexParams& __x, const IndexParams& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const IndexParams& rhs) const;
#ifndef SWIG
  friend bool operator>(const IndexParams& __x, const IndexParams& __y) {
    return __y < __x;
  }
  friend bool operator<=(const IndexParams& __x, const IndexParams& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const IndexParams& __x, const IndexParams& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> s2_max_level_ref() const& {
    return {this->s2_max_level, __isset.s2_max_level};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> s2_max_level_ref() const&& {
    return {std::move(this->s2_max_level), __isset.s2_max_level};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> s2_max_level_ref() & {
    return {this->s2_max_level, __isset.s2_max_level};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> s2_max_level_ref() && {
    return {std::move(this->s2_max_level), __isset.s2_max_level};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> s2_max_cells_ref() const& {
    return {this->s2_max_cells, __isset.s2_max_cells};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> s2_max_cells_ref() const&& {
    return {std::move(this->s2_max_cells), __isset.s2_max_cells};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> s2_max_cells_ref() & {
    return {this->s2_max_cells, __isset.s2_max_cells};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> s2_max_cells_ref() && {
    return {std::move(this->s2_max_cells), __isset.s2_max_cells};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const int32_t* get_s2_max_level() const& {
    return s2_max_level_ref() ? std::addressof(s2_max_level) : nullptr;
  }

  int32_t* get_s2_max_level() & {
    return s2_max_level_ref() ? std::addressof(s2_max_level) : nullptr;
  }
  int32_t* get_s2_max_level() && = delete;

  int32_t& set_s2_max_level(int32_t s2_max_level_) {
    s2_max_level = s2_max_level_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.s2_max_level = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return s2_max_level;
  }

  const int32_t* get_s2_max_cells() const& {
    return s2_max_cells_ref() ? std::addressof(s2_max_cells) : nullptr;
  }

  int32_t* get_s2_max_cells() & {
    return s2_max_cells_ref() ? std::addressof(s2_max_cells) : nullptr;
  }
  int32_t* get_s2_max_cells() && = delete;

  int32_t& set_s2_max_cells(int32_t s2_max_cells_) {
    s2_max_cells = s2_max_cells_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.s2_max_cells = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return s2_max_cells;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< IndexParams >;
  friend void swap(IndexParams& a, IndexParams& b);
};

template <class Protocol_>
uint32_t IndexParams::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class IndexItem final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = IndexItem;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  IndexItem();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  IndexItem(apache::thrift::FragileConstructor,  ::nebula::cpp2::IndexID index_id__arg, ::std::string index_name__arg,  ::nebula::cpp2::SchemaID schema_id__arg, ::std::string schema_name__arg, ::std::vector< ::nebula::meta::cpp2::ColumnDef> fields__arg, ::std::string comment__arg,  ::nebula::meta::cpp2::IndexParams index_params__arg);

  IndexItem(IndexItem&&) = default;

  IndexItem(const IndexItem&) = default;


  IndexItem& operator=(IndexItem&&) = default;

  IndexItem& operator=(const IndexItem&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~IndexItem();

 private:
   ::nebula::cpp2::IndexID index_id;
 private:
  ::std::string index_name;
 private:
   ::nebula::cpp2::SchemaID schema_id;
 private:
  ::std::string schema_name;
 private:
  ::std::vector< ::nebula::meta::cpp2::ColumnDef> fields;
 private:
  ::std::string comment;
 private:
   ::nebula::meta::cpp2::IndexParams index_params;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool index_id;
    bool index_name;
    bool schema_id;
    bool schema_name;
    bool fields;
    bool comment;
    bool index_params;
  } __isset = {};
  bool operator==(const IndexItem& rhs) const;
#ifndef SWIG
  friend bool operator!=(const IndexItem& __x, const IndexItem& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const IndexItem& rhs) const;
#ifndef SWIG
  friend bool operator>(const IndexItem& __x, const IndexItem& __y) {
    return __y < __x;
  }
  friend bool operator<=(const IndexItem& __x, const IndexItem& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const IndexItem& __x, const IndexItem& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::IndexID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> index_id_ref() const& {
    return {this->index_id, __isset.index_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::IndexID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> index_id_ref() const&& {
    return {std::move(this->index_id), __isset.index_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::IndexID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> index_id_ref() & {
    return {this->index_id, __isset.index_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::IndexID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> index_id_ref() && {
    return {std::move(this->index_id), __isset.index_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> index_name_ref() const& {
    return {this->index_name, __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> index_name_ref() const&& {
    return {std::move(this->index_name), __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> index_name_ref() & {
    return {this->index_name, __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> index_name_ref() && {
    return {std::move(this->index_name), __isset.index_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::SchemaID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> schema_id_ref() const& {
    return {this->schema_id, __isset.schema_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::SchemaID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> schema_id_ref() const&& {
    return {std::move(this->schema_id), __isset.schema_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::SchemaID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> schema_id_ref() & {
    return {this->schema_id, __isset.schema_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::SchemaID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> schema_id_ref() && {
    return {std::move(this->schema_id), __isset.schema_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> schema_name_ref() const& {
    return {this->schema_name, __isset.schema_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> schema_name_ref() const&& {
    return {std::move(this->schema_name), __isset.schema_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> schema_name_ref() & {
    return {this->schema_name, __isset.schema_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> schema_name_ref() && {
    return {std::move(this->schema_name), __isset.schema_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ColumnDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fields_ref() const& {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ColumnDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fields_ref() const&& {
    return {std::move(this->fields), __isset.fields};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ColumnDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fields_ref() & {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ColumnDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fields_ref() && {
    return {std::move(this->fields), __isset.fields};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> comment_ref() const& {
    return {this->comment, __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> comment_ref() const&& {
    return {std::move(this->comment), __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> comment_ref() & {
    return {this->comment, __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> comment_ref() && {
    return {std::move(this->comment), __isset.comment};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::IndexParams>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> index_params_ref() const& {
    return {this->index_params, __isset.index_params};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::IndexParams>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> index_params_ref() const&& {
    return {std::move(this->index_params), __isset.index_params};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::IndexParams>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> index_params_ref() & {
    return {this->index_params, __isset.index_params};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::IndexParams>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> index_params_ref() && {
    return {std::move(this->index_params), __isset.index_params};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::IndexID get_index_id() const {
    return index_id;
  }

   ::nebula::cpp2::IndexID& set_index_id( ::nebula::cpp2::IndexID index_id_) {
    index_id = index_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.index_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return index_id;
  }

  const ::std::string& get_index_name() const& {
    return index_name;
  }

  ::std::string get_index_name() && {
    return std::move(index_name);
  }

  template <typename T_IndexItem_index_name_struct_setter = ::std::string>
  ::std::string& set_index_name(T_IndexItem_index_name_struct_setter&& index_name_) {
    index_name = std::forward<T_IndexItem_index_name_struct_setter>(index_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.index_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return index_name;
  }
  const  ::nebula::cpp2::SchemaID& get_schema_id() const&;
   ::nebula::cpp2::SchemaID get_schema_id() &&;

  template <typename T_IndexItem_schema_id_struct_setter =  ::nebula::cpp2::SchemaID>
   ::nebula::cpp2::SchemaID& set_schema_id(T_IndexItem_schema_id_struct_setter&& schema_id_) {
    schema_id = std::forward<T_IndexItem_schema_id_struct_setter>(schema_id_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.schema_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return schema_id;
  }

  const ::std::string& get_schema_name() const& {
    return schema_name;
  }

  ::std::string get_schema_name() && {
    return std::move(schema_name);
  }

  template <typename T_IndexItem_schema_name_struct_setter = ::std::string>
  ::std::string& set_schema_name(T_IndexItem_schema_name_struct_setter&& schema_name_) {
    schema_name = std::forward<T_IndexItem_schema_name_struct_setter>(schema_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.schema_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return schema_name;
  }
  const ::std::vector< ::nebula::meta::cpp2::ColumnDef>& get_fields() const&;
  ::std::vector< ::nebula::meta::cpp2::ColumnDef> get_fields() &&;

  template <typename T_IndexItem_fields_struct_setter = ::std::vector< ::nebula::meta::cpp2::ColumnDef>>
  ::std::vector< ::nebula::meta::cpp2::ColumnDef>& set_fields(T_IndexItem_fields_struct_setter&& fields_) {
    fields = std::forward<T_IndexItem_fields_struct_setter>(fields_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fields = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fields;
  }

  const ::std::string* get_comment() const& {
    return comment_ref() ? std::addressof(comment) : nullptr;
  }

  ::std::string* get_comment() & {
    return comment_ref() ? std::addressof(comment) : nullptr;
  }
  ::std::string* get_comment() && = delete;

  template <typename T_IndexItem_comment_struct_setter = ::std::string>
  ::std::string& set_comment(T_IndexItem_comment_struct_setter&& comment_) {
    comment = std::forward<T_IndexItem_comment_struct_setter>(comment_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.comment = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return comment;
  }
  const  ::nebula::meta::cpp2::IndexParams* get_index_params() const&;
   ::nebula::meta::cpp2::IndexParams* get_index_params() &;
   ::nebula::meta::cpp2::IndexParams* get_index_params() && = delete;

  template <typename T_IndexItem_index_params_struct_setter =  ::nebula::meta::cpp2::IndexParams>
   ::nebula::meta::cpp2::IndexParams& set_index_params(T_IndexItem_index_params_struct_setter&& index_params_) {
    index_params = std::forward<T_IndexItem_index_params_struct_setter>(index_params_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.index_params = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return index_params;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< IndexItem >;
  friend void swap(IndexItem& a, IndexItem& b);
};

template <class Protocol_>
uint32_t IndexItem::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class HostItem final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = HostItem;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  HostItem();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  HostItem(apache::thrift::FragileConstructor, nebula::HostAddr hostAddr__arg,  ::nebula::meta::cpp2::HostStatus status__arg, std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>> leader_parts__arg, std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>> all_parts__arg,  ::nebula::meta::cpp2::HostRole role__arg, ::std::string git_info_sha__arg, ::std::string zone_name__arg, ::std::string version__arg);

  HostItem(HostItem&&) = default;

  HostItem(const HostItem&) = default;


  HostItem& operator=(HostItem&&) = default;

  HostItem& operator=(const HostItem&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~HostItem();

 private:
  nebula::HostAddr hostAddr;
 private:
   ::nebula::meta::cpp2::HostStatus status;
 private:
  std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>> leader_parts;
 private:
  std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>> all_parts;
 private:
   ::nebula::meta::cpp2::HostRole role;
 private:
  ::std::string git_info_sha;
 private:
  ::std::string zone_name;
 private:
  ::std::string version;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool hostAddr;
    bool status;
    bool leader_parts;
    bool all_parts;
    bool role;
    bool git_info_sha;
    bool zone_name;
    bool version;
  } __isset = {};
  bool operator==(const HostItem& rhs) const;
#ifndef SWIG
  friend bool operator!=(const HostItem& __x, const HostItem& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const HostItem& rhs) const;
#ifndef SWIG
  friend bool operator>(const HostItem& __x, const HostItem& __y) {
    return __y < __x;
  }
  friend bool operator<=(const HostItem& __x, const HostItem& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const HostItem& __x, const HostItem& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> hostAddr_ref() const& {
    return {this->hostAddr, __isset.hostAddr};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> hostAddr_ref() const&& {
    return {std::move(this->hostAddr), __isset.hostAddr};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> hostAddr_ref() & {
    return {this->hostAddr, __isset.hostAddr};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> hostAddr_ref() && {
    return {std::move(this->hostAddr), __isset.hostAddr};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::HostStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> status_ref() const& {
    return {this->status, __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::HostStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> status_ref() const&& {
    return {std::move(this->status), __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::HostStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> status_ref() & {
    return {this->status, __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::HostStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> status_ref() && {
    return {std::move(this->status), __isset.status};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_parts_ref() const& {
    return {this->leader_parts, __isset.leader_parts};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_parts_ref() const&& {
    return {std::move(this->leader_parts), __isset.leader_parts};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_parts_ref() & {
    return {this->leader_parts, __isset.leader_parts};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_parts_ref() && {
    return {std::move(this->leader_parts), __isset.leader_parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> all_parts_ref() const& {
    return {this->all_parts, __isset.all_parts};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> all_parts_ref() const&& {
    return {std::move(this->all_parts), __isset.all_parts};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> all_parts_ref() & {
    return {this->all_parts, __isset.all_parts};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> all_parts_ref() && {
    return {std::move(this->all_parts), __isset.all_parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::HostRole>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> role_ref() const& {
    return {this->role, __isset.role};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::HostRole>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> role_ref() const&& {
    return {std::move(this->role), __isset.role};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::HostRole>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> role_ref() & {
    return {this->role, __isset.role};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::HostRole>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> role_ref() && {
    return {std::move(this->role), __isset.role};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> git_info_sha_ref() const& {
    return {this->git_info_sha, __isset.git_info_sha};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> git_info_sha_ref() const&& {
    return {std::move(this->git_info_sha), __isset.git_info_sha};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> git_info_sha_ref() & {
    return {this->git_info_sha, __isset.git_info_sha};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> git_info_sha_ref() && {
    return {std::move(this->git_info_sha), __isset.git_info_sha};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> zone_name_ref() const& {
    return {this->zone_name, __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> zone_name_ref() const&& {
    return {std::move(this->zone_name), __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> zone_name_ref() & {
    return {this->zone_name, __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> zone_name_ref() && {
    return {std::move(this->zone_name), __isset.zone_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> version_ref() const& {
    return {this->version, __isset.version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> version_ref() const&& {
    return {std::move(this->version), __isset.version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> version_ref() & {
    return {this->version, __isset.version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> version_ref() && {
    return {std::move(this->version), __isset.version};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const nebula::HostAddr& get_hostAddr() const&;
  nebula::HostAddr get_hostAddr() &&;

  template <typename T_HostItem_hostAddr_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_hostAddr(T_HostItem_hostAddr_struct_setter&& hostAddr_) {
    hostAddr = std::forward<T_HostItem_hostAddr_struct_setter>(hostAddr_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.hostAddr = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return hostAddr;
  }

   ::nebula::meta::cpp2::HostStatus get_status() const {
    return status;
  }

   ::nebula::meta::cpp2::HostStatus& set_status( ::nebula::meta::cpp2::HostStatus status_) {
    status = status_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.status = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return status;
  }
  const std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>>& get_leader_parts() const&;
  std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>> get_leader_parts() &&;

  template <typename T_HostItem_leader_parts_struct_setter = std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>>>
  std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>>& set_leader_parts(T_HostItem_leader_parts_struct_setter&& leader_parts_) {
    leader_parts = std::forward<T_HostItem_leader_parts_struct_setter>(leader_parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader_parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader_parts;
  }
  const std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>>& get_all_parts() const&;
  std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>> get_all_parts() &&;

  template <typename T_HostItem_all_parts_struct_setter = std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>>>
  std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>>& set_all_parts(T_HostItem_all_parts_struct_setter&& all_parts_) {
    all_parts = std::forward<T_HostItem_all_parts_struct_setter>(all_parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.all_parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return all_parts;
  }

   ::nebula::meta::cpp2::HostRole get_role() const {
    return role;
  }

   ::nebula::meta::cpp2::HostRole& set_role( ::nebula::meta::cpp2::HostRole role_) {
    role = role_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.role = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return role;
  }

  const ::std::string& get_git_info_sha() const& {
    return git_info_sha;
  }

  ::std::string get_git_info_sha() && {
    return std::move(git_info_sha);
  }

  template <typename T_HostItem_git_info_sha_struct_setter = ::std::string>
  ::std::string& set_git_info_sha(T_HostItem_git_info_sha_struct_setter&& git_info_sha_) {
    git_info_sha = std::forward<T_HostItem_git_info_sha_struct_setter>(git_info_sha_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.git_info_sha = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return git_info_sha;
  }

  const ::std::string* get_zone_name() const& {
    return zone_name_ref() ? std::addressof(zone_name) : nullptr;
  }

  ::std::string* get_zone_name() & {
    return zone_name_ref() ? std::addressof(zone_name) : nullptr;
  }
  ::std::string* get_zone_name() && = delete;

  template <typename T_HostItem_zone_name_struct_setter = ::std::string>
  ::std::string& set_zone_name(T_HostItem_zone_name_struct_setter&& zone_name_) {
    zone_name = std::forward<T_HostItem_zone_name_struct_setter>(zone_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.zone_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return zone_name;
  }

  const ::std::string* get_version() const& {
    return version_ref() ? std::addressof(version) : nullptr;
  }

  ::std::string* get_version() & {
    return version_ref() ? std::addressof(version) : nullptr;
  }
  ::std::string* get_version() && = delete;

  template <typename T_HostItem_version_struct_setter = ::std::string>
  ::std::string& set_version(T_HostItem_version_struct_setter&& version_) {
    version = std::forward<T_HostItem_version_struct_setter>(version_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.version = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return version;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< HostItem >;
  friend void swap(HostItem& a, HostItem& b);
};

template <class Protocol_>
uint32_t HostItem::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class UserItem final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = UserItem;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  UserItem();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  UserItem(apache::thrift::FragileConstructor, ::std::string account__arg, bool is_lock__arg, int32_t max_queries_per_hour__arg, int32_t max_updates_per_hour__arg, int32_t max_connections_per_hour__arg, int32_t max_user_connections__arg);

  UserItem(UserItem&&) = default;

  UserItem(const UserItem&) = default;


  UserItem& operator=(UserItem&&) = default;

  UserItem& operator=(const UserItem&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~UserItem();

 private:
  ::std::string account;
 private:
  bool is_lock;
 private:
  int32_t max_queries_per_hour;
 private:
  int32_t max_updates_per_hour;
 private:
  int32_t max_connections_per_hour;
 private:
  int32_t max_user_connections;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool account;
    bool is_lock;
    bool max_queries_per_hour;
    bool max_updates_per_hour;
    bool max_connections_per_hour;
    bool max_user_connections;
  } __isset = {};
  bool operator==(const UserItem& rhs) const;
#ifndef SWIG
  friend bool operator!=(const UserItem& __x, const UserItem& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const UserItem& rhs) const;
#ifndef SWIG
  friend bool operator>(const UserItem& __x, const UserItem& __y) {
    return __y < __x;
  }
  friend bool operator<=(const UserItem& __x, const UserItem& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const UserItem& __x, const UserItem& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> account_ref() const& {
    return {this->account, __isset.account};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> account_ref() const&& {
    return {std::move(this->account), __isset.account};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> account_ref() & {
    return {this->account, __isset.account};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> account_ref() && {
    return {std::move(this->account), __isset.account};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> is_lock_ref() const& {
    return {this->is_lock, __isset.is_lock};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> is_lock_ref() const&& {
    return {std::move(this->is_lock), __isset.is_lock};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> is_lock_ref() & {
    return {this->is_lock, __isset.is_lock};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> is_lock_ref() && {
    return {std::move(this->is_lock), __isset.is_lock};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> max_queries_per_hour_ref() const& {
    return {this->max_queries_per_hour, __isset.max_queries_per_hour};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> max_queries_per_hour_ref() const&& {
    return {std::move(this->max_queries_per_hour), __isset.max_queries_per_hour};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> max_queries_per_hour_ref() & {
    return {this->max_queries_per_hour, __isset.max_queries_per_hour};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> max_queries_per_hour_ref() && {
    return {std::move(this->max_queries_per_hour), __isset.max_queries_per_hour};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> max_updates_per_hour_ref() const& {
    return {this->max_updates_per_hour, __isset.max_updates_per_hour};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> max_updates_per_hour_ref() const&& {
    return {std::move(this->max_updates_per_hour), __isset.max_updates_per_hour};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> max_updates_per_hour_ref() & {
    return {this->max_updates_per_hour, __isset.max_updates_per_hour};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> max_updates_per_hour_ref() && {
    return {std::move(this->max_updates_per_hour), __isset.max_updates_per_hour};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> max_connections_per_hour_ref() const& {
    return {this->max_connections_per_hour, __isset.max_connections_per_hour};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> max_connections_per_hour_ref() const&& {
    return {std::move(this->max_connections_per_hour), __isset.max_connections_per_hour};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> max_connections_per_hour_ref() & {
    return {this->max_connections_per_hour, __isset.max_connections_per_hour};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> max_connections_per_hour_ref() && {
    return {std::move(this->max_connections_per_hour), __isset.max_connections_per_hour};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> max_user_connections_ref() const& {
    return {this->max_user_connections, __isset.max_user_connections};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> max_user_connections_ref() const&& {
    return {std::move(this->max_user_connections), __isset.max_user_connections};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> max_user_connections_ref() & {
    return {this->max_user_connections, __isset.max_user_connections};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> max_user_connections_ref() && {
    return {std::move(this->max_user_connections), __isset.max_user_connections};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_account() const& {
    return account;
  }

  ::std::string get_account() && {
    return std::move(account);
  }

  template <typename T_UserItem_account_struct_setter = ::std::string>
  ::std::string& set_account(T_UserItem_account_struct_setter&& account_) {
    account = std::forward<T_UserItem_account_struct_setter>(account_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.account = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return account;
  }

  bool get_is_lock() const {
    return is_lock;
  }

  bool& set_is_lock(bool is_lock_) {
    is_lock = is_lock_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.is_lock = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return is_lock;
  }

  int32_t get_max_queries_per_hour() const {
    return max_queries_per_hour;
  }

  int32_t& set_max_queries_per_hour(int32_t max_queries_per_hour_) {
    max_queries_per_hour = max_queries_per_hour_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.max_queries_per_hour = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return max_queries_per_hour;
  }

  int32_t get_max_updates_per_hour() const {
    return max_updates_per_hour;
  }

  int32_t& set_max_updates_per_hour(int32_t max_updates_per_hour_) {
    max_updates_per_hour = max_updates_per_hour_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.max_updates_per_hour = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return max_updates_per_hour;
  }

  int32_t get_max_connections_per_hour() const {
    return max_connections_per_hour;
  }

  int32_t& set_max_connections_per_hour(int32_t max_connections_per_hour_) {
    max_connections_per_hour = max_connections_per_hour_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.max_connections_per_hour = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return max_connections_per_hour;
  }

  int32_t get_max_user_connections() const {
    return max_user_connections;
  }

  int32_t& set_max_user_connections(int32_t max_user_connections_) {
    max_user_connections = max_user_connections_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.max_user_connections = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return max_user_connections;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< UserItem >;
  friend void swap(UserItem& a, UserItem& b);
};

template <class Protocol_>
uint32_t UserItem::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class RoleItem final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = RoleItem;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  RoleItem() :
      space_id(0),
      role_type(static_cast< ::nebula::meta::cpp2::RoleType>(0)) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RoleItem(apache::thrift::FragileConstructor, ::std::string user_id__arg,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::meta::cpp2::RoleType role_type__arg);

  RoleItem(RoleItem&&) = default;

  RoleItem(const RoleItem&) = default;


  RoleItem& operator=(RoleItem&&) = default;

  RoleItem& operator=(const RoleItem&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string user_id;
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
   ::nebula::meta::cpp2::RoleType role_type;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool user_id;
    bool space_id;
    bool role_type;
  } __isset = {};
  bool operator==(const RoleItem& rhs) const;
#ifndef SWIG
  friend bool operator!=(const RoleItem& __x, const RoleItem& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const RoleItem& rhs) const;
#ifndef SWIG
  friend bool operator>(const RoleItem& __x, const RoleItem& __y) {
    return __y < __x;
  }
  friend bool operator<=(const RoleItem& __x, const RoleItem& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const RoleItem& __x, const RoleItem& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> user_id_ref() const& {
    return {this->user_id, __isset.user_id};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> user_id_ref() const&& {
    return {std::move(this->user_id), __isset.user_id};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> user_id_ref() & {
    return {this->user_id, __isset.user_id};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> user_id_ref() && {
    return {std::move(this->user_id), __isset.user_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::RoleType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> role_type_ref() const& {
    return {this->role_type, __isset.role_type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::RoleType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> role_type_ref() const&& {
    return {std::move(this->role_type), __isset.role_type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::RoleType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> role_type_ref() & {
    return {this->role_type, __isset.role_type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::RoleType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> role_type_ref() && {
    return {std::move(this->role_type), __isset.role_type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_user_id() const& {
    return user_id;
  }

  ::std::string get_user_id() && {
    return std::move(user_id);
  }

  template <typename T_RoleItem_user_id_struct_setter = ::std::string>
  ::std::string& set_user_id(T_RoleItem_user_id_struct_setter&& user_id_) {
    user_id = std::forward<T_RoleItem_user_id_struct_setter>(user_id_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.user_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return user_id;
  }

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

   ::nebula::meta::cpp2::RoleType get_role_type() const {
    return role_type;
  }

   ::nebula::meta::cpp2::RoleType& set_role_type( ::nebula::meta::cpp2::RoleType role_type_) {
    role_type = role_type_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.role_type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return role_type;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< RoleItem >;
  friend void swap(RoleItem& a, RoleItem& b);
};

template <class Protocol_>
uint32_t RoleItem::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ExecResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ExecResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ExecResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ExecResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg,  ::nebula::meta::cpp2::ID id__arg, nebula::HostAddr leader__arg);

  ExecResp(ExecResp&&) = default;

  ExecResp(const ExecResp&) = default;


  ExecResp& operator=(ExecResp&&) = default;

  ExecResp& operator=(const ExecResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
   ::nebula::meta::cpp2::ID id;
 private:
  nebula::HostAddr leader;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool id;
    bool leader;
  } __isset = {};
  bool operator==(const ExecResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ExecResp& __x, const ExecResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ExecResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ExecResp& __x, const ExecResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ExecResp& __x, const ExecResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ExecResp& __x, const ExecResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::ID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> id_ref() const& {
    return {this->id, __isset.id};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> id_ref() const&& {
    return {std::move(this->id), __isset.id};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> id_ref() & {
    return {this->id, __isset.id};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> id_ref() && {
    return {std::move(this->id), __isset.id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const  ::nebula::meta::cpp2::ID& get_id() const&;
   ::nebula::meta::cpp2::ID get_id() &&;

  template <typename T_ExecResp_id_struct_setter =  ::nebula::meta::cpp2::ID>
   ::nebula::meta::cpp2::ID& set_id(T_ExecResp_id_struct_setter&& id_) {
    id = std::forward<T_ExecResp_id_struct_setter>(id_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return id;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_ExecResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_ExecResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_ExecResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ExecResp >;
  friend void swap(ExecResp& a, ExecResp& b);
};

template <class Protocol_>
uint32_t ExecResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class AlterSpaceReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AlterSpaceReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  AlterSpaceReq() :
      op(static_cast< ::nebula::meta::cpp2::AlterSpaceOp>(0)) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AlterSpaceReq(apache::thrift::FragileConstructor, ::std::string space_name__arg,  ::nebula::meta::cpp2::AlterSpaceOp op__arg, ::std::vector<::std::string> paras__arg);

  AlterSpaceReq(AlterSpaceReq&&) = default;

  AlterSpaceReq(const AlterSpaceReq&) = default;


  AlterSpaceReq& operator=(AlterSpaceReq&&) = default;

  AlterSpaceReq& operator=(const AlterSpaceReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string space_name;
 private:
   ::nebula::meta::cpp2::AlterSpaceOp op;
 private:
  ::std::vector<::std::string> paras;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_name;
    bool op;
    bool paras;
  } __isset = {};
  bool operator==(const AlterSpaceReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AlterSpaceReq& __x, const AlterSpaceReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AlterSpaceReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const AlterSpaceReq& __x, const AlterSpaceReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AlterSpaceReq& __x, const AlterSpaceReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AlterSpaceReq& __x, const AlterSpaceReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_name_ref() const& {
    return {this->space_name, __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_name_ref() const&& {
    return {std::move(this->space_name), __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_name_ref() & {
    return {this->space_name, __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_name_ref() && {
    return {std::move(this->space_name), __isset.space_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::AlterSpaceOp>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> op_ref() const& {
    return {this->op, __isset.op};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::AlterSpaceOp>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> op_ref() const&& {
    return {std::move(this->op), __isset.op};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::AlterSpaceOp>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> op_ref() & {
    return {this->op, __isset.op};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::AlterSpaceOp>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> op_ref() && {
    return {std::move(this->op), __isset.op};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> paras_ref() const& {
    return {this->paras, __isset.paras};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> paras_ref() const&& {
    return {std::move(this->paras), __isset.paras};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> paras_ref() & {
    return {this->paras, __isset.paras};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> paras_ref() && {
    return {std::move(this->paras), __isset.paras};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_space_name() const& {
    return space_name;
  }

  ::std::string get_space_name() && {
    return std::move(space_name);
  }

  template <typename T_AlterSpaceReq_space_name_struct_setter = ::std::string>
  ::std::string& set_space_name(T_AlterSpaceReq_space_name_struct_setter&& space_name_) {
    space_name = std::forward<T_AlterSpaceReq_space_name_struct_setter>(space_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_name;
  }

   ::nebula::meta::cpp2::AlterSpaceOp get_op() const {
    return op;
  }

   ::nebula::meta::cpp2::AlterSpaceOp& set_op( ::nebula::meta::cpp2::AlterSpaceOp op_) {
    op = op_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.op = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return op;
  }
  const ::std::vector<::std::string>& get_paras() const&;
  ::std::vector<::std::string> get_paras() &&;

  template <typename T_AlterSpaceReq_paras_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_paras(T_AlterSpaceReq_paras_struct_setter&& paras_) {
    paras = std::forward<T_AlterSpaceReq_paras_struct_setter>(paras_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.paras = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return paras;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AlterSpaceReq >;
  friend void swap(AlterSpaceReq& a, AlterSpaceReq& b);
};

template <class Protocol_>
uint32_t AlterSpaceReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class AdminJobReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AdminJobReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  AdminJobReq() :
      space_id(0),
      op(static_cast< ::nebula::meta::cpp2::JobOp>(0)),
      type( ::nebula::meta::cpp2::JobType::COMPACT) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AdminJobReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::meta::cpp2::JobOp op__arg,  ::nebula::meta::cpp2::JobType type__arg, ::std::vector<::std::string> paras__arg);

  AdminJobReq(AdminJobReq&&) = default;

  AdminJobReq(const AdminJobReq&) = default;


  AdminJobReq& operator=(AdminJobReq&&) = default;

  AdminJobReq& operator=(const AdminJobReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
   ::nebula::meta::cpp2::JobOp op;
 private:
   ::nebula::meta::cpp2::JobType type;
 private:
  ::std::vector<::std::string> paras;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool op;
    bool type;
    bool paras;
  } __isset = {};
  bool operator==(const AdminJobReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AdminJobReq& __x, const AdminJobReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AdminJobReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const AdminJobReq& __x, const AdminJobReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AdminJobReq& __x, const AdminJobReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AdminJobReq& __x, const AdminJobReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::JobOp>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> op_ref() const& {
    return {this->op, __isset.op};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::JobOp>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> op_ref() const&& {
    return {std::move(this->op), __isset.op};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::JobOp>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> op_ref() & {
    return {this->op, __isset.op};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::JobOp>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> op_ref() && {
    return {std::move(this->op), __isset.op};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::JobType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> type_ref() const& {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::JobType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> type_ref() const&& {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::JobType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> type_ref() & {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::JobType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> type_ref() && {
    return {std::move(this->type), __isset.type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> paras_ref() const& {
    return {this->paras, __isset.paras};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> paras_ref() const&& {
    return {std::move(this->paras), __isset.paras};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> paras_ref() & {
    return {this->paras, __isset.paras};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> paras_ref() && {
    return {std::move(this->paras), __isset.paras};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

   ::nebula::meta::cpp2::JobOp get_op() const {
    return op;
  }

   ::nebula::meta::cpp2::JobOp& set_op( ::nebula::meta::cpp2::JobOp op_) {
    op = op_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.op = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return op;
  }

   ::nebula::meta::cpp2::JobType get_type() const {
    return type;
  }

   ::nebula::meta::cpp2::JobType& set_type( ::nebula::meta::cpp2::JobType type_) {
    type = type_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return type;
  }
  const ::std::vector<::std::string>& get_paras() const&;
  ::std::vector<::std::string> get_paras() &&;

  template <typename T_AdminJobReq_paras_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_paras(T_AdminJobReq_paras_struct_setter&& paras_) {
    paras = std::forward<T_AdminJobReq_paras_struct_setter>(paras_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.paras = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return paras;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AdminJobReq >;
  friend void swap(AdminJobReq& a, AdminJobReq& b);
};

template <class Protocol_>
uint32_t AdminJobReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class JobDesc final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = JobDesc;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  JobDesc();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  JobDesc(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, int32_t job_id__arg,  ::nebula::meta::cpp2::JobType type__arg, ::std::vector<::std::string> paras__arg,  ::nebula::meta::cpp2::JobStatus status__arg, int64_t start_time__arg, int64_t stop_time__arg,  ::nebula::cpp2::ErrorCode code__arg);

  JobDesc(JobDesc&&) = default;

  JobDesc(const JobDesc&) = default;


  JobDesc& operator=(JobDesc&&) = default;

  JobDesc& operator=(const JobDesc&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~JobDesc();

 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  int32_t job_id;
 private:
   ::nebula::meta::cpp2::JobType type;
 private:
  ::std::vector<::std::string> paras;
 private:
   ::nebula::meta::cpp2::JobStatus status;
 private:
  int64_t start_time;
 private:
  int64_t stop_time;
 private:
   ::nebula::cpp2::ErrorCode code;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool job_id;
    bool type;
    bool paras;
    bool status;
    bool start_time;
    bool stop_time;
    bool code;
  } __isset = {};
  bool operator==(const JobDesc& rhs) const;
#ifndef SWIG
  friend bool operator!=(const JobDesc& __x, const JobDesc& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const JobDesc& rhs) const;
#ifndef SWIG
  friend bool operator>(const JobDesc& __x, const JobDesc& __y) {
    return __y < __x;
  }
  friend bool operator<=(const JobDesc& __x, const JobDesc& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const JobDesc& __x, const JobDesc& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> job_id_ref() const& {
    return {this->job_id, __isset.job_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> job_id_ref() const&& {
    return {std::move(this->job_id), __isset.job_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> job_id_ref() & {
    return {this->job_id, __isset.job_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> job_id_ref() && {
    return {std::move(this->job_id), __isset.job_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::JobType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> type_ref() const& {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::JobType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> type_ref() const&& {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::JobType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> type_ref() & {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::JobType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> type_ref() && {
    return {std::move(this->type), __isset.type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> paras_ref() const& {
    return {this->paras, __isset.paras};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> paras_ref() const&& {
    return {std::move(this->paras), __isset.paras};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> paras_ref() & {
    return {this->paras, __isset.paras};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> paras_ref() && {
    return {std::move(this->paras), __isset.paras};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::JobStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> status_ref() const& {
    return {this->status, __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::JobStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> status_ref() const&& {
    return {std::move(this->status), __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::JobStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> status_ref() & {
    return {this->status, __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::JobStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> status_ref() && {
    return {std::move(this->status), __isset.status};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> start_time_ref() const& {
    return {this->start_time, __isset.start_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> start_time_ref() const&& {
    return {std::move(this->start_time), __isset.start_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> start_time_ref() & {
    return {this->start_time, __isset.start_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> start_time_ref() && {
    return {std::move(this->start_time), __isset.start_time};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> stop_time_ref() const& {
    return {this->stop_time, __isset.stop_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> stop_time_ref() const&& {
    return {std::move(this->stop_time), __isset.stop_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> stop_time_ref() & {
    return {this->stop_time, __isset.stop_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> stop_time_ref() && {
    return {std::move(this->stop_time), __isset.stop_time};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  int32_t get_job_id() const {
    return job_id;
  }

  int32_t& set_job_id(int32_t job_id_) {
    job_id = job_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.job_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return job_id;
  }

   ::nebula::meta::cpp2::JobType get_type() const {
    return type;
  }

   ::nebula::meta::cpp2::JobType& set_type( ::nebula::meta::cpp2::JobType type_) {
    type = type_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return type;
  }
  const ::std::vector<::std::string>& get_paras() const&;
  ::std::vector<::std::string> get_paras() &&;

  template <typename T_JobDesc_paras_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_paras(T_JobDesc_paras_struct_setter&& paras_) {
    paras = std::forward<T_JobDesc_paras_struct_setter>(paras_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.paras = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return paras;
  }

   ::nebula::meta::cpp2::JobStatus get_status() const {
    return status;
  }

   ::nebula::meta::cpp2::JobStatus& set_status( ::nebula::meta::cpp2::JobStatus status_) {
    status = status_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.status = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return status;
  }

  int64_t get_start_time() const {
    return start_time;
  }

  int64_t& set_start_time(int64_t start_time_) {
    start_time = start_time_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.start_time = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return start_time;
  }

  int64_t get_stop_time() const {
    return stop_time;
  }

  int64_t& set_stop_time(int64_t stop_time_) {
    stop_time = stop_time_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.stop_time = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return stop_time;
  }

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< JobDesc >;
  friend void swap(JobDesc& a, JobDesc& b);
};

template <class Protocol_>
uint32_t JobDesc::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class TaskDesc final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = TaskDesc;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  TaskDesc() :
      space_id(0),
      job_id(0),
      task_id(0),
      status(static_cast< ::nebula::meta::cpp2::JobStatus>(0)),
      start_time(0),
      stop_time(0),
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  TaskDesc(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, int32_t job_id__arg, int32_t task_id__arg, nebula::HostAddr host__arg,  ::nebula::meta::cpp2::JobStatus status__arg, int64_t start_time__arg, int64_t stop_time__arg,  ::nebula::cpp2::ErrorCode code__arg);

  TaskDesc(TaskDesc&&) = default;

  TaskDesc(const TaskDesc&) = default;


  TaskDesc& operator=(TaskDesc&&) = default;

  TaskDesc& operator=(const TaskDesc&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  int32_t job_id;
 private:
  int32_t task_id;
 private:
  nebula::HostAddr host;
 private:
   ::nebula::meta::cpp2::JobStatus status;
 private:
  int64_t start_time;
 private:
  int64_t stop_time;
 private:
   ::nebula::cpp2::ErrorCode code;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool job_id;
    bool task_id;
    bool host;
    bool status;
    bool start_time;
    bool stop_time;
    bool code;
  } __isset = {};
  bool operator==(const TaskDesc& rhs) const;
#ifndef SWIG
  friend bool operator!=(const TaskDesc& __x, const TaskDesc& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const TaskDesc& rhs) const;
#ifndef SWIG
  friend bool operator>(const TaskDesc& __x, const TaskDesc& __y) {
    return __y < __x;
  }
  friend bool operator<=(const TaskDesc& __x, const TaskDesc& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const TaskDesc& __x, const TaskDesc& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> job_id_ref() const& {
    return {this->job_id, __isset.job_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> job_id_ref() const&& {
    return {std::move(this->job_id), __isset.job_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> job_id_ref() & {
    return {this->job_id, __isset.job_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> job_id_ref() && {
    return {std::move(this->job_id), __isset.job_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> task_id_ref() const& {
    return {this->task_id, __isset.task_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> task_id_ref() const&& {
    return {std::move(this->task_id), __isset.task_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> task_id_ref() & {
    return {this->task_id, __isset.task_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> task_id_ref() && {
    return {std::move(this->task_id), __isset.task_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> host_ref() const& {
    return {this->host, __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> host_ref() const&& {
    return {std::move(this->host), __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> host_ref() & {
    return {this->host, __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> host_ref() && {
    return {std::move(this->host), __isset.host};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::JobStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> status_ref() const& {
    return {this->status, __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::JobStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> status_ref() const&& {
    return {std::move(this->status), __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::JobStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> status_ref() & {
    return {this->status, __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::JobStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> status_ref() && {
    return {std::move(this->status), __isset.status};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> start_time_ref() const& {
    return {this->start_time, __isset.start_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> start_time_ref() const&& {
    return {std::move(this->start_time), __isset.start_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> start_time_ref() & {
    return {this->start_time, __isset.start_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> start_time_ref() && {
    return {std::move(this->start_time), __isset.start_time};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> stop_time_ref() const& {
    return {this->stop_time, __isset.stop_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> stop_time_ref() const&& {
    return {std::move(this->stop_time), __isset.stop_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> stop_time_ref() & {
    return {this->stop_time, __isset.stop_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> stop_time_ref() && {
    return {std::move(this->stop_time), __isset.stop_time};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  int32_t get_job_id() const {
    return job_id;
  }

  int32_t& set_job_id(int32_t job_id_) {
    job_id = job_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.job_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return job_id;
  }

  int32_t get_task_id() const {
    return task_id;
  }

  int32_t& set_task_id(int32_t task_id_) {
    task_id = task_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.task_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return task_id;
  }
  const nebula::HostAddr& get_host() const&;
  nebula::HostAddr get_host() &&;

  template <typename T_TaskDesc_host_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_host(T_TaskDesc_host_struct_setter&& host_) {
    host = std::forward<T_TaskDesc_host_struct_setter>(host_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.host = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return host;
  }

   ::nebula::meta::cpp2::JobStatus get_status() const {
    return status;
  }

   ::nebula::meta::cpp2::JobStatus& set_status( ::nebula::meta::cpp2::JobStatus status_) {
    status = status_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.status = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return status;
  }

  int64_t get_start_time() const {
    return start_time;
  }

  int64_t& set_start_time(int64_t start_time_) {
    start_time = start_time_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.start_time = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return start_time;
  }

  int64_t get_stop_time() const {
    return stop_time;
  }

  int64_t& set_stop_time(int64_t stop_time_) {
    stop_time = stop_time_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.stop_time = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return stop_time;
  }

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< TaskDesc >;
  friend void swap(TaskDesc& a, TaskDesc& b);
};

template <class Protocol_>
uint32_t TaskDesc::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class AdminJobResult final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AdminJobResult;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  AdminJobResult() :
      job_id(0),
      recovered_job_num(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AdminJobResult(apache::thrift::FragileConstructor, int32_t job_id__arg, ::std::vector< ::nebula::meta::cpp2::JobDesc> job_desc__arg, ::std::vector< ::nebula::meta::cpp2::TaskDesc> task_desc__arg, int32_t recovered_job_num__arg);

  AdminJobResult(AdminJobResult&&) = default;

  AdminJobResult(const AdminJobResult&) = default;


  AdminJobResult& operator=(AdminJobResult&&) = default;

  AdminJobResult& operator=(const AdminJobResult&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  int32_t job_id;
 private:
  ::std::vector< ::nebula::meta::cpp2::JobDesc> job_desc;
 private:
  ::std::vector< ::nebula::meta::cpp2::TaskDesc> task_desc;
 private:
  int32_t recovered_job_num;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool job_id;
    bool job_desc;
    bool task_desc;
    bool recovered_job_num;
  } __isset = {};
  bool operator==(const AdminJobResult& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AdminJobResult& __x, const AdminJobResult& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AdminJobResult& rhs) const;
#ifndef SWIG
  friend bool operator>(const AdminJobResult& __x, const AdminJobResult& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AdminJobResult& __x, const AdminJobResult& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AdminJobResult& __x, const AdminJobResult& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> job_id_ref() const& {
    return {this->job_id, __isset.job_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> job_id_ref() const&& {
    return {std::move(this->job_id), __isset.job_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> job_id_ref() & {
    return {this->job_id, __isset.job_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> job_id_ref() && {
    return {std::move(this->job_id), __isset.job_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::JobDesc>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> job_desc_ref() const& {
    return {this->job_desc, __isset.job_desc};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::JobDesc>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> job_desc_ref() const&& {
    return {std::move(this->job_desc), __isset.job_desc};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::JobDesc>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> job_desc_ref() & {
    return {this->job_desc, __isset.job_desc};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::JobDesc>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> job_desc_ref() && {
    return {std::move(this->job_desc), __isset.job_desc};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::TaskDesc>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> task_desc_ref() const& {
    return {this->task_desc, __isset.task_desc};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::TaskDesc>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> task_desc_ref() const&& {
    return {std::move(this->task_desc), __isset.task_desc};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::TaskDesc>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> task_desc_ref() & {
    return {this->task_desc, __isset.task_desc};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::TaskDesc>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> task_desc_ref() && {
    return {std::move(this->task_desc), __isset.task_desc};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> recovered_job_num_ref() const& {
    return {this->recovered_job_num, __isset.recovered_job_num};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> recovered_job_num_ref() const&& {
    return {std::move(this->recovered_job_num), __isset.recovered_job_num};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> recovered_job_num_ref() & {
    return {this->recovered_job_num, __isset.recovered_job_num};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> recovered_job_num_ref() && {
    return {std::move(this->recovered_job_num), __isset.recovered_job_num};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const int32_t* get_job_id() const& {
    return job_id_ref() ? std::addressof(job_id) : nullptr;
  }

  int32_t* get_job_id() & {
    return job_id_ref() ? std::addressof(job_id) : nullptr;
  }
  int32_t* get_job_id() && = delete;

  int32_t& set_job_id(int32_t job_id_) {
    job_id = job_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.job_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return job_id;
  }
  const ::std::vector< ::nebula::meta::cpp2::JobDesc>* get_job_desc() const&;
  ::std::vector< ::nebula::meta::cpp2::JobDesc>* get_job_desc() &;
  ::std::vector< ::nebula::meta::cpp2::JobDesc>* get_job_desc() && = delete;

  template <typename T_AdminJobResult_job_desc_struct_setter = ::std::vector< ::nebula::meta::cpp2::JobDesc>>
  ::std::vector< ::nebula::meta::cpp2::JobDesc>& set_job_desc(T_AdminJobResult_job_desc_struct_setter&& job_desc_) {
    job_desc = std::forward<T_AdminJobResult_job_desc_struct_setter>(job_desc_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.job_desc = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return job_desc;
  }
  const ::std::vector< ::nebula::meta::cpp2::TaskDesc>* get_task_desc() const&;
  ::std::vector< ::nebula::meta::cpp2::TaskDesc>* get_task_desc() &;
  ::std::vector< ::nebula::meta::cpp2::TaskDesc>* get_task_desc() && = delete;

  template <typename T_AdminJobResult_task_desc_struct_setter = ::std::vector< ::nebula::meta::cpp2::TaskDesc>>
  ::std::vector< ::nebula::meta::cpp2::TaskDesc>& set_task_desc(T_AdminJobResult_task_desc_struct_setter&& task_desc_) {
    task_desc = std::forward<T_AdminJobResult_task_desc_struct_setter>(task_desc_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.task_desc = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return task_desc;
  }

  const int32_t* get_recovered_job_num() const& {
    return recovered_job_num_ref() ? std::addressof(recovered_job_num) : nullptr;
  }

  int32_t* get_recovered_job_num() & {
    return recovered_job_num_ref() ? std::addressof(recovered_job_num) : nullptr;
  }
  int32_t* get_recovered_job_num() && = delete;

  int32_t& set_recovered_job_num(int32_t recovered_job_num_) {
    recovered_job_num = recovered_job_num_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.recovered_job_num = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return recovered_job_num;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AdminJobResult >;
  friend void swap(AdminJobResult& a, AdminJobResult& b);
};

template <class Protocol_>
uint32_t AdminJobResult::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class AdminJobResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AdminJobResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  AdminJobResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AdminJobResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::AdminJobResult result__arg);

  AdminJobResp(AdminJobResp&&) = default;

  AdminJobResp(const AdminJobResp&) = default;


  AdminJobResp& operator=(AdminJobResp&&) = default;

  AdminJobResp& operator=(const AdminJobResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
   ::nebula::meta::cpp2::AdminJobResult result;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool result;
  } __isset = {};
  bool operator==(const AdminJobResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AdminJobResp& __x, const AdminJobResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AdminJobResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const AdminJobResp& __x, const AdminJobResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AdminJobResp& __x, const AdminJobResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AdminJobResp& __x, const AdminJobResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::AdminJobResult>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> result_ref() const& {
    return {this->result, __isset.result};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::AdminJobResult>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> result_ref() const&& {
    return {std::move(this->result), __isset.result};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::AdminJobResult>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> result_ref() & {
    return {this->result, __isset.result};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::AdminJobResult>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> result_ref() && {
    return {std::move(this->result), __isset.result};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_AdminJobResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_AdminJobResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_AdminJobResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const  ::nebula::meta::cpp2::AdminJobResult& get_result() const&;
   ::nebula::meta::cpp2::AdminJobResult get_result() &&;

  template <typename T_AdminJobResp_result_struct_setter =  ::nebula::meta::cpp2::AdminJobResult>
   ::nebula::meta::cpp2::AdminJobResult& set_result(T_AdminJobResp_result_struct_setter&& result_) {
    result = std::forward<T_AdminJobResp_result_struct_setter>(result_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.result = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return result;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AdminJobResp >;
  friend void swap(AdminJobResp& a, AdminJobResp& b);
};

template <class Protocol_>
uint32_t AdminJobResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class Correlativity final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Correlativity;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  Correlativity() :
      part_id(0),
      proportion(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Correlativity(apache::thrift::FragileConstructor,  ::nebula::cpp2::PartitionID part_id__arg, double proportion__arg);

  Correlativity(Correlativity&&) = default;

  Correlativity(const Correlativity&) = default;


  Correlativity& operator=(Correlativity&&) = default;

  Correlativity& operator=(const Correlativity&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::PartitionID part_id;
 private:
  double proportion;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool part_id;
    bool proportion;
  } __isset = {};
  bool operator==(const Correlativity& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Correlativity& __x, const Correlativity& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Correlativity& rhs) const;
#ifndef SWIG
  friend bool operator>(const Correlativity& __x, const Correlativity& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Correlativity& __x, const Correlativity& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Correlativity& __x, const Correlativity& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> part_id_ref() const& {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> part_id_ref() const&& {
    return {std::move(this->part_id), __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> part_id_ref() & {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> part_id_ref() && {
    return {std::move(this->part_id), __isset.part_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> proportion_ref() const& {
    return {this->proportion, __isset.proportion};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> proportion_ref() const&& {
    return {std::move(this->proportion), __isset.proportion};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> proportion_ref() & {
    return {this->proportion, __isset.proportion};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> proportion_ref() && {
    return {std::move(this->proportion), __isset.proportion};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::PartitionID get_part_id() const {
    return part_id;
  }

   ::nebula::cpp2::PartitionID& set_part_id( ::nebula::cpp2::PartitionID part_id_) {
    part_id = part_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.part_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return part_id;
  }

  double get_proportion() const {
    return proportion;
  }

  double& set_proportion(double proportion_) {
    proportion = proportion_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.proportion = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return proportion;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Correlativity >;
  friend void swap(Correlativity& a, Correlativity& b);
};

template <class Protocol_>
uint32_t Correlativity::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class StatsItem final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = StatsItem;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  StatsItem();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  StatsItem(apache::thrift::FragileConstructor, std::unordered_map<::std::string, int64_t> tag_vertices__arg, std::unordered_map<::std::string, int64_t> edges__arg, int64_t space_vertices__arg, int64_t space_edges__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>> positive_part_correlativity__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>> negative_part_correlativity__arg,  ::nebula::meta::cpp2::JobStatus status__arg);

  StatsItem(StatsItem&&) = default;

  StatsItem(const StatsItem&) = default;


  StatsItem& operator=(StatsItem&&) = default;

  StatsItem& operator=(const StatsItem&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~StatsItem();

 private:
  std::unordered_map<::std::string, int64_t> tag_vertices;
 private:
  std::unordered_map<::std::string, int64_t> edges;
 private:
  int64_t space_vertices;
 private:
  int64_t space_edges;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>> positive_part_correlativity;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>> negative_part_correlativity;
 private:
   ::nebula::meta::cpp2::JobStatus status;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool tag_vertices;
    bool edges;
    bool space_vertices;
    bool space_edges;
    bool positive_part_correlativity;
    bool negative_part_correlativity;
    bool status;
  } __isset = {};
  bool operator==(const StatsItem& rhs) const;
#ifndef SWIG
  friend bool operator!=(const StatsItem& __x, const StatsItem& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const StatsItem& rhs) const;
#ifndef SWIG
  friend bool operator>(const StatsItem& __x, const StatsItem& __y) {
    return __y < __x;
  }
  friend bool operator<=(const StatsItem& __x, const StatsItem& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const StatsItem& __x, const StatsItem& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map<::std::string, int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> tag_vertices_ref() const& {
    return {this->tag_vertices, __isset.tag_vertices};
  }

  template <typename..., typename T = std::unordered_map<::std::string, int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> tag_vertices_ref() const&& {
    return {std::move(this->tag_vertices), __isset.tag_vertices};
  }

  template <typename..., typename T = std::unordered_map<::std::string, int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> tag_vertices_ref() & {
    return {this->tag_vertices, __isset.tag_vertices};
  }

  template <typename..., typename T = std::unordered_map<::std::string, int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> tag_vertices_ref() && {
    return {std::move(this->tag_vertices), __isset.tag_vertices};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map<::std::string, int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> edges_ref() const& {
    return {this->edges, __isset.edges};
  }

  template <typename..., typename T = std::unordered_map<::std::string, int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> edges_ref() const&& {
    return {std::move(this->edges), __isset.edges};
  }

  template <typename..., typename T = std::unordered_map<::std::string, int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> edges_ref() & {
    return {this->edges, __isset.edges};
  }

  template <typename..., typename T = std::unordered_map<::std::string, int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> edges_ref() && {
    return {std::move(this->edges), __isset.edges};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_vertices_ref() const& {
    return {this->space_vertices, __isset.space_vertices};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_vertices_ref() const&& {
    return {std::move(this->space_vertices), __isset.space_vertices};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_vertices_ref() & {
    return {this->space_vertices, __isset.space_vertices};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_vertices_ref() && {
    return {std::move(this->space_vertices), __isset.space_vertices};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_edges_ref() const& {
    return {this->space_edges, __isset.space_edges};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_edges_ref() const&& {
    return {std::move(this->space_edges), __isset.space_edges};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_edges_ref() & {
    return {this->space_edges, __isset.space_edges};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_edges_ref() && {
    return {std::move(this->space_edges), __isset.space_edges};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> positive_part_correlativity_ref() const& {
    return {this->positive_part_correlativity, __isset.positive_part_correlativity};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> positive_part_correlativity_ref() const&& {
    return {std::move(this->positive_part_correlativity), __isset.positive_part_correlativity};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> positive_part_correlativity_ref() & {
    return {this->positive_part_correlativity, __isset.positive_part_correlativity};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> positive_part_correlativity_ref() && {
    return {std::move(this->positive_part_correlativity), __isset.positive_part_correlativity};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> negative_part_correlativity_ref() const& {
    return {this->negative_part_correlativity, __isset.negative_part_correlativity};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> negative_part_correlativity_ref() const&& {
    return {std::move(this->negative_part_correlativity), __isset.negative_part_correlativity};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> negative_part_correlativity_ref() & {
    return {this->negative_part_correlativity, __isset.negative_part_correlativity};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> negative_part_correlativity_ref() && {
    return {std::move(this->negative_part_correlativity), __isset.negative_part_correlativity};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::JobStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> status_ref() const& {
    return {this->status, __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::JobStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> status_ref() const&& {
    return {std::move(this->status), __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::JobStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> status_ref() & {
    return {this->status, __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::JobStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> status_ref() && {
    return {std::move(this->status), __isset.status};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const std::unordered_map<::std::string, int64_t>& get_tag_vertices() const&;
  std::unordered_map<::std::string, int64_t> get_tag_vertices() &&;

  template <typename T_StatsItem_tag_vertices_struct_setter = std::unordered_map<::std::string, int64_t>>
  std::unordered_map<::std::string, int64_t>& set_tag_vertices(T_StatsItem_tag_vertices_struct_setter&& tag_vertices_) {
    tag_vertices = std::forward<T_StatsItem_tag_vertices_struct_setter>(tag_vertices_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.tag_vertices = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return tag_vertices;
  }
  const std::unordered_map<::std::string, int64_t>& get_edges() const&;
  std::unordered_map<::std::string, int64_t> get_edges() &&;

  template <typename T_StatsItem_edges_struct_setter = std::unordered_map<::std::string, int64_t>>
  std::unordered_map<::std::string, int64_t>& set_edges(T_StatsItem_edges_struct_setter&& edges_) {
    edges = std::forward<T_StatsItem_edges_struct_setter>(edges_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.edges = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return edges;
  }

  int64_t get_space_vertices() const {
    return space_vertices;
  }

  int64_t& set_space_vertices(int64_t space_vertices_) {
    space_vertices = space_vertices_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_vertices = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_vertices;
  }

  int64_t get_space_edges() const {
    return space_edges;
  }

  int64_t& set_space_edges(int64_t space_edges_) {
    space_edges = space_edges_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_edges = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_edges;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>& get_positive_part_correlativity() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>> get_positive_part_correlativity() &&;

  template <typename T_StatsItem_positive_part_correlativity_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>>
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>& set_positive_part_correlativity(T_StatsItem_positive_part_correlativity_struct_setter&& positive_part_correlativity_) {
    positive_part_correlativity = std::forward<T_StatsItem_positive_part_correlativity_struct_setter>(positive_part_correlativity_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.positive_part_correlativity = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return positive_part_correlativity;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>& get_negative_part_correlativity() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>> get_negative_part_correlativity() &&;

  template <typename T_StatsItem_negative_part_correlativity_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>>
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>& set_negative_part_correlativity(T_StatsItem_negative_part_correlativity_struct_setter&& negative_part_correlativity_) {
    negative_part_correlativity = std::forward<T_StatsItem_negative_part_correlativity_struct_setter>(negative_part_correlativity_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.negative_part_correlativity = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return negative_part_correlativity;
  }

   ::nebula::meta::cpp2::JobStatus get_status() const {
    return status;
  }

   ::nebula::meta::cpp2::JobStatus& set_status( ::nebula::meta::cpp2::JobStatus status_) {
    status = status_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.status = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return status;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< StatsItem >;
  friend void swap(StatsItem& a, StatsItem& b);
};

template <class Protocol_>
uint32_t StatsItem::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class CreateSpaceReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CreateSpaceReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  CreateSpaceReq() :
      if_not_exists(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CreateSpaceReq(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::SpaceDesc properties__arg, bool if_not_exists__arg);

  CreateSpaceReq(CreateSpaceReq&&) = default;

  CreateSpaceReq(const CreateSpaceReq&) = default;


  CreateSpaceReq& operator=(CreateSpaceReq&&) = default;

  CreateSpaceReq& operator=(const CreateSpaceReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::meta::cpp2::SpaceDesc properties;
 private:
  bool if_not_exists;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool properties;
    bool if_not_exists;
  } __isset = {};
  bool operator==(const CreateSpaceReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CreateSpaceReq& __x, const CreateSpaceReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CreateSpaceReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const CreateSpaceReq& __x, const CreateSpaceReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CreateSpaceReq& __x, const CreateSpaceReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CreateSpaceReq& __x, const CreateSpaceReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::SpaceDesc>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> properties_ref() const& {
    return {this->properties, __isset.properties};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SpaceDesc>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> properties_ref() const&& {
    return {std::move(this->properties), __isset.properties};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SpaceDesc>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> properties_ref() & {
    return {this->properties, __isset.properties};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SpaceDesc>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> properties_ref() && {
    return {std::move(this->properties), __isset.properties};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> if_not_exists_ref() const& {
    return {this->if_not_exists, __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> if_not_exists_ref() const&& {
    return {std::move(this->if_not_exists), __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> if_not_exists_ref() & {
    return {this->if_not_exists, __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> if_not_exists_ref() && {
    return {std::move(this->if_not_exists), __isset.if_not_exists};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::meta::cpp2::SpaceDesc& get_properties() const&;
   ::nebula::meta::cpp2::SpaceDesc get_properties() &&;

  template <typename T_CreateSpaceReq_properties_struct_setter =  ::nebula::meta::cpp2::SpaceDesc>
   ::nebula::meta::cpp2::SpaceDesc& set_properties(T_CreateSpaceReq_properties_struct_setter&& properties_) {
    properties = std::forward<T_CreateSpaceReq_properties_struct_setter>(properties_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.properties = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return properties;
  }

  bool get_if_not_exists() const {
    return if_not_exists;
  }

  bool& set_if_not_exists(bool if_not_exists_) {
    if_not_exists = if_not_exists_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.if_not_exists = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return if_not_exists;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CreateSpaceReq >;
  friend void swap(CreateSpaceReq& a, CreateSpaceReq& b);
};

template <class Protocol_>
uint32_t CreateSpaceReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class CreateSpaceAsReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CreateSpaceAsReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  CreateSpaceAsReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CreateSpaceAsReq(apache::thrift::FragileConstructor, ::std::string old_space_name__arg, ::std::string new_space_name__arg);

  CreateSpaceAsReq(CreateSpaceAsReq&&) = default;

  CreateSpaceAsReq(const CreateSpaceAsReq&) = default;


  CreateSpaceAsReq& operator=(CreateSpaceAsReq&&) = default;

  CreateSpaceAsReq& operator=(const CreateSpaceAsReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string old_space_name;
 private:
  ::std::string new_space_name;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool old_space_name;
    bool new_space_name;
  } __isset = {};
  bool operator==(const CreateSpaceAsReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CreateSpaceAsReq& __x, const CreateSpaceAsReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CreateSpaceAsReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const CreateSpaceAsReq& __x, const CreateSpaceAsReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CreateSpaceAsReq& __x, const CreateSpaceAsReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CreateSpaceAsReq& __x, const CreateSpaceAsReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> old_space_name_ref() const& {
    return {this->old_space_name, __isset.old_space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> old_space_name_ref() const&& {
    return {std::move(this->old_space_name), __isset.old_space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> old_space_name_ref() & {
    return {this->old_space_name, __isset.old_space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> old_space_name_ref() && {
    return {std::move(this->old_space_name), __isset.old_space_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> new_space_name_ref() const& {
    return {this->new_space_name, __isset.new_space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> new_space_name_ref() const&& {
    return {std::move(this->new_space_name), __isset.new_space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> new_space_name_ref() & {
    return {this->new_space_name, __isset.new_space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> new_space_name_ref() && {
    return {std::move(this->new_space_name), __isset.new_space_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_old_space_name() const& {
    return old_space_name;
  }

  ::std::string get_old_space_name() && {
    return std::move(old_space_name);
  }

  template <typename T_CreateSpaceAsReq_old_space_name_struct_setter = ::std::string>
  ::std::string& set_old_space_name(T_CreateSpaceAsReq_old_space_name_struct_setter&& old_space_name_) {
    old_space_name = std::forward<T_CreateSpaceAsReq_old_space_name_struct_setter>(old_space_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.old_space_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return old_space_name;
  }

  const ::std::string& get_new_space_name() const& {
    return new_space_name;
  }

  ::std::string get_new_space_name() && {
    return std::move(new_space_name);
  }

  template <typename T_CreateSpaceAsReq_new_space_name_struct_setter = ::std::string>
  ::std::string& set_new_space_name(T_CreateSpaceAsReq_new_space_name_struct_setter&& new_space_name_) {
    new_space_name = std::forward<T_CreateSpaceAsReq_new_space_name_struct_setter>(new_space_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.new_space_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return new_space_name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CreateSpaceAsReq >;
  friend void swap(CreateSpaceAsReq& a, CreateSpaceAsReq& b);
};

template <class Protocol_>
uint32_t CreateSpaceAsReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class DropSpaceReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = DropSpaceReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  DropSpaceReq() :
      if_exists(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  DropSpaceReq(apache::thrift::FragileConstructor, ::std::string space_name__arg, bool if_exists__arg);

  DropSpaceReq(DropSpaceReq&&) = default;

  DropSpaceReq(const DropSpaceReq&) = default;


  DropSpaceReq& operator=(DropSpaceReq&&) = default;

  DropSpaceReq& operator=(const DropSpaceReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string space_name;
 private:
  bool if_exists;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_name;
    bool if_exists;
  } __isset = {};
  bool operator==(const DropSpaceReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const DropSpaceReq& __x, const DropSpaceReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const DropSpaceReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const DropSpaceReq& __x, const DropSpaceReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const DropSpaceReq& __x, const DropSpaceReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const DropSpaceReq& __x, const DropSpaceReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_name_ref() const& {
    return {this->space_name, __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_name_ref() const&& {
    return {std::move(this->space_name), __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_name_ref() & {
    return {this->space_name, __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_name_ref() && {
    return {std::move(this->space_name), __isset.space_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> if_exists_ref() const& {
    return {this->if_exists, __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> if_exists_ref() const&& {
    return {std::move(this->if_exists), __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> if_exists_ref() & {
    return {this->if_exists, __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> if_exists_ref() && {
    return {std::move(this->if_exists), __isset.if_exists};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_space_name() const& {
    return space_name;
  }

  ::std::string get_space_name() && {
    return std::move(space_name);
  }

  template <typename T_DropSpaceReq_space_name_struct_setter = ::std::string>
  ::std::string& set_space_name(T_DropSpaceReq_space_name_struct_setter&& space_name_) {
    space_name = std::forward<T_DropSpaceReq_space_name_struct_setter>(space_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_name;
  }

  bool get_if_exists() const {
    return if_exists;
  }

  bool& set_if_exists(bool if_exists_) {
    if_exists = if_exists_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.if_exists = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return if_exists;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< DropSpaceReq >;
  friend void swap(DropSpaceReq& a, DropSpaceReq& b);
};

template <class Protocol_>
uint32_t DropSpaceReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ClearSpaceReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ClearSpaceReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ClearSpaceReq() :
      if_exists(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ClearSpaceReq(apache::thrift::FragileConstructor, ::std::string space_name__arg, bool if_exists__arg);

  ClearSpaceReq(ClearSpaceReq&&) = default;

  ClearSpaceReq(const ClearSpaceReq&) = default;


  ClearSpaceReq& operator=(ClearSpaceReq&&) = default;

  ClearSpaceReq& operator=(const ClearSpaceReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string space_name;
 private:
  bool if_exists;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_name;
    bool if_exists;
  } __isset = {};
  bool operator==(const ClearSpaceReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ClearSpaceReq& __x, const ClearSpaceReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ClearSpaceReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ClearSpaceReq& __x, const ClearSpaceReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ClearSpaceReq& __x, const ClearSpaceReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ClearSpaceReq& __x, const ClearSpaceReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_name_ref() const& {
    return {this->space_name, __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_name_ref() const&& {
    return {std::move(this->space_name), __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_name_ref() & {
    return {this->space_name, __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_name_ref() && {
    return {std::move(this->space_name), __isset.space_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> if_exists_ref() const& {
    return {this->if_exists, __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> if_exists_ref() const&& {
    return {std::move(this->if_exists), __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> if_exists_ref() & {
    return {this->if_exists, __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> if_exists_ref() && {
    return {std::move(this->if_exists), __isset.if_exists};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_space_name() const& {
    return space_name;
  }

  ::std::string get_space_name() && {
    return std::move(space_name);
  }

  template <typename T_ClearSpaceReq_space_name_struct_setter = ::std::string>
  ::std::string& set_space_name(T_ClearSpaceReq_space_name_struct_setter&& space_name_) {
    space_name = std::forward<T_ClearSpaceReq_space_name_struct_setter>(space_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_name;
  }

  bool get_if_exists() const {
    return if_exists;
  }

  bool& set_if_exists(bool if_exists_) {
    if_exists = if_exists_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.if_exists = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return if_exists;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ClearSpaceReq >;
  friend void swap(ClearSpaceReq& a, ClearSpaceReq& b);
};

template <class Protocol_>
uint32_t ClearSpaceReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListSpacesReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListSpacesReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListSpacesReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListSpacesReq(apache::thrift::FragileConstructor);

  ListSpacesReq(ListSpacesReq&&) = default;

  ListSpacesReq(const ListSpacesReq&) = default;


  ListSpacesReq& operator=(ListSpacesReq&&) = default;

  ListSpacesReq& operator=(const ListSpacesReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
  bool operator==(const ListSpacesReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListSpacesReq& __x, const ListSpacesReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListSpacesReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListSpacesReq& __x, const ListSpacesReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListSpacesReq& __x, const ListSpacesReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListSpacesReq& __x, const ListSpacesReq& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListSpacesReq >;
  friend void swap(ListSpacesReq& a, ListSpacesReq& b);
};

template <class Protocol_>
uint32_t ListSpacesReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListSpacesResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListSpacesResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListSpacesResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListSpacesResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::IdName> spaces__arg);

  ListSpacesResp(ListSpacesResp&&) = default;

  ListSpacesResp(const ListSpacesResp&) = default;


  ListSpacesResp& operator=(ListSpacesResp&&) = default;

  ListSpacesResp& operator=(const ListSpacesResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::vector< ::nebula::meta::cpp2::IdName> spaces;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool spaces;
  } __isset = {};
  bool operator==(const ListSpacesResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListSpacesResp& __x, const ListSpacesResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListSpacesResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListSpacesResp& __x, const ListSpacesResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListSpacesResp& __x, const ListSpacesResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListSpacesResp& __x, const ListSpacesResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IdName>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> spaces_ref() const& {
    return {this->spaces, __isset.spaces};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IdName>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> spaces_ref() const&& {
    return {std::move(this->spaces), __isset.spaces};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IdName>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> spaces_ref() & {
    return {this->spaces, __isset.spaces};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IdName>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> spaces_ref() && {
    return {std::move(this->spaces), __isset.spaces};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_ListSpacesResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_ListSpacesResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_ListSpacesResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const ::std::vector< ::nebula::meta::cpp2::IdName>& get_spaces() const&;
  ::std::vector< ::nebula::meta::cpp2::IdName> get_spaces() &&;

  template <typename T_ListSpacesResp_spaces_struct_setter = ::std::vector< ::nebula::meta::cpp2::IdName>>
  ::std::vector< ::nebula::meta::cpp2::IdName>& set_spaces(T_ListSpacesResp_spaces_struct_setter&& spaces_) {
    spaces = std::forward<T_ListSpacesResp_spaces_struct_setter>(spaces_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.spaces = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return spaces;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListSpacesResp >;
  friend void swap(ListSpacesResp& a, ListSpacesResp& b);
};

template <class Protocol_>
uint32_t ListSpacesResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetSpaceReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetSpaceReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetSpaceReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetSpaceReq(apache::thrift::FragileConstructor, ::std::string space_name__arg);

  GetSpaceReq(GetSpaceReq&&) = default;

  GetSpaceReq(const GetSpaceReq&) = default;


  GetSpaceReq& operator=(GetSpaceReq&&) = default;

  GetSpaceReq& operator=(const GetSpaceReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string space_name;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_name;
  } __isset = {};
  bool operator==(const GetSpaceReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetSpaceReq& __x, const GetSpaceReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetSpaceReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetSpaceReq& __x, const GetSpaceReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetSpaceReq& __x, const GetSpaceReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetSpaceReq& __x, const GetSpaceReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_name_ref() const& {
    return {this->space_name, __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_name_ref() const&& {
    return {std::move(this->space_name), __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_name_ref() & {
    return {this->space_name, __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_name_ref() && {
    return {std::move(this->space_name), __isset.space_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_space_name() const& {
    return space_name;
  }

  ::std::string get_space_name() && {
    return std::move(space_name);
  }

  template <typename T_GetSpaceReq_space_name_struct_setter = ::std::string>
  ::std::string& set_space_name(T_GetSpaceReq_space_name_struct_setter&& space_name_) {
    space_name = std::forward<T_GetSpaceReq_space_name_struct_setter>(space_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetSpaceReq >;
  friend void swap(GetSpaceReq& a, GetSpaceReq& b);
};

template <class Protocol_>
uint32_t GetSpaceReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetSpaceResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetSpaceResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetSpaceResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetSpaceResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::SpaceItem item__arg);

  GetSpaceResp(GetSpaceResp&&) = default;

  GetSpaceResp(const GetSpaceResp&) = default;


  GetSpaceResp& operator=(GetSpaceResp&&) = default;

  GetSpaceResp& operator=(const GetSpaceResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
   ::nebula::meta::cpp2::SpaceItem item;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool item;
  } __isset = {};
  bool operator==(const GetSpaceResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetSpaceResp& __x, const GetSpaceResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetSpaceResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetSpaceResp& __x, const GetSpaceResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetSpaceResp& __x, const GetSpaceResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetSpaceResp& __x, const GetSpaceResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::SpaceItem>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> item_ref() const& {
    return {this->item, __isset.item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SpaceItem>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> item_ref() const&& {
    return {std::move(this->item), __isset.item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SpaceItem>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> item_ref() & {
    return {this->item, __isset.item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SpaceItem>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> item_ref() && {
    return {std::move(this->item), __isset.item};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_GetSpaceResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_GetSpaceResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_GetSpaceResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const  ::nebula::meta::cpp2::SpaceItem& get_item() const&;
   ::nebula::meta::cpp2::SpaceItem get_item() &&;

  template <typename T_GetSpaceResp_item_struct_setter =  ::nebula::meta::cpp2::SpaceItem>
   ::nebula::meta::cpp2::SpaceItem& set_item(T_GetSpaceResp_item_struct_setter&& item_) {
    item = std::forward<T_GetSpaceResp_item_struct_setter>(item_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.item = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return item;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetSpaceResp >;
  friend void swap(GetSpaceResp& a, GetSpaceResp& b);
};

template <class Protocol_>
uint32_t GetSpaceResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class CreateTagReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CreateTagReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  CreateTagReq() :
      space_id(0),
      if_not_exists(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CreateTagReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string tag_name__arg,  ::nebula::meta::cpp2::Schema schema__arg, bool if_not_exists__arg);

  CreateTagReq(CreateTagReq&&) = default;

  CreateTagReq(const CreateTagReq&) = default;


  CreateTagReq& operator=(CreateTagReq&&) = default;

  CreateTagReq& operator=(const CreateTagReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::string tag_name;
 private:
   ::nebula::meta::cpp2::Schema schema;
 private:
  bool if_not_exists;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool tag_name;
    bool schema;
    bool if_not_exists;
  } __isset = {};
  bool operator==(const CreateTagReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CreateTagReq& __x, const CreateTagReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CreateTagReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const CreateTagReq& __x, const CreateTagReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CreateTagReq& __x, const CreateTagReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CreateTagReq& __x, const CreateTagReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> tag_name_ref() const& {
    return {this->tag_name, __isset.tag_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> tag_name_ref() const&& {
    return {std::move(this->tag_name), __isset.tag_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> tag_name_ref() & {
    return {this->tag_name, __isset.tag_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> tag_name_ref() && {
    return {std::move(this->tag_name), __isset.tag_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> schema_ref() const& {
    return {this->schema, __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> schema_ref() const&& {
    return {std::move(this->schema), __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> schema_ref() & {
    return {this->schema, __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> schema_ref() && {
    return {std::move(this->schema), __isset.schema};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> if_not_exists_ref() const& {
    return {this->if_not_exists, __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> if_not_exists_ref() const&& {
    return {std::move(this->if_not_exists), __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> if_not_exists_ref() & {
    return {this->if_not_exists, __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> if_not_exists_ref() && {
    return {std::move(this->if_not_exists), __isset.if_not_exists};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  const ::std::string& get_tag_name() const& {
    return tag_name;
  }

  ::std::string get_tag_name() && {
    return std::move(tag_name);
  }

  template <typename T_CreateTagReq_tag_name_struct_setter = ::std::string>
  ::std::string& set_tag_name(T_CreateTagReq_tag_name_struct_setter&& tag_name_) {
    tag_name = std::forward<T_CreateTagReq_tag_name_struct_setter>(tag_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.tag_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return tag_name;
  }
  const  ::nebula::meta::cpp2::Schema& get_schema() const&;
   ::nebula::meta::cpp2::Schema get_schema() &&;

  template <typename T_CreateTagReq_schema_struct_setter =  ::nebula::meta::cpp2::Schema>
   ::nebula::meta::cpp2::Schema& set_schema(T_CreateTagReq_schema_struct_setter&& schema_) {
    schema = std::forward<T_CreateTagReq_schema_struct_setter>(schema_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.schema = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return schema;
  }

  bool get_if_not_exists() const {
    return if_not_exists;
  }

  bool& set_if_not_exists(bool if_not_exists_) {
    if_not_exists = if_not_exists_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.if_not_exists = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return if_not_exists;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CreateTagReq >;
  friend void swap(CreateTagReq& a, CreateTagReq& b);
};

template <class Protocol_>
uint32_t CreateTagReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class AlterTagReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AlterTagReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  AlterTagReq() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AlterTagReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string tag_name__arg, ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem> tag_items__arg,  ::nebula::meta::cpp2::SchemaProp schema_prop__arg);

  AlterTagReq(AlterTagReq&&) = default;

  AlterTagReq(const AlterTagReq&) = default;


  AlterTagReq& operator=(AlterTagReq&&) = default;

  AlterTagReq& operator=(const AlterTagReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::string tag_name;
 private:
  ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem> tag_items;
 private:
   ::nebula::meta::cpp2::SchemaProp schema_prop;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool tag_name;
    bool tag_items;
    bool schema_prop;
  } __isset = {};
  bool operator==(const AlterTagReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AlterTagReq& __x, const AlterTagReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AlterTagReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const AlterTagReq& __x, const AlterTagReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AlterTagReq& __x, const AlterTagReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AlterTagReq& __x, const AlterTagReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> tag_name_ref() const& {
    return {this->tag_name, __isset.tag_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> tag_name_ref() const&& {
    return {std::move(this->tag_name), __isset.tag_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> tag_name_ref() & {
    return {this->tag_name, __isset.tag_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> tag_name_ref() && {
    return {std::move(this->tag_name), __isset.tag_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> tag_items_ref() const& {
    return {this->tag_items, __isset.tag_items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> tag_items_ref() const&& {
    return {std::move(this->tag_items), __isset.tag_items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> tag_items_ref() & {
    return {this->tag_items, __isset.tag_items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> tag_items_ref() && {
    return {std::move(this->tag_items), __isset.tag_items};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaProp>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> schema_prop_ref() const& {
    return {this->schema_prop, __isset.schema_prop};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaProp>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> schema_prop_ref() const&& {
    return {std::move(this->schema_prop), __isset.schema_prop};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaProp>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> schema_prop_ref() & {
    return {this->schema_prop, __isset.schema_prop};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaProp>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> schema_prop_ref() && {
    return {std::move(this->schema_prop), __isset.schema_prop};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  const ::std::string& get_tag_name() const& {
    return tag_name;
  }

  ::std::string get_tag_name() && {
    return std::move(tag_name);
  }

  template <typename T_AlterTagReq_tag_name_struct_setter = ::std::string>
  ::std::string& set_tag_name(T_AlterTagReq_tag_name_struct_setter&& tag_name_) {
    tag_name = std::forward<T_AlterTagReq_tag_name_struct_setter>(tag_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.tag_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return tag_name;
  }
  const ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>& get_tag_items() const&;
  ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem> get_tag_items() &&;

  template <typename T_AlterTagReq_tag_items_struct_setter = ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>>
  ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>& set_tag_items(T_AlterTagReq_tag_items_struct_setter&& tag_items_) {
    tag_items = std::forward<T_AlterTagReq_tag_items_struct_setter>(tag_items_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.tag_items = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return tag_items;
  }
  const  ::nebula::meta::cpp2::SchemaProp& get_schema_prop() const&;
   ::nebula::meta::cpp2::SchemaProp get_schema_prop() &&;

  template <typename T_AlterTagReq_schema_prop_struct_setter =  ::nebula::meta::cpp2::SchemaProp>
   ::nebula::meta::cpp2::SchemaProp& set_schema_prop(T_AlterTagReq_schema_prop_struct_setter&& schema_prop_) {
    schema_prop = std::forward<T_AlterTagReq_schema_prop_struct_setter>(schema_prop_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.schema_prop = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return schema_prop;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AlterTagReq >;
  friend void swap(AlterTagReq& a, AlterTagReq& b);
};

template <class Protocol_>
uint32_t AlterTagReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class DropTagReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = DropTagReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  DropTagReq() :
      space_id(0),
      if_exists(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  DropTagReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string tag_name__arg, bool if_exists__arg);

  DropTagReq(DropTagReq&&) = default;

  DropTagReq(const DropTagReq&) = default;


  DropTagReq& operator=(DropTagReq&&) = default;

  DropTagReq& operator=(const DropTagReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::string tag_name;
 private:
  bool if_exists;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool tag_name;
    bool if_exists;
  } __isset = {};
  bool operator==(const DropTagReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const DropTagReq& __x, const DropTagReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const DropTagReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const DropTagReq& __x, const DropTagReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const DropTagReq& __x, const DropTagReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const DropTagReq& __x, const DropTagReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> tag_name_ref() const& {
    return {this->tag_name, __isset.tag_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> tag_name_ref() const&& {
    return {std::move(this->tag_name), __isset.tag_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> tag_name_ref() & {
    return {this->tag_name, __isset.tag_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> tag_name_ref() && {
    return {std::move(this->tag_name), __isset.tag_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> if_exists_ref() const& {
    return {this->if_exists, __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> if_exists_ref() const&& {
    return {std::move(this->if_exists), __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> if_exists_ref() & {
    return {this->if_exists, __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> if_exists_ref() && {
    return {std::move(this->if_exists), __isset.if_exists};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  const ::std::string& get_tag_name() const& {
    return tag_name;
  }

  ::std::string get_tag_name() && {
    return std::move(tag_name);
  }

  template <typename T_DropTagReq_tag_name_struct_setter = ::std::string>
  ::std::string& set_tag_name(T_DropTagReq_tag_name_struct_setter&& tag_name_) {
    tag_name = std::forward<T_DropTagReq_tag_name_struct_setter>(tag_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.tag_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return tag_name;
  }

  bool get_if_exists() const {
    return if_exists;
  }

  bool& set_if_exists(bool if_exists_) {
    if_exists = if_exists_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.if_exists = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return if_exists;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< DropTagReq >;
  friend void swap(DropTagReq& a, DropTagReq& b);
};

template <class Protocol_>
uint32_t DropTagReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListTagsReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListTagsReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListTagsReq() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListTagsReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg);

  ListTagsReq(ListTagsReq&&) = default;

  ListTagsReq(const ListTagsReq&) = default;


  ListTagsReq& operator=(ListTagsReq&&) = default;

  ListTagsReq& operator=(const ListTagsReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
  } __isset = {};
  bool operator==(const ListTagsReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListTagsReq& __x, const ListTagsReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListTagsReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListTagsReq& __x, const ListTagsReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListTagsReq& __x, const ListTagsReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListTagsReq& __x, const ListTagsReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListTagsReq >;
  friend void swap(ListTagsReq& a, ListTagsReq& b);
};

template <class Protocol_>
uint32_t ListTagsReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListTagsResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListTagsResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListTagsResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListTagsResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::TagItem> tags__arg);

  ListTagsResp(ListTagsResp&&) = default;

  ListTagsResp(const ListTagsResp&) = default;


  ListTagsResp& operator=(ListTagsResp&&) = default;

  ListTagsResp& operator=(const ListTagsResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::vector< ::nebula::meta::cpp2::TagItem> tags;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool tags;
  } __isset = {};
  bool operator==(const ListTagsResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListTagsResp& __x, const ListTagsResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListTagsResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListTagsResp& __x, const ListTagsResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListTagsResp& __x, const ListTagsResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListTagsResp& __x, const ListTagsResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::TagItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> tags_ref() const& {
    return {this->tags, __isset.tags};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::TagItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> tags_ref() const&& {
    return {std::move(this->tags), __isset.tags};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::TagItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> tags_ref() & {
    return {this->tags, __isset.tags};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::TagItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> tags_ref() && {
    return {std::move(this->tags), __isset.tags};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_ListTagsResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_ListTagsResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_ListTagsResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const ::std::vector< ::nebula::meta::cpp2::TagItem>& get_tags() const&;
  ::std::vector< ::nebula::meta::cpp2::TagItem> get_tags() &&;

  template <typename T_ListTagsResp_tags_struct_setter = ::std::vector< ::nebula::meta::cpp2::TagItem>>
  ::std::vector< ::nebula::meta::cpp2::TagItem>& set_tags(T_ListTagsResp_tags_struct_setter&& tags_) {
    tags = std::forward<T_ListTagsResp_tags_struct_setter>(tags_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.tags = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return tags;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListTagsResp >;
  friend void swap(ListTagsResp& a, ListTagsResp& b);
};

template <class Protocol_>
uint32_t ListTagsResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetTagReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetTagReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetTagReq() :
      space_id(0),
      version(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetTagReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string tag_name__arg,  ::nebula::meta::cpp2::SchemaVer version__arg);

  GetTagReq(GetTagReq&&) = default;

  GetTagReq(const GetTagReq&) = default;


  GetTagReq& operator=(GetTagReq&&) = default;

  GetTagReq& operator=(const GetTagReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::string tag_name;
 private:
   ::nebula::meta::cpp2::SchemaVer version;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool tag_name;
    bool version;
  } __isset = {};
  bool operator==(const GetTagReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetTagReq& __x, const GetTagReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetTagReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetTagReq& __x, const GetTagReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetTagReq& __x, const GetTagReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetTagReq& __x, const GetTagReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> tag_name_ref() const& {
    return {this->tag_name, __isset.tag_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> tag_name_ref() const&& {
    return {std::move(this->tag_name), __isset.tag_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> tag_name_ref() & {
    return {this->tag_name, __isset.tag_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> tag_name_ref() && {
    return {std::move(this->tag_name), __isset.tag_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaVer>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> version_ref() const& {
    return {this->version, __isset.version};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaVer>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> version_ref() const&& {
    return {std::move(this->version), __isset.version};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaVer>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> version_ref() & {
    return {this->version, __isset.version};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaVer>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> version_ref() && {
    return {std::move(this->version), __isset.version};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  const ::std::string& get_tag_name() const& {
    return tag_name;
  }

  ::std::string get_tag_name() && {
    return std::move(tag_name);
  }

  template <typename T_GetTagReq_tag_name_struct_setter = ::std::string>
  ::std::string& set_tag_name(T_GetTagReq_tag_name_struct_setter&& tag_name_) {
    tag_name = std::forward<T_GetTagReq_tag_name_struct_setter>(tag_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.tag_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return tag_name;
  }

   ::nebula::meta::cpp2::SchemaVer get_version() const {
    return version;
  }

   ::nebula::meta::cpp2::SchemaVer& set_version( ::nebula::meta::cpp2::SchemaVer version_) {
    version = version_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.version = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return version;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetTagReq >;
  friend void swap(GetTagReq& a, GetTagReq& b);
};

template <class Protocol_>
uint32_t GetTagReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetTagResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetTagResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetTagResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetTagResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::Schema schema__arg);

  GetTagResp(GetTagResp&&) = default;

  GetTagResp(const GetTagResp&) = default;


  GetTagResp& operator=(GetTagResp&&) = default;

  GetTagResp& operator=(const GetTagResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
   ::nebula::meta::cpp2::Schema schema;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool schema;
  } __isset = {};
  bool operator==(const GetTagResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetTagResp& __x, const GetTagResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetTagResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetTagResp& __x, const GetTagResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetTagResp& __x, const GetTagResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetTagResp& __x, const GetTagResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> schema_ref() const& {
    return {this->schema, __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> schema_ref() const&& {
    return {std::move(this->schema), __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> schema_ref() & {
    return {this->schema, __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> schema_ref() && {
    return {std::move(this->schema), __isset.schema};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_GetTagResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_GetTagResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_GetTagResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const  ::nebula::meta::cpp2::Schema& get_schema() const&;
   ::nebula::meta::cpp2::Schema get_schema() &&;

  template <typename T_GetTagResp_schema_struct_setter =  ::nebula::meta::cpp2::Schema>
   ::nebula::meta::cpp2::Schema& set_schema(T_GetTagResp_schema_struct_setter&& schema_) {
    schema = std::forward<T_GetTagResp_schema_struct_setter>(schema_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.schema = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return schema;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetTagResp >;
  friend void swap(GetTagResp& a, GetTagResp& b);
};

template <class Protocol_>
uint32_t GetTagResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class CreateEdgeReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CreateEdgeReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  CreateEdgeReq() :
      space_id(0),
      if_not_exists(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CreateEdgeReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string edge_name__arg,  ::nebula::meta::cpp2::Schema schema__arg, bool if_not_exists__arg);

  CreateEdgeReq(CreateEdgeReq&&) = default;

  CreateEdgeReq(const CreateEdgeReq&) = default;


  CreateEdgeReq& operator=(CreateEdgeReq&&) = default;

  CreateEdgeReq& operator=(const CreateEdgeReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::string edge_name;
 private:
   ::nebula::meta::cpp2::Schema schema;
 private:
  bool if_not_exists;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool edge_name;
    bool schema;
    bool if_not_exists;
  } __isset = {};
  bool operator==(const CreateEdgeReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CreateEdgeReq& __x, const CreateEdgeReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CreateEdgeReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const CreateEdgeReq& __x, const CreateEdgeReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CreateEdgeReq& __x, const CreateEdgeReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CreateEdgeReq& __x, const CreateEdgeReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> edge_name_ref() const& {
    return {this->edge_name, __isset.edge_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> edge_name_ref() const&& {
    return {std::move(this->edge_name), __isset.edge_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> edge_name_ref() & {
    return {this->edge_name, __isset.edge_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> edge_name_ref() && {
    return {std::move(this->edge_name), __isset.edge_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> schema_ref() const& {
    return {this->schema, __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> schema_ref() const&& {
    return {std::move(this->schema), __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> schema_ref() & {
    return {this->schema, __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> schema_ref() && {
    return {std::move(this->schema), __isset.schema};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> if_not_exists_ref() const& {
    return {this->if_not_exists, __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> if_not_exists_ref() const&& {
    return {std::move(this->if_not_exists), __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> if_not_exists_ref() & {
    return {this->if_not_exists, __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> if_not_exists_ref() && {
    return {std::move(this->if_not_exists), __isset.if_not_exists};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  const ::std::string& get_edge_name() const& {
    return edge_name;
  }

  ::std::string get_edge_name() && {
    return std::move(edge_name);
  }

  template <typename T_CreateEdgeReq_edge_name_struct_setter = ::std::string>
  ::std::string& set_edge_name(T_CreateEdgeReq_edge_name_struct_setter&& edge_name_) {
    edge_name = std::forward<T_CreateEdgeReq_edge_name_struct_setter>(edge_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.edge_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return edge_name;
  }
  const  ::nebula::meta::cpp2::Schema& get_schema() const&;
   ::nebula::meta::cpp2::Schema get_schema() &&;

  template <typename T_CreateEdgeReq_schema_struct_setter =  ::nebula::meta::cpp2::Schema>
   ::nebula::meta::cpp2::Schema& set_schema(T_CreateEdgeReq_schema_struct_setter&& schema_) {
    schema = std::forward<T_CreateEdgeReq_schema_struct_setter>(schema_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.schema = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return schema;
  }

  bool get_if_not_exists() const {
    return if_not_exists;
  }

  bool& set_if_not_exists(bool if_not_exists_) {
    if_not_exists = if_not_exists_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.if_not_exists = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return if_not_exists;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CreateEdgeReq >;
  friend void swap(CreateEdgeReq& a, CreateEdgeReq& b);
};

template <class Protocol_>
uint32_t CreateEdgeReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class AlterEdgeReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AlterEdgeReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  AlterEdgeReq() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AlterEdgeReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string edge_name__arg, ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem> edge_items__arg,  ::nebula::meta::cpp2::SchemaProp schema_prop__arg);

  AlterEdgeReq(AlterEdgeReq&&) = default;

  AlterEdgeReq(const AlterEdgeReq&) = default;


  AlterEdgeReq& operator=(AlterEdgeReq&&) = default;

  AlterEdgeReq& operator=(const AlterEdgeReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::string edge_name;
 private:
  ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem> edge_items;
 private:
   ::nebula::meta::cpp2::SchemaProp schema_prop;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool edge_name;
    bool edge_items;
    bool schema_prop;
  } __isset = {};
  bool operator==(const AlterEdgeReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AlterEdgeReq& __x, const AlterEdgeReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AlterEdgeReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const AlterEdgeReq& __x, const AlterEdgeReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AlterEdgeReq& __x, const AlterEdgeReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AlterEdgeReq& __x, const AlterEdgeReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> edge_name_ref() const& {
    return {this->edge_name, __isset.edge_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> edge_name_ref() const&& {
    return {std::move(this->edge_name), __isset.edge_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> edge_name_ref() & {
    return {this->edge_name, __isset.edge_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> edge_name_ref() && {
    return {std::move(this->edge_name), __isset.edge_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> edge_items_ref() const& {
    return {this->edge_items, __isset.edge_items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> edge_items_ref() const&& {
    return {std::move(this->edge_items), __isset.edge_items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> edge_items_ref() & {
    return {this->edge_items, __isset.edge_items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> edge_items_ref() && {
    return {std::move(this->edge_items), __isset.edge_items};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaProp>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> schema_prop_ref() const& {
    return {this->schema_prop, __isset.schema_prop};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaProp>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> schema_prop_ref() const&& {
    return {std::move(this->schema_prop), __isset.schema_prop};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaProp>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> schema_prop_ref() & {
    return {this->schema_prop, __isset.schema_prop};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaProp>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> schema_prop_ref() && {
    return {std::move(this->schema_prop), __isset.schema_prop};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  const ::std::string& get_edge_name() const& {
    return edge_name;
  }

  ::std::string get_edge_name() && {
    return std::move(edge_name);
  }

  template <typename T_AlterEdgeReq_edge_name_struct_setter = ::std::string>
  ::std::string& set_edge_name(T_AlterEdgeReq_edge_name_struct_setter&& edge_name_) {
    edge_name = std::forward<T_AlterEdgeReq_edge_name_struct_setter>(edge_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.edge_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return edge_name;
  }
  const ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>& get_edge_items() const&;
  ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem> get_edge_items() &&;

  template <typename T_AlterEdgeReq_edge_items_struct_setter = ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>>
  ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>& set_edge_items(T_AlterEdgeReq_edge_items_struct_setter&& edge_items_) {
    edge_items = std::forward<T_AlterEdgeReq_edge_items_struct_setter>(edge_items_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.edge_items = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return edge_items;
  }
  const  ::nebula::meta::cpp2::SchemaProp& get_schema_prop() const&;
   ::nebula::meta::cpp2::SchemaProp get_schema_prop() &&;

  template <typename T_AlterEdgeReq_schema_prop_struct_setter =  ::nebula::meta::cpp2::SchemaProp>
   ::nebula::meta::cpp2::SchemaProp& set_schema_prop(T_AlterEdgeReq_schema_prop_struct_setter&& schema_prop_) {
    schema_prop = std::forward<T_AlterEdgeReq_schema_prop_struct_setter>(schema_prop_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.schema_prop = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return schema_prop;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AlterEdgeReq >;
  friend void swap(AlterEdgeReq& a, AlterEdgeReq& b);
};

template <class Protocol_>
uint32_t AlterEdgeReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetEdgeReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetEdgeReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetEdgeReq() :
      space_id(0),
      version(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetEdgeReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string edge_name__arg,  ::nebula::meta::cpp2::SchemaVer version__arg);

  GetEdgeReq(GetEdgeReq&&) = default;

  GetEdgeReq(const GetEdgeReq&) = default;


  GetEdgeReq& operator=(GetEdgeReq&&) = default;

  GetEdgeReq& operator=(const GetEdgeReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::string edge_name;
 private:
   ::nebula::meta::cpp2::SchemaVer version;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool edge_name;
    bool version;
  } __isset = {};
  bool operator==(const GetEdgeReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetEdgeReq& __x, const GetEdgeReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetEdgeReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetEdgeReq& __x, const GetEdgeReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetEdgeReq& __x, const GetEdgeReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetEdgeReq& __x, const GetEdgeReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> edge_name_ref() const& {
    return {this->edge_name, __isset.edge_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> edge_name_ref() const&& {
    return {std::move(this->edge_name), __isset.edge_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> edge_name_ref() & {
    return {this->edge_name, __isset.edge_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> edge_name_ref() && {
    return {std::move(this->edge_name), __isset.edge_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaVer>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> version_ref() const& {
    return {this->version, __isset.version};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaVer>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> version_ref() const&& {
    return {std::move(this->version), __isset.version};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaVer>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> version_ref() & {
    return {this->version, __isset.version};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SchemaVer>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> version_ref() && {
    return {std::move(this->version), __isset.version};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  const ::std::string& get_edge_name() const& {
    return edge_name;
  }

  ::std::string get_edge_name() && {
    return std::move(edge_name);
  }

  template <typename T_GetEdgeReq_edge_name_struct_setter = ::std::string>
  ::std::string& set_edge_name(T_GetEdgeReq_edge_name_struct_setter&& edge_name_) {
    edge_name = std::forward<T_GetEdgeReq_edge_name_struct_setter>(edge_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.edge_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return edge_name;
  }

   ::nebula::meta::cpp2::SchemaVer get_version() const {
    return version;
  }

   ::nebula::meta::cpp2::SchemaVer& set_version( ::nebula::meta::cpp2::SchemaVer version_) {
    version = version_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.version = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return version;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetEdgeReq >;
  friend void swap(GetEdgeReq& a, GetEdgeReq& b);
};

template <class Protocol_>
uint32_t GetEdgeReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetEdgeResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetEdgeResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetEdgeResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetEdgeResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::Schema schema__arg);

  GetEdgeResp(GetEdgeResp&&) = default;

  GetEdgeResp(const GetEdgeResp&) = default;


  GetEdgeResp& operator=(GetEdgeResp&&) = default;

  GetEdgeResp& operator=(const GetEdgeResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
   ::nebula::meta::cpp2::Schema schema;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool schema;
  } __isset = {};
  bool operator==(const GetEdgeResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetEdgeResp& __x, const GetEdgeResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetEdgeResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetEdgeResp& __x, const GetEdgeResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetEdgeResp& __x, const GetEdgeResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetEdgeResp& __x, const GetEdgeResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> schema_ref() const& {
    return {this->schema, __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> schema_ref() const&& {
    return {std::move(this->schema), __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> schema_ref() & {
    return {this->schema, __isset.schema};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Schema>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> schema_ref() && {
    return {std::move(this->schema), __isset.schema};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_GetEdgeResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_GetEdgeResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_GetEdgeResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const  ::nebula::meta::cpp2::Schema& get_schema() const&;
   ::nebula::meta::cpp2::Schema get_schema() &&;

  template <typename T_GetEdgeResp_schema_struct_setter =  ::nebula::meta::cpp2::Schema>
   ::nebula::meta::cpp2::Schema& set_schema(T_GetEdgeResp_schema_struct_setter&& schema_) {
    schema = std::forward<T_GetEdgeResp_schema_struct_setter>(schema_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.schema = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return schema;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetEdgeResp >;
  friend void swap(GetEdgeResp& a, GetEdgeResp& b);
};

template <class Protocol_>
uint32_t GetEdgeResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class DropEdgeReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = DropEdgeReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  DropEdgeReq() :
      space_id(0),
      if_exists(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  DropEdgeReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string edge_name__arg, bool if_exists__arg);

  DropEdgeReq(DropEdgeReq&&) = default;

  DropEdgeReq(const DropEdgeReq&) = default;


  DropEdgeReq& operator=(DropEdgeReq&&) = default;

  DropEdgeReq& operator=(const DropEdgeReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::string edge_name;
 private:
  bool if_exists;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool edge_name;
    bool if_exists;
  } __isset = {};
  bool operator==(const DropEdgeReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const DropEdgeReq& __x, const DropEdgeReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const DropEdgeReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const DropEdgeReq& __x, const DropEdgeReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const DropEdgeReq& __x, const DropEdgeReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const DropEdgeReq& __x, const DropEdgeReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> edge_name_ref() const& {
    return {this->edge_name, __isset.edge_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> edge_name_ref() const&& {
    return {std::move(this->edge_name), __isset.edge_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> edge_name_ref() & {
    return {this->edge_name, __isset.edge_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> edge_name_ref() && {
    return {std::move(this->edge_name), __isset.edge_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> if_exists_ref() const& {
    return {this->if_exists, __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> if_exists_ref() const&& {
    return {std::move(this->if_exists), __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> if_exists_ref() & {
    return {this->if_exists, __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> if_exists_ref() && {
    return {std::move(this->if_exists), __isset.if_exists};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  const ::std::string& get_edge_name() const& {
    return edge_name;
  }

  ::std::string get_edge_name() && {
    return std::move(edge_name);
  }

  template <typename T_DropEdgeReq_edge_name_struct_setter = ::std::string>
  ::std::string& set_edge_name(T_DropEdgeReq_edge_name_struct_setter&& edge_name_) {
    edge_name = std::forward<T_DropEdgeReq_edge_name_struct_setter>(edge_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.edge_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return edge_name;
  }

  bool get_if_exists() const {
    return if_exists;
  }

  bool& set_if_exists(bool if_exists_) {
    if_exists = if_exists_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.if_exists = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return if_exists;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< DropEdgeReq >;
  friend void swap(DropEdgeReq& a, DropEdgeReq& b);
};

template <class Protocol_>
uint32_t DropEdgeReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListEdgesReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListEdgesReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListEdgesReq() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListEdgesReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg);

  ListEdgesReq(ListEdgesReq&&) = default;

  ListEdgesReq(const ListEdgesReq&) = default;


  ListEdgesReq& operator=(ListEdgesReq&&) = default;

  ListEdgesReq& operator=(const ListEdgesReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
  } __isset = {};
  bool operator==(const ListEdgesReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListEdgesReq& __x, const ListEdgesReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListEdgesReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListEdgesReq& __x, const ListEdgesReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListEdgesReq& __x, const ListEdgesReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListEdgesReq& __x, const ListEdgesReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListEdgesReq >;
  friend void swap(ListEdgesReq& a, ListEdgesReq& b);
};

template <class Protocol_>
uint32_t ListEdgesReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListEdgesResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListEdgesResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListEdgesResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListEdgesResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::EdgeItem> edges__arg);

  ListEdgesResp(ListEdgesResp&&) = default;

  ListEdgesResp(const ListEdgesResp&) = default;


  ListEdgesResp& operator=(ListEdgesResp&&) = default;

  ListEdgesResp& operator=(const ListEdgesResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::vector< ::nebula::meta::cpp2::EdgeItem> edges;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool edges;
  } __isset = {};
  bool operator==(const ListEdgesResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListEdgesResp& __x, const ListEdgesResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListEdgesResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListEdgesResp& __x, const ListEdgesResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListEdgesResp& __x, const ListEdgesResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListEdgesResp& __x, const ListEdgesResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::EdgeItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> edges_ref() const& {
    return {this->edges, __isset.edges};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::EdgeItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> edges_ref() const&& {
    return {std::move(this->edges), __isset.edges};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::EdgeItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> edges_ref() & {
    return {this->edges, __isset.edges};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::EdgeItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> edges_ref() && {
    return {std::move(this->edges), __isset.edges};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_ListEdgesResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_ListEdgesResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_ListEdgesResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const ::std::vector< ::nebula::meta::cpp2::EdgeItem>& get_edges() const&;
  ::std::vector< ::nebula::meta::cpp2::EdgeItem> get_edges() &&;

  template <typename T_ListEdgesResp_edges_struct_setter = ::std::vector< ::nebula::meta::cpp2::EdgeItem>>
  ::std::vector< ::nebula::meta::cpp2::EdgeItem>& set_edges(T_ListEdgesResp_edges_struct_setter&& edges_) {
    edges = std::forward<T_ListEdgesResp_edges_struct_setter>(edges_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.edges = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return edges;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListEdgesResp >;
  friend void swap(ListEdgesResp& a, ListEdgesResp& b);
};

template <class Protocol_>
uint32_t ListEdgesResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class AddHostsReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AddHostsReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  AddHostsReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AddHostsReq(apache::thrift::FragileConstructor, ::std::vector<nebula::HostAddr> hosts__arg);

  AddHostsReq(AddHostsReq&&) = default;

  AddHostsReq(const AddHostsReq&) = default;


  AddHostsReq& operator=(AddHostsReq&&) = default;

  AddHostsReq& operator=(const AddHostsReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector<nebula::HostAddr> hosts;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool hosts;
  } __isset = {};
  bool operator==(const AddHostsReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AddHostsReq& __x, const AddHostsReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AddHostsReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const AddHostsReq& __x, const AddHostsReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AddHostsReq& __x, const AddHostsReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AddHostsReq& __x, const AddHostsReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> hosts_ref() const& {
    return {this->hosts, __isset.hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> hosts_ref() const&& {
    return {std::move(this->hosts), __isset.hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> hosts_ref() & {
    return {this->hosts, __isset.hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> hosts_ref() && {
    return {std::move(this->hosts), __isset.hosts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector<nebula::HostAddr>& get_hosts() const&;
  ::std::vector<nebula::HostAddr> get_hosts() &&;

  template <typename T_AddHostsReq_hosts_struct_setter = ::std::vector<nebula::HostAddr>>
  ::std::vector<nebula::HostAddr>& set_hosts(T_AddHostsReq_hosts_struct_setter&& hosts_) {
    hosts = std::forward<T_AddHostsReq_hosts_struct_setter>(hosts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.hosts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return hosts;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AddHostsReq >;
  friend void swap(AddHostsReq& a, AddHostsReq& b);
};

template <class Protocol_>
uint32_t AddHostsReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class DropHostsReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = DropHostsReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  DropHostsReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  DropHostsReq(apache::thrift::FragileConstructor, ::std::vector<nebula::HostAddr> hosts__arg);

  DropHostsReq(DropHostsReq&&) = default;

  DropHostsReq(const DropHostsReq&) = default;


  DropHostsReq& operator=(DropHostsReq&&) = default;

  DropHostsReq& operator=(const DropHostsReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector<nebula::HostAddr> hosts;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool hosts;
  } __isset = {};
  bool operator==(const DropHostsReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const DropHostsReq& __x, const DropHostsReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const DropHostsReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const DropHostsReq& __x, const DropHostsReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const DropHostsReq& __x, const DropHostsReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const DropHostsReq& __x, const DropHostsReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> hosts_ref() const& {
    return {this->hosts, __isset.hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> hosts_ref() const&& {
    return {std::move(this->hosts), __isset.hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> hosts_ref() & {
    return {this->hosts, __isset.hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> hosts_ref() && {
    return {std::move(this->hosts), __isset.hosts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector<nebula::HostAddr>& get_hosts() const&;
  ::std::vector<nebula::HostAddr> get_hosts() &&;

  template <typename T_DropHostsReq_hosts_struct_setter = ::std::vector<nebula::HostAddr>>
  ::std::vector<nebula::HostAddr>& set_hosts(T_DropHostsReq_hosts_struct_setter&& hosts_) {
    hosts = std::forward<T_DropHostsReq_hosts_struct_setter>(hosts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.hosts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return hosts;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< DropHostsReq >;
  friend void swap(DropHostsReq& a, DropHostsReq& b);
};

template <class Protocol_>
uint32_t DropHostsReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListHostsReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListHostsReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListHostsReq() :
      type( ::nebula::meta::cpp2::ListHostType::ALLOC) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListHostsReq(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::ListHostType type__arg);

  ListHostsReq(ListHostsReq&&) = default;

  ListHostsReq(const ListHostsReq&) = default;


  ListHostsReq& operator=(ListHostsReq&&) = default;

  ListHostsReq& operator=(const ListHostsReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::meta::cpp2::ListHostType type;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool type;
  } __isset = {};
  bool operator==(const ListHostsReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListHostsReq& __x, const ListHostsReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListHostsReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListHostsReq& __x, const ListHostsReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListHostsReq& __x, const ListHostsReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListHostsReq& __x, const ListHostsReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::ListHostType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> type_ref() const& {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ListHostType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> type_ref() const&& {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ListHostType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> type_ref() & {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ListHostType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> type_ref() && {
    return {std::move(this->type), __isset.type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::meta::cpp2::ListHostType get_type() const {
    return type;
  }

   ::nebula::meta::cpp2::ListHostType& set_type( ::nebula::meta::cpp2::ListHostType type_) {
    type = type_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return type;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListHostsReq >;
  friend void swap(ListHostsReq& a, ListHostsReq& b);
};

template <class Protocol_>
uint32_t ListHostsReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListHostsResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListHostsResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListHostsResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListHostsResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::HostItem> hosts__arg);

  ListHostsResp(ListHostsResp&&) = default;

  ListHostsResp(const ListHostsResp&) = default;


  ListHostsResp& operator=(ListHostsResp&&) = default;

  ListHostsResp& operator=(const ListHostsResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::vector< ::nebula::meta::cpp2::HostItem> hosts;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool hosts;
  } __isset = {};
  bool operator==(const ListHostsResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListHostsResp& __x, const ListHostsResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListHostsResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListHostsResp& __x, const ListHostsResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListHostsResp& __x, const ListHostsResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListHostsResp& __x, const ListHostsResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::HostItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> hosts_ref() const& {
    return {this->hosts, __isset.hosts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::HostItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> hosts_ref() const&& {
    return {std::move(this->hosts), __isset.hosts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::HostItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> hosts_ref() & {
    return {this->hosts, __isset.hosts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::HostItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> hosts_ref() && {
    return {std::move(this->hosts), __isset.hosts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_ListHostsResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_ListHostsResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_ListHostsResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const ::std::vector< ::nebula::meta::cpp2::HostItem>& get_hosts() const&;
  ::std::vector< ::nebula::meta::cpp2::HostItem> get_hosts() &&;

  template <typename T_ListHostsResp_hosts_struct_setter = ::std::vector< ::nebula::meta::cpp2::HostItem>>
  ::std::vector< ::nebula::meta::cpp2::HostItem>& set_hosts(T_ListHostsResp_hosts_struct_setter&& hosts_) {
    hosts = std::forward<T_ListHostsResp_hosts_struct_setter>(hosts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.hosts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return hosts;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListHostsResp >;
  friend void swap(ListHostsResp& a, ListHostsResp& b);
};

template <class Protocol_>
uint32_t ListHostsResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class PartItem final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = PartItem;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  PartItem() :
      part_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  PartItem(apache::thrift::FragileConstructor,  ::nebula::cpp2::PartitionID part_id__arg, nebula::HostAddr leader__arg, ::std::vector<nebula::HostAddr> peers__arg, ::std::vector<nebula::HostAddr> losts__arg);

  PartItem(PartItem&&) = default;

  PartItem(const PartItem&) = default;


  PartItem& operator=(PartItem&&) = default;

  PartItem& operator=(const PartItem&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
   ::nebula::cpp2::PartitionID part_id;
 private:
  nebula::HostAddr leader;
 public:
  ::std::vector<nebula::HostAddr> peers;
 public:
  ::std::vector<nebula::HostAddr> losts;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool leader;
  } __isset = {};
  bool operator==(const PartItem& rhs) const;
#ifndef SWIG
  friend bool operator!=(const PartItem& __x, const PartItem& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const PartItem& rhs) const;
#ifndef SWIG
  friend bool operator>(const PartItem& __x, const PartItem& __y) {
    return __y < __x;
  }
  friend bool operator<=(const PartItem& __x, const PartItem& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const PartItem& __x, const PartItem& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> part_id_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> part_id_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->part_id)};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> part_id_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> part_id_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->part_id)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> peers_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->peers};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> peers_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->peers)};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> peers_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->peers};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> peers_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->peers)};
  }
  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> losts_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->losts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> losts_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->losts)};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> losts_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->losts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> losts_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->losts)};
  }

   ::nebula::cpp2::PartitionID get_part_id() const {
    return part_id;
  }

   ::nebula::cpp2::PartitionID& set_part_id( ::nebula::cpp2::PartitionID part_id_) {
    part_id = part_id_;
    return part_id;
  }
  const nebula::HostAddr* get_leader() const&;
  nebula::HostAddr* get_leader() &;
  nebula::HostAddr* get_leader() && = delete;

  template <typename T_PartItem_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_PartItem_leader_struct_setter&& leader_) {
    leader = std::forward<T_PartItem_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const ::std::vector<nebula::HostAddr>& get_peers() const&;
  ::std::vector<nebula::HostAddr> get_peers() &&;

  template <typename T_PartItem_peers_struct_setter = ::std::vector<nebula::HostAddr>>
  ::std::vector<nebula::HostAddr>& set_peers(T_PartItem_peers_struct_setter&& peers_) {
    peers = std::forward<T_PartItem_peers_struct_setter>(peers_);
    return peers;
  }
  const ::std::vector<nebula::HostAddr>& get_losts() const&;
  ::std::vector<nebula::HostAddr> get_losts() &&;

  template <typename T_PartItem_losts_struct_setter = ::std::vector<nebula::HostAddr>>
  ::std::vector<nebula::HostAddr>& set_losts(T_PartItem_losts_struct_setter&& losts_) {
    losts = std::forward<T_PartItem_losts_struct_setter>(losts_);
    return losts;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< PartItem >;
  friend void swap(PartItem& a, PartItem& b);
};

template <class Protocol_>
uint32_t PartItem::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListPartsReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListPartsReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListPartsReq() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListPartsReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::vector< ::nebula::cpp2::PartitionID> part_ids__arg);

  ListPartsReq(ListPartsReq&&) = default;

  ListPartsReq(const ListPartsReq&) = default;


  ListPartsReq& operator=(ListPartsReq&&) = default;

  ListPartsReq& operator=(const ListPartsReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::vector< ::nebula::cpp2::PartitionID> part_ids;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool part_ids;
  } __isset = {};
  bool operator==(const ListPartsReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListPartsReq& __x, const ListPartsReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListPartsReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListPartsReq& __x, const ListPartsReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListPartsReq& __x, const ListPartsReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListPartsReq& __x, const ListPartsReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> part_ids_ref() const& {
    return {this->part_ids, __isset.part_ids};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> part_ids_ref() const&& {
    return {std::move(this->part_ids), __isset.part_ids};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> part_ids_ref() & {
    return {this->part_ids, __isset.part_ids};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> part_ids_ref() && {
    return {std::move(this->part_ids), __isset.part_ids};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const ::std::vector< ::nebula::cpp2::PartitionID>& get_part_ids() const&;
  ::std::vector< ::nebula::cpp2::PartitionID> get_part_ids() &&;

  template <typename T_ListPartsReq_part_ids_struct_setter = ::std::vector< ::nebula::cpp2::PartitionID>>
  ::std::vector< ::nebula::cpp2::PartitionID>& set_part_ids(T_ListPartsReq_part_ids_struct_setter&& part_ids_) {
    part_ids = std::forward<T_ListPartsReq_part_ids_struct_setter>(part_ids_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.part_ids = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return part_ids;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListPartsReq >;
  friend void swap(ListPartsReq& a, ListPartsReq& b);
};

template <class Protocol_>
uint32_t ListPartsReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListPartsResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListPartsResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListPartsResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListPartsResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::PartItem> parts__arg);

  ListPartsResp(ListPartsResp&&) = default;

  ListPartsResp(const ListPartsResp&) = default;


  ListPartsResp& operator=(ListPartsResp&&) = default;

  ListPartsResp& operator=(const ListPartsResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::vector< ::nebula::meta::cpp2::PartItem> parts;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool parts;
  } __isset = {};
  bool operator==(const ListPartsResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListPartsResp& __x, const ListPartsResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListPartsResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListPartsResp& __x, const ListPartsResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListPartsResp& __x, const ListPartsResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListPartsResp& __x, const ListPartsResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::PartItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> parts_ref() const& {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::PartItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> parts_ref() const&& {
    return {std::move(this->parts), __isset.parts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::PartItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> parts_ref() & {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::PartItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> parts_ref() && {
    return {std::move(this->parts), __isset.parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_ListPartsResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_ListPartsResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_ListPartsResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const ::std::vector< ::nebula::meta::cpp2::PartItem>& get_parts() const&;
  ::std::vector< ::nebula::meta::cpp2::PartItem> get_parts() &&;

  template <typename T_ListPartsResp_parts_struct_setter = ::std::vector< ::nebula::meta::cpp2::PartItem>>
  ::std::vector< ::nebula::meta::cpp2::PartItem>& set_parts(T_ListPartsResp_parts_struct_setter&& parts_) {
    parts = std::forward<T_ListPartsResp_parts_struct_setter>(parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return parts;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListPartsResp >;
  friend void swap(ListPartsResp& a, ListPartsResp& b);
};

template <class Protocol_>
uint32_t ListPartsResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetPartsAllocReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetPartsAllocReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetPartsAllocReq() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetPartsAllocReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg);

  GetPartsAllocReq(GetPartsAllocReq&&) = default;

  GetPartsAllocReq(const GetPartsAllocReq&) = default;


  GetPartsAllocReq& operator=(GetPartsAllocReq&&) = default;

  GetPartsAllocReq& operator=(const GetPartsAllocReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
  } __isset = {};
  bool operator==(const GetPartsAllocReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetPartsAllocReq& __x, const GetPartsAllocReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetPartsAllocReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetPartsAllocReq& __x, const GetPartsAllocReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetPartsAllocReq& __x, const GetPartsAllocReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetPartsAllocReq& __x, const GetPartsAllocReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetPartsAllocReq >;
  friend void swap(GetPartsAllocReq& a, GetPartsAllocReq& b);
};

template <class Protocol_>
uint32_t GetPartsAllocReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetPartsAllocResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetPartsAllocResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetPartsAllocResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetPartsAllocResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::HostAddr>> parts__arg, std::unordered_map< ::nebula::cpp2::PartitionID, int64_t> terms__arg);

  GetPartsAllocResp(GetPartsAllocResp&&) = default;

  GetPartsAllocResp(const GetPartsAllocResp&) = default;


  GetPartsAllocResp& operator=(GetPartsAllocResp&&) = default;

  GetPartsAllocResp& operator=(const GetPartsAllocResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::HostAddr>> parts;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID, int64_t> terms;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool parts;
    bool terms;
  } __isset = {};
  bool operator==(const GetPartsAllocResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetPartsAllocResp& __x, const GetPartsAllocResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetPartsAllocResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetPartsAllocResp& __x, const GetPartsAllocResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetPartsAllocResp& __x, const GetPartsAllocResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetPartsAllocResp& __x, const GetPartsAllocResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::HostAddr>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> parts_ref() const& {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::HostAddr>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> parts_ref() const&& {
    return {std::move(this->parts), __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::HostAddr>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> parts_ref() & {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::HostAddr>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> parts_ref() && {
    return {std::move(this->parts), __isset.parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, int64_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> terms_ref() const& {
    return {this->terms, __isset.terms};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, int64_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> terms_ref() const&& {
    return {std::move(this->terms), __isset.terms};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, int64_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> terms_ref() & {
    return {this->terms, __isset.terms};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, int64_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> terms_ref() && {
    return {std::move(this->terms), __isset.terms};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_GetPartsAllocResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_GetPartsAllocResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_GetPartsAllocResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::HostAddr>>& get_parts() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::HostAddr>> get_parts() &&;

  template <typename T_GetPartsAllocResp_parts_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::HostAddr>>>
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::HostAddr>>& set_parts(T_GetPartsAllocResp_parts_struct_setter&& parts_) {
    parts = std::forward<T_GetPartsAllocResp_parts_struct_setter>(parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return parts;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID, int64_t>* get_terms() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID, int64_t>* get_terms() &;
  std::unordered_map< ::nebula::cpp2::PartitionID, int64_t>* get_terms() && = delete;

  template <typename T_GetPartsAllocResp_terms_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID, int64_t>>
  std::unordered_map< ::nebula::cpp2::PartitionID, int64_t>& set_terms(T_GetPartsAllocResp_terms_struct_setter&& terms_) {
    terms = std::forward<T_GetPartsAllocResp_terms_struct_setter>(terms_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.terms = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return terms;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetPartsAllocResp >;
  friend void swap(GetPartsAllocResp& a, GetPartsAllocResp& b);
};

template <class Protocol_>
uint32_t GetPartsAllocResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetWorkerIdReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetWorkerIdReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetWorkerIdReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetWorkerIdReq(apache::thrift::FragileConstructor, ::std::string host__arg);

  GetWorkerIdReq(GetWorkerIdReq&&) = default;

  GetWorkerIdReq(const GetWorkerIdReq&) = default;


  GetWorkerIdReq& operator=(GetWorkerIdReq&&) = default;

  GetWorkerIdReq& operator=(const GetWorkerIdReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string host;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool host;
  } __isset = {};
  bool operator==(const GetWorkerIdReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetWorkerIdReq& __x, const GetWorkerIdReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetWorkerIdReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetWorkerIdReq& __x, const GetWorkerIdReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetWorkerIdReq& __x, const GetWorkerIdReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetWorkerIdReq& __x, const GetWorkerIdReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> host_ref() const& {
    return {this->host, __isset.host};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> host_ref() const&& {
    return {std::move(this->host), __isset.host};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> host_ref() & {
    return {this->host, __isset.host};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> host_ref() && {
    return {std::move(this->host), __isset.host};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_host() const& {
    return host;
  }

  ::std::string get_host() && {
    return std::move(host);
  }

  template <typename T_GetWorkerIdReq_host_struct_setter = ::std::string>
  ::std::string& set_host(T_GetWorkerIdReq_host_struct_setter&& host_) {
    host = std::forward<T_GetWorkerIdReq_host_struct_setter>(host_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.host = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return host;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetWorkerIdReq >;
  friend void swap(GetWorkerIdReq& a, GetWorkerIdReq& b);
};

template <class Protocol_>
uint32_t GetWorkerIdReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetWorkerIdResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetWorkerIdResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetWorkerIdResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED),
      workerid(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetWorkerIdResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, int64_t workerid__arg);

  GetWorkerIdResp(GetWorkerIdResp&&) = default;

  GetWorkerIdResp(const GetWorkerIdResp&) = default;


  GetWorkerIdResp& operator=(GetWorkerIdResp&&) = default;

  GetWorkerIdResp& operator=(const GetWorkerIdResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  int64_t workerid;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool workerid;
  } __isset = {};
  bool operator==(const GetWorkerIdResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetWorkerIdResp& __x, const GetWorkerIdResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetWorkerIdResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetWorkerIdResp& __x, const GetWorkerIdResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetWorkerIdResp& __x, const GetWorkerIdResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetWorkerIdResp& __x, const GetWorkerIdResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> workerid_ref() const& {
    return {this->workerid, __isset.workerid};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> workerid_ref() const&& {
    return {std::move(this->workerid), __isset.workerid};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> workerid_ref() & {
    return {this->workerid, __isset.workerid};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> workerid_ref() && {
    return {std::move(this->workerid), __isset.workerid};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_GetWorkerIdResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_GetWorkerIdResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_GetWorkerIdResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }

  int64_t get_workerid() const {
    return workerid;
  }

  int64_t& set_workerid(int64_t workerid_) {
    workerid = workerid_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.workerid = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return workerid;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetWorkerIdResp >;
  friend void swap(GetWorkerIdResp& a, GetWorkerIdResp& b);
};

template <class Protocol_>
uint32_t GetWorkerIdResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetSegmentIdReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetSegmentIdReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetSegmentIdReq() :
      length(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetSegmentIdReq(apache::thrift::FragileConstructor, int64_t length__arg);

  GetSegmentIdReq(GetSegmentIdReq&&) = default;

  GetSegmentIdReq(const GetSegmentIdReq&) = default;


  GetSegmentIdReq& operator=(GetSegmentIdReq&&) = default;

  GetSegmentIdReq& operator=(const GetSegmentIdReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  int64_t length;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool length;
  } __isset = {};
  bool operator==(const GetSegmentIdReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetSegmentIdReq& __x, const GetSegmentIdReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetSegmentIdReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetSegmentIdReq& __x, const GetSegmentIdReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetSegmentIdReq& __x, const GetSegmentIdReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetSegmentIdReq& __x, const GetSegmentIdReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> length_ref() const& {
    return {this->length, __isset.length};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> length_ref() const&& {
    return {std::move(this->length), __isset.length};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> length_ref() & {
    return {this->length, __isset.length};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> length_ref() && {
    return {std::move(this->length), __isset.length};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  int64_t get_length() const {
    return length;
  }

  int64_t& set_length(int64_t length_) {
    length = length_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.length = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return length;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetSegmentIdReq >;
  friend void swap(GetSegmentIdReq& a, GetSegmentIdReq& b);
};

template <class Protocol_>
uint32_t GetSegmentIdReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetSegmentIdResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetSegmentIdResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetSegmentIdResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED),
      segment_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetSegmentIdResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, int64_t segment_id__arg);

  GetSegmentIdResp(GetSegmentIdResp&&) = default;

  GetSegmentIdResp(const GetSegmentIdResp&) = default;


  GetSegmentIdResp& operator=(GetSegmentIdResp&&) = default;

  GetSegmentIdResp& operator=(const GetSegmentIdResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  int64_t segment_id;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool segment_id;
  } __isset = {};
  bool operator==(const GetSegmentIdResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetSegmentIdResp& __x, const GetSegmentIdResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetSegmentIdResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetSegmentIdResp& __x, const GetSegmentIdResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetSegmentIdResp& __x, const GetSegmentIdResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetSegmentIdResp& __x, const GetSegmentIdResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> segment_id_ref() const& {
    return {this->segment_id, __isset.segment_id};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> segment_id_ref() const&& {
    return {std::move(this->segment_id), __isset.segment_id};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> segment_id_ref() & {
    return {this->segment_id, __isset.segment_id};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> segment_id_ref() && {
    return {std::move(this->segment_id), __isset.segment_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_GetSegmentIdResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_GetSegmentIdResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_GetSegmentIdResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }

  int64_t get_segment_id() const {
    return segment_id;
  }

  int64_t& set_segment_id(int64_t segment_id_) {
    segment_id = segment_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.segment_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return segment_id;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetSegmentIdResp >;
  friend void swap(GetSegmentIdResp& a, GetSegmentIdResp& b);
};

template <class Protocol_>
uint32_t GetSegmentIdResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class HBResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = HBResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  HBResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED),
      cluster_id(0),
      last_update_time_in_ms(0),
      meta_version(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  HBResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::ClusterID cluster_id__arg, int64_t last_update_time_in_ms__arg, int32_t meta_version__arg);

  HBResp(HBResp&&) = default;

  HBResp(const HBResp&) = default;


  HBResp& operator=(HBResp&&) = default;

  HBResp& operator=(const HBResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
   ::nebula::meta::cpp2::ClusterID cluster_id;
 private:
  int64_t last_update_time_in_ms;
 private:
  int32_t meta_version;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool cluster_id;
    bool last_update_time_in_ms;
    bool meta_version;
  } __isset = {};
  bool operator==(const HBResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const HBResp& __x, const HBResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const HBResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const HBResp& __x, const HBResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const HBResp& __x, const HBResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const HBResp& __x, const HBResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> cluster_id_ref() const& {
    return {this->cluster_id, __isset.cluster_id};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> cluster_id_ref() const&& {
    return {std::move(this->cluster_id), __isset.cluster_id};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> cluster_id_ref() & {
    return {this->cluster_id, __isset.cluster_id};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> cluster_id_ref() && {
    return {std::move(this->cluster_id), __isset.cluster_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> last_update_time_in_ms_ref() const& {
    return {this->last_update_time_in_ms, __isset.last_update_time_in_ms};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> last_update_time_in_ms_ref() const&& {
    return {std::move(this->last_update_time_in_ms), __isset.last_update_time_in_ms};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> last_update_time_in_ms_ref() & {
    return {this->last_update_time_in_ms, __isset.last_update_time_in_ms};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> last_update_time_in_ms_ref() && {
    return {std::move(this->last_update_time_in_ms), __isset.last_update_time_in_ms};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> meta_version_ref() const& {
    return {this->meta_version, __isset.meta_version};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> meta_version_ref() const&& {
    return {std::move(this->meta_version), __isset.meta_version};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> meta_version_ref() & {
    return {this->meta_version, __isset.meta_version};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> meta_version_ref() && {
    return {std::move(this->meta_version), __isset.meta_version};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_HBResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_HBResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_HBResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }

   ::nebula::meta::cpp2::ClusterID get_cluster_id() const {
    return cluster_id;
  }

   ::nebula::meta::cpp2::ClusterID& set_cluster_id( ::nebula::meta::cpp2::ClusterID cluster_id_) {
    cluster_id = cluster_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.cluster_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return cluster_id;
  }

  int64_t get_last_update_time_in_ms() const {
    return last_update_time_in_ms;
  }

  int64_t& set_last_update_time_in_ms(int64_t last_update_time_in_ms_) {
    last_update_time_in_ms = last_update_time_in_ms_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.last_update_time_in_ms = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return last_update_time_in_ms;
  }

  int32_t get_meta_version() const {
    return meta_version;
  }

  int32_t& set_meta_version(int32_t meta_version_) {
    meta_version = meta_version_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.meta_version = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return meta_version;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< HBResp >;
  friend void swap(HBResp& a, HBResp& b);
};

template <class Protocol_>
uint32_t HBResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class LeaderInfo final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = LeaderInfo;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  LeaderInfo() :
      part_id(0),
      term(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  LeaderInfo(apache::thrift::FragileConstructor,  ::nebula::cpp2::PartitionID part_id__arg, int64_t term__arg);

  LeaderInfo(LeaderInfo&&) = default;

  LeaderInfo(const LeaderInfo&) = default;


  LeaderInfo& operator=(LeaderInfo&&) = default;

  LeaderInfo& operator=(const LeaderInfo&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::PartitionID part_id;
 private:
  int64_t term;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool part_id;
    bool term;
  } __isset = {};
  bool operator==(const LeaderInfo& rhs) const;
#ifndef SWIG
  friend bool operator!=(const LeaderInfo& __x, const LeaderInfo& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const LeaderInfo& rhs) const;
#ifndef SWIG
  friend bool operator>(const LeaderInfo& __x, const LeaderInfo& __y) {
    return __y < __x;
  }
  friend bool operator<=(const LeaderInfo& __x, const LeaderInfo& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const LeaderInfo& __x, const LeaderInfo& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> part_id_ref() const& {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> part_id_ref() const&& {
    return {std::move(this->part_id), __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> part_id_ref() & {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> part_id_ref() && {
    return {std::move(this->part_id), __isset.part_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> term_ref() const& {
    return {this->term, __isset.term};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> term_ref() const&& {
    return {std::move(this->term), __isset.term};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> term_ref() & {
    return {this->term, __isset.term};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> term_ref() && {
    return {std::move(this->term), __isset.term};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::PartitionID get_part_id() const {
    return part_id;
  }

   ::nebula::cpp2::PartitionID& set_part_id( ::nebula::cpp2::PartitionID part_id_) {
    part_id = part_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.part_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return part_id;
  }

  int64_t get_term() const {
    return term;
  }

  int64_t& set_term(int64_t term_) {
    term = term_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.term = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return term;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< LeaderInfo >;
  friend void swap(LeaderInfo& a, LeaderInfo& b);
};

template <class Protocol_>
uint32_t LeaderInfo::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class PartitionList final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = PartitionList;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  PartitionList() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  PartitionList(apache::thrift::FragileConstructor, ::std::vector< ::nebula::cpp2::PartitionID> part_list__arg);

  PartitionList(PartitionList&&) = default;

  PartitionList(const PartitionList&) = default;


  PartitionList& operator=(PartitionList&&) = default;

  PartitionList& operator=(const PartitionList&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector< ::nebula::cpp2::PartitionID> part_list;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool part_list;
  } __isset = {};
  bool operator==(const PartitionList& rhs) const;
#ifndef SWIG
  friend bool operator!=(const PartitionList& __x, const PartitionList& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const PartitionList& rhs) const;
#ifndef SWIG
  friend bool operator>(const PartitionList& __x, const PartitionList& __y) {
    return __y < __x;
  }
  friend bool operator<=(const PartitionList& __x, const PartitionList& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const PartitionList& __x, const PartitionList& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> part_list_ref() const& {
    return {this->part_list, __isset.part_list};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> part_list_ref() const&& {
    return {std::move(this->part_list), __isset.part_list};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> part_list_ref() & {
    return {this->part_list, __isset.part_list};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> part_list_ref() && {
    return {std::move(this->part_list), __isset.part_list};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector< ::nebula::cpp2::PartitionID>& get_part_list() const&;
  ::std::vector< ::nebula::cpp2::PartitionID> get_part_list() &&;

  template <typename T_PartitionList_part_list_struct_setter = ::std::vector< ::nebula::cpp2::PartitionID>>
  ::std::vector< ::nebula::cpp2::PartitionID>& set_part_list(T_PartitionList_part_list_struct_setter&& part_list_) {
    part_list = std::forward<T_PartitionList_part_list_struct_setter>(part_list_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.part_list = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return part_list;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< PartitionList >;
  friend void swap(PartitionList& a, PartitionList& b);
};

template <class Protocol_>
uint32_t PartitionList::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class HBReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = HBReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  HBReq();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  HBReq(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::HostRole role__arg, nebula::HostAddr host__arg,  ::nebula::meta::cpp2::ClusterID cluster_id__arg, std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::LeaderInfo>> leader_partIds__arg, ::std::string git_info_sha__arg, std::unordered_map< ::nebula::cpp2::GraphSpaceID, std::unordered_map<::std::string,  ::nebula::meta::cpp2::PartitionList>> disk_parts__arg,  ::nebula::cpp2::DirInfo dir__arg, ::std::string version__arg);

  HBReq(HBReq&&) = default;

  HBReq(const HBReq&) = default;


  HBReq& operator=(HBReq&&) = default;

  HBReq& operator=(const HBReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~HBReq();

 private:
   ::nebula::meta::cpp2::HostRole role;
 private:
  nebula::HostAddr host;
 private:
   ::nebula::meta::cpp2::ClusterID cluster_id;
 private:
  std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::LeaderInfo>> leader_partIds;
 private:
  ::std::string git_info_sha;
 private:
  std::unordered_map< ::nebula::cpp2::GraphSpaceID, std::unordered_map<::std::string,  ::nebula::meta::cpp2::PartitionList>> disk_parts;
 private:
   ::nebula::cpp2::DirInfo dir;
 private:
  ::std::string version;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool role;
    bool host;
    bool cluster_id;
    bool leader_partIds;
    bool git_info_sha;
    bool disk_parts;
    bool dir;
    bool version;
  } __isset = {};
  bool operator==(const HBReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const HBReq& __x, const HBReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const HBReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const HBReq& __x, const HBReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const HBReq& __x, const HBReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const HBReq& __x, const HBReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::HostRole>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> role_ref() const& {
    return {this->role, __isset.role};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::HostRole>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> role_ref() const&& {
    return {std::move(this->role), __isset.role};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::HostRole>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> role_ref() & {
    return {this->role, __isset.role};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::HostRole>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> role_ref() && {
    return {std::move(this->role), __isset.role};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> host_ref() const& {
    return {this->host, __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> host_ref() const&& {
    return {std::move(this->host), __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> host_ref() & {
    return {this->host, __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> host_ref() && {
    return {std::move(this->host), __isset.host};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> cluster_id_ref() const& {
    return {this->cluster_id, __isset.cluster_id};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> cluster_id_ref() const&& {
    return {std::move(this->cluster_id), __isset.cluster_id};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> cluster_id_ref() & {
    return {this->cluster_id, __isset.cluster_id};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> cluster_id_ref() && {
    return {std::move(this->cluster_id), __isset.cluster_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::LeaderInfo>>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> leader_partIds_ref() const& {
    return {this->leader_partIds, __isset.leader_partIds};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::LeaderInfo>>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> leader_partIds_ref() const&& {
    return {std::move(this->leader_partIds), __isset.leader_partIds};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::LeaderInfo>>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> leader_partIds_ref() & {
    return {this->leader_partIds, __isset.leader_partIds};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::LeaderInfo>>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> leader_partIds_ref() && {
    return {std::move(this->leader_partIds), __isset.leader_partIds};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> git_info_sha_ref() const& {
    return {this->git_info_sha, __isset.git_info_sha};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> git_info_sha_ref() const&& {
    return {std::move(this->git_info_sha), __isset.git_info_sha};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> git_info_sha_ref() & {
    return {this->git_info_sha, __isset.git_info_sha};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> git_info_sha_ref() && {
    return {std::move(this->git_info_sha), __isset.git_info_sha};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID, std::unordered_map<::std::string,  ::nebula::meta::cpp2::PartitionList>>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> disk_parts_ref() const& {
    return {this->disk_parts, __isset.disk_parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID, std::unordered_map<::std::string,  ::nebula::meta::cpp2::PartitionList>>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> disk_parts_ref() const&& {
    return {std::move(this->disk_parts), __isset.disk_parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID, std::unordered_map<::std::string,  ::nebula::meta::cpp2::PartitionList>>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> disk_parts_ref() & {
    return {this->disk_parts, __isset.disk_parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID, std::unordered_map<::std::string,  ::nebula::meta::cpp2::PartitionList>>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> disk_parts_ref() && {
    return {std::move(this->disk_parts), __isset.disk_parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::DirInfo>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> dir_ref() const& {
    return {this->dir, __isset.dir};
  }

  template <typename..., typename T =  ::nebula::cpp2::DirInfo>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> dir_ref() const&& {
    return {std::move(this->dir), __isset.dir};
  }

  template <typename..., typename T =  ::nebula::cpp2::DirInfo>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> dir_ref() & {
    return {this->dir, __isset.dir};
  }

  template <typename..., typename T =  ::nebula::cpp2::DirInfo>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> dir_ref() && {
    return {std::move(this->dir), __isset.dir};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> version_ref() const& {
    return {this->version, __isset.version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> version_ref() const&& {
    return {std::move(this->version), __isset.version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> version_ref() & {
    return {this->version, __isset.version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> version_ref() && {
    return {std::move(this->version), __isset.version};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::meta::cpp2::HostRole get_role() const {
    return role;
  }

   ::nebula::meta::cpp2::HostRole& set_role( ::nebula::meta::cpp2::HostRole role_) {
    role = role_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.role = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return role;
  }
  const nebula::HostAddr& get_host() const&;
  nebula::HostAddr get_host() &&;

  template <typename T_HBReq_host_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_host(T_HBReq_host_struct_setter&& host_) {
    host = std::forward<T_HBReq_host_struct_setter>(host_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.host = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return host;
  }

   ::nebula::meta::cpp2::ClusterID get_cluster_id() const {
    return cluster_id;
  }

   ::nebula::meta::cpp2::ClusterID& set_cluster_id( ::nebula::meta::cpp2::ClusterID cluster_id_) {
    cluster_id = cluster_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.cluster_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return cluster_id;
  }
  const std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::LeaderInfo>>* get_leader_partIds() const&;
  std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::LeaderInfo>>* get_leader_partIds() &;
  std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::LeaderInfo>>* get_leader_partIds() && = delete;

  template <typename T_HBReq_leader_partIds_struct_setter = std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::LeaderInfo>>>
  std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::LeaderInfo>>& set_leader_partIds(T_HBReq_leader_partIds_struct_setter&& leader_partIds_) {
    leader_partIds = std::forward<T_HBReq_leader_partIds_struct_setter>(leader_partIds_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader_partIds = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader_partIds;
  }

  const ::std::string& get_git_info_sha() const& {
    return git_info_sha;
  }

  ::std::string get_git_info_sha() && {
    return std::move(git_info_sha);
  }

  template <typename T_HBReq_git_info_sha_struct_setter = ::std::string>
  ::std::string& set_git_info_sha(T_HBReq_git_info_sha_struct_setter&& git_info_sha_) {
    git_info_sha = std::forward<T_HBReq_git_info_sha_struct_setter>(git_info_sha_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.git_info_sha = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return git_info_sha;
  }
  const std::unordered_map< ::nebula::cpp2::GraphSpaceID, std::unordered_map<::std::string,  ::nebula::meta::cpp2::PartitionList>>* get_disk_parts() const&;
  std::unordered_map< ::nebula::cpp2::GraphSpaceID, std::unordered_map<::std::string,  ::nebula::meta::cpp2::PartitionList>>* get_disk_parts() &;
  std::unordered_map< ::nebula::cpp2::GraphSpaceID, std::unordered_map<::std::string,  ::nebula::meta::cpp2::PartitionList>>* get_disk_parts() && = delete;

  template <typename T_HBReq_disk_parts_struct_setter = std::unordered_map< ::nebula::cpp2::GraphSpaceID, std::unordered_map<::std::string,  ::nebula::meta::cpp2::PartitionList>>>
  std::unordered_map< ::nebula::cpp2::GraphSpaceID, std::unordered_map<::std::string,  ::nebula::meta::cpp2::PartitionList>>& set_disk_parts(T_HBReq_disk_parts_struct_setter&& disk_parts_) {
    disk_parts = std::forward<T_HBReq_disk_parts_struct_setter>(disk_parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.disk_parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return disk_parts;
  }
  const  ::nebula::cpp2::DirInfo* get_dir() const&;
   ::nebula::cpp2::DirInfo* get_dir() &;
   ::nebula::cpp2::DirInfo* get_dir() && = delete;

  template <typename T_HBReq_dir_struct_setter =  ::nebula::cpp2::DirInfo>
   ::nebula::cpp2::DirInfo& set_dir(T_HBReq_dir_struct_setter&& dir_) {
    dir = std::forward<T_HBReq_dir_struct_setter>(dir_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.dir = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return dir;
  }

  const ::std::string* get_version() const& {
    return version_ref() ? std::addressof(version) : nullptr;
  }

  ::std::string* get_version() & {
    return version_ref() ? std::addressof(version) : nullptr;
  }
  ::std::string* get_version() && = delete;

  template <typename T_HBReq_version_struct_setter = ::std::string>
  ::std::string& set_version(T_HBReq_version_struct_setter&& version_) {
    version = std::forward<T_HBReq_version_struct_setter>(version_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.version = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return version;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< HBReq >;
  friend void swap(HBReq& a, HBReq& b);
};

template <class Protocol_>
uint32_t HBReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ServiceInfo final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ServiceInfo;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ServiceInfo() :
      role( ::nebula::meta::cpp2::HostRole::GRAPH) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ServiceInfo(apache::thrift::FragileConstructor,  ::nebula::cpp2::DirInfo dir__arg, nebula::HostAddr addr__arg,  ::nebula::meta::cpp2::HostRole role__arg);

  ServiceInfo(ServiceInfo&&) = default;

  ServiceInfo(const ServiceInfo&) = default;


  ServiceInfo& operator=(ServiceInfo&&) = default;

  ServiceInfo& operator=(const ServiceInfo&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::DirInfo dir;
 private:
  nebula::HostAddr addr;
 private:
   ::nebula::meta::cpp2::HostRole role;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool dir;
    bool addr;
    bool role;
  } __isset = {};
  bool operator==(const ServiceInfo& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ServiceInfo& __x, const ServiceInfo& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ServiceInfo& rhs) const;
#ifndef SWIG
  friend bool operator>(const ServiceInfo& __x, const ServiceInfo& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ServiceInfo& __x, const ServiceInfo& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ServiceInfo& __x, const ServiceInfo& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::DirInfo>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> dir_ref() const& {
    return {this->dir, __isset.dir};
  }

  template <typename..., typename T =  ::nebula::cpp2::DirInfo>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> dir_ref() const&& {
    return {std::move(this->dir), __isset.dir};
  }

  template <typename..., typename T =  ::nebula::cpp2::DirInfo>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> dir_ref() & {
    return {this->dir, __isset.dir};
  }

  template <typename..., typename T =  ::nebula::cpp2::DirInfo>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> dir_ref() && {
    return {std::move(this->dir), __isset.dir};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> addr_ref() const& {
    return {this->addr, __isset.addr};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> addr_ref() const&& {
    return {std::move(this->addr), __isset.addr};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> addr_ref() & {
    return {this->addr, __isset.addr};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> addr_ref() && {
    return {std::move(this->addr), __isset.addr};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::HostRole>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> role_ref() const& {
    return {this->role, __isset.role};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::HostRole>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> role_ref() const&& {
    return {std::move(this->role), __isset.role};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::HostRole>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> role_ref() & {
    return {this->role, __isset.role};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::HostRole>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> role_ref() && {
    return {std::move(this->role), __isset.role};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::cpp2::DirInfo& get_dir() const&;
   ::nebula::cpp2::DirInfo get_dir() &&;

  template <typename T_ServiceInfo_dir_struct_setter =  ::nebula::cpp2::DirInfo>
   ::nebula::cpp2::DirInfo& set_dir(T_ServiceInfo_dir_struct_setter&& dir_) {
    dir = std::forward<T_ServiceInfo_dir_struct_setter>(dir_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.dir = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return dir;
  }
  const nebula::HostAddr& get_addr() const&;
  nebula::HostAddr get_addr() &&;

  template <typename T_ServiceInfo_addr_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_addr(T_ServiceInfo_addr_struct_setter&& addr_) {
    addr = std::forward<T_ServiceInfo_addr_struct_setter>(addr_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.addr = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return addr;
  }

   ::nebula::meta::cpp2::HostRole get_role() const {
    return role;
  }

   ::nebula::meta::cpp2::HostRole& set_role( ::nebula::meta::cpp2::HostRole role_) {
    role = role_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.role = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return role;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ServiceInfo >;
  friend void swap(ServiceInfo& a, ServiceInfo& b);
};

template <class Protocol_>
uint32_t ServiceInfo::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class AgentHBReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AgentHBReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  AgentHBReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AgentHBReq(apache::thrift::FragileConstructor, nebula::HostAddr host__arg, ::std::string git_info_sha__arg, ::std::string version__arg);

  AgentHBReq(AgentHBReq&&) = default;

  AgentHBReq(const AgentHBReq&) = default;


  AgentHBReq& operator=(AgentHBReq&&) = default;

  AgentHBReq& operator=(const AgentHBReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  nebula::HostAddr host;
 private:
  ::std::string git_info_sha;
 private:
  ::std::string version;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool host;
    bool git_info_sha;
    bool version;
  } __isset = {};
  bool operator==(const AgentHBReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AgentHBReq& __x, const AgentHBReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AgentHBReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const AgentHBReq& __x, const AgentHBReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AgentHBReq& __x, const AgentHBReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AgentHBReq& __x, const AgentHBReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> host_ref() const& {
    return {this->host, __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> host_ref() const&& {
    return {std::move(this->host), __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> host_ref() & {
    return {this->host, __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> host_ref() && {
    return {std::move(this->host), __isset.host};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> git_info_sha_ref() const& {
    return {this->git_info_sha, __isset.git_info_sha};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> git_info_sha_ref() const&& {
    return {std::move(this->git_info_sha), __isset.git_info_sha};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> git_info_sha_ref() & {
    return {this->git_info_sha, __isset.git_info_sha};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> git_info_sha_ref() && {
    return {std::move(this->git_info_sha), __isset.git_info_sha};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> version_ref() const& {
    return {this->version, __isset.version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> version_ref() const&& {
    return {std::move(this->version), __isset.version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> version_ref() & {
    return {this->version, __isset.version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> version_ref() && {
    return {std::move(this->version), __isset.version};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const nebula::HostAddr& get_host() const&;
  nebula::HostAddr get_host() &&;

  template <typename T_AgentHBReq_host_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_host(T_AgentHBReq_host_struct_setter&& host_) {
    host = std::forward<T_AgentHBReq_host_struct_setter>(host_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.host = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return host;
  }

  const ::std::string& get_git_info_sha() const& {
    return git_info_sha;
  }

  ::std::string get_git_info_sha() && {
    return std::move(git_info_sha);
  }

  template <typename T_AgentHBReq_git_info_sha_struct_setter = ::std::string>
  ::std::string& set_git_info_sha(T_AgentHBReq_git_info_sha_struct_setter&& git_info_sha_) {
    git_info_sha = std::forward<T_AgentHBReq_git_info_sha_struct_setter>(git_info_sha_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.git_info_sha = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return git_info_sha;
  }

  const ::std::string* get_version() const& {
    return version_ref() ? std::addressof(version) : nullptr;
  }

  ::std::string* get_version() & {
    return version_ref() ? std::addressof(version) : nullptr;
  }
  ::std::string* get_version() && = delete;

  template <typename T_AgentHBReq_version_struct_setter = ::std::string>
  ::std::string& set_version(T_AgentHBReq_version_struct_setter&& version_) {
    version = std::forward<T_AgentHBReq_version_struct_setter>(version_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.version = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return version;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AgentHBReq >;
  friend void swap(AgentHBReq& a, AgentHBReq& b);
};

template <class Protocol_>
uint32_t AgentHBReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class AgentHBResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AgentHBResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  AgentHBResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AgentHBResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::ServiceInfo> service_list__arg);

  AgentHBResp(AgentHBResp&&) = default;

  AgentHBResp(const AgentHBResp&) = default;


  AgentHBResp& operator=(AgentHBResp&&) = default;

  AgentHBResp& operator=(const AgentHBResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::vector< ::nebula::meta::cpp2::ServiceInfo> service_list;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool service_list;
  } __isset = {};
  bool operator==(const AgentHBResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AgentHBResp& __x, const AgentHBResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AgentHBResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const AgentHBResp& __x, const AgentHBResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AgentHBResp& __x, const AgentHBResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AgentHBResp& __x, const AgentHBResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ServiceInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> service_list_ref() const& {
    return {this->service_list, __isset.service_list};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ServiceInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> service_list_ref() const&& {
    return {std::move(this->service_list), __isset.service_list};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ServiceInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> service_list_ref() & {
    return {this->service_list, __isset.service_list};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ServiceInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> service_list_ref() && {
    return {std::move(this->service_list), __isset.service_list};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_AgentHBResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_AgentHBResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_AgentHBResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const ::std::vector< ::nebula::meta::cpp2::ServiceInfo>& get_service_list() const&;
  ::std::vector< ::nebula::meta::cpp2::ServiceInfo> get_service_list() &&;

  template <typename T_AgentHBResp_service_list_struct_setter = ::std::vector< ::nebula::meta::cpp2::ServiceInfo>>
  ::std::vector< ::nebula::meta::cpp2::ServiceInfo>& set_service_list(T_AgentHBResp_service_list_struct_setter&& service_list_) {
    service_list = std::forward<T_AgentHBResp_service_list_struct_setter>(service_list_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.service_list = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return service_list;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AgentHBResp >;
  friend void swap(AgentHBResp& a, AgentHBResp& b);
};

template <class Protocol_>
uint32_t AgentHBResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class IndexFieldDef final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = IndexFieldDef;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  IndexFieldDef() :
      type_length(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  IndexFieldDef(apache::thrift::FragileConstructor, ::std::string name__arg, int16_t type_length__arg);

  IndexFieldDef(IndexFieldDef&&) = default;

  IndexFieldDef(const IndexFieldDef&) = default;


  IndexFieldDef& operator=(IndexFieldDef&&) = default;

  IndexFieldDef& operator=(const IndexFieldDef&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
  ::std::string name;
 private:
  int16_t type_length;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool type_length;
  } __isset = {};
  bool operator==(const IndexFieldDef& rhs) const;
#ifndef SWIG
  friend bool operator!=(const IndexFieldDef& __x, const IndexFieldDef& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const IndexFieldDef& rhs) const;
#ifndef SWIG
  friend bool operator>(const IndexFieldDef& __x, const IndexFieldDef& __y) {
    return __y < __x;
  }
  friend bool operator<=(const IndexFieldDef& __x, const IndexFieldDef& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const IndexFieldDef& __x, const IndexFieldDef& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> name_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> name_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->name)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> name_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> name_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->name)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> type_length_ref() const& {
    return {this->type_length, __isset.type_length};
  }

  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> type_length_ref() const&& {
    return {std::move(this->type_length), __isset.type_length};
  }

  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> type_length_ref() & {
    return {this->type_length, __isset.type_length};
  }

  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> type_length_ref() && {
    return {std::move(this->type_length), __isset.type_length};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_IndexFieldDef_name_struct_setter = ::std::string>
  ::std::string& set_name(T_IndexFieldDef_name_struct_setter&& name_) {
    name = std::forward<T_IndexFieldDef_name_struct_setter>(name_);
    return name;
  }

  const int16_t* get_type_length() const& {
    return type_length_ref() ? std::addressof(type_length) : nullptr;
  }

  int16_t* get_type_length() & {
    return type_length_ref() ? std::addressof(type_length) : nullptr;
  }
  int16_t* get_type_length() && = delete;

  int16_t& set_type_length(int16_t type_length_) {
    type_length = type_length_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.type_length = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return type_length;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< IndexFieldDef >;
  friend void swap(IndexFieldDef& a, IndexFieldDef& b);
};

template <class Protocol_>
uint32_t IndexFieldDef::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class CreateTagIndexReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CreateTagIndexReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  CreateTagIndexReq();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CreateTagIndexReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string index_name__arg, ::std::string tag_name__arg, ::std::vector< ::nebula::meta::cpp2::IndexFieldDef> fields__arg, bool if_not_exists__arg, ::std::string comment__arg,  ::nebula::meta::cpp2::IndexParams index_params__arg);

  CreateTagIndexReq(CreateTagIndexReq&&) = default;

  CreateTagIndexReq(const CreateTagIndexReq&) = default;


  CreateTagIndexReq& operator=(CreateTagIndexReq&&) = default;

  CreateTagIndexReq& operator=(const CreateTagIndexReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~CreateTagIndexReq();

 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::string index_name;
 private:
  ::std::string tag_name;
 private:
  ::std::vector< ::nebula::meta::cpp2::IndexFieldDef> fields;
 private:
  bool if_not_exists;
 private:
  ::std::string comment;
 private:
   ::nebula::meta::cpp2::IndexParams index_params;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool index_name;
    bool tag_name;
    bool fields;
    bool if_not_exists;
    bool comment;
    bool index_params;
  } __isset = {};
  bool operator==(const CreateTagIndexReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CreateTagIndexReq& __x, const CreateTagIndexReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CreateTagIndexReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const CreateTagIndexReq& __x, const CreateTagIndexReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CreateTagIndexReq& __x, const CreateTagIndexReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CreateTagIndexReq& __x, const CreateTagIndexReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> index_name_ref() const& {
    return {this->index_name, __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> index_name_ref() const&& {
    return {std::move(this->index_name), __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> index_name_ref() & {
    return {this->index_name, __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> index_name_ref() && {
    return {std::move(this->index_name), __isset.index_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> tag_name_ref() const& {
    return {this->tag_name, __isset.tag_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> tag_name_ref() const&& {
    return {std::move(this->tag_name), __isset.tag_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> tag_name_ref() & {
    return {this->tag_name, __isset.tag_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> tag_name_ref() && {
    return {std::move(this->tag_name), __isset.tag_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fields_ref() const& {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fields_ref() const&& {
    return {std::move(this->fields), __isset.fields};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fields_ref() & {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fields_ref() && {
    return {std::move(this->fields), __isset.fields};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> if_not_exists_ref() const& {
    return {this->if_not_exists, __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> if_not_exists_ref() const&& {
    return {std::move(this->if_not_exists), __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> if_not_exists_ref() & {
    return {this->if_not_exists, __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> if_not_exists_ref() && {
    return {std::move(this->if_not_exists), __isset.if_not_exists};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> comment_ref() const& {
    return {this->comment, __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> comment_ref() const&& {
    return {std::move(this->comment), __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> comment_ref() & {
    return {this->comment, __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> comment_ref() && {
    return {std::move(this->comment), __isset.comment};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::IndexParams>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> index_params_ref() const& {
    return {this->index_params, __isset.index_params};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::IndexParams>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> index_params_ref() const&& {
    return {std::move(this->index_params), __isset.index_params};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::IndexParams>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> index_params_ref() & {
    return {this->index_params, __isset.index_params};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::IndexParams>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> index_params_ref() && {
    return {std::move(this->index_params), __isset.index_params};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  const ::std::string& get_index_name() const& {
    return index_name;
  }

  ::std::string get_index_name() && {
    return std::move(index_name);
  }

  template <typename T_CreateTagIndexReq_index_name_struct_setter = ::std::string>
  ::std::string& set_index_name(T_CreateTagIndexReq_index_name_struct_setter&& index_name_) {
    index_name = std::forward<T_CreateTagIndexReq_index_name_struct_setter>(index_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.index_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return index_name;
  }

  const ::std::string& get_tag_name() const& {
    return tag_name;
  }

  ::std::string get_tag_name() && {
    return std::move(tag_name);
  }

  template <typename T_CreateTagIndexReq_tag_name_struct_setter = ::std::string>
  ::std::string& set_tag_name(T_CreateTagIndexReq_tag_name_struct_setter&& tag_name_) {
    tag_name = std::forward<T_CreateTagIndexReq_tag_name_struct_setter>(tag_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.tag_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return tag_name;
  }
  const ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>& get_fields() const&;
  ::std::vector< ::nebula::meta::cpp2::IndexFieldDef> get_fields() &&;

  template <typename T_CreateTagIndexReq_fields_struct_setter = ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>>
  ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>& set_fields(T_CreateTagIndexReq_fields_struct_setter&& fields_) {
    fields = std::forward<T_CreateTagIndexReq_fields_struct_setter>(fields_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fields = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fields;
  }

  bool get_if_not_exists() const {
    return if_not_exists;
  }

  bool& set_if_not_exists(bool if_not_exists_) {
    if_not_exists = if_not_exists_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.if_not_exists = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return if_not_exists;
  }

  const ::std::string* get_comment() const& {
    return comment_ref() ? std::addressof(comment) : nullptr;
  }

  ::std::string* get_comment() & {
    return comment_ref() ? std::addressof(comment) : nullptr;
  }
  ::std::string* get_comment() && = delete;

  template <typename T_CreateTagIndexReq_comment_struct_setter = ::std::string>
  ::std::string& set_comment(T_CreateTagIndexReq_comment_struct_setter&& comment_) {
    comment = std::forward<T_CreateTagIndexReq_comment_struct_setter>(comment_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.comment = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return comment;
  }
  const  ::nebula::meta::cpp2::IndexParams* get_index_params() const&;
   ::nebula::meta::cpp2::IndexParams* get_index_params() &;
   ::nebula::meta::cpp2::IndexParams* get_index_params() && = delete;

  template <typename T_CreateTagIndexReq_index_params_struct_setter =  ::nebula::meta::cpp2::IndexParams>
   ::nebula::meta::cpp2::IndexParams& set_index_params(T_CreateTagIndexReq_index_params_struct_setter&& index_params_) {
    index_params = std::forward<T_CreateTagIndexReq_index_params_struct_setter>(index_params_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.index_params = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return index_params;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CreateTagIndexReq >;
  friend void swap(CreateTagIndexReq& a, CreateTagIndexReq& b);
};

template <class Protocol_>
uint32_t CreateTagIndexReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class DropTagIndexReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = DropTagIndexReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  DropTagIndexReq() :
      space_id(0),
      if_exists(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  DropTagIndexReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string index_name__arg, bool if_exists__arg);

  DropTagIndexReq(DropTagIndexReq&&) = default;

  DropTagIndexReq(const DropTagIndexReq&) = default;


  DropTagIndexReq& operator=(DropTagIndexReq&&) = default;

  DropTagIndexReq& operator=(const DropTagIndexReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::string index_name;
 private:
  bool if_exists;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool index_name;
    bool if_exists;
  } __isset = {};
  bool operator==(const DropTagIndexReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const DropTagIndexReq& __x, const DropTagIndexReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const DropTagIndexReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const DropTagIndexReq& __x, const DropTagIndexReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const DropTagIndexReq& __x, const DropTagIndexReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const DropTagIndexReq& __x, const DropTagIndexReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> index_name_ref() const& {
    return {this->index_name, __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> index_name_ref() const&& {
    return {std::move(this->index_name), __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> index_name_ref() & {
    return {this->index_name, __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> index_name_ref() && {
    return {std::move(this->index_name), __isset.index_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> if_exists_ref() const& {
    return {this->if_exists, __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> if_exists_ref() const&& {
    return {std::move(this->if_exists), __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> if_exists_ref() & {
    return {this->if_exists, __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> if_exists_ref() && {
    return {std::move(this->if_exists), __isset.if_exists};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  const ::std::string& get_index_name() const& {
    return index_name;
  }

  ::std::string get_index_name() && {
    return std::move(index_name);
  }

  template <typename T_DropTagIndexReq_index_name_struct_setter = ::std::string>
  ::std::string& set_index_name(T_DropTagIndexReq_index_name_struct_setter&& index_name_) {
    index_name = std::forward<T_DropTagIndexReq_index_name_struct_setter>(index_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.index_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return index_name;
  }

  bool get_if_exists() const {
    return if_exists;
  }

  bool& set_if_exists(bool if_exists_) {
    if_exists = if_exists_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.if_exists = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return if_exists;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< DropTagIndexReq >;
  friend void swap(DropTagIndexReq& a, DropTagIndexReq& b);
};

template <class Protocol_>
uint32_t DropTagIndexReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetTagIndexReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetTagIndexReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetTagIndexReq() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetTagIndexReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string index_name__arg);

  GetTagIndexReq(GetTagIndexReq&&) = default;

  GetTagIndexReq(const GetTagIndexReq&) = default;


  GetTagIndexReq& operator=(GetTagIndexReq&&) = default;

  GetTagIndexReq& operator=(const GetTagIndexReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::string index_name;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool index_name;
  } __isset = {};
  bool operator==(const GetTagIndexReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetTagIndexReq& __x, const GetTagIndexReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetTagIndexReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetTagIndexReq& __x, const GetTagIndexReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetTagIndexReq& __x, const GetTagIndexReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetTagIndexReq& __x, const GetTagIndexReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> index_name_ref() const& {
    return {this->index_name, __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> index_name_ref() const&& {
    return {std::move(this->index_name), __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> index_name_ref() & {
    return {this->index_name, __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> index_name_ref() && {
    return {std::move(this->index_name), __isset.index_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  const ::std::string& get_index_name() const& {
    return index_name;
  }

  ::std::string get_index_name() && {
    return std::move(index_name);
  }

  template <typename T_GetTagIndexReq_index_name_struct_setter = ::std::string>
  ::std::string& set_index_name(T_GetTagIndexReq_index_name_struct_setter&& index_name_) {
    index_name = std::forward<T_GetTagIndexReq_index_name_struct_setter>(index_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.index_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return index_name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetTagIndexReq >;
  friend void swap(GetTagIndexReq& a, GetTagIndexReq& b);
};

template <class Protocol_>
uint32_t GetTagIndexReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetTagIndexResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetTagIndexResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetTagIndexResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetTagIndexResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::IndexItem item__arg);

  GetTagIndexResp(GetTagIndexResp&&) = default;

  GetTagIndexResp(const GetTagIndexResp&) = default;


  GetTagIndexResp& operator=(GetTagIndexResp&&) = default;

  GetTagIndexResp& operator=(const GetTagIndexResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
   ::nebula::meta::cpp2::IndexItem item;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool item;
  } __isset = {};
  bool operator==(const GetTagIndexResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetTagIndexResp& __x, const GetTagIndexResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetTagIndexResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetTagIndexResp& __x, const GetTagIndexResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetTagIndexResp& __x, const GetTagIndexResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetTagIndexResp& __x, const GetTagIndexResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::IndexItem>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> item_ref() const& {
    return {this->item, __isset.item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::IndexItem>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> item_ref() const&& {
    return {std::move(this->item), __isset.item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::IndexItem>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> item_ref() & {
    return {this->item, __isset.item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::IndexItem>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> item_ref() && {
    return {std::move(this->item), __isset.item};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_GetTagIndexResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_GetTagIndexResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_GetTagIndexResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const  ::nebula::meta::cpp2::IndexItem& get_item() const&;
   ::nebula::meta::cpp2::IndexItem get_item() &&;

  template <typename T_GetTagIndexResp_item_struct_setter =  ::nebula::meta::cpp2::IndexItem>
   ::nebula::meta::cpp2::IndexItem& set_item(T_GetTagIndexResp_item_struct_setter&& item_) {
    item = std::forward<T_GetTagIndexResp_item_struct_setter>(item_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.item = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return item;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetTagIndexResp >;
  friend void swap(GetTagIndexResp& a, GetTagIndexResp& b);
};

template <class Protocol_>
uint32_t GetTagIndexResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListTagIndexesReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListTagIndexesReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListTagIndexesReq() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListTagIndexesReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg);

  ListTagIndexesReq(ListTagIndexesReq&&) = default;

  ListTagIndexesReq(const ListTagIndexesReq&) = default;


  ListTagIndexesReq& operator=(ListTagIndexesReq&&) = default;

  ListTagIndexesReq& operator=(const ListTagIndexesReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
  } __isset = {};
  bool operator==(const ListTagIndexesReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListTagIndexesReq& __x, const ListTagIndexesReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListTagIndexesReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListTagIndexesReq& __x, const ListTagIndexesReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListTagIndexesReq& __x, const ListTagIndexesReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListTagIndexesReq& __x, const ListTagIndexesReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListTagIndexesReq >;
  friend void swap(ListTagIndexesReq& a, ListTagIndexesReq& b);
};

template <class Protocol_>
uint32_t ListTagIndexesReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListTagIndexesResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListTagIndexesResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListTagIndexesResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListTagIndexesResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::IndexItem> items__arg);

  ListTagIndexesResp(ListTagIndexesResp&&) = default;

  ListTagIndexesResp(const ListTagIndexesResp&) = default;


  ListTagIndexesResp& operator=(ListTagIndexesResp&&) = default;

  ListTagIndexesResp& operator=(const ListTagIndexesResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::vector< ::nebula::meta::cpp2::IndexItem> items;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool items;
  } __isset = {};
  bool operator==(const ListTagIndexesResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListTagIndexesResp& __x, const ListTagIndexesResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListTagIndexesResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListTagIndexesResp& __x, const ListTagIndexesResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListTagIndexesResp& __x, const ListTagIndexesResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListTagIndexesResp& __x, const ListTagIndexesResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> items_ref() const& {
    return {this->items, __isset.items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> items_ref() const&& {
    return {std::move(this->items), __isset.items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> items_ref() & {
    return {this->items, __isset.items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> items_ref() && {
    return {std::move(this->items), __isset.items};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_ListTagIndexesResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_ListTagIndexesResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_ListTagIndexesResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const ::std::vector< ::nebula::meta::cpp2::IndexItem>& get_items() const&;
  ::std::vector< ::nebula::meta::cpp2::IndexItem> get_items() &&;

  template <typename T_ListTagIndexesResp_items_struct_setter = ::std::vector< ::nebula::meta::cpp2::IndexItem>>
  ::std::vector< ::nebula::meta::cpp2::IndexItem>& set_items(T_ListTagIndexesResp_items_struct_setter&& items_) {
    items = std::forward<T_ListTagIndexesResp_items_struct_setter>(items_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.items = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return items;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListTagIndexesResp >;
  friend void swap(ListTagIndexesResp& a, ListTagIndexesResp& b);
};

template <class Protocol_>
uint32_t ListTagIndexesResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class CreateEdgeIndexReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CreateEdgeIndexReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  CreateEdgeIndexReq();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CreateEdgeIndexReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string index_name__arg, ::std::string edge_name__arg, ::std::vector< ::nebula::meta::cpp2::IndexFieldDef> fields__arg, bool if_not_exists__arg, ::std::string comment__arg,  ::nebula::meta::cpp2::IndexParams index_params__arg);

  CreateEdgeIndexReq(CreateEdgeIndexReq&&) = default;

  CreateEdgeIndexReq(const CreateEdgeIndexReq&) = default;


  CreateEdgeIndexReq& operator=(CreateEdgeIndexReq&&) = default;

  CreateEdgeIndexReq& operator=(const CreateEdgeIndexReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~CreateEdgeIndexReq();

 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::string index_name;
 private:
  ::std::string edge_name;
 private:
  ::std::vector< ::nebula::meta::cpp2::IndexFieldDef> fields;
 private:
  bool if_not_exists;
 private:
  ::std::string comment;
 private:
   ::nebula::meta::cpp2::IndexParams index_params;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool index_name;
    bool edge_name;
    bool fields;
    bool if_not_exists;
    bool comment;
    bool index_params;
  } __isset = {};
  bool operator==(const CreateEdgeIndexReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CreateEdgeIndexReq& __x, const CreateEdgeIndexReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CreateEdgeIndexReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const CreateEdgeIndexReq& __x, const CreateEdgeIndexReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CreateEdgeIndexReq& __x, const CreateEdgeIndexReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CreateEdgeIndexReq& __x, const CreateEdgeIndexReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> index_name_ref() const& {
    return {this->index_name, __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> index_name_ref() const&& {
    return {std::move(this->index_name), __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> index_name_ref() & {
    return {this->index_name, __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> index_name_ref() && {
    return {std::move(this->index_name), __isset.index_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> edge_name_ref() const& {
    return {this->edge_name, __isset.edge_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> edge_name_ref() const&& {
    return {std::move(this->edge_name), __isset.edge_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> edge_name_ref() & {
    return {this->edge_name, __isset.edge_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> edge_name_ref() && {
    return {std::move(this->edge_name), __isset.edge_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fields_ref() const& {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fields_ref() const&& {
    return {std::move(this->fields), __isset.fields};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fields_ref() & {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fields_ref() && {
    return {std::move(this->fields), __isset.fields};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> if_not_exists_ref() const& {
    return {this->if_not_exists, __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> if_not_exists_ref() const&& {
    return {std::move(this->if_not_exists), __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> if_not_exists_ref() & {
    return {this->if_not_exists, __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> if_not_exists_ref() && {
    return {std::move(this->if_not_exists), __isset.if_not_exists};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> comment_ref() const& {
    return {this->comment, __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> comment_ref() const&& {
    return {std::move(this->comment), __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> comment_ref() & {
    return {this->comment, __isset.comment};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> comment_ref() && {
    return {std::move(this->comment), __isset.comment};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::IndexParams>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> index_params_ref() const& {
    return {this->index_params, __isset.index_params};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::IndexParams>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> index_params_ref() const&& {
    return {std::move(this->index_params), __isset.index_params};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::IndexParams>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> index_params_ref() & {
    return {this->index_params, __isset.index_params};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::IndexParams>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> index_params_ref() && {
    return {std::move(this->index_params), __isset.index_params};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  const ::std::string& get_index_name() const& {
    return index_name;
  }

  ::std::string get_index_name() && {
    return std::move(index_name);
  }

  template <typename T_CreateEdgeIndexReq_index_name_struct_setter = ::std::string>
  ::std::string& set_index_name(T_CreateEdgeIndexReq_index_name_struct_setter&& index_name_) {
    index_name = std::forward<T_CreateEdgeIndexReq_index_name_struct_setter>(index_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.index_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return index_name;
  }

  const ::std::string& get_edge_name() const& {
    return edge_name;
  }

  ::std::string get_edge_name() && {
    return std::move(edge_name);
  }

  template <typename T_CreateEdgeIndexReq_edge_name_struct_setter = ::std::string>
  ::std::string& set_edge_name(T_CreateEdgeIndexReq_edge_name_struct_setter&& edge_name_) {
    edge_name = std::forward<T_CreateEdgeIndexReq_edge_name_struct_setter>(edge_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.edge_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return edge_name;
  }
  const ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>& get_fields() const&;
  ::std::vector< ::nebula::meta::cpp2::IndexFieldDef> get_fields() &&;

  template <typename T_CreateEdgeIndexReq_fields_struct_setter = ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>>
  ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>& set_fields(T_CreateEdgeIndexReq_fields_struct_setter&& fields_) {
    fields = std::forward<T_CreateEdgeIndexReq_fields_struct_setter>(fields_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fields = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fields;
  }

  bool get_if_not_exists() const {
    return if_not_exists;
  }

  bool& set_if_not_exists(bool if_not_exists_) {
    if_not_exists = if_not_exists_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.if_not_exists = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return if_not_exists;
  }

  const ::std::string* get_comment() const& {
    return comment_ref() ? std::addressof(comment) : nullptr;
  }

  ::std::string* get_comment() & {
    return comment_ref() ? std::addressof(comment) : nullptr;
  }
  ::std::string* get_comment() && = delete;

  template <typename T_CreateEdgeIndexReq_comment_struct_setter = ::std::string>
  ::std::string& set_comment(T_CreateEdgeIndexReq_comment_struct_setter&& comment_) {
    comment = std::forward<T_CreateEdgeIndexReq_comment_struct_setter>(comment_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.comment = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return comment;
  }
  const  ::nebula::meta::cpp2::IndexParams* get_index_params() const&;
   ::nebula::meta::cpp2::IndexParams* get_index_params() &;
   ::nebula::meta::cpp2::IndexParams* get_index_params() && = delete;

  template <typename T_CreateEdgeIndexReq_index_params_struct_setter =  ::nebula::meta::cpp2::IndexParams>
   ::nebula::meta::cpp2::IndexParams& set_index_params(T_CreateEdgeIndexReq_index_params_struct_setter&& index_params_) {
    index_params = std::forward<T_CreateEdgeIndexReq_index_params_struct_setter>(index_params_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.index_params = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return index_params;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CreateEdgeIndexReq >;
  friend void swap(CreateEdgeIndexReq& a, CreateEdgeIndexReq& b);
};

template <class Protocol_>
uint32_t CreateEdgeIndexReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class DropEdgeIndexReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = DropEdgeIndexReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  DropEdgeIndexReq() :
      space_id(0),
      if_exists(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  DropEdgeIndexReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string index_name__arg, bool if_exists__arg);

  DropEdgeIndexReq(DropEdgeIndexReq&&) = default;

  DropEdgeIndexReq(const DropEdgeIndexReq&) = default;


  DropEdgeIndexReq& operator=(DropEdgeIndexReq&&) = default;

  DropEdgeIndexReq& operator=(const DropEdgeIndexReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::string index_name;
 private:
  bool if_exists;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool index_name;
    bool if_exists;
  } __isset = {};
  bool operator==(const DropEdgeIndexReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const DropEdgeIndexReq& __x, const DropEdgeIndexReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const DropEdgeIndexReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const DropEdgeIndexReq& __x, const DropEdgeIndexReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const DropEdgeIndexReq& __x, const DropEdgeIndexReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const DropEdgeIndexReq& __x, const DropEdgeIndexReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> index_name_ref() const& {
    return {this->index_name, __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> index_name_ref() const&& {
    return {std::move(this->index_name), __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> index_name_ref() & {
    return {this->index_name, __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> index_name_ref() && {
    return {std::move(this->index_name), __isset.index_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> if_exists_ref() const& {
    return {this->if_exists, __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> if_exists_ref() const&& {
    return {std::move(this->if_exists), __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> if_exists_ref() & {
    return {this->if_exists, __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> if_exists_ref() && {
    return {std::move(this->if_exists), __isset.if_exists};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  const ::std::string& get_index_name() const& {
    return index_name;
  }

  ::std::string get_index_name() && {
    return std::move(index_name);
  }

  template <typename T_DropEdgeIndexReq_index_name_struct_setter = ::std::string>
  ::std::string& set_index_name(T_DropEdgeIndexReq_index_name_struct_setter&& index_name_) {
    index_name = std::forward<T_DropEdgeIndexReq_index_name_struct_setter>(index_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.index_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return index_name;
  }

  bool get_if_exists() const {
    return if_exists;
  }

  bool& set_if_exists(bool if_exists_) {
    if_exists = if_exists_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.if_exists = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return if_exists;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< DropEdgeIndexReq >;
  friend void swap(DropEdgeIndexReq& a, DropEdgeIndexReq& b);
};

template <class Protocol_>
uint32_t DropEdgeIndexReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetEdgeIndexReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetEdgeIndexReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetEdgeIndexReq() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetEdgeIndexReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string index_name__arg);

  GetEdgeIndexReq(GetEdgeIndexReq&&) = default;

  GetEdgeIndexReq(const GetEdgeIndexReq&) = default;


  GetEdgeIndexReq& operator=(GetEdgeIndexReq&&) = default;

  GetEdgeIndexReq& operator=(const GetEdgeIndexReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::string index_name;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool index_name;
  } __isset = {};
  bool operator==(const GetEdgeIndexReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetEdgeIndexReq& __x, const GetEdgeIndexReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetEdgeIndexReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetEdgeIndexReq& __x, const GetEdgeIndexReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetEdgeIndexReq& __x, const GetEdgeIndexReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetEdgeIndexReq& __x, const GetEdgeIndexReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> index_name_ref() const& {
    return {this->index_name, __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> index_name_ref() const&& {
    return {std::move(this->index_name), __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> index_name_ref() & {
    return {this->index_name, __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> index_name_ref() && {
    return {std::move(this->index_name), __isset.index_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  const ::std::string& get_index_name() const& {
    return index_name;
  }

  ::std::string get_index_name() && {
    return std::move(index_name);
  }

  template <typename T_GetEdgeIndexReq_index_name_struct_setter = ::std::string>
  ::std::string& set_index_name(T_GetEdgeIndexReq_index_name_struct_setter&& index_name_) {
    index_name = std::forward<T_GetEdgeIndexReq_index_name_struct_setter>(index_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.index_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return index_name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetEdgeIndexReq >;
  friend void swap(GetEdgeIndexReq& a, GetEdgeIndexReq& b);
};

template <class Protocol_>
uint32_t GetEdgeIndexReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetEdgeIndexResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetEdgeIndexResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetEdgeIndexResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetEdgeIndexResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::IndexItem item__arg);

  GetEdgeIndexResp(GetEdgeIndexResp&&) = default;

  GetEdgeIndexResp(const GetEdgeIndexResp&) = default;


  GetEdgeIndexResp& operator=(GetEdgeIndexResp&&) = default;

  GetEdgeIndexResp& operator=(const GetEdgeIndexResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
   ::nebula::meta::cpp2::IndexItem item;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool item;
  } __isset = {};
  bool operator==(const GetEdgeIndexResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetEdgeIndexResp& __x, const GetEdgeIndexResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetEdgeIndexResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetEdgeIndexResp& __x, const GetEdgeIndexResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetEdgeIndexResp& __x, const GetEdgeIndexResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetEdgeIndexResp& __x, const GetEdgeIndexResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::IndexItem>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> item_ref() const& {
    return {this->item, __isset.item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::IndexItem>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> item_ref() const&& {
    return {std::move(this->item), __isset.item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::IndexItem>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> item_ref() & {
    return {this->item, __isset.item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::IndexItem>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> item_ref() && {
    return {std::move(this->item), __isset.item};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_GetEdgeIndexResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_GetEdgeIndexResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_GetEdgeIndexResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const  ::nebula::meta::cpp2::IndexItem& get_item() const&;
   ::nebula::meta::cpp2::IndexItem get_item() &&;

  template <typename T_GetEdgeIndexResp_item_struct_setter =  ::nebula::meta::cpp2::IndexItem>
   ::nebula::meta::cpp2::IndexItem& set_item(T_GetEdgeIndexResp_item_struct_setter&& item_) {
    item = std::forward<T_GetEdgeIndexResp_item_struct_setter>(item_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.item = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return item;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetEdgeIndexResp >;
  friend void swap(GetEdgeIndexResp& a, GetEdgeIndexResp& b);
};

template <class Protocol_>
uint32_t GetEdgeIndexResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListEdgeIndexesReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListEdgeIndexesReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListEdgeIndexesReq() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListEdgeIndexesReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg);

  ListEdgeIndexesReq(ListEdgeIndexesReq&&) = default;

  ListEdgeIndexesReq(const ListEdgeIndexesReq&) = default;


  ListEdgeIndexesReq& operator=(ListEdgeIndexesReq&&) = default;

  ListEdgeIndexesReq& operator=(const ListEdgeIndexesReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
  } __isset = {};
  bool operator==(const ListEdgeIndexesReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListEdgeIndexesReq& __x, const ListEdgeIndexesReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListEdgeIndexesReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListEdgeIndexesReq& __x, const ListEdgeIndexesReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListEdgeIndexesReq& __x, const ListEdgeIndexesReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListEdgeIndexesReq& __x, const ListEdgeIndexesReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListEdgeIndexesReq >;
  friend void swap(ListEdgeIndexesReq& a, ListEdgeIndexesReq& b);
};

template <class Protocol_>
uint32_t ListEdgeIndexesReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListEdgeIndexesResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListEdgeIndexesResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListEdgeIndexesResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListEdgeIndexesResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::IndexItem> items__arg);

  ListEdgeIndexesResp(ListEdgeIndexesResp&&) = default;

  ListEdgeIndexesResp(const ListEdgeIndexesResp&) = default;


  ListEdgeIndexesResp& operator=(ListEdgeIndexesResp&&) = default;

  ListEdgeIndexesResp& operator=(const ListEdgeIndexesResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::vector< ::nebula::meta::cpp2::IndexItem> items;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool items;
  } __isset = {};
  bool operator==(const ListEdgeIndexesResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListEdgeIndexesResp& __x, const ListEdgeIndexesResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListEdgeIndexesResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListEdgeIndexesResp& __x, const ListEdgeIndexesResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListEdgeIndexesResp& __x, const ListEdgeIndexesResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListEdgeIndexesResp& __x, const ListEdgeIndexesResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> items_ref() const& {
    return {this->items, __isset.items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> items_ref() const&& {
    return {std::move(this->items), __isset.items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> items_ref() & {
    return {this->items, __isset.items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> items_ref() && {
    return {std::move(this->items), __isset.items};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_ListEdgeIndexesResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_ListEdgeIndexesResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_ListEdgeIndexesResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const ::std::vector< ::nebula::meta::cpp2::IndexItem>& get_items() const&;
  ::std::vector< ::nebula::meta::cpp2::IndexItem> get_items() &&;

  template <typename T_ListEdgeIndexesResp_items_struct_setter = ::std::vector< ::nebula::meta::cpp2::IndexItem>>
  ::std::vector< ::nebula::meta::cpp2::IndexItem>& set_items(T_ListEdgeIndexesResp_items_struct_setter&& items_) {
    items = std::forward<T_ListEdgeIndexesResp_items_struct_setter>(items_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.items = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return items;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListEdgeIndexesResp >;
  friend void swap(ListEdgeIndexesResp& a, ListEdgeIndexesResp& b);
};

template <class Protocol_>
uint32_t ListEdgeIndexesResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class RebuildIndexReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = RebuildIndexReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  RebuildIndexReq() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RebuildIndexReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string index_name__arg);

  RebuildIndexReq(RebuildIndexReq&&) = default;

  RebuildIndexReq(const RebuildIndexReq&) = default;


  RebuildIndexReq& operator=(RebuildIndexReq&&) = default;

  RebuildIndexReq& operator=(const RebuildIndexReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::string index_name;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool index_name;
  } __isset = {};
  bool operator==(const RebuildIndexReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const RebuildIndexReq& __x, const RebuildIndexReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const RebuildIndexReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const RebuildIndexReq& __x, const RebuildIndexReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const RebuildIndexReq& __x, const RebuildIndexReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const RebuildIndexReq& __x, const RebuildIndexReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> index_name_ref() const& {
    return {this->index_name, __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> index_name_ref() const&& {
    return {std::move(this->index_name), __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> index_name_ref() & {
    return {this->index_name, __isset.index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> index_name_ref() && {
    return {std::move(this->index_name), __isset.index_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  const ::std::string& get_index_name() const& {
    return index_name;
  }

  ::std::string get_index_name() && {
    return std::move(index_name);
  }

  template <typename T_RebuildIndexReq_index_name_struct_setter = ::std::string>
  ::std::string& set_index_name(T_RebuildIndexReq_index_name_struct_setter&& index_name_) {
    index_name = std::forward<T_RebuildIndexReq_index_name_struct_setter>(index_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.index_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return index_name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< RebuildIndexReq >;
  friend void swap(RebuildIndexReq& a, RebuildIndexReq& b);
};

template <class Protocol_>
uint32_t RebuildIndexReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class CreateUserReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CreateUserReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  CreateUserReq() :
      if_not_exists(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CreateUserReq(apache::thrift::FragileConstructor, ::std::string account__arg, ::std::string encoded_pwd__arg, bool if_not_exists__arg);

  CreateUserReq(CreateUserReq&&) = default;

  CreateUserReq(const CreateUserReq&) = default;


  CreateUserReq& operator=(CreateUserReq&&) = default;

  CreateUserReq& operator=(const CreateUserReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string account;
 private:
  ::std::string encoded_pwd;
 private:
  bool if_not_exists;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool account;
    bool encoded_pwd;
    bool if_not_exists;
  } __isset = {};
  bool operator==(const CreateUserReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CreateUserReq& __x, const CreateUserReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CreateUserReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const CreateUserReq& __x, const CreateUserReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CreateUserReq& __x, const CreateUserReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CreateUserReq& __x, const CreateUserReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> account_ref() const& {
    return {this->account, __isset.account};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> account_ref() const&& {
    return {std::move(this->account), __isset.account};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> account_ref() & {
    return {this->account, __isset.account};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> account_ref() && {
    return {std::move(this->account), __isset.account};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> encoded_pwd_ref() const& {
    return {this->encoded_pwd, __isset.encoded_pwd};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> encoded_pwd_ref() const&& {
    return {std::move(this->encoded_pwd), __isset.encoded_pwd};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> encoded_pwd_ref() & {
    return {this->encoded_pwd, __isset.encoded_pwd};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> encoded_pwd_ref() && {
    return {std::move(this->encoded_pwd), __isset.encoded_pwd};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> if_not_exists_ref() const& {
    return {this->if_not_exists, __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> if_not_exists_ref() const&& {
    return {std::move(this->if_not_exists), __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> if_not_exists_ref() & {
    return {this->if_not_exists, __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> if_not_exists_ref() && {
    return {std::move(this->if_not_exists), __isset.if_not_exists};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_account() const& {
    return account;
  }

  ::std::string get_account() && {
    return std::move(account);
  }

  template <typename T_CreateUserReq_account_struct_setter = ::std::string>
  ::std::string& set_account(T_CreateUserReq_account_struct_setter&& account_) {
    account = std::forward<T_CreateUserReq_account_struct_setter>(account_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.account = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return account;
  }

  const ::std::string& get_encoded_pwd() const& {
    return encoded_pwd;
  }

  ::std::string get_encoded_pwd() && {
    return std::move(encoded_pwd);
  }

  template <typename T_CreateUserReq_encoded_pwd_struct_setter = ::std::string>
  ::std::string& set_encoded_pwd(T_CreateUserReq_encoded_pwd_struct_setter&& encoded_pwd_) {
    encoded_pwd = std::forward<T_CreateUserReq_encoded_pwd_struct_setter>(encoded_pwd_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.encoded_pwd = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return encoded_pwd;
  }

  bool get_if_not_exists() const {
    return if_not_exists;
  }

  bool& set_if_not_exists(bool if_not_exists_) {
    if_not_exists = if_not_exists_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.if_not_exists = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return if_not_exists;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CreateUserReq >;
  friend void swap(CreateUserReq& a, CreateUserReq& b);
};

template <class Protocol_>
uint32_t CreateUserReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class DropUserReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = DropUserReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  DropUserReq() :
      if_exists(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  DropUserReq(apache::thrift::FragileConstructor, ::std::string account__arg, bool if_exists__arg);

  DropUserReq(DropUserReq&&) = default;

  DropUserReq(const DropUserReq&) = default;


  DropUserReq& operator=(DropUserReq&&) = default;

  DropUserReq& operator=(const DropUserReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string account;
 private:
  bool if_exists;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool account;
    bool if_exists;
  } __isset = {};
  bool operator==(const DropUserReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const DropUserReq& __x, const DropUserReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const DropUserReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const DropUserReq& __x, const DropUserReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const DropUserReq& __x, const DropUserReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const DropUserReq& __x, const DropUserReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> account_ref() const& {
    return {this->account, __isset.account};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> account_ref() const&& {
    return {std::move(this->account), __isset.account};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> account_ref() & {
    return {this->account, __isset.account};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> account_ref() && {
    return {std::move(this->account), __isset.account};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> if_exists_ref() const& {
    return {this->if_exists, __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> if_exists_ref() const&& {
    return {std::move(this->if_exists), __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> if_exists_ref() & {
    return {this->if_exists, __isset.if_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> if_exists_ref() && {
    return {std::move(this->if_exists), __isset.if_exists};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_account() const& {
    return account;
  }

  ::std::string get_account() && {
    return std::move(account);
  }

  template <typename T_DropUserReq_account_struct_setter = ::std::string>
  ::std::string& set_account(T_DropUserReq_account_struct_setter&& account_) {
    account = std::forward<T_DropUserReq_account_struct_setter>(account_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.account = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return account;
  }

  bool get_if_exists() const {
    return if_exists;
  }

  bool& set_if_exists(bool if_exists_) {
    if_exists = if_exists_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.if_exists = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return if_exists;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< DropUserReq >;
  friend void swap(DropUserReq& a, DropUserReq& b);
};

template <class Protocol_>
uint32_t DropUserReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class AlterUserReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AlterUserReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  AlterUserReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AlterUserReq(apache::thrift::FragileConstructor, ::std::string account__arg, ::std::string encoded_pwd__arg);

  AlterUserReq(AlterUserReq&&) = default;

  AlterUserReq(const AlterUserReq&) = default;


  AlterUserReq& operator=(AlterUserReq&&) = default;

  AlterUserReq& operator=(const AlterUserReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string account;
 private:
  ::std::string encoded_pwd;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool account;
    bool encoded_pwd;
  } __isset = {};
  bool operator==(const AlterUserReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AlterUserReq& __x, const AlterUserReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AlterUserReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const AlterUserReq& __x, const AlterUserReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AlterUserReq& __x, const AlterUserReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AlterUserReq& __x, const AlterUserReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> account_ref() const& {
    return {this->account, __isset.account};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> account_ref() const&& {
    return {std::move(this->account), __isset.account};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> account_ref() & {
    return {this->account, __isset.account};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> account_ref() && {
    return {std::move(this->account), __isset.account};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> encoded_pwd_ref() const& {
    return {this->encoded_pwd, __isset.encoded_pwd};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> encoded_pwd_ref() const&& {
    return {std::move(this->encoded_pwd), __isset.encoded_pwd};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> encoded_pwd_ref() & {
    return {this->encoded_pwd, __isset.encoded_pwd};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> encoded_pwd_ref() && {
    return {std::move(this->encoded_pwd), __isset.encoded_pwd};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_account() const& {
    return account;
  }

  ::std::string get_account() && {
    return std::move(account);
  }

  template <typename T_AlterUserReq_account_struct_setter = ::std::string>
  ::std::string& set_account(T_AlterUserReq_account_struct_setter&& account_) {
    account = std::forward<T_AlterUserReq_account_struct_setter>(account_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.account = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return account;
  }

  const ::std::string& get_encoded_pwd() const& {
    return encoded_pwd;
  }

  ::std::string get_encoded_pwd() && {
    return std::move(encoded_pwd);
  }

  template <typename T_AlterUserReq_encoded_pwd_struct_setter = ::std::string>
  ::std::string& set_encoded_pwd(T_AlterUserReq_encoded_pwd_struct_setter&& encoded_pwd_) {
    encoded_pwd = std::forward<T_AlterUserReq_encoded_pwd_struct_setter>(encoded_pwd_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.encoded_pwd = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return encoded_pwd;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AlterUserReq >;
  friend void swap(AlterUserReq& a, AlterUserReq& b);
};

template <class Protocol_>
uint32_t AlterUserReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GrantRoleReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GrantRoleReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GrantRoleReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GrantRoleReq(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::RoleItem role_item__arg);

  GrantRoleReq(GrantRoleReq&&) = default;

  GrantRoleReq(const GrantRoleReq&) = default;


  GrantRoleReq& operator=(GrantRoleReq&&) = default;

  GrantRoleReq& operator=(const GrantRoleReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::meta::cpp2::RoleItem role_item;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool role_item;
  } __isset = {};
  bool operator==(const GrantRoleReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GrantRoleReq& __x, const GrantRoleReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GrantRoleReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const GrantRoleReq& __x, const GrantRoleReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GrantRoleReq& __x, const GrantRoleReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GrantRoleReq& __x, const GrantRoleReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::RoleItem>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> role_item_ref() const& {
    return {this->role_item, __isset.role_item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::RoleItem>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> role_item_ref() const&& {
    return {std::move(this->role_item), __isset.role_item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::RoleItem>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> role_item_ref() & {
    return {this->role_item, __isset.role_item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::RoleItem>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> role_item_ref() && {
    return {std::move(this->role_item), __isset.role_item};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::meta::cpp2::RoleItem& get_role_item() const&;
   ::nebula::meta::cpp2::RoleItem get_role_item() &&;

  template <typename T_GrantRoleReq_role_item_struct_setter =  ::nebula::meta::cpp2::RoleItem>
   ::nebula::meta::cpp2::RoleItem& set_role_item(T_GrantRoleReq_role_item_struct_setter&& role_item_) {
    role_item = std::forward<T_GrantRoleReq_role_item_struct_setter>(role_item_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.role_item = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return role_item;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GrantRoleReq >;
  friend void swap(GrantRoleReq& a, GrantRoleReq& b);
};

template <class Protocol_>
uint32_t GrantRoleReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class RevokeRoleReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = RevokeRoleReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  RevokeRoleReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RevokeRoleReq(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::RoleItem role_item__arg);

  RevokeRoleReq(RevokeRoleReq&&) = default;

  RevokeRoleReq(const RevokeRoleReq&) = default;


  RevokeRoleReq& operator=(RevokeRoleReq&&) = default;

  RevokeRoleReq& operator=(const RevokeRoleReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::meta::cpp2::RoleItem role_item;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool role_item;
  } __isset = {};
  bool operator==(const RevokeRoleReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const RevokeRoleReq& __x, const RevokeRoleReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const RevokeRoleReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const RevokeRoleReq& __x, const RevokeRoleReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const RevokeRoleReq& __x, const RevokeRoleReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const RevokeRoleReq& __x, const RevokeRoleReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::RoleItem>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> role_item_ref() const& {
    return {this->role_item, __isset.role_item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::RoleItem>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> role_item_ref() const&& {
    return {std::move(this->role_item), __isset.role_item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::RoleItem>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> role_item_ref() & {
    return {this->role_item, __isset.role_item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::RoleItem>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> role_item_ref() && {
    return {std::move(this->role_item), __isset.role_item};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::meta::cpp2::RoleItem& get_role_item() const&;
   ::nebula::meta::cpp2::RoleItem get_role_item() &&;

  template <typename T_RevokeRoleReq_role_item_struct_setter =  ::nebula::meta::cpp2::RoleItem>
   ::nebula::meta::cpp2::RoleItem& set_role_item(T_RevokeRoleReq_role_item_struct_setter&& role_item_) {
    role_item = std::forward<T_RevokeRoleReq_role_item_struct_setter>(role_item_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.role_item = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return role_item;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< RevokeRoleReq >;
  friend void swap(RevokeRoleReq& a, RevokeRoleReq& b);
};

template <class Protocol_>
uint32_t RevokeRoleReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListUsersReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListUsersReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListUsersReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListUsersReq(apache::thrift::FragileConstructor);

  ListUsersReq(ListUsersReq&&) = default;

  ListUsersReq(const ListUsersReq&) = default;


  ListUsersReq& operator=(ListUsersReq&&) = default;

  ListUsersReq& operator=(const ListUsersReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
  bool operator==(const ListUsersReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListUsersReq& __x, const ListUsersReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListUsersReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListUsersReq& __x, const ListUsersReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListUsersReq& __x, const ListUsersReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListUsersReq& __x, const ListUsersReq& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListUsersReq >;
  friend void swap(ListUsersReq& a, ListUsersReq& b);
};

template <class Protocol_>
uint32_t ListUsersReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListUsersResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListUsersResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListUsersResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListUsersResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, std::unordered_map<::std::string, ::std::string> users__arg);

  ListUsersResp(ListUsersResp&&) = default;

  ListUsersResp(const ListUsersResp&) = default;


  ListUsersResp& operator=(ListUsersResp&&) = default;

  ListUsersResp& operator=(const ListUsersResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  std::unordered_map<::std::string, ::std::string> users;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool users;
  } __isset = {};
  bool operator==(const ListUsersResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListUsersResp& __x, const ListUsersResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListUsersResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListUsersResp& __x, const ListUsersResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListUsersResp& __x, const ListUsersResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListUsersResp& __x, const ListUsersResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> users_ref() const& {
    return {this->users, __isset.users};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> users_ref() const&& {
    return {std::move(this->users), __isset.users};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> users_ref() & {
    return {this->users, __isset.users};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> users_ref() && {
    return {std::move(this->users), __isset.users};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_ListUsersResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_ListUsersResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_ListUsersResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const std::unordered_map<::std::string, ::std::string>& get_users() const&;
  std::unordered_map<::std::string, ::std::string> get_users() &&;

  template <typename T_ListUsersResp_users_struct_setter = std::unordered_map<::std::string, ::std::string>>
  std::unordered_map<::std::string, ::std::string>& set_users(T_ListUsersResp_users_struct_setter&& users_) {
    users = std::forward<T_ListUsersResp_users_struct_setter>(users_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.users = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return users;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListUsersResp >;
  friend void swap(ListUsersResp& a, ListUsersResp& b);
};

template <class Protocol_>
uint32_t ListUsersResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListRolesReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListRolesReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListRolesReq() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListRolesReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg);

  ListRolesReq(ListRolesReq&&) = default;

  ListRolesReq(const ListRolesReq&) = default;


  ListRolesReq& operator=(ListRolesReq&&) = default;

  ListRolesReq& operator=(const ListRolesReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
  } __isset = {};
  bool operator==(const ListRolesReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListRolesReq& __x, const ListRolesReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListRolesReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListRolesReq& __x, const ListRolesReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListRolesReq& __x, const ListRolesReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListRolesReq& __x, const ListRolesReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListRolesReq >;
  friend void swap(ListRolesReq& a, ListRolesReq& b);
};

template <class Protocol_>
uint32_t ListRolesReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListRolesResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListRolesResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListRolesResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListRolesResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::RoleItem> roles__arg);

  ListRolesResp(ListRolesResp&&) = default;

  ListRolesResp(const ListRolesResp&) = default;


  ListRolesResp& operator=(ListRolesResp&&) = default;

  ListRolesResp& operator=(const ListRolesResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::vector< ::nebula::meta::cpp2::RoleItem> roles;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool roles;
  } __isset = {};
  bool operator==(const ListRolesResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListRolesResp& __x, const ListRolesResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListRolesResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListRolesResp& __x, const ListRolesResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListRolesResp& __x, const ListRolesResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListRolesResp& __x, const ListRolesResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::RoleItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> roles_ref() const& {
    return {this->roles, __isset.roles};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::RoleItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> roles_ref() const&& {
    return {std::move(this->roles), __isset.roles};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::RoleItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> roles_ref() & {
    return {this->roles, __isset.roles};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::RoleItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> roles_ref() && {
    return {std::move(this->roles), __isset.roles};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_ListRolesResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_ListRolesResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_ListRolesResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const ::std::vector< ::nebula::meta::cpp2::RoleItem>& get_roles() const&;
  ::std::vector< ::nebula::meta::cpp2::RoleItem> get_roles() &&;

  template <typename T_ListRolesResp_roles_struct_setter = ::std::vector< ::nebula::meta::cpp2::RoleItem>>
  ::std::vector< ::nebula::meta::cpp2::RoleItem>& set_roles(T_ListRolesResp_roles_struct_setter&& roles_) {
    roles = std::forward<T_ListRolesResp_roles_struct_setter>(roles_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.roles = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return roles;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListRolesResp >;
  friend void swap(ListRolesResp& a, ListRolesResp& b);
};

template <class Protocol_>
uint32_t ListRolesResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetUserRolesReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetUserRolesReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetUserRolesReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetUserRolesReq(apache::thrift::FragileConstructor, ::std::string account__arg);

  GetUserRolesReq(GetUserRolesReq&&) = default;

  GetUserRolesReq(const GetUserRolesReq&) = default;


  GetUserRolesReq& operator=(GetUserRolesReq&&) = default;

  GetUserRolesReq& operator=(const GetUserRolesReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string account;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool account;
  } __isset = {};
  bool operator==(const GetUserRolesReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetUserRolesReq& __x, const GetUserRolesReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetUserRolesReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetUserRolesReq& __x, const GetUserRolesReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetUserRolesReq& __x, const GetUserRolesReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetUserRolesReq& __x, const GetUserRolesReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> account_ref() const& {
    return {this->account, __isset.account};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> account_ref() const&& {
    return {std::move(this->account), __isset.account};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> account_ref() & {
    return {this->account, __isset.account};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> account_ref() && {
    return {std::move(this->account), __isset.account};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_account() const& {
    return account;
  }

  ::std::string get_account() && {
    return std::move(account);
  }

  template <typename T_GetUserRolesReq_account_struct_setter = ::std::string>
  ::std::string& set_account(T_GetUserRolesReq_account_struct_setter&& account_) {
    account = std::forward<T_GetUserRolesReq_account_struct_setter>(account_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.account = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return account;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetUserRolesReq >;
  friend void swap(GetUserRolesReq& a, GetUserRolesReq& b);
};

template <class Protocol_>
uint32_t GetUserRolesReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ChangePasswordReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ChangePasswordReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ChangePasswordReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ChangePasswordReq(apache::thrift::FragileConstructor, ::std::string account__arg, ::std::string new_encoded_pwd__arg, ::std::string old_encoded_pwd__arg);

  ChangePasswordReq(ChangePasswordReq&&) = default;

  ChangePasswordReq(const ChangePasswordReq&) = default;


  ChangePasswordReq& operator=(ChangePasswordReq&&) = default;

  ChangePasswordReq& operator=(const ChangePasswordReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string account;
 private:
  ::std::string new_encoded_pwd;
 private:
  ::std::string old_encoded_pwd;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool account;
    bool new_encoded_pwd;
    bool old_encoded_pwd;
  } __isset = {};
  bool operator==(const ChangePasswordReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ChangePasswordReq& __x, const ChangePasswordReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ChangePasswordReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ChangePasswordReq& __x, const ChangePasswordReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ChangePasswordReq& __x, const ChangePasswordReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ChangePasswordReq& __x, const ChangePasswordReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> account_ref() const& {
    return {this->account, __isset.account};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> account_ref() const&& {
    return {std::move(this->account), __isset.account};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> account_ref() & {
    return {this->account, __isset.account};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> account_ref() && {
    return {std::move(this->account), __isset.account};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> new_encoded_pwd_ref() const& {
    return {this->new_encoded_pwd, __isset.new_encoded_pwd};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> new_encoded_pwd_ref() const&& {
    return {std::move(this->new_encoded_pwd), __isset.new_encoded_pwd};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> new_encoded_pwd_ref() & {
    return {this->new_encoded_pwd, __isset.new_encoded_pwd};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> new_encoded_pwd_ref() && {
    return {std::move(this->new_encoded_pwd), __isset.new_encoded_pwd};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> old_encoded_pwd_ref() const& {
    return {this->old_encoded_pwd, __isset.old_encoded_pwd};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> old_encoded_pwd_ref() const&& {
    return {std::move(this->old_encoded_pwd), __isset.old_encoded_pwd};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> old_encoded_pwd_ref() & {
    return {this->old_encoded_pwd, __isset.old_encoded_pwd};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> old_encoded_pwd_ref() && {
    return {std::move(this->old_encoded_pwd), __isset.old_encoded_pwd};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_account() const& {
    return account;
  }

  ::std::string get_account() && {
    return std::move(account);
  }

  template <typename T_ChangePasswordReq_account_struct_setter = ::std::string>
  ::std::string& set_account(T_ChangePasswordReq_account_struct_setter&& account_) {
    account = std::forward<T_ChangePasswordReq_account_struct_setter>(account_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.account = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return account;
  }

  const ::std::string& get_new_encoded_pwd() const& {
    return new_encoded_pwd;
  }

  ::std::string get_new_encoded_pwd() && {
    return std::move(new_encoded_pwd);
  }

  template <typename T_ChangePasswordReq_new_encoded_pwd_struct_setter = ::std::string>
  ::std::string& set_new_encoded_pwd(T_ChangePasswordReq_new_encoded_pwd_struct_setter&& new_encoded_pwd_) {
    new_encoded_pwd = std::forward<T_ChangePasswordReq_new_encoded_pwd_struct_setter>(new_encoded_pwd_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.new_encoded_pwd = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return new_encoded_pwd;
  }

  const ::std::string& get_old_encoded_pwd() const& {
    return old_encoded_pwd;
  }

  ::std::string get_old_encoded_pwd() && {
    return std::move(old_encoded_pwd);
  }

  template <typename T_ChangePasswordReq_old_encoded_pwd_struct_setter = ::std::string>
  ::std::string& set_old_encoded_pwd(T_ChangePasswordReq_old_encoded_pwd_struct_setter&& old_encoded_pwd_) {
    old_encoded_pwd = std::forward<T_ChangePasswordReq_old_encoded_pwd_struct_setter>(old_encoded_pwd_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.old_encoded_pwd = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return old_encoded_pwd;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ChangePasswordReq >;
  friend void swap(ChangePasswordReq& a, ChangePasswordReq& b);
};

template <class Protocol_>
uint32_t ChangePasswordReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class BalanceTask final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = BalanceTask;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  BalanceTask();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  BalanceTask(apache::thrift::FragileConstructor, ::std::string id__arg, ::std::string command__arg,  ::nebula::meta::cpp2::TaskResult result__arg, int64_t start_time__arg, int64_t stop_time__arg);

  BalanceTask(BalanceTask&&) = default;

  BalanceTask(const BalanceTask&) = default;


  BalanceTask& operator=(BalanceTask&&) = default;

  BalanceTask& operator=(const BalanceTask&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~BalanceTask();

 private:
  ::std::string id;
 private:
  ::std::string command;
 private:
   ::nebula::meta::cpp2::TaskResult result;
 private:
  int64_t start_time;
 private:
  int64_t stop_time;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool id;
    bool command;
    bool result;
    bool start_time;
    bool stop_time;
  } __isset = {};
  bool operator==(const BalanceTask& rhs) const;
#ifndef SWIG
  friend bool operator!=(const BalanceTask& __x, const BalanceTask& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const BalanceTask& rhs) const;
#ifndef SWIG
  friend bool operator>(const BalanceTask& __x, const BalanceTask& __y) {
    return __y < __x;
  }
  friend bool operator<=(const BalanceTask& __x, const BalanceTask& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const BalanceTask& __x, const BalanceTask& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> id_ref() const& {
    return {this->id, __isset.id};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> id_ref() const&& {
    return {std::move(this->id), __isset.id};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> id_ref() & {
    return {this->id, __isset.id};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> id_ref() && {
    return {std::move(this->id), __isset.id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> command_ref() const& {
    return {this->command, __isset.command};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> command_ref() const&& {
    return {std::move(this->command), __isset.command};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> command_ref() & {
    return {this->command, __isset.command};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> command_ref() && {
    return {std::move(this->command), __isset.command};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::TaskResult>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> result_ref() const& {
    return {this->result, __isset.result};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::TaskResult>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> result_ref() const&& {
    return {std::move(this->result), __isset.result};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::TaskResult>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> result_ref() & {
    return {this->result, __isset.result};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::TaskResult>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> result_ref() && {
    return {std::move(this->result), __isset.result};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> start_time_ref() const& {
    return {this->start_time, __isset.start_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> start_time_ref() const&& {
    return {std::move(this->start_time), __isset.start_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> start_time_ref() & {
    return {this->start_time, __isset.start_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> start_time_ref() && {
    return {std::move(this->start_time), __isset.start_time};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> stop_time_ref() const& {
    return {this->stop_time, __isset.stop_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> stop_time_ref() const&& {
    return {std::move(this->stop_time), __isset.stop_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> stop_time_ref() & {
    return {this->stop_time, __isset.stop_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> stop_time_ref() && {
    return {std::move(this->stop_time), __isset.stop_time};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_id() const& {
    return id;
  }

  ::std::string get_id() && {
    return std::move(id);
  }

  template <typename T_BalanceTask_id_struct_setter = ::std::string>
  ::std::string& set_id(T_BalanceTask_id_struct_setter&& id_) {
    id = std::forward<T_BalanceTask_id_struct_setter>(id_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return id;
  }

  const ::std::string& get_command() const& {
    return command;
  }

  ::std::string get_command() && {
    return std::move(command);
  }

  template <typename T_BalanceTask_command_struct_setter = ::std::string>
  ::std::string& set_command(T_BalanceTask_command_struct_setter&& command_) {
    command = std::forward<T_BalanceTask_command_struct_setter>(command_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.command = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return command;
  }

   ::nebula::meta::cpp2::TaskResult get_result() const {
    return result;
  }

   ::nebula::meta::cpp2::TaskResult& set_result( ::nebula::meta::cpp2::TaskResult result_) {
    result = result_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.result = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return result;
  }

  int64_t get_start_time() const {
    return start_time;
  }

  int64_t& set_start_time(int64_t start_time_) {
    start_time = start_time_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.start_time = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return start_time;
  }

  int64_t get_stop_time() const {
    return stop_time;
  }

  int64_t& set_stop_time(int64_t stop_time_) {
    stop_time = stop_time_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.stop_time = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return stop_time;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< BalanceTask >;
  friend void swap(BalanceTask& a, BalanceTask& b);
};

template <class Protocol_>
uint32_t BalanceTask::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ConfigItem final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ConfigItem;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ConfigItem() :
      module( ::nebula::meta::cpp2::ConfigModule::UNKNOWN),
      mode( ::nebula::meta::cpp2::ConfigMode::IMMUTABLE) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ConfigItem(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::ConfigModule module__arg, ::std::string name__arg,  ::nebula::meta::cpp2::ConfigMode mode__arg, nebula::Value value__arg);

  ConfigItem(ConfigItem&&) = default;

  ConfigItem(const ConfigItem&) = default;


  ConfigItem& operator=(ConfigItem&&) = default;

  ConfigItem& operator=(const ConfigItem&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::meta::cpp2::ConfigModule module;
 private:
  ::std::string name;
 private:
   ::nebula::meta::cpp2::ConfigMode mode;
 private:
  nebula::Value value;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool module;
    bool name;
    bool mode;
    bool value;
  } __isset = {};
  bool operator==(const ConfigItem& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ConfigItem& __x, const ConfigItem& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ConfigItem& rhs) const;
#ifndef SWIG
  friend bool operator>(const ConfigItem& __x, const ConfigItem& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ConfigItem& __x, const ConfigItem& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ConfigItem& __x, const ConfigItem& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigModule>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> module_ref() const& {
    return {this->module, __isset.module};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigModule>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> module_ref() const&& {
    return {std::move(this->module), __isset.module};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigModule>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> module_ref() & {
    return {this->module, __isset.module};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigModule>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> module_ref() && {
    return {std::move(this->module), __isset.module};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigMode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> mode_ref() const& {
    return {this->mode, __isset.mode};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigMode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> mode_ref() const&& {
    return {std::move(this->mode), __isset.mode};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigMode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> mode_ref() & {
    return {this->mode, __isset.mode};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigMode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> mode_ref() && {
    return {std::move(this->mode), __isset.mode};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> value_ref() const& {
    return {this->value, __isset.value};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> value_ref() const&& {
    return {std::move(this->value), __isset.value};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> value_ref() & {
    return {this->value, __isset.value};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> value_ref() && {
    return {std::move(this->value), __isset.value};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::meta::cpp2::ConfigModule get_module() const {
    return module;
  }

   ::nebula::meta::cpp2::ConfigModule& set_module( ::nebula::meta::cpp2::ConfigModule module_) {
    module = module_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.module = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return module;
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ConfigItem_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ConfigItem_name_struct_setter&& name_) {
    name = std::forward<T_ConfigItem_name_struct_setter>(name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return name;
  }

   ::nebula::meta::cpp2::ConfigMode get_mode() const {
    return mode;
  }

   ::nebula::meta::cpp2::ConfigMode& set_mode( ::nebula::meta::cpp2::ConfigMode mode_) {
    mode = mode_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.mode = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return mode;
  }
  const nebula::Value& get_value() const&;
  nebula::Value get_value() &&;

  template <typename T_ConfigItem_value_struct_setter = nebula::Value>
  nebula::Value& set_value(T_ConfigItem_value_struct_setter&& value_) {
    value = std::forward<T_ConfigItem_value_struct_setter>(value_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.value = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return value;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ConfigItem >;
  friend void swap(ConfigItem& a, ConfigItem& b);
};

template <class Protocol_>
uint32_t ConfigItem::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class RegConfigReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = RegConfigReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  RegConfigReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RegConfigReq(apache::thrift::FragileConstructor, ::std::vector< ::nebula::meta::cpp2::ConfigItem> items__arg);

  RegConfigReq(RegConfigReq&&) = default;

  RegConfigReq(const RegConfigReq&) = default;


  RegConfigReq& operator=(RegConfigReq&&) = default;

  RegConfigReq& operator=(const RegConfigReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector< ::nebula::meta::cpp2::ConfigItem> items;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool items;
  } __isset = {};
  bool operator==(const RegConfigReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const RegConfigReq& __x, const RegConfigReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const RegConfigReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const RegConfigReq& __x, const RegConfigReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const RegConfigReq& __x, const RegConfigReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const RegConfigReq& __x, const RegConfigReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ConfigItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> items_ref() const& {
    return {this->items, __isset.items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ConfigItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> items_ref() const&& {
    return {std::move(this->items), __isset.items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ConfigItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> items_ref() & {
    return {this->items, __isset.items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ConfigItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> items_ref() && {
    return {std::move(this->items), __isset.items};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector< ::nebula::meta::cpp2::ConfigItem>& get_items() const&;
  ::std::vector< ::nebula::meta::cpp2::ConfigItem> get_items() &&;

  template <typename T_RegConfigReq_items_struct_setter = ::std::vector< ::nebula::meta::cpp2::ConfigItem>>
  ::std::vector< ::nebula::meta::cpp2::ConfigItem>& set_items(T_RegConfigReq_items_struct_setter&& items_) {
    items = std::forward<T_RegConfigReq_items_struct_setter>(items_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.items = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return items;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< RegConfigReq >;
  friend void swap(RegConfigReq& a, RegConfigReq& b);
};

template <class Protocol_>
uint32_t RegConfigReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetConfigReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetConfigReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetConfigReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetConfigReq(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::ConfigItem item__arg);

  GetConfigReq(GetConfigReq&&) = default;

  GetConfigReq(const GetConfigReq&) = default;


  GetConfigReq& operator=(GetConfigReq&&) = default;

  GetConfigReq& operator=(const GetConfigReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::meta::cpp2::ConfigItem item;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool item;
  } __isset = {};
  bool operator==(const GetConfigReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetConfigReq& __x, const GetConfigReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetConfigReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetConfigReq& __x, const GetConfigReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetConfigReq& __x, const GetConfigReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetConfigReq& __x, const GetConfigReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigItem>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> item_ref() const& {
    return {this->item, __isset.item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigItem>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> item_ref() const&& {
    return {std::move(this->item), __isset.item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigItem>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> item_ref() & {
    return {this->item, __isset.item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigItem>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> item_ref() && {
    return {std::move(this->item), __isset.item};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::meta::cpp2::ConfigItem& get_item() const&;
   ::nebula::meta::cpp2::ConfigItem get_item() &&;

  template <typename T_GetConfigReq_item_struct_setter =  ::nebula::meta::cpp2::ConfigItem>
   ::nebula::meta::cpp2::ConfigItem& set_item(T_GetConfigReq_item_struct_setter&& item_) {
    item = std::forward<T_GetConfigReq_item_struct_setter>(item_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.item = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return item;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetConfigReq >;
  friend void swap(GetConfigReq& a, GetConfigReq& b);
};

template <class Protocol_>
uint32_t GetConfigReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetConfigResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetConfigResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetConfigResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetConfigResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::ConfigItem> items__arg);

  GetConfigResp(GetConfigResp&&) = default;

  GetConfigResp(const GetConfigResp&) = default;


  GetConfigResp& operator=(GetConfigResp&&) = default;

  GetConfigResp& operator=(const GetConfigResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::vector< ::nebula::meta::cpp2::ConfigItem> items;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool items;
  } __isset = {};
  bool operator==(const GetConfigResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetConfigResp& __x, const GetConfigResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetConfigResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetConfigResp& __x, const GetConfigResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetConfigResp& __x, const GetConfigResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetConfigResp& __x, const GetConfigResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ConfigItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> items_ref() const& {
    return {this->items, __isset.items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ConfigItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> items_ref() const&& {
    return {std::move(this->items), __isset.items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ConfigItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> items_ref() & {
    return {this->items, __isset.items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ConfigItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> items_ref() && {
    return {std::move(this->items), __isset.items};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_GetConfigResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_GetConfigResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_GetConfigResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const ::std::vector< ::nebula::meta::cpp2::ConfigItem>& get_items() const&;
  ::std::vector< ::nebula::meta::cpp2::ConfigItem> get_items() &&;

  template <typename T_GetConfigResp_items_struct_setter = ::std::vector< ::nebula::meta::cpp2::ConfigItem>>
  ::std::vector< ::nebula::meta::cpp2::ConfigItem>& set_items(T_GetConfigResp_items_struct_setter&& items_) {
    items = std::forward<T_GetConfigResp_items_struct_setter>(items_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.items = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return items;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetConfigResp >;
  friend void swap(GetConfigResp& a, GetConfigResp& b);
};

template <class Protocol_>
uint32_t GetConfigResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class SetConfigReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = SetConfigReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  SetConfigReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  SetConfigReq(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::ConfigItem item__arg);

  SetConfigReq(SetConfigReq&&) = default;

  SetConfigReq(const SetConfigReq&) = default;


  SetConfigReq& operator=(SetConfigReq&&) = default;

  SetConfigReq& operator=(const SetConfigReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::meta::cpp2::ConfigItem item;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool item;
  } __isset = {};
  bool operator==(const SetConfigReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const SetConfigReq& __x, const SetConfigReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const SetConfigReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const SetConfigReq& __x, const SetConfigReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const SetConfigReq& __x, const SetConfigReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const SetConfigReq& __x, const SetConfigReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigItem>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> item_ref() const& {
    return {this->item, __isset.item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigItem>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> item_ref() const&& {
    return {std::move(this->item), __isset.item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigItem>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> item_ref() & {
    return {this->item, __isset.item};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigItem>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> item_ref() && {
    return {std::move(this->item), __isset.item};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::meta::cpp2::ConfigItem& get_item() const&;
   ::nebula::meta::cpp2::ConfigItem get_item() &&;

  template <typename T_SetConfigReq_item_struct_setter =  ::nebula::meta::cpp2::ConfigItem>
   ::nebula::meta::cpp2::ConfigItem& set_item(T_SetConfigReq_item_struct_setter&& item_) {
    item = std::forward<T_SetConfigReq_item_struct_setter>(item_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.item = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return item;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< SetConfigReq >;
  friend void swap(SetConfigReq& a, SetConfigReq& b);
};

template <class Protocol_>
uint32_t SetConfigReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListConfigsReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListConfigsReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListConfigsReq() :
      module( ::nebula::meta::cpp2::ConfigModule::UNKNOWN) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListConfigsReq(apache::thrift::FragileConstructor, ::std::string space__arg,  ::nebula::meta::cpp2::ConfigModule module__arg);

  ListConfigsReq(ListConfigsReq&&) = default;

  ListConfigsReq(const ListConfigsReq&) = default;


  ListConfigsReq& operator=(ListConfigsReq&&) = default;

  ListConfigsReq& operator=(const ListConfigsReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string space;
 private:
   ::nebula::meta::cpp2::ConfigModule module;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space;
    bool module;
  } __isset = {};
  bool operator==(const ListConfigsReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListConfigsReq& __x, const ListConfigsReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListConfigsReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListConfigsReq& __x, const ListConfigsReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListConfigsReq& __x, const ListConfigsReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListConfigsReq& __x, const ListConfigsReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_ref() const& {
    return {this->space, __isset.space};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_ref() const&& {
    return {std::move(this->space), __isset.space};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_ref() & {
    return {this->space, __isset.space};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_ref() && {
    return {std::move(this->space), __isset.space};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigModule>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> module_ref() const& {
    return {this->module, __isset.module};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigModule>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> module_ref() const&& {
    return {std::move(this->module), __isset.module};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigModule>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> module_ref() & {
    return {this->module, __isset.module};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ConfigModule>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> module_ref() && {
    return {std::move(this->module), __isset.module};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_space() const& {
    return space;
  }

  ::std::string get_space() && {
    return std::move(space);
  }

  template <typename T_ListConfigsReq_space_struct_setter = ::std::string>
  ::std::string& set_space(T_ListConfigsReq_space_struct_setter&& space_) {
    space = std::forward<T_ListConfigsReq_space_struct_setter>(space_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space;
  }

   ::nebula::meta::cpp2::ConfigModule get_module() const {
    return module;
  }

   ::nebula::meta::cpp2::ConfigModule& set_module( ::nebula::meta::cpp2::ConfigModule module_) {
    module = module_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.module = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return module;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListConfigsReq >;
  friend void swap(ListConfigsReq& a, ListConfigsReq& b);
};

template <class Protocol_>
uint32_t ListConfigsReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListConfigsResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListConfigsResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListConfigsResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListConfigsResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::ConfigItem> items__arg);

  ListConfigsResp(ListConfigsResp&&) = default;

  ListConfigsResp(const ListConfigsResp&) = default;


  ListConfigsResp& operator=(ListConfigsResp&&) = default;

  ListConfigsResp& operator=(const ListConfigsResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::vector< ::nebula::meta::cpp2::ConfigItem> items;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool items;
  } __isset = {};
  bool operator==(const ListConfigsResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListConfigsResp& __x, const ListConfigsResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListConfigsResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListConfigsResp& __x, const ListConfigsResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListConfigsResp& __x, const ListConfigsResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListConfigsResp& __x, const ListConfigsResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ConfigItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> items_ref() const& {
    return {this->items, __isset.items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ConfigItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> items_ref() const&& {
    return {std::move(this->items), __isset.items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ConfigItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> items_ref() & {
    return {this->items, __isset.items};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ConfigItem>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> items_ref() && {
    return {std::move(this->items), __isset.items};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_ListConfigsResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_ListConfigsResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_ListConfigsResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const ::std::vector< ::nebula::meta::cpp2::ConfigItem>& get_items() const&;
  ::std::vector< ::nebula::meta::cpp2::ConfigItem> get_items() &&;

  template <typename T_ListConfigsResp_items_struct_setter = ::std::vector< ::nebula::meta::cpp2::ConfigItem>>
  ::std::vector< ::nebula::meta::cpp2::ConfigItem>& set_items(T_ListConfigsResp_items_struct_setter&& items_) {
    items = std::forward<T_ListConfigsResp_items_struct_setter>(items_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.items = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return items;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListConfigsResp >;
  friend void swap(ListConfigsResp& a, ListConfigsResp& b);
};

template <class Protocol_>
uint32_t ListConfigsResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class CreateSnapshotReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CreateSnapshotReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  CreateSnapshotReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CreateSnapshotReq(apache::thrift::FragileConstructor);

  CreateSnapshotReq(CreateSnapshotReq&&) = default;

  CreateSnapshotReq(const CreateSnapshotReq&) = default;


  CreateSnapshotReq& operator=(CreateSnapshotReq&&) = default;

  CreateSnapshotReq& operator=(const CreateSnapshotReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
  bool operator==(const CreateSnapshotReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CreateSnapshotReq& __x, const CreateSnapshotReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CreateSnapshotReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const CreateSnapshotReq& __x, const CreateSnapshotReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CreateSnapshotReq& __x, const CreateSnapshotReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CreateSnapshotReq& __x, const CreateSnapshotReq& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CreateSnapshotReq >;
  friend void swap(CreateSnapshotReq& a, CreateSnapshotReq& b);
};

template <class Protocol_>
uint32_t CreateSnapshotReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class DropSnapshotReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = DropSnapshotReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  DropSnapshotReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  DropSnapshotReq(apache::thrift::FragileConstructor, ::std::vector<::std::string> names__arg);

  DropSnapshotReq(DropSnapshotReq&&) = default;

  DropSnapshotReq(const DropSnapshotReq&) = default;


  DropSnapshotReq& operator=(DropSnapshotReq&&) = default;

  DropSnapshotReq& operator=(const DropSnapshotReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector<::std::string> names;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool names;
  } __isset = {};
  bool operator==(const DropSnapshotReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const DropSnapshotReq& __x, const DropSnapshotReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const DropSnapshotReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const DropSnapshotReq& __x, const DropSnapshotReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const DropSnapshotReq& __x, const DropSnapshotReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const DropSnapshotReq& __x, const DropSnapshotReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> names_ref() const& {
    return {this->names, __isset.names};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> names_ref() const&& {
    return {std::move(this->names), __isset.names};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> names_ref() & {
    return {this->names, __isset.names};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> names_ref() && {
    return {std::move(this->names), __isset.names};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector<::std::string>& get_names() const&;
  ::std::vector<::std::string> get_names() &&;

  template <typename T_DropSnapshotReq_names_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_names(T_DropSnapshotReq_names_struct_setter&& names_) {
    names = std::forward<T_DropSnapshotReq_names_struct_setter>(names_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.names = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return names;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< DropSnapshotReq >;
  friend void swap(DropSnapshotReq& a, DropSnapshotReq& b);
};

template <class Protocol_>
uint32_t DropSnapshotReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListSnapshotsReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListSnapshotsReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListSnapshotsReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListSnapshotsReq(apache::thrift::FragileConstructor);

  ListSnapshotsReq(ListSnapshotsReq&&) = default;

  ListSnapshotsReq(const ListSnapshotsReq&) = default;


  ListSnapshotsReq& operator=(ListSnapshotsReq&&) = default;

  ListSnapshotsReq& operator=(const ListSnapshotsReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
  bool operator==(const ListSnapshotsReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListSnapshotsReq& __x, const ListSnapshotsReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListSnapshotsReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListSnapshotsReq& __x, const ListSnapshotsReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListSnapshotsReq& __x, const ListSnapshotsReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListSnapshotsReq& __x, const ListSnapshotsReq& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListSnapshotsReq >;
  friend void swap(ListSnapshotsReq& a, ListSnapshotsReq& b);
};

template <class Protocol_>
uint32_t ListSnapshotsReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class Snapshot final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Snapshot;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  Snapshot() :
      status( ::nebula::meta::cpp2::SnapshotStatus::VALID) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Snapshot(apache::thrift::FragileConstructor, ::std::string name__arg,  ::nebula::meta::cpp2::SnapshotStatus status__arg, ::std::string hosts__arg);

  Snapshot(Snapshot&&) = default;

  Snapshot(const Snapshot&) = default;


  Snapshot& operator=(Snapshot&&) = default;

  Snapshot& operator=(const Snapshot&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string name;
 private:
   ::nebula::meta::cpp2::SnapshotStatus status;
 private:
  ::std::string hosts;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool name;
    bool status;
    bool hosts;
  } __isset = {};
  bool operator==(const Snapshot& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Snapshot& __x, const Snapshot& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Snapshot& rhs) const;
#ifndef SWIG
  friend bool operator>(const Snapshot& __x, const Snapshot& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Snapshot& __x, const Snapshot& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Snapshot& __x, const Snapshot& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::SnapshotStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> status_ref() const& {
    return {this->status, __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SnapshotStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> status_ref() const&& {
    return {std::move(this->status), __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SnapshotStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> status_ref() & {
    return {this->status, __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SnapshotStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> status_ref() && {
    return {std::move(this->status), __isset.status};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> hosts_ref() const& {
    return {this->hosts, __isset.hosts};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> hosts_ref() const&& {
    return {std::move(this->hosts), __isset.hosts};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> hosts_ref() & {
    return {this->hosts, __isset.hosts};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> hosts_ref() && {
    return {std::move(this->hosts), __isset.hosts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_Snapshot_name_struct_setter = ::std::string>
  ::std::string& set_name(T_Snapshot_name_struct_setter&& name_) {
    name = std::forward<T_Snapshot_name_struct_setter>(name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return name;
  }

   ::nebula::meta::cpp2::SnapshotStatus get_status() const {
    return status;
  }

   ::nebula::meta::cpp2::SnapshotStatus& set_status( ::nebula::meta::cpp2::SnapshotStatus status_) {
    status = status_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.status = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return status;
  }

  const ::std::string& get_hosts() const& {
    return hosts;
  }

  ::std::string get_hosts() && {
    return std::move(hosts);
  }

  template <typename T_Snapshot_hosts_struct_setter = ::std::string>
  ::std::string& set_hosts(T_Snapshot_hosts_struct_setter&& hosts_) {
    hosts = std::forward<T_Snapshot_hosts_struct_setter>(hosts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.hosts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return hosts;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Snapshot >;
  friend void swap(Snapshot& a, Snapshot& b);
};

template <class Protocol_>
uint32_t Snapshot::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListSnapshotsResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListSnapshotsResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListSnapshotsResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListSnapshotsResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::Snapshot> snapshots__arg);

  ListSnapshotsResp(ListSnapshotsResp&&) = default;

  ListSnapshotsResp(const ListSnapshotsResp&) = default;


  ListSnapshotsResp& operator=(ListSnapshotsResp&&) = default;

  ListSnapshotsResp& operator=(const ListSnapshotsResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::vector< ::nebula::meta::cpp2::Snapshot> snapshots;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool snapshots;
  } __isset = {};
  bool operator==(const ListSnapshotsResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListSnapshotsResp& __x, const ListSnapshotsResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListSnapshotsResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListSnapshotsResp& __x, const ListSnapshotsResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListSnapshotsResp& __x, const ListSnapshotsResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListSnapshotsResp& __x, const ListSnapshotsResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::Snapshot>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> snapshots_ref() const& {
    return {this->snapshots, __isset.snapshots};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::Snapshot>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> snapshots_ref() const&& {
    return {std::move(this->snapshots), __isset.snapshots};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::Snapshot>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> snapshots_ref() & {
    return {this->snapshots, __isset.snapshots};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::Snapshot>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> snapshots_ref() && {
    return {std::move(this->snapshots), __isset.snapshots};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_ListSnapshotsResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_ListSnapshotsResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_ListSnapshotsResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const ::std::vector< ::nebula::meta::cpp2::Snapshot>& get_snapshots() const&;
  ::std::vector< ::nebula::meta::cpp2::Snapshot> get_snapshots() &&;

  template <typename T_ListSnapshotsResp_snapshots_struct_setter = ::std::vector< ::nebula::meta::cpp2::Snapshot>>
  ::std::vector< ::nebula::meta::cpp2::Snapshot>& set_snapshots(T_ListSnapshotsResp_snapshots_struct_setter&& snapshots_) {
    snapshots = std::forward<T_ListSnapshotsResp_snapshots_struct_setter>(snapshots_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.snapshots = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return snapshots;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListSnapshotsResp >;
  friend void swap(ListSnapshotsResp& a, ListSnapshotsResp& b);
};

template <class Protocol_>
uint32_t ListSnapshotsResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListIndexStatusReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListIndexStatusReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListIndexStatusReq() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListIndexStatusReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg);

  ListIndexStatusReq(ListIndexStatusReq&&) = default;

  ListIndexStatusReq(const ListIndexStatusReq&) = default;


  ListIndexStatusReq& operator=(ListIndexStatusReq&&) = default;

  ListIndexStatusReq& operator=(const ListIndexStatusReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
  } __isset = {};
  bool operator==(const ListIndexStatusReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListIndexStatusReq& __x, const ListIndexStatusReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListIndexStatusReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListIndexStatusReq& __x, const ListIndexStatusReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListIndexStatusReq& __x, const ListIndexStatusReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListIndexStatusReq& __x, const ListIndexStatusReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListIndexStatusReq >;
  friend void swap(ListIndexStatusReq& a, ListIndexStatusReq& b);
};

template <class Protocol_>
uint32_t ListIndexStatusReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class IndexStatus final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = IndexStatus;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  IndexStatus() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  IndexStatus(apache::thrift::FragileConstructor, ::std::string name__arg, ::std::string status__arg);

  IndexStatus(IndexStatus&&) = default;

  IndexStatus(const IndexStatus&) = default;


  IndexStatus& operator=(IndexStatus&&) = default;

  IndexStatus& operator=(const IndexStatus&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string name;
 private:
  ::std::string status;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool name;
    bool status;
  } __isset = {};
  bool operator==(const IndexStatus& rhs) const;
#ifndef SWIG
  friend bool operator!=(const IndexStatus& __x, const IndexStatus& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const IndexStatus& rhs) const;
#ifndef SWIG
  friend bool operator>(const IndexStatus& __x, const IndexStatus& __y) {
    return __y < __x;
  }
  friend bool operator<=(const IndexStatus& __x, const IndexStatus& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const IndexStatus& __x, const IndexStatus& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> status_ref() const& {
    return {this->status, __isset.status};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> status_ref() const&& {
    return {std::move(this->status), __isset.status};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> status_ref() & {
    return {this->status, __isset.status};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> status_ref() && {
    return {std::move(this->status), __isset.status};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_IndexStatus_name_struct_setter = ::std::string>
  ::std::string& set_name(T_IndexStatus_name_struct_setter&& name_) {
    name = std::forward<T_IndexStatus_name_struct_setter>(name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return name;
  }

  const ::std::string& get_status() const& {
    return status;
  }

  ::std::string get_status() && {
    return std::move(status);
  }

  template <typename T_IndexStatus_status_struct_setter = ::std::string>
  ::std::string& set_status(T_IndexStatus_status_struct_setter&& status_) {
    status = std::forward<T_IndexStatus_status_struct_setter>(status_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.status = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return status;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< IndexStatus >;
  friend void swap(IndexStatus& a, IndexStatus& b);
};

template <class Protocol_>
uint32_t IndexStatus::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListIndexStatusResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListIndexStatusResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListIndexStatusResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListIndexStatusResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::IndexStatus> statuses__arg);

  ListIndexStatusResp(ListIndexStatusResp&&) = default;

  ListIndexStatusResp(const ListIndexStatusResp&) = default;


  ListIndexStatusResp& operator=(ListIndexStatusResp&&) = default;

  ListIndexStatusResp& operator=(const ListIndexStatusResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::vector< ::nebula::meta::cpp2::IndexStatus> statuses;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool statuses;
  } __isset = {};
  bool operator==(const ListIndexStatusResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListIndexStatusResp& __x, const ListIndexStatusResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListIndexStatusResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListIndexStatusResp& __x, const ListIndexStatusResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListIndexStatusResp& __x, const ListIndexStatusResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListIndexStatusResp& __x, const ListIndexStatusResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexStatus>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> statuses_ref() const& {
    return {this->statuses, __isset.statuses};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexStatus>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> statuses_ref() const&& {
    return {std::move(this->statuses), __isset.statuses};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexStatus>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> statuses_ref() & {
    return {this->statuses, __isset.statuses};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::IndexStatus>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> statuses_ref() && {
    return {std::move(this->statuses), __isset.statuses};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_ListIndexStatusResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_ListIndexStatusResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_ListIndexStatusResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const ::std::vector< ::nebula::meta::cpp2::IndexStatus>& get_statuses() const&;
  ::std::vector< ::nebula::meta::cpp2::IndexStatus> get_statuses() &&;

  template <typename T_ListIndexStatusResp_statuses_struct_setter = ::std::vector< ::nebula::meta::cpp2::IndexStatus>>
  ::std::vector< ::nebula::meta::cpp2::IndexStatus>& set_statuses(T_ListIndexStatusResp_statuses_struct_setter&& statuses_) {
    statuses = std::forward<T_ListIndexStatusResp_statuses_struct_setter>(statuses_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.statuses = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return statuses;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListIndexStatusResp >;
  friend void swap(ListIndexStatusResp& a, ListIndexStatusResp& b);
};

template <class Protocol_>
uint32_t ListIndexStatusResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class MergeZoneReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = MergeZoneReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  MergeZoneReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  MergeZoneReq(apache::thrift::FragileConstructor, ::std::vector<::std::string> zones__arg, ::std::string zone_name__arg);

  MergeZoneReq(MergeZoneReq&&) = default;

  MergeZoneReq(const MergeZoneReq&) = default;


  MergeZoneReq& operator=(MergeZoneReq&&) = default;

  MergeZoneReq& operator=(const MergeZoneReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector<::std::string> zones;
 private:
  ::std::string zone_name;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool zones;
    bool zone_name;
  } __isset = {};
  bool operator==(const MergeZoneReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const MergeZoneReq& __x, const MergeZoneReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const MergeZoneReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const MergeZoneReq& __x, const MergeZoneReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const MergeZoneReq& __x, const MergeZoneReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const MergeZoneReq& __x, const MergeZoneReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> zones_ref() const& {
    return {this->zones, __isset.zones};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> zones_ref() const&& {
    return {std::move(this->zones), __isset.zones};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> zones_ref() & {
    return {this->zones, __isset.zones};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> zones_ref() && {
    return {std::move(this->zones), __isset.zones};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> zone_name_ref() const& {
    return {this->zone_name, __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> zone_name_ref() const&& {
    return {std::move(this->zone_name), __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> zone_name_ref() & {
    return {this->zone_name, __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> zone_name_ref() && {
    return {std::move(this->zone_name), __isset.zone_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector<::std::string>& get_zones() const&;
  ::std::vector<::std::string> get_zones() &&;

  template <typename T_MergeZoneReq_zones_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_zones(T_MergeZoneReq_zones_struct_setter&& zones_) {
    zones = std::forward<T_MergeZoneReq_zones_struct_setter>(zones_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.zones = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return zones;
  }

  const ::std::string& get_zone_name() const& {
    return zone_name;
  }

  ::std::string get_zone_name() && {
    return std::move(zone_name);
  }

  template <typename T_MergeZoneReq_zone_name_struct_setter = ::std::string>
  ::std::string& set_zone_name(T_MergeZoneReq_zone_name_struct_setter&& zone_name_) {
    zone_name = std::forward<T_MergeZoneReq_zone_name_struct_setter>(zone_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.zone_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return zone_name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< MergeZoneReq >;
  friend void swap(MergeZoneReq& a, MergeZoneReq& b);
};

template <class Protocol_>
uint32_t MergeZoneReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class DropZoneReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = DropZoneReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  DropZoneReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  DropZoneReq(apache::thrift::FragileConstructor, ::std::string zone_name__arg);

  DropZoneReq(DropZoneReq&&) = default;

  DropZoneReq(const DropZoneReq&) = default;


  DropZoneReq& operator=(DropZoneReq&&) = default;

  DropZoneReq& operator=(const DropZoneReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string zone_name;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool zone_name;
  } __isset = {};
  bool operator==(const DropZoneReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const DropZoneReq& __x, const DropZoneReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const DropZoneReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const DropZoneReq& __x, const DropZoneReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const DropZoneReq& __x, const DropZoneReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const DropZoneReq& __x, const DropZoneReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> zone_name_ref() const& {
    return {this->zone_name, __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> zone_name_ref() const&& {
    return {std::move(this->zone_name), __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> zone_name_ref() & {
    return {this->zone_name, __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> zone_name_ref() && {
    return {std::move(this->zone_name), __isset.zone_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_zone_name() const& {
    return zone_name;
  }

  ::std::string get_zone_name() && {
    return std::move(zone_name);
  }

  template <typename T_DropZoneReq_zone_name_struct_setter = ::std::string>
  ::std::string& set_zone_name(T_DropZoneReq_zone_name_struct_setter&& zone_name_) {
    zone_name = std::forward<T_DropZoneReq_zone_name_struct_setter>(zone_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.zone_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return zone_name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< DropZoneReq >;
  friend void swap(DropZoneReq& a, DropZoneReq& b);
};

template <class Protocol_>
uint32_t DropZoneReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class DivideZoneReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = DivideZoneReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  DivideZoneReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  DivideZoneReq(apache::thrift::FragileConstructor, ::std::string zone_name__arg, std::unordered_map<::std::string, ::std::vector<nebula::HostAddr>> zone_items__arg);

  DivideZoneReq(DivideZoneReq&&) = default;

  DivideZoneReq(const DivideZoneReq&) = default;


  DivideZoneReq& operator=(DivideZoneReq&&) = default;

  DivideZoneReq& operator=(const DivideZoneReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string zone_name;
 private:
  std::unordered_map<::std::string, ::std::vector<nebula::HostAddr>> zone_items;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool zone_name;
    bool zone_items;
  } __isset = {};
  bool operator==(const DivideZoneReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const DivideZoneReq& __x, const DivideZoneReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const DivideZoneReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const DivideZoneReq& __x, const DivideZoneReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const DivideZoneReq& __x, const DivideZoneReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const DivideZoneReq& __x, const DivideZoneReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> zone_name_ref() const& {
    return {this->zone_name, __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> zone_name_ref() const&& {
    return {std::move(this->zone_name), __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> zone_name_ref() & {
    return {this->zone_name, __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> zone_name_ref() && {
    return {std::move(this->zone_name), __isset.zone_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map<::std::string, ::std::vector<nebula::HostAddr>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> zone_items_ref() const& {
    return {this->zone_items, __isset.zone_items};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::vector<nebula::HostAddr>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> zone_items_ref() const&& {
    return {std::move(this->zone_items), __isset.zone_items};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::vector<nebula::HostAddr>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> zone_items_ref() & {
    return {this->zone_items, __isset.zone_items};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::vector<nebula::HostAddr>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> zone_items_ref() && {
    return {std::move(this->zone_items), __isset.zone_items};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_zone_name() const& {
    return zone_name;
  }

  ::std::string get_zone_name() && {
    return std::move(zone_name);
  }

  template <typename T_DivideZoneReq_zone_name_struct_setter = ::std::string>
  ::std::string& set_zone_name(T_DivideZoneReq_zone_name_struct_setter&& zone_name_) {
    zone_name = std::forward<T_DivideZoneReq_zone_name_struct_setter>(zone_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.zone_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return zone_name;
  }
  const std::unordered_map<::std::string, ::std::vector<nebula::HostAddr>>& get_zone_items() const&;
  std::unordered_map<::std::string, ::std::vector<nebula::HostAddr>> get_zone_items() &&;

  template <typename T_DivideZoneReq_zone_items_struct_setter = std::unordered_map<::std::string, ::std::vector<nebula::HostAddr>>>
  std::unordered_map<::std::string, ::std::vector<nebula::HostAddr>>& set_zone_items(T_DivideZoneReq_zone_items_struct_setter&& zone_items_) {
    zone_items = std::forward<T_DivideZoneReq_zone_items_struct_setter>(zone_items_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.zone_items = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return zone_items;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< DivideZoneReq >;
  friend void swap(DivideZoneReq& a, DivideZoneReq& b);
};

template <class Protocol_>
uint32_t DivideZoneReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class RenameZoneReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = RenameZoneReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  RenameZoneReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RenameZoneReq(apache::thrift::FragileConstructor, ::std::string original_zone_name__arg, ::std::string zone_name__arg);

  RenameZoneReq(RenameZoneReq&&) = default;

  RenameZoneReq(const RenameZoneReq&) = default;


  RenameZoneReq& operator=(RenameZoneReq&&) = default;

  RenameZoneReq& operator=(const RenameZoneReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string original_zone_name;
 private:
  ::std::string zone_name;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool original_zone_name;
    bool zone_name;
  } __isset = {};
  bool operator==(const RenameZoneReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const RenameZoneReq& __x, const RenameZoneReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const RenameZoneReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const RenameZoneReq& __x, const RenameZoneReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const RenameZoneReq& __x, const RenameZoneReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const RenameZoneReq& __x, const RenameZoneReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> original_zone_name_ref() const& {
    return {this->original_zone_name, __isset.original_zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> original_zone_name_ref() const&& {
    return {std::move(this->original_zone_name), __isset.original_zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> original_zone_name_ref() & {
    return {this->original_zone_name, __isset.original_zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> original_zone_name_ref() && {
    return {std::move(this->original_zone_name), __isset.original_zone_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> zone_name_ref() const& {
    return {this->zone_name, __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> zone_name_ref() const&& {
    return {std::move(this->zone_name), __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> zone_name_ref() & {
    return {this->zone_name, __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> zone_name_ref() && {
    return {std::move(this->zone_name), __isset.zone_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_original_zone_name() const& {
    return original_zone_name;
  }

  ::std::string get_original_zone_name() && {
    return std::move(original_zone_name);
  }

  template <typename T_RenameZoneReq_original_zone_name_struct_setter = ::std::string>
  ::std::string& set_original_zone_name(T_RenameZoneReq_original_zone_name_struct_setter&& original_zone_name_) {
    original_zone_name = std::forward<T_RenameZoneReq_original_zone_name_struct_setter>(original_zone_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.original_zone_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return original_zone_name;
  }

  const ::std::string& get_zone_name() const& {
    return zone_name;
  }

  ::std::string get_zone_name() && {
    return std::move(zone_name);
  }

  template <typename T_RenameZoneReq_zone_name_struct_setter = ::std::string>
  ::std::string& set_zone_name(T_RenameZoneReq_zone_name_struct_setter&& zone_name_) {
    zone_name = std::forward<T_RenameZoneReq_zone_name_struct_setter>(zone_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.zone_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return zone_name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< RenameZoneReq >;
  friend void swap(RenameZoneReq& a, RenameZoneReq& b);
};

template <class Protocol_>
uint32_t RenameZoneReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class AddHostsIntoZoneReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AddHostsIntoZoneReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  AddHostsIntoZoneReq() :
      is_new(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AddHostsIntoZoneReq(apache::thrift::FragileConstructor, ::std::vector<nebula::HostAddr> hosts__arg, ::std::string zone_name__arg, bool is_new__arg);

  AddHostsIntoZoneReq(AddHostsIntoZoneReq&&) = default;

  AddHostsIntoZoneReq(const AddHostsIntoZoneReq&) = default;


  AddHostsIntoZoneReq& operator=(AddHostsIntoZoneReq&&) = default;

  AddHostsIntoZoneReq& operator=(const AddHostsIntoZoneReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector<nebula::HostAddr> hosts;
 private:
  ::std::string zone_name;
 private:
  bool is_new;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool hosts;
    bool zone_name;
    bool is_new;
  } __isset = {};
  bool operator==(const AddHostsIntoZoneReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AddHostsIntoZoneReq& __x, const AddHostsIntoZoneReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AddHostsIntoZoneReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const AddHostsIntoZoneReq& __x, const AddHostsIntoZoneReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AddHostsIntoZoneReq& __x, const AddHostsIntoZoneReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AddHostsIntoZoneReq& __x, const AddHostsIntoZoneReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> hosts_ref() const& {
    return {this->hosts, __isset.hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> hosts_ref() const&& {
    return {std::move(this->hosts), __isset.hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> hosts_ref() & {
    return {this->hosts, __isset.hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> hosts_ref() && {
    return {std::move(this->hosts), __isset.hosts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> zone_name_ref() const& {
    return {this->zone_name, __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> zone_name_ref() const&& {
    return {std::move(this->zone_name), __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> zone_name_ref() & {
    return {this->zone_name, __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> zone_name_ref() && {
    return {std::move(this->zone_name), __isset.zone_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> is_new_ref() const& {
    return {this->is_new, __isset.is_new};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> is_new_ref() const&& {
    return {std::move(this->is_new), __isset.is_new};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> is_new_ref() & {
    return {this->is_new, __isset.is_new};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> is_new_ref() && {
    return {std::move(this->is_new), __isset.is_new};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector<nebula::HostAddr>& get_hosts() const&;
  ::std::vector<nebula::HostAddr> get_hosts() &&;

  template <typename T_AddHostsIntoZoneReq_hosts_struct_setter = ::std::vector<nebula::HostAddr>>
  ::std::vector<nebula::HostAddr>& set_hosts(T_AddHostsIntoZoneReq_hosts_struct_setter&& hosts_) {
    hosts = std::forward<T_AddHostsIntoZoneReq_hosts_struct_setter>(hosts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.hosts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return hosts;
  }

  const ::std::string& get_zone_name() const& {
    return zone_name;
  }

  ::std::string get_zone_name() && {
    return std::move(zone_name);
  }

  template <typename T_AddHostsIntoZoneReq_zone_name_struct_setter = ::std::string>
  ::std::string& set_zone_name(T_AddHostsIntoZoneReq_zone_name_struct_setter&& zone_name_) {
    zone_name = std::forward<T_AddHostsIntoZoneReq_zone_name_struct_setter>(zone_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.zone_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return zone_name;
  }

  bool get_is_new() const {
    return is_new;
  }

  bool& set_is_new(bool is_new_) {
    is_new = is_new_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.is_new = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return is_new;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AddHostsIntoZoneReq >;
  friend void swap(AddHostsIntoZoneReq& a, AddHostsIntoZoneReq& b);
};

template <class Protocol_>
uint32_t AddHostsIntoZoneReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetZoneReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetZoneReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetZoneReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetZoneReq(apache::thrift::FragileConstructor, ::std::string zone_name__arg);

  GetZoneReq(GetZoneReq&&) = default;

  GetZoneReq(const GetZoneReq&) = default;


  GetZoneReq& operator=(GetZoneReq&&) = default;

  GetZoneReq& operator=(const GetZoneReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string zone_name;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool zone_name;
  } __isset = {};
  bool operator==(const GetZoneReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetZoneReq& __x, const GetZoneReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetZoneReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetZoneReq& __x, const GetZoneReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetZoneReq& __x, const GetZoneReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetZoneReq& __x, const GetZoneReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> zone_name_ref() const& {
    return {this->zone_name, __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> zone_name_ref() const&& {
    return {std::move(this->zone_name), __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> zone_name_ref() & {
    return {this->zone_name, __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> zone_name_ref() && {
    return {std::move(this->zone_name), __isset.zone_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_zone_name() const& {
    return zone_name;
  }

  ::std::string get_zone_name() && {
    return std::move(zone_name);
  }

  template <typename T_GetZoneReq_zone_name_struct_setter = ::std::string>
  ::std::string& set_zone_name(T_GetZoneReq_zone_name_struct_setter&& zone_name_) {
    zone_name = std::forward<T_GetZoneReq_zone_name_struct_setter>(zone_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.zone_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return zone_name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetZoneReq >;
  friend void swap(GetZoneReq& a, GetZoneReq& b);
};

template <class Protocol_>
uint32_t GetZoneReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetZoneResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetZoneResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetZoneResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetZoneResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector<nebula::HostAddr> hosts__arg);

  GetZoneResp(GetZoneResp&&) = default;

  GetZoneResp(const GetZoneResp&) = default;


  GetZoneResp& operator=(GetZoneResp&&) = default;

  GetZoneResp& operator=(const GetZoneResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::vector<nebula::HostAddr> hosts;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool hosts;
  } __isset = {};
  bool operator==(const GetZoneResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetZoneResp& __x, const GetZoneResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetZoneResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetZoneResp& __x, const GetZoneResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetZoneResp& __x, const GetZoneResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetZoneResp& __x, const GetZoneResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> hosts_ref() const& {
    return {this->hosts, __isset.hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> hosts_ref() const&& {
    return {std::move(this->hosts), __isset.hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> hosts_ref() & {
    return {this->hosts, __isset.hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> hosts_ref() && {
    return {std::move(this->hosts), __isset.hosts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_GetZoneResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_GetZoneResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_GetZoneResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const ::std::vector<nebula::HostAddr>& get_hosts() const&;
  ::std::vector<nebula::HostAddr> get_hosts() &&;

  template <typename T_GetZoneResp_hosts_struct_setter = ::std::vector<nebula::HostAddr>>
  ::std::vector<nebula::HostAddr>& set_hosts(T_GetZoneResp_hosts_struct_setter&& hosts_) {
    hosts = std::forward<T_GetZoneResp_hosts_struct_setter>(hosts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.hosts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return hosts;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetZoneResp >;
  friend void swap(GetZoneResp& a, GetZoneResp& b);
};

template <class Protocol_>
uint32_t GetZoneResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListZonesReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListZonesReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListZonesReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListZonesReq(apache::thrift::FragileConstructor);

  ListZonesReq(ListZonesReq&&) = default;

  ListZonesReq(const ListZonesReq&) = default;


  ListZonesReq& operator=(ListZonesReq&&) = default;

  ListZonesReq& operator=(const ListZonesReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
  bool operator==(const ListZonesReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListZonesReq& __x, const ListZonesReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListZonesReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListZonesReq& __x, const ListZonesReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListZonesReq& __x, const ListZonesReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListZonesReq& __x, const ListZonesReq& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListZonesReq >;
  friend void swap(ListZonesReq& a, ListZonesReq& b);
};

template <class Protocol_>
uint32_t ListZonesReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class Zone final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Zone;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  Zone() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Zone(apache::thrift::FragileConstructor, ::std::string zone_name__arg, ::std::vector<nebula::HostAddr> nodes__arg);

  Zone(Zone&&) = default;

  Zone(const Zone&) = default;


  Zone& operator=(Zone&&) = default;

  Zone& operator=(const Zone&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string zone_name;
 private:
  ::std::vector<nebula::HostAddr> nodes;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool zone_name;
    bool nodes;
  } __isset = {};
  bool operator==(const Zone& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Zone& __x, const Zone& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Zone& rhs) const;
#ifndef SWIG
  friend bool operator>(const Zone& __x, const Zone& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Zone& __x, const Zone& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Zone& __x, const Zone& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> zone_name_ref() const& {
    return {this->zone_name, __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> zone_name_ref() const&& {
    return {std::move(this->zone_name), __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> zone_name_ref() & {
    return {this->zone_name, __isset.zone_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> zone_name_ref() && {
    return {std::move(this->zone_name), __isset.zone_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> nodes_ref() const& {
    return {this->nodes, __isset.nodes};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> nodes_ref() const&& {
    return {std::move(this->nodes), __isset.nodes};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> nodes_ref() & {
    return {this->nodes, __isset.nodes};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> nodes_ref() && {
    return {std::move(this->nodes), __isset.nodes};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_zone_name() const& {
    return zone_name;
  }

  ::std::string get_zone_name() && {
    return std::move(zone_name);
  }

  template <typename T_Zone_zone_name_struct_setter = ::std::string>
  ::std::string& set_zone_name(T_Zone_zone_name_struct_setter&& zone_name_) {
    zone_name = std::forward<T_Zone_zone_name_struct_setter>(zone_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.zone_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return zone_name;
  }
  const ::std::vector<nebula::HostAddr>& get_nodes() const&;
  ::std::vector<nebula::HostAddr> get_nodes() &&;

  template <typename T_Zone_nodes_struct_setter = ::std::vector<nebula::HostAddr>>
  ::std::vector<nebula::HostAddr>& set_nodes(T_Zone_nodes_struct_setter&& nodes_) {
    nodes = std::forward<T_Zone_nodes_struct_setter>(nodes_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.nodes = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return nodes;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Zone >;
  friend void swap(Zone& a, Zone& b);
};

template <class Protocol_>
uint32_t Zone::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListZonesResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListZonesResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListZonesResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListZonesResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::Zone> zones__arg);

  ListZonesResp(ListZonesResp&&) = default;

  ListZonesResp(const ListZonesResp&) = default;


  ListZonesResp& operator=(ListZonesResp&&) = default;

  ListZonesResp& operator=(const ListZonesResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::vector< ::nebula::meta::cpp2::Zone> zones;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool zones;
  } __isset = {};
  bool operator==(const ListZonesResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListZonesResp& __x, const ListZonesResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListZonesResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListZonesResp& __x, const ListZonesResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListZonesResp& __x, const ListZonesResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListZonesResp& __x, const ListZonesResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::Zone>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> zones_ref() const& {
    return {this->zones, __isset.zones};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::Zone>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> zones_ref() const&& {
    return {std::move(this->zones), __isset.zones};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::Zone>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> zones_ref() & {
    return {this->zones, __isset.zones};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::Zone>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> zones_ref() && {
    return {std::move(this->zones), __isset.zones};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_ListZonesResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_ListZonesResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_ListZonesResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const ::std::vector< ::nebula::meta::cpp2::Zone>& get_zones() const&;
  ::std::vector< ::nebula::meta::cpp2::Zone> get_zones() &&;

  template <typename T_ListZonesResp_zones_struct_setter = ::std::vector< ::nebula::meta::cpp2::Zone>>
  ::std::vector< ::nebula::meta::cpp2::Zone>& set_zones(T_ListZonesResp_zones_struct_setter&& zones_) {
    zones = std::forward<T_ListZonesResp_zones_struct_setter>(zones_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.zones = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return zones;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListZonesResp >;
  friend void swap(ListZonesResp& a, ListZonesResp& b);
};

template <class Protocol_>
uint32_t ListZonesResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class AddListenerReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AddListenerReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  AddListenerReq() :
      space_id(0),
      type( ::nebula::meta::cpp2::ListenerType::UNKNOWN) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AddListenerReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::meta::cpp2::ListenerType type__arg, ::std::vector<nebula::HostAddr> hosts__arg);

  AddListenerReq(AddListenerReq&&) = default;

  AddListenerReq(const AddListenerReq&) = default;


  AddListenerReq& operator=(AddListenerReq&&) = default;

  AddListenerReq& operator=(const AddListenerReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
   ::nebula::meta::cpp2::ListenerType type;
 private:
  ::std::vector<nebula::HostAddr> hosts;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool type;
    bool hosts;
  } __isset = {};
  bool operator==(const AddListenerReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AddListenerReq& __x, const AddListenerReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AddListenerReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const AddListenerReq& __x, const AddListenerReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AddListenerReq& __x, const AddListenerReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AddListenerReq& __x, const AddListenerReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::ListenerType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> type_ref() const& {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ListenerType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> type_ref() const&& {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ListenerType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> type_ref() & {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ListenerType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> type_ref() && {
    return {std::move(this->type), __isset.type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> hosts_ref() const& {
    return {this->hosts, __isset.hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> hosts_ref() const&& {
    return {std::move(this->hosts), __isset.hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> hosts_ref() & {
    return {this->hosts, __isset.hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> hosts_ref() && {
    return {std::move(this->hosts), __isset.hosts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

   ::nebula::meta::cpp2::ListenerType get_type() const {
    return type;
  }

   ::nebula::meta::cpp2::ListenerType& set_type( ::nebula::meta::cpp2::ListenerType type_) {
    type = type_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return type;
  }
  const ::std::vector<nebula::HostAddr>& get_hosts() const&;
  ::std::vector<nebula::HostAddr> get_hosts() &&;

  template <typename T_AddListenerReq_hosts_struct_setter = ::std::vector<nebula::HostAddr>>
  ::std::vector<nebula::HostAddr>& set_hosts(T_AddListenerReq_hosts_struct_setter&& hosts_) {
    hosts = std::forward<T_AddListenerReq_hosts_struct_setter>(hosts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.hosts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return hosts;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AddListenerReq >;
  friend void swap(AddListenerReq& a, AddListenerReq& b);
};

template <class Protocol_>
uint32_t AddListenerReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class RemoveListenerReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = RemoveListenerReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  RemoveListenerReq() :
      space_id(0),
      type( ::nebula::meta::cpp2::ListenerType::UNKNOWN) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RemoveListenerReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::meta::cpp2::ListenerType type__arg);

  RemoveListenerReq(RemoveListenerReq&&) = default;

  RemoveListenerReq(const RemoveListenerReq&) = default;


  RemoveListenerReq& operator=(RemoveListenerReq&&) = default;

  RemoveListenerReq& operator=(const RemoveListenerReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
   ::nebula::meta::cpp2::ListenerType type;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool type;
  } __isset = {};
  bool operator==(const RemoveListenerReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const RemoveListenerReq& __x, const RemoveListenerReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const RemoveListenerReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const RemoveListenerReq& __x, const RemoveListenerReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const RemoveListenerReq& __x, const RemoveListenerReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const RemoveListenerReq& __x, const RemoveListenerReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::ListenerType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> type_ref() const& {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ListenerType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> type_ref() const&& {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ListenerType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> type_ref() & {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ListenerType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> type_ref() && {
    return {std::move(this->type), __isset.type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

   ::nebula::meta::cpp2::ListenerType get_type() const {
    return type;
  }

   ::nebula::meta::cpp2::ListenerType& set_type( ::nebula::meta::cpp2::ListenerType type_) {
    type = type_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return type;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< RemoveListenerReq >;
  friend void swap(RemoveListenerReq& a, RemoveListenerReq& b);
};

template <class Protocol_>
uint32_t RemoveListenerReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListListenerReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListListenerReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListListenerReq() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListListenerReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg);

  ListListenerReq(ListListenerReq&&) = default;

  ListListenerReq(const ListListenerReq&) = default;


  ListListenerReq& operator=(ListListenerReq&&) = default;

  ListListenerReq& operator=(const ListListenerReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
  } __isset = {};
  bool operator==(const ListListenerReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListListenerReq& __x, const ListListenerReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListListenerReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListListenerReq& __x, const ListListenerReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListListenerReq& __x, const ListListenerReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListListenerReq& __x, const ListListenerReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListListenerReq >;
  friend void swap(ListListenerReq& a, ListListenerReq& b);
};

template <class Protocol_>
uint32_t ListListenerReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListenerInfo final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListenerInfo;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListenerInfo() :
      type( ::nebula::meta::cpp2::ListenerType::UNKNOWN),
      part_id(0),
      status( ::nebula::meta::cpp2::HostStatus::ONLINE) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListenerInfo(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::ListenerType type__arg, nebula::HostAddr host__arg,  ::nebula::cpp2::PartitionID part_id__arg,  ::nebula::meta::cpp2::HostStatus status__arg);

  ListenerInfo(ListenerInfo&&) = default;

  ListenerInfo(const ListenerInfo&) = default;


  ListenerInfo& operator=(ListenerInfo&&) = default;

  ListenerInfo& operator=(const ListenerInfo&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::meta::cpp2::ListenerType type;
 private:
  nebula::HostAddr host;
 private:
   ::nebula::cpp2::PartitionID part_id;
 private:
   ::nebula::meta::cpp2::HostStatus status;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool type;
    bool host;
    bool part_id;
    bool status;
  } __isset = {};
  bool operator==(const ListenerInfo& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListenerInfo& __x, const ListenerInfo& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListenerInfo& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListenerInfo& __x, const ListenerInfo& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListenerInfo& __x, const ListenerInfo& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListenerInfo& __x, const ListenerInfo& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::ListenerType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> type_ref() const& {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ListenerType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> type_ref() const&& {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ListenerType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> type_ref() & {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ListenerType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> type_ref() && {
    return {std::move(this->type), __isset.type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> host_ref() const& {
    return {this->host, __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> host_ref() const&& {
    return {std::move(this->host), __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> host_ref() & {
    return {this->host, __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> host_ref() && {
    return {std::move(this->host), __isset.host};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> part_id_ref() const& {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> part_id_ref() const&& {
    return {std::move(this->part_id), __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> part_id_ref() & {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> part_id_ref() && {
    return {std::move(this->part_id), __isset.part_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::HostStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> status_ref() const& {
    return {this->status, __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::HostStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> status_ref() const&& {
    return {std::move(this->status), __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::HostStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> status_ref() & {
    return {this->status, __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::HostStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> status_ref() && {
    return {std::move(this->status), __isset.status};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::meta::cpp2::ListenerType get_type() const {
    return type;
  }

   ::nebula::meta::cpp2::ListenerType& set_type( ::nebula::meta::cpp2::ListenerType type_) {
    type = type_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return type;
  }
  const nebula::HostAddr& get_host() const&;
  nebula::HostAddr get_host() &&;

  template <typename T_ListenerInfo_host_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_host(T_ListenerInfo_host_struct_setter&& host_) {
    host = std::forward<T_ListenerInfo_host_struct_setter>(host_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.host = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return host;
  }

   ::nebula::cpp2::PartitionID get_part_id() const {
    return part_id;
  }

   ::nebula::cpp2::PartitionID& set_part_id( ::nebula::cpp2::PartitionID part_id_) {
    part_id = part_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.part_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return part_id;
  }

   ::nebula::meta::cpp2::HostStatus get_status() const {
    return status;
  }

   ::nebula::meta::cpp2::HostStatus& set_status( ::nebula::meta::cpp2::HostStatus status_) {
    status = status_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.status = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return status;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListenerInfo >;
  friend void swap(ListenerInfo& a, ListenerInfo& b);
};

template <class Protocol_>
uint32_t ListenerInfo::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListListenerResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListListenerResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListListenerResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListListenerResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::ListenerInfo> listeners__arg);

  ListListenerResp(ListListenerResp&&) = default;

  ListListenerResp(const ListListenerResp&) = default;


  ListListenerResp& operator=(ListListenerResp&&) = default;

  ListListenerResp& operator=(const ListListenerResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::vector< ::nebula::meta::cpp2::ListenerInfo> listeners;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool listeners;
  } __isset = {};
  bool operator==(const ListListenerResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListListenerResp& __x, const ListListenerResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListListenerResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListListenerResp& __x, const ListListenerResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListListenerResp& __x, const ListListenerResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListListenerResp& __x, const ListListenerResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ListenerInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> listeners_ref() const& {
    return {this->listeners, __isset.listeners};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ListenerInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> listeners_ref() const&& {
    return {std::move(this->listeners), __isset.listeners};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ListenerInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> listeners_ref() & {
    return {this->listeners, __isset.listeners};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ListenerInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> listeners_ref() && {
    return {std::move(this->listeners), __isset.listeners};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_ListListenerResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_ListListenerResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_ListListenerResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const ::std::vector< ::nebula::meta::cpp2::ListenerInfo>& get_listeners() const&;
  ::std::vector< ::nebula::meta::cpp2::ListenerInfo> get_listeners() &&;

  template <typename T_ListListenerResp_listeners_struct_setter = ::std::vector< ::nebula::meta::cpp2::ListenerInfo>>
  ::std::vector< ::nebula::meta::cpp2::ListenerInfo>& set_listeners(T_ListListenerResp_listeners_struct_setter&& listeners_) {
    listeners = std::forward<T_ListListenerResp_listeners_struct_setter>(listeners_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.listeners = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return listeners;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListListenerResp >;
  friend void swap(ListListenerResp& a, ListListenerResp& b);
};

template <class Protocol_>
uint32_t ListListenerResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetStatsReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetStatsReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetStatsReq() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetStatsReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg);

  GetStatsReq(GetStatsReq&&) = default;

  GetStatsReq(const GetStatsReq&) = default;


  GetStatsReq& operator=(GetStatsReq&&) = default;

  GetStatsReq& operator=(const GetStatsReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
  } __isset = {};
  bool operator==(const GetStatsReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetStatsReq& __x, const GetStatsReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetStatsReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetStatsReq& __x, const GetStatsReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetStatsReq& __x, const GetStatsReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetStatsReq& __x, const GetStatsReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetStatsReq >;
  friend void swap(GetStatsReq& a, GetStatsReq& b);
};

template <class Protocol_>
uint32_t GetStatsReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetStatsResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetStatsResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetStatsResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetStatsResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::StatsItem stats__arg);

  GetStatsResp(GetStatsResp&&) = default;

  GetStatsResp(const GetStatsResp&) = default;


  GetStatsResp& operator=(GetStatsResp&&) = default;

  GetStatsResp& operator=(const GetStatsResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
   ::nebula::meta::cpp2::StatsItem stats;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool stats;
  } __isset = {};
  bool operator==(const GetStatsResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetStatsResp& __x, const GetStatsResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetStatsResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetStatsResp& __x, const GetStatsResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetStatsResp& __x, const GetStatsResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetStatsResp& __x, const GetStatsResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::StatsItem>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> stats_ref() const& {
    return {this->stats, __isset.stats};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::StatsItem>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> stats_ref() const&& {
    return {std::move(this->stats), __isset.stats};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::StatsItem>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> stats_ref() & {
    return {this->stats, __isset.stats};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::StatsItem>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> stats_ref() && {
    return {std::move(this->stats), __isset.stats};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_GetStatsResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_GetStatsResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_GetStatsResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const  ::nebula::meta::cpp2::StatsItem& get_stats() const&;
   ::nebula::meta::cpp2::StatsItem get_stats() &&;

  template <typename T_GetStatsResp_stats_struct_setter =  ::nebula::meta::cpp2::StatsItem>
   ::nebula::meta::cpp2::StatsItem& set_stats(T_GetStatsResp_stats_struct_setter&& stats_) {
    stats = std::forward<T_GetStatsResp_stats_struct_setter>(stats_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.stats = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return stats;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetStatsResp >;
  friend void swap(GetStatsResp& a, GetStatsResp& b);
};

template <class Protocol_>
uint32_t GetStatsResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class HostBackupInfo final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = HostBackupInfo;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  HostBackupInfo() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  HostBackupInfo(apache::thrift::FragileConstructor, nebula::HostAddr host__arg, ::std::vector< ::nebula::cpp2::CheckpointInfo> checkpoints__arg);

  HostBackupInfo(HostBackupInfo&&) = default;

  HostBackupInfo(const HostBackupInfo&) = default;


  HostBackupInfo& operator=(HostBackupInfo&&) = default;

  HostBackupInfo& operator=(const HostBackupInfo&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  nebula::HostAddr host;
 private:
  ::std::vector< ::nebula::cpp2::CheckpointInfo> checkpoints;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool host;
    bool checkpoints;
  } __isset = {};
  bool operator==(const HostBackupInfo& rhs) const;
#ifndef SWIG
  friend bool operator!=(const HostBackupInfo& __x, const HostBackupInfo& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const HostBackupInfo& rhs) const;
#ifndef SWIG
  friend bool operator>(const HostBackupInfo& __x, const HostBackupInfo& __y) {
    return __y < __x;
  }
  friend bool operator<=(const HostBackupInfo& __x, const HostBackupInfo& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const HostBackupInfo& __x, const HostBackupInfo& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> host_ref() const& {
    return {this->host, __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> host_ref() const&& {
    return {std::move(this->host), __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> host_ref() & {
    return {this->host, __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> host_ref() && {
    return {std::move(this->host), __isset.host};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::cpp2::CheckpointInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> checkpoints_ref() const& {
    return {this->checkpoints, __isset.checkpoints};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::CheckpointInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> checkpoints_ref() const&& {
    return {std::move(this->checkpoints), __isset.checkpoints};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::CheckpointInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> checkpoints_ref() & {
    return {this->checkpoints, __isset.checkpoints};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::CheckpointInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> checkpoints_ref() && {
    return {std::move(this->checkpoints), __isset.checkpoints};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const nebula::HostAddr& get_host() const&;
  nebula::HostAddr get_host() &&;

  template <typename T_HostBackupInfo_host_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_host(T_HostBackupInfo_host_struct_setter&& host_) {
    host = std::forward<T_HostBackupInfo_host_struct_setter>(host_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.host = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return host;
  }
  const ::std::vector< ::nebula::cpp2::CheckpointInfo>& get_checkpoints() const&;
  ::std::vector< ::nebula::cpp2::CheckpointInfo> get_checkpoints() &&;

  template <typename T_HostBackupInfo_checkpoints_struct_setter = ::std::vector< ::nebula::cpp2::CheckpointInfo>>
  ::std::vector< ::nebula::cpp2::CheckpointInfo>& set_checkpoints(T_HostBackupInfo_checkpoints_struct_setter&& checkpoints_) {
    checkpoints = std::forward<T_HostBackupInfo_checkpoints_struct_setter>(checkpoints_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.checkpoints = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return checkpoints;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< HostBackupInfo >;
  friend void swap(HostBackupInfo& a, HostBackupInfo& b);
};

template <class Protocol_>
uint32_t HostBackupInfo::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class SpaceBackupInfo final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = SpaceBackupInfo;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  SpaceBackupInfo() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  SpaceBackupInfo(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::SpaceDesc space__arg, ::std::vector< ::nebula::meta::cpp2::HostBackupInfo> host_backups__arg);

  SpaceBackupInfo(SpaceBackupInfo&&) = default;

  SpaceBackupInfo(const SpaceBackupInfo&) = default;


  SpaceBackupInfo& operator=(SpaceBackupInfo&&) = default;

  SpaceBackupInfo& operator=(const SpaceBackupInfo&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::meta::cpp2::SpaceDesc space;
 private:
  ::std::vector< ::nebula::meta::cpp2::HostBackupInfo> host_backups;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space;
    bool host_backups;
  } __isset = {};
  bool operator==(const SpaceBackupInfo& rhs) const;
#ifndef SWIG
  friend bool operator!=(const SpaceBackupInfo& __x, const SpaceBackupInfo& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const SpaceBackupInfo& rhs) const;
#ifndef SWIG
  friend bool operator>(const SpaceBackupInfo& __x, const SpaceBackupInfo& __y) {
    return __y < __x;
  }
  friend bool operator<=(const SpaceBackupInfo& __x, const SpaceBackupInfo& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const SpaceBackupInfo& __x, const SpaceBackupInfo& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::SpaceDesc>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_ref() const& {
    return {this->space, __isset.space};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SpaceDesc>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_ref() const&& {
    return {std::move(this->space), __isset.space};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SpaceDesc>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_ref() & {
    return {this->space, __isset.space};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::SpaceDesc>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_ref() && {
    return {std::move(this->space), __isset.space};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::HostBackupInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> host_backups_ref() const& {
    return {this->host_backups, __isset.host_backups};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::HostBackupInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> host_backups_ref() const&& {
    return {std::move(this->host_backups), __isset.host_backups};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::HostBackupInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> host_backups_ref() & {
    return {this->host_backups, __isset.host_backups};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::HostBackupInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> host_backups_ref() && {
    return {std::move(this->host_backups), __isset.host_backups};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::meta::cpp2::SpaceDesc& get_space() const&;
   ::nebula::meta::cpp2::SpaceDesc get_space() &&;

  template <typename T_SpaceBackupInfo_space_struct_setter =  ::nebula::meta::cpp2::SpaceDesc>
   ::nebula::meta::cpp2::SpaceDesc& set_space(T_SpaceBackupInfo_space_struct_setter&& space_) {
    space = std::forward<T_SpaceBackupInfo_space_struct_setter>(space_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space;
  }
  const ::std::vector< ::nebula::meta::cpp2::HostBackupInfo>& get_host_backups() const&;
  ::std::vector< ::nebula::meta::cpp2::HostBackupInfo> get_host_backups() &&;

  template <typename T_SpaceBackupInfo_host_backups_struct_setter = ::std::vector< ::nebula::meta::cpp2::HostBackupInfo>>
  ::std::vector< ::nebula::meta::cpp2::HostBackupInfo>& set_host_backups(T_SpaceBackupInfo_host_backups_struct_setter&& host_backups_) {
    host_backups = std::forward<T_SpaceBackupInfo_host_backups_struct_setter>(host_backups_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.host_backups = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return host_backups;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< SpaceBackupInfo >;
  friend void swap(SpaceBackupInfo& a, SpaceBackupInfo& b);
};

template <class Protocol_>
uint32_t SpaceBackupInfo::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class BackupMeta final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = BackupMeta;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  BackupMeta();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  BackupMeta(apache::thrift::FragileConstructor, std::unordered_map< ::nebula::cpp2::GraphSpaceID,  ::nebula::meta::cpp2::SpaceBackupInfo> space_backups__arg, ::std::vector<::std::string> meta_files__arg, ::std::string backup_name__arg, bool full__arg, bool all_spaces__arg, int64_t create_time__arg, ::std::string base_backup_name__arg, ::std::vector<nebula::HostAddr> storage_hosts__arg,  ::nebula::meta::cpp2::ClusterID cluster_id__arg);

  BackupMeta(BackupMeta&&) = default;

  BackupMeta(const BackupMeta&) = default;


  BackupMeta& operator=(BackupMeta&&) = default;

  BackupMeta& operator=(const BackupMeta&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~BackupMeta();

 private:
  std::unordered_map< ::nebula::cpp2::GraphSpaceID,  ::nebula::meta::cpp2::SpaceBackupInfo> space_backups;
 private:
  ::std::vector<::std::string> meta_files;
 private:
  ::std::string backup_name;
 private:
  bool full;
 private:
  bool all_spaces;
 private:
  int64_t create_time;
 private:
  ::std::string base_backup_name;
 private:
  ::std::vector<nebula::HostAddr> storage_hosts;
 private:
   ::nebula::meta::cpp2::ClusterID cluster_id;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_backups;
    bool meta_files;
    bool backup_name;
    bool full;
    bool all_spaces;
    bool create_time;
    bool base_backup_name;
    bool storage_hosts;
    bool cluster_id;
  } __isset = {};
  bool operator==(const BackupMeta& rhs) const;
#ifndef SWIG
  friend bool operator!=(const BackupMeta& __x, const BackupMeta& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const BackupMeta& rhs) const;
#ifndef SWIG
  friend bool operator>(const BackupMeta& __x, const BackupMeta& __y) {
    return __y < __x;
  }
  friend bool operator<=(const BackupMeta& __x, const BackupMeta& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const BackupMeta& __x, const BackupMeta& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID,  ::nebula::meta::cpp2::SpaceBackupInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_backups_ref() const& {
    return {this->space_backups, __isset.space_backups};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID,  ::nebula::meta::cpp2::SpaceBackupInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_backups_ref() const&& {
    return {std::move(this->space_backups), __isset.space_backups};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID,  ::nebula::meta::cpp2::SpaceBackupInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_backups_ref() & {
    return {this->space_backups, __isset.space_backups};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID,  ::nebula::meta::cpp2::SpaceBackupInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_backups_ref() && {
    return {std::move(this->space_backups), __isset.space_backups};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> meta_files_ref() const& {
    return {this->meta_files, __isset.meta_files};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> meta_files_ref() const&& {
    return {std::move(this->meta_files), __isset.meta_files};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> meta_files_ref() & {
    return {this->meta_files, __isset.meta_files};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> meta_files_ref() && {
    return {std::move(this->meta_files), __isset.meta_files};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> backup_name_ref() const& {
    return {this->backup_name, __isset.backup_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> backup_name_ref() const&& {
    return {std::move(this->backup_name), __isset.backup_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> backup_name_ref() & {
    return {this->backup_name, __isset.backup_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> backup_name_ref() && {
    return {std::move(this->backup_name), __isset.backup_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> full_ref() const& {
    return {this->full, __isset.full};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> full_ref() const&& {
    return {std::move(this->full), __isset.full};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> full_ref() & {
    return {this->full, __isset.full};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> full_ref() && {
    return {std::move(this->full), __isset.full};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> all_spaces_ref() const& {
    return {this->all_spaces, __isset.all_spaces};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> all_spaces_ref() const&& {
    return {std::move(this->all_spaces), __isset.all_spaces};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> all_spaces_ref() & {
    return {this->all_spaces, __isset.all_spaces};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> all_spaces_ref() && {
    return {std::move(this->all_spaces), __isset.all_spaces};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> create_time_ref() const& {
    return {this->create_time, __isset.create_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> create_time_ref() const&& {
    return {std::move(this->create_time), __isset.create_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> create_time_ref() & {
    return {this->create_time, __isset.create_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> create_time_ref() && {
    return {std::move(this->create_time), __isset.create_time};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> base_backup_name_ref() const& {
    return {this->base_backup_name, __isset.base_backup_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> base_backup_name_ref() const&& {
    return {std::move(this->base_backup_name), __isset.base_backup_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> base_backup_name_ref() & {
    return {this->base_backup_name, __isset.base_backup_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> base_backup_name_ref() && {
    return {std::move(this->base_backup_name), __isset.base_backup_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> storage_hosts_ref() const& {
    return {this->storage_hosts, __isset.storage_hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> storage_hosts_ref() const&& {
    return {std::move(this->storage_hosts), __isset.storage_hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> storage_hosts_ref() & {
    return {this->storage_hosts, __isset.storage_hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> storage_hosts_ref() && {
    return {std::move(this->storage_hosts), __isset.storage_hosts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> cluster_id_ref() const& {
    return {this->cluster_id, __isset.cluster_id};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> cluster_id_ref() const&& {
    return {std::move(this->cluster_id), __isset.cluster_id};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> cluster_id_ref() & {
    return {this->cluster_id, __isset.cluster_id};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> cluster_id_ref() && {
    return {std::move(this->cluster_id), __isset.cluster_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const std::unordered_map< ::nebula::cpp2::GraphSpaceID,  ::nebula::meta::cpp2::SpaceBackupInfo>& get_space_backups() const&;
  std::unordered_map< ::nebula::cpp2::GraphSpaceID,  ::nebula::meta::cpp2::SpaceBackupInfo> get_space_backups() &&;

  template <typename T_BackupMeta_space_backups_struct_setter = std::unordered_map< ::nebula::cpp2::GraphSpaceID,  ::nebula::meta::cpp2::SpaceBackupInfo>>
  std::unordered_map< ::nebula::cpp2::GraphSpaceID,  ::nebula::meta::cpp2::SpaceBackupInfo>& set_space_backups(T_BackupMeta_space_backups_struct_setter&& space_backups_) {
    space_backups = std::forward<T_BackupMeta_space_backups_struct_setter>(space_backups_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_backups = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_backups;
  }
  const ::std::vector<::std::string>& get_meta_files() const&;
  ::std::vector<::std::string> get_meta_files() &&;

  template <typename T_BackupMeta_meta_files_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_meta_files(T_BackupMeta_meta_files_struct_setter&& meta_files_) {
    meta_files = std::forward<T_BackupMeta_meta_files_struct_setter>(meta_files_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.meta_files = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return meta_files;
  }

  const ::std::string& get_backup_name() const& {
    return backup_name;
  }

  ::std::string get_backup_name() && {
    return std::move(backup_name);
  }

  template <typename T_BackupMeta_backup_name_struct_setter = ::std::string>
  ::std::string& set_backup_name(T_BackupMeta_backup_name_struct_setter&& backup_name_) {
    backup_name = std::forward<T_BackupMeta_backup_name_struct_setter>(backup_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.backup_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return backup_name;
  }

  bool get_full() const {
    return full;
  }

  bool& set_full(bool full_) {
    full = full_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.full = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return full;
  }

  bool get_all_spaces() const {
    return all_spaces;
  }

  bool& set_all_spaces(bool all_spaces_) {
    all_spaces = all_spaces_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.all_spaces = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return all_spaces;
  }

  int64_t get_create_time() const {
    return create_time;
  }

  int64_t& set_create_time(int64_t create_time_) {
    create_time = create_time_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.create_time = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return create_time;
  }

  const ::std::string& get_base_backup_name() const& {
    return base_backup_name;
  }

  ::std::string get_base_backup_name() && {
    return std::move(base_backup_name);
  }

  template <typename T_BackupMeta_base_backup_name_struct_setter = ::std::string>
  ::std::string& set_base_backup_name(T_BackupMeta_base_backup_name_struct_setter&& base_backup_name_) {
    base_backup_name = std::forward<T_BackupMeta_base_backup_name_struct_setter>(base_backup_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.base_backup_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return base_backup_name;
  }
  const ::std::vector<nebula::HostAddr>& get_storage_hosts() const&;
  ::std::vector<nebula::HostAddr> get_storage_hosts() &&;

  template <typename T_BackupMeta_storage_hosts_struct_setter = ::std::vector<nebula::HostAddr>>
  ::std::vector<nebula::HostAddr>& set_storage_hosts(T_BackupMeta_storage_hosts_struct_setter&& storage_hosts_) {
    storage_hosts = std::forward<T_BackupMeta_storage_hosts_struct_setter>(storage_hosts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.storage_hosts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return storage_hosts;
  }

   ::nebula::meta::cpp2::ClusterID get_cluster_id() const {
    return cluster_id;
  }

   ::nebula::meta::cpp2::ClusterID& set_cluster_id( ::nebula::meta::cpp2::ClusterID cluster_id_) {
    cluster_id = cluster_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.cluster_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return cluster_id;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< BackupMeta >;
  friend void swap(BackupMeta& a, BackupMeta& b);
};

template <class Protocol_>
uint32_t BackupMeta::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class CreateBackupReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CreateBackupReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  CreateBackupReq() :
      cluster_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CreateBackupReq(apache::thrift::FragileConstructor, ::std::vector<::std::string> spaces__arg, ::std::string base_backup_name__arg,  ::nebula::meta::cpp2::ClusterID cluster_id__arg);

  CreateBackupReq(CreateBackupReq&&) = default;

  CreateBackupReq(const CreateBackupReq&) = default;


  CreateBackupReq& operator=(CreateBackupReq&&) = default;

  CreateBackupReq& operator=(const CreateBackupReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector<::std::string> spaces;
 private:
  ::std::string base_backup_name;
 private:
   ::nebula::meta::cpp2::ClusterID cluster_id;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool spaces;
    bool base_backup_name;
    bool cluster_id;
  } __isset = {};
  bool operator==(const CreateBackupReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CreateBackupReq& __x, const CreateBackupReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CreateBackupReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const CreateBackupReq& __x, const CreateBackupReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CreateBackupReq& __x, const CreateBackupReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CreateBackupReq& __x, const CreateBackupReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> spaces_ref() const& {
    return {this->spaces, __isset.spaces};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> spaces_ref() const&& {
    return {std::move(this->spaces), __isset.spaces};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> spaces_ref() & {
    return {this->spaces, __isset.spaces};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> spaces_ref() && {
    return {std::move(this->spaces), __isset.spaces};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> base_backup_name_ref() const& {
    return {this->base_backup_name, __isset.base_backup_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> base_backup_name_ref() const&& {
    return {std::move(this->base_backup_name), __isset.base_backup_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> base_backup_name_ref() & {
    return {this->base_backup_name, __isset.base_backup_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> base_backup_name_ref() && {
    return {std::move(this->base_backup_name), __isset.base_backup_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> cluster_id_ref() const& {
    return {this->cluster_id, __isset.cluster_id};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> cluster_id_ref() const&& {
    return {std::move(this->cluster_id), __isset.cluster_id};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> cluster_id_ref() & {
    return {this->cluster_id, __isset.cluster_id};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ClusterID>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> cluster_id_ref() && {
    return {std::move(this->cluster_id), __isset.cluster_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector<::std::string>* get_spaces() const&;
  ::std::vector<::std::string>* get_spaces() &;
  ::std::vector<::std::string>* get_spaces() && = delete;

  template <typename T_CreateBackupReq_spaces_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_spaces(T_CreateBackupReq_spaces_struct_setter&& spaces_) {
    spaces = std::forward<T_CreateBackupReq_spaces_struct_setter>(spaces_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.spaces = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return spaces;
  }

  const ::std::string* get_base_backup_name() const& {
    return base_backup_name_ref() ? std::addressof(base_backup_name) : nullptr;
  }

  ::std::string* get_base_backup_name() & {
    return base_backup_name_ref() ? std::addressof(base_backup_name) : nullptr;
  }
  ::std::string* get_base_backup_name() && = delete;

  template <typename T_CreateBackupReq_base_backup_name_struct_setter = ::std::string>
  ::std::string& set_base_backup_name(T_CreateBackupReq_base_backup_name_struct_setter&& base_backup_name_) {
    base_backup_name = std::forward<T_CreateBackupReq_base_backup_name_struct_setter>(base_backup_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.base_backup_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return base_backup_name;
  }

  const  ::nebula::meta::cpp2::ClusterID* get_cluster_id() const& {
    return cluster_id_ref() ? std::addressof(cluster_id) : nullptr;
  }

   ::nebula::meta::cpp2::ClusterID* get_cluster_id() & {
    return cluster_id_ref() ? std::addressof(cluster_id) : nullptr;
  }
   ::nebula::meta::cpp2::ClusterID* get_cluster_id() && = delete;

   ::nebula::meta::cpp2::ClusterID& set_cluster_id( ::nebula::meta::cpp2::ClusterID cluster_id_) {
    cluster_id = cluster_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.cluster_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return cluster_id;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CreateBackupReq >;
  friend void swap(CreateBackupReq& a, CreateBackupReq& b);
};

template <class Protocol_>
uint32_t CreateBackupReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class CreateBackupResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CreateBackupResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  CreateBackupResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CreateBackupResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::BackupMeta meta__arg);

  CreateBackupResp(CreateBackupResp&&) = default;

  CreateBackupResp(const CreateBackupResp&) = default;


  CreateBackupResp& operator=(CreateBackupResp&&) = default;

  CreateBackupResp& operator=(const CreateBackupResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
   ::nebula::meta::cpp2::BackupMeta meta;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool meta;
  } __isset = {};
  bool operator==(const CreateBackupResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CreateBackupResp& __x, const CreateBackupResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CreateBackupResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const CreateBackupResp& __x, const CreateBackupResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CreateBackupResp& __x, const CreateBackupResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CreateBackupResp& __x, const CreateBackupResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::BackupMeta>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> meta_ref() const& {
    return {this->meta, __isset.meta};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::BackupMeta>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> meta_ref() const&& {
    return {std::move(this->meta), __isset.meta};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::BackupMeta>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> meta_ref() & {
    return {this->meta, __isset.meta};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::BackupMeta>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> meta_ref() && {
    return {std::move(this->meta), __isset.meta};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_CreateBackupResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_CreateBackupResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_CreateBackupResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const  ::nebula::meta::cpp2::BackupMeta& get_meta() const&;
   ::nebula::meta::cpp2::BackupMeta get_meta() &&;

  template <typename T_CreateBackupResp_meta_struct_setter =  ::nebula::meta::cpp2::BackupMeta>
   ::nebula::meta::cpp2::BackupMeta& set_meta(T_CreateBackupResp_meta_struct_setter&& meta_) {
    meta = std::forward<T_CreateBackupResp_meta_struct_setter>(meta_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.meta = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return meta;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CreateBackupResp >;
  friend void swap(CreateBackupResp& a, CreateBackupResp& b);
};

template <class Protocol_>
uint32_t CreateBackupResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class HostPair final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = HostPair;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  HostPair() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  HostPair(apache::thrift::FragileConstructor, nebula::HostAddr from_host__arg, nebula::HostAddr to_host__arg);

  HostPair(HostPair&&) = default;

  HostPair(const HostPair&) = default;


  HostPair& operator=(HostPair&&) = default;

  HostPair& operator=(const HostPair&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  nebula::HostAddr from_host;
 private:
  nebula::HostAddr to_host;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool from_host;
    bool to_host;
  } __isset = {};
  bool operator==(const HostPair& rhs) const;
#ifndef SWIG
  friend bool operator!=(const HostPair& __x, const HostPair& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const HostPair& rhs) const;
#ifndef SWIG
  friend bool operator>(const HostPair& __x, const HostPair& __y) {
    return __y < __x;
  }
  friend bool operator<=(const HostPair& __x, const HostPair& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const HostPair& __x, const HostPair& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> from_host_ref() const& {
    return {this->from_host, __isset.from_host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> from_host_ref() const&& {
    return {std::move(this->from_host), __isset.from_host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> from_host_ref() & {
    return {this->from_host, __isset.from_host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> from_host_ref() && {
    return {std::move(this->from_host), __isset.from_host};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> to_host_ref() const& {
    return {this->to_host, __isset.to_host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> to_host_ref() const&& {
    return {std::move(this->to_host), __isset.to_host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> to_host_ref() & {
    return {this->to_host, __isset.to_host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> to_host_ref() && {
    return {std::move(this->to_host), __isset.to_host};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const nebula::HostAddr& get_from_host() const&;
  nebula::HostAddr get_from_host() &&;

  template <typename T_HostPair_from_host_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_from_host(T_HostPair_from_host_struct_setter&& from_host_) {
    from_host = std::forward<T_HostPair_from_host_struct_setter>(from_host_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.from_host = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return from_host;
  }
  const nebula::HostAddr& get_to_host() const&;
  nebula::HostAddr get_to_host() &&;

  template <typename T_HostPair_to_host_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_to_host(T_HostPair_to_host_struct_setter&& to_host_) {
    to_host = std::forward<T_HostPair_to_host_struct_setter>(to_host_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.to_host = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return to_host;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< HostPair >;
  friend void swap(HostPair& a, HostPair& b);
};

template <class Protocol_>
uint32_t HostPair::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class RestoreMetaReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = RestoreMetaReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  RestoreMetaReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RestoreMetaReq(apache::thrift::FragileConstructor, ::std::vector<::std::string> files__arg, ::std::vector< ::nebula::meta::cpp2::HostPair> hosts__arg);

  RestoreMetaReq(RestoreMetaReq&&) = default;

  RestoreMetaReq(const RestoreMetaReq&) = default;


  RestoreMetaReq& operator=(RestoreMetaReq&&) = default;

  RestoreMetaReq& operator=(const RestoreMetaReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector<::std::string> files;
 private:
  ::std::vector< ::nebula::meta::cpp2::HostPair> hosts;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool files;
    bool hosts;
  } __isset = {};
  bool operator==(const RestoreMetaReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const RestoreMetaReq& __x, const RestoreMetaReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const RestoreMetaReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const RestoreMetaReq& __x, const RestoreMetaReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const RestoreMetaReq& __x, const RestoreMetaReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const RestoreMetaReq& __x, const RestoreMetaReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> files_ref() const& {
    return {this->files, __isset.files};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> files_ref() const&& {
    return {std::move(this->files), __isset.files};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> files_ref() & {
    return {this->files, __isset.files};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> files_ref() && {
    return {std::move(this->files), __isset.files};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::HostPair>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> hosts_ref() const& {
    return {this->hosts, __isset.hosts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::HostPair>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> hosts_ref() const&& {
    return {std::move(this->hosts), __isset.hosts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::HostPair>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> hosts_ref() & {
    return {this->hosts, __isset.hosts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::HostPair>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> hosts_ref() && {
    return {std::move(this->hosts), __isset.hosts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector<::std::string>& get_files() const&;
  ::std::vector<::std::string> get_files() &&;

  template <typename T_RestoreMetaReq_files_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_files(T_RestoreMetaReq_files_struct_setter&& files_) {
    files = std::forward<T_RestoreMetaReq_files_struct_setter>(files_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.files = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return files;
  }
  const ::std::vector< ::nebula::meta::cpp2::HostPair>& get_hosts() const&;
  ::std::vector< ::nebula::meta::cpp2::HostPair> get_hosts() &&;

  template <typename T_RestoreMetaReq_hosts_struct_setter = ::std::vector< ::nebula::meta::cpp2::HostPair>>
  ::std::vector< ::nebula::meta::cpp2::HostPair>& set_hosts(T_RestoreMetaReq_hosts_struct_setter&& hosts_) {
    hosts = std::forward<T_RestoreMetaReq_hosts_struct_setter>(hosts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.hosts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return hosts;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< RestoreMetaReq >;
  friend void swap(RestoreMetaReq& a, RestoreMetaReq& b);
};

template <class Protocol_>
uint32_t RestoreMetaReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class PartInfo final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = PartInfo;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  PartInfo() :
      part_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  PartInfo(apache::thrift::FragileConstructor,  ::nebula::cpp2::PartitionID part_id__arg, ::std::vector<nebula::HostAddr> hosts__arg);

  PartInfo(PartInfo&&) = default;

  PartInfo(const PartInfo&) = default;


  PartInfo& operator=(PartInfo&&) = default;

  PartInfo& operator=(const PartInfo&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::PartitionID part_id;
 private:
  ::std::vector<nebula::HostAddr> hosts;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool part_id;
    bool hosts;
  } __isset = {};
  bool operator==(const PartInfo& rhs) const;
#ifndef SWIG
  friend bool operator!=(const PartInfo& __x, const PartInfo& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const PartInfo& rhs) const;
#ifndef SWIG
  friend bool operator>(const PartInfo& __x, const PartInfo& __y) {
    return __y < __x;
  }
  friend bool operator<=(const PartInfo& __x, const PartInfo& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const PartInfo& __x, const PartInfo& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> part_id_ref() const& {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> part_id_ref() const&& {
    return {std::move(this->part_id), __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> part_id_ref() & {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> part_id_ref() && {
    return {std::move(this->part_id), __isset.part_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> hosts_ref() const& {
    return {this->hosts, __isset.hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> hosts_ref() const&& {
    return {std::move(this->hosts), __isset.hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> hosts_ref() & {
    return {this->hosts, __isset.hosts};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> hosts_ref() && {
    return {std::move(this->hosts), __isset.hosts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::PartitionID get_part_id() const {
    return part_id;
  }

   ::nebula::cpp2::PartitionID& set_part_id( ::nebula::cpp2::PartitionID part_id_) {
    part_id = part_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.part_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return part_id;
  }
  const ::std::vector<nebula::HostAddr>& get_hosts() const&;
  ::std::vector<nebula::HostAddr> get_hosts() &&;

  template <typename T_PartInfo_hosts_struct_setter = ::std::vector<nebula::HostAddr>>
  ::std::vector<nebula::HostAddr>& set_hosts(T_PartInfo_hosts_struct_setter&& hosts_) {
    hosts = std::forward<T_PartInfo_hosts_struct_setter>(hosts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.hosts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return hosts;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< PartInfo >;
  friend void swap(PartInfo& a, PartInfo& b);
};

template <class Protocol_>
uint32_t PartInfo::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class RestoreMetaResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = RestoreMetaResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  RestoreMetaResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RestoreMetaResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::PartInfo>> part_hosts__arg);

  RestoreMetaResp(RestoreMetaResp&&) = default;

  RestoreMetaResp(const RestoreMetaResp&) = default;


  RestoreMetaResp& operator=(RestoreMetaResp&&) = default;

  RestoreMetaResp& operator=(const RestoreMetaResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::PartInfo>> part_hosts;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool part_hosts;
  } __isset = {};
  bool operator==(const RestoreMetaResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const RestoreMetaResp& __x, const RestoreMetaResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const RestoreMetaResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const RestoreMetaResp& __x, const RestoreMetaResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const RestoreMetaResp& __x, const RestoreMetaResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const RestoreMetaResp& __x, const RestoreMetaResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::PartInfo>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> part_hosts_ref() const& {
    return {this->part_hosts, __isset.part_hosts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::PartInfo>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> part_hosts_ref() const&& {
    return {std::move(this->part_hosts), __isset.part_hosts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::PartInfo>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> part_hosts_ref() & {
    return {this->part_hosts, __isset.part_hosts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::PartInfo>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> part_hosts_ref() && {
    return {std::move(this->part_hosts), __isset.part_hosts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_RestoreMetaResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_RestoreMetaResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_RestoreMetaResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::PartInfo>>& get_part_hosts() const&;
  std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::PartInfo>> get_part_hosts() &&;

  template <typename T_RestoreMetaResp_part_hosts_struct_setter = std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::PartInfo>>>
  std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::PartInfo>>& set_part_hosts(T_RestoreMetaResp_part_hosts_struct_setter&& part_hosts_) {
    part_hosts = std::forward<T_RestoreMetaResp_part_hosts_struct_setter>(part_hosts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.part_hosts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return part_hosts;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< RestoreMetaResp >;
  friend void swap(RestoreMetaResp& a, RestoreMetaResp& b);
};

template <class Protocol_>
uint32_t RestoreMetaResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ServiceClient final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ServiceClient;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ServiceClient() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ServiceClient(apache::thrift::FragileConstructor, nebula::HostAddr host__arg, ::std::string user__arg, ::std::string pwd__arg, ::std::string conn_type__arg);

  ServiceClient(ServiceClient&&) = default;

  ServiceClient(const ServiceClient&) = default;


  ServiceClient& operator=(ServiceClient&&) = default;

  ServiceClient& operator=(const ServiceClient&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
  nebula::HostAddr host;
 private:
  ::std::string user;
 private:
  ::std::string pwd;
 private:
  ::std::string conn_type;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool user;
    bool pwd;
    bool conn_type;
  } __isset = {};
  bool operator==(const ServiceClient& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ServiceClient& __x, const ServiceClient& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ServiceClient& rhs) const;
#ifndef SWIG
  friend bool operator>(const ServiceClient& __x, const ServiceClient& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ServiceClient& __x, const ServiceClient& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ServiceClient& __x, const ServiceClient& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> host_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> host_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->host)};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> host_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> host_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->host)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> user_ref() const& {
    return {this->user, __isset.user};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> user_ref() const&& {
    return {std::move(this->user), __isset.user};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> user_ref() & {
    return {this->user, __isset.user};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> user_ref() && {
    return {std::move(this->user), __isset.user};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> pwd_ref() const& {
    return {this->pwd, __isset.pwd};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> pwd_ref() const&& {
    return {std::move(this->pwd), __isset.pwd};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> pwd_ref() & {
    return {this->pwd, __isset.pwd};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> pwd_ref() && {
    return {std::move(this->pwd), __isset.pwd};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> conn_type_ref() const& {
    return {this->conn_type, __isset.conn_type};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> conn_type_ref() const&& {
    return {std::move(this->conn_type), __isset.conn_type};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> conn_type_ref() & {
    return {this->conn_type, __isset.conn_type};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> conn_type_ref() && {
    return {std::move(this->conn_type), __isset.conn_type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const nebula::HostAddr& get_host() const&;
  nebula::HostAddr get_host() &&;

  template <typename T_ServiceClient_host_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_host(T_ServiceClient_host_struct_setter&& host_) {
    host = std::forward<T_ServiceClient_host_struct_setter>(host_);
    return host;
  }

  const ::std::string* get_user() const& {
    return user_ref() ? std::addressof(user) : nullptr;
  }

  ::std::string* get_user() & {
    return user_ref() ? std::addressof(user) : nullptr;
  }
  ::std::string* get_user() && = delete;

  template <typename T_ServiceClient_user_struct_setter = ::std::string>
  ::std::string& set_user(T_ServiceClient_user_struct_setter&& user_) {
    user = std::forward<T_ServiceClient_user_struct_setter>(user_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.user = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return user;
  }

  const ::std::string* get_pwd() const& {
    return pwd_ref() ? std::addressof(pwd) : nullptr;
  }

  ::std::string* get_pwd() & {
    return pwd_ref() ? std::addressof(pwd) : nullptr;
  }
  ::std::string* get_pwd() && = delete;

  template <typename T_ServiceClient_pwd_struct_setter = ::std::string>
  ::std::string& set_pwd(T_ServiceClient_pwd_struct_setter&& pwd_) {
    pwd = std::forward<T_ServiceClient_pwd_struct_setter>(pwd_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.pwd = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return pwd;
  }

  const ::std::string* get_conn_type() const& {
    return conn_type_ref() ? std::addressof(conn_type) : nullptr;
  }

  ::std::string* get_conn_type() & {
    return conn_type_ref() ? std::addressof(conn_type) : nullptr;
  }
  ::std::string* get_conn_type() && = delete;

  template <typename T_ServiceClient_conn_type_struct_setter = ::std::string>
  ::std::string& set_conn_type(T_ServiceClient_conn_type_struct_setter&& conn_type_) {
    conn_type = std::forward<T_ServiceClient_conn_type_struct_setter>(conn_type_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.conn_type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return conn_type;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ServiceClient >;
  friend void swap(ServiceClient& a, ServiceClient& b);
};

template <class Protocol_>
uint32_t ServiceClient::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class SignInServiceReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = SignInServiceReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  SignInServiceReq() :
      type(static_cast< ::nebula::meta::cpp2::ExternalServiceType>(0)) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  SignInServiceReq(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::ExternalServiceType type__arg, ::std::vector< ::nebula::meta::cpp2::ServiceClient> clients__arg);

  SignInServiceReq(SignInServiceReq&&) = default;

  SignInServiceReq(const SignInServiceReq&) = default;


  SignInServiceReq& operator=(SignInServiceReq&&) = default;

  SignInServiceReq& operator=(const SignInServiceReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::meta::cpp2::ExternalServiceType type;
 private:
  ::std::vector< ::nebula::meta::cpp2::ServiceClient> clients;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool type;
    bool clients;
  } __isset = {};
  bool operator==(const SignInServiceReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const SignInServiceReq& __x, const SignInServiceReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const SignInServiceReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const SignInServiceReq& __x, const SignInServiceReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const SignInServiceReq& __x, const SignInServiceReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const SignInServiceReq& __x, const SignInServiceReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::ExternalServiceType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> type_ref() const& {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ExternalServiceType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> type_ref() const&& {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ExternalServiceType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> type_ref() & {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ExternalServiceType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> type_ref() && {
    return {std::move(this->type), __isset.type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ServiceClient>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> clients_ref() const& {
    return {this->clients, __isset.clients};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ServiceClient>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> clients_ref() const&& {
    return {std::move(this->clients), __isset.clients};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ServiceClient>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> clients_ref() & {
    return {this->clients, __isset.clients};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::ServiceClient>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> clients_ref() && {
    return {std::move(this->clients), __isset.clients};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::meta::cpp2::ExternalServiceType get_type() const {
    return type;
  }

   ::nebula::meta::cpp2::ExternalServiceType& set_type( ::nebula::meta::cpp2::ExternalServiceType type_) {
    type = type_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return type;
  }
  const ::std::vector< ::nebula::meta::cpp2::ServiceClient>& get_clients() const&;
  ::std::vector< ::nebula::meta::cpp2::ServiceClient> get_clients() &&;

  template <typename T_SignInServiceReq_clients_struct_setter = ::std::vector< ::nebula::meta::cpp2::ServiceClient>>
  ::std::vector< ::nebula::meta::cpp2::ServiceClient>& set_clients(T_SignInServiceReq_clients_struct_setter&& clients_) {
    clients = std::forward<T_SignInServiceReq_clients_struct_setter>(clients_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.clients = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return clients;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< SignInServiceReq >;
  friend void swap(SignInServiceReq& a, SignInServiceReq& b);
};

template <class Protocol_>
uint32_t SignInServiceReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class SignOutServiceReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = SignOutServiceReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  SignOutServiceReq() :
      type(static_cast< ::nebula::meta::cpp2::ExternalServiceType>(0)) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  SignOutServiceReq(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::ExternalServiceType type__arg);

  SignOutServiceReq(SignOutServiceReq&&) = default;

  SignOutServiceReq(const SignOutServiceReq&) = default;


  SignOutServiceReq& operator=(SignOutServiceReq&&) = default;

  SignOutServiceReq& operator=(const SignOutServiceReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::meta::cpp2::ExternalServiceType type;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool type;
  } __isset = {};
  bool operator==(const SignOutServiceReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const SignOutServiceReq& __x, const SignOutServiceReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const SignOutServiceReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const SignOutServiceReq& __x, const SignOutServiceReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const SignOutServiceReq& __x, const SignOutServiceReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const SignOutServiceReq& __x, const SignOutServiceReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::ExternalServiceType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> type_ref() const& {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ExternalServiceType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> type_ref() const&& {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ExternalServiceType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> type_ref() & {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ExternalServiceType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> type_ref() && {
    return {std::move(this->type), __isset.type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::meta::cpp2::ExternalServiceType get_type() const {
    return type;
  }

   ::nebula::meta::cpp2::ExternalServiceType& set_type( ::nebula::meta::cpp2::ExternalServiceType type_) {
    type = type_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return type;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< SignOutServiceReq >;
  friend void swap(SignOutServiceReq& a, SignOutServiceReq& b);
};

template <class Protocol_>
uint32_t SignOutServiceReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListServiceClientsReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListServiceClientsReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListServiceClientsReq() :
      type(static_cast< ::nebula::meta::cpp2::ExternalServiceType>(0)) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListServiceClientsReq(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::ExternalServiceType type__arg);

  ListServiceClientsReq(ListServiceClientsReq&&) = default;

  ListServiceClientsReq(const ListServiceClientsReq&) = default;


  ListServiceClientsReq& operator=(ListServiceClientsReq&&) = default;

  ListServiceClientsReq& operator=(const ListServiceClientsReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::meta::cpp2::ExternalServiceType type;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool type;
  } __isset = {};
  bool operator==(const ListServiceClientsReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListServiceClientsReq& __x, const ListServiceClientsReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListServiceClientsReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListServiceClientsReq& __x, const ListServiceClientsReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListServiceClientsReq& __x, const ListServiceClientsReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListServiceClientsReq& __x, const ListServiceClientsReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::ExternalServiceType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> type_ref() const& {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ExternalServiceType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> type_ref() const&& {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ExternalServiceType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> type_ref() & {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::ExternalServiceType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> type_ref() && {
    return {std::move(this->type), __isset.type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::meta::cpp2::ExternalServiceType get_type() const {
    return type;
  }

   ::nebula::meta::cpp2::ExternalServiceType& set_type( ::nebula::meta::cpp2::ExternalServiceType type_) {
    type = type_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return type;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListServiceClientsReq >;
  friend void swap(ListServiceClientsReq& a, ListServiceClientsReq& b);
};

template <class Protocol_>
uint32_t ListServiceClientsReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListServiceClientsResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListServiceClientsResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListServiceClientsResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListServiceClientsResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, std::unordered_map< ::nebula::meta::cpp2::ExternalServiceType, ::std::vector< ::nebula::meta::cpp2::ServiceClient>> clients__arg);

  ListServiceClientsResp(ListServiceClientsResp&&) = default;

  ListServiceClientsResp(const ListServiceClientsResp&) = default;


  ListServiceClientsResp& operator=(ListServiceClientsResp&&) = default;

  ListServiceClientsResp& operator=(const ListServiceClientsResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  std::unordered_map< ::nebula::meta::cpp2::ExternalServiceType, ::std::vector< ::nebula::meta::cpp2::ServiceClient>> clients;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool clients;
  } __isset = {};
  bool operator==(const ListServiceClientsResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListServiceClientsResp& __x, const ListServiceClientsResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListServiceClientsResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListServiceClientsResp& __x, const ListServiceClientsResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListServiceClientsResp& __x, const ListServiceClientsResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListServiceClientsResp& __x, const ListServiceClientsResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::meta::cpp2::ExternalServiceType, ::std::vector< ::nebula::meta::cpp2::ServiceClient>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> clients_ref() const& {
    return {this->clients, __isset.clients};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::meta::cpp2::ExternalServiceType, ::std::vector< ::nebula::meta::cpp2::ServiceClient>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> clients_ref() const&& {
    return {std::move(this->clients), __isset.clients};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::meta::cpp2::ExternalServiceType, ::std::vector< ::nebula::meta::cpp2::ServiceClient>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> clients_ref() & {
    return {this->clients, __isset.clients};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::meta::cpp2::ExternalServiceType, ::std::vector< ::nebula::meta::cpp2::ServiceClient>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> clients_ref() && {
    return {std::move(this->clients), __isset.clients};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_ListServiceClientsResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_ListServiceClientsResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_ListServiceClientsResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const std::unordered_map< ::nebula::meta::cpp2::ExternalServiceType, ::std::vector< ::nebula::meta::cpp2::ServiceClient>>& get_clients() const&;
  std::unordered_map< ::nebula::meta::cpp2::ExternalServiceType, ::std::vector< ::nebula::meta::cpp2::ServiceClient>> get_clients() &&;

  template <typename T_ListServiceClientsResp_clients_struct_setter = std::unordered_map< ::nebula::meta::cpp2::ExternalServiceType, ::std::vector< ::nebula::meta::cpp2::ServiceClient>>>
  std::unordered_map< ::nebula::meta::cpp2::ExternalServiceType, ::std::vector< ::nebula::meta::cpp2::ServiceClient>>& set_clients(T_ListServiceClientsResp_clients_struct_setter&& clients_) {
    clients = std::forward<T_ListServiceClientsResp_clients_struct_setter>(clients_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.clients = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return clients;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListServiceClientsResp >;
  friend void swap(ListServiceClientsResp& a, ListServiceClientsResp& b);
};

template <class Protocol_>
uint32_t ListServiceClientsResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class FTIndex final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = FTIndex;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  FTIndex() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  FTIndex(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::SchemaID depend_schema__arg, ::std::vector<::std::string> fields__arg);

  FTIndex(FTIndex&&) = default;

  FTIndex(const FTIndex&) = default;


  FTIndex& operator=(FTIndex&&) = default;

  FTIndex& operator=(const FTIndex&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
   ::nebula::cpp2::SchemaID depend_schema;
 private:
  ::std::vector<::std::string> fields;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool depend_schema;
    bool fields;
  } __isset = {};
  bool operator==(const FTIndex& rhs) const;
#ifndef SWIG
  friend bool operator!=(const FTIndex& __x, const FTIndex& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const FTIndex& rhs) const;
#ifndef SWIG
  friend bool operator>(const FTIndex& __x, const FTIndex& __y) {
    return __y < __x;
  }
  friend bool operator<=(const FTIndex& __x, const FTIndex& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const FTIndex& __x, const FTIndex& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::SchemaID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> depend_schema_ref() const& {
    return {this->depend_schema, __isset.depend_schema};
  }

  template <typename..., typename T =  ::nebula::cpp2::SchemaID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> depend_schema_ref() const&& {
    return {std::move(this->depend_schema), __isset.depend_schema};
  }

  template <typename..., typename T =  ::nebula::cpp2::SchemaID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> depend_schema_ref() & {
    return {this->depend_schema, __isset.depend_schema};
  }

  template <typename..., typename T =  ::nebula::cpp2::SchemaID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> depend_schema_ref() && {
    return {std::move(this->depend_schema), __isset.depend_schema};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fields_ref() const& {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fields_ref() const&& {
    return {std::move(this->fields), __isset.fields};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fields_ref() & {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fields_ref() && {
    return {std::move(this->fields), __isset.fields};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const  ::nebula::cpp2::SchemaID& get_depend_schema() const&;
   ::nebula::cpp2::SchemaID get_depend_schema() &&;

  template <typename T_FTIndex_depend_schema_struct_setter =  ::nebula::cpp2::SchemaID>
   ::nebula::cpp2::SchemaID& set_depend_schema(T_FTIndex_depend_schema_struct_setter&& depend_schema_) {
    depend_schema = std::forward<T_FTIndex_depend_schema_struct_setter>(depend_schema_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.depend_schema = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return depend_schema;
  }
  const ::std::vector<::std::string>& get_fields() const&;
  ::std::vector<::std::string> get_fields() &&;

  template <typename T_FTIndex_fields_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_fields(T_FTIndex_fields_struct_setter&& fields_) {
    fields = std::forward<T_FTIndex_fields_struct_setter>(fields_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fields = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fields;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< FTIndex >;
  friend void swap(FTIndex& a, FTIndex& b);
};

template <class Protocol_>
uint32_t FTIndex::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class CreateFTIndexReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CreateFTIndexReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  CreateFTIndexReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CreateFTIndexReq(apache::thrift::FragileConstructor, ::std::string fulltext_index_name__arg,  ::nebula::meta::cpp2::FTIndex index__arg);

  CreateFTIndexReq(CreateFTIndexReq&&) = default;

  CreateFTIndexReq(const CreateFTIndexReq&) = default;


  CreateFTIndexReq& operator=(CreateFTIndexReq&&) = default;

  CreateFTIndexReq& operator=(const CreateFTIndexReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string fulltext_index_name;
 private:
   ::nebula::meta::cpp2::FTIndex index;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool fulltext_index_name;
    bool index;
  } __isset = {};
  bool operator==(const CreateFTIndexReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CreateFTIndexReq& __x, const CreateFTIndexReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CreateFTIndexReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const CreateFTIndexReq& __x, const CreateFTIndexReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CreateFTIndexReq& __x, const CreateFTIndexReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CreateFTIndexReq& __x, const CreateFTIndexReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fulltext_index_name_ref() const& {
    return {this->fulltext_index_name, __isset.fulltext_index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fulltext_index_name_ref() const&& {
    return {std::move(this->fulltext_index_name), __isset.fulltext_index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fulltext_index_name_ref() & {
    return {this->fulltext_index_name, __isset.fulltext_index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fulltext_index_name_ref() && {
    return {std::move(this->fulltext_index_name), __isset.fulltext_index_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::FTIndex>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> index_ref() const& {
    return {this->index, __isset.index};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::FTIndex>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> index_ref() const&& {
    return {std::move(this->index), __isset.index};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::FTIndex>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> index_ref() & {
    return {this->index, __isset.index};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::FTIndex>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> index_ref() && {
    return {std::move(this->index), __isset.index};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_fulltext_index_name() const& {
    return fulltext_index_name;
  }

  ::std::string get_fulltext_index_name() && {
    return std::move(fulltext_index_name);
  }

  template <typename T_CreateFTIndexReq_fulltext_index_name_struct_setter = ::std::string>
  ::std::string& set_fulltext_index_name(T_CreateFTIndexReq_fulltext_index_name_struct_setter&& fulltext_index_name_) {
    fulltext_index_name = std::forward<T_CreateFTIndexReq_fulltext_index_name_struct_setter>(fulltext_index_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fulltext_index_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fulltext_index_name;
  }
  const  ::nebula::meta::cpp2::FTIndex& get_index() const&;
   ::nebula::meta::cpp2::FTIndex get_index() &&;

  template <typename T_CreateFTIndexReq_index_struct_setter =  ::nebula::meta::cpp2::FTIndex>
   ::nebula::meta::cpp2::FTIndex& set_index(T_CreateFTIndexReq_index_struct_setter&& index_) {
    index = std::forward<T_CreateFTIndexReq_index_struct_setter>(index_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.index = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return index;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CreateFTIndexReq >;
  friend void swap(CreateFTIndexReq& a, CreateFTIndexReq& b);
};

template <class Protocol_>
uint32_t CreateFTIndexReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class DropFTIndexReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = DropFTIndexReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  DropFTIndexReq() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  DropFTIndexReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string fulltext_index_name__arg);

  DropFTIndexReq(DropFTIndexReq&&) = default;

  DropFTIndexReq(const DropFTIndexReq&) = default;


  DropFTIndexReq& operator=(DropFTIndexReq&&) = default;

  DropFTIndexReq& operator=(const DropFTIndexReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::string fulltext_index_name;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool fulltext_index_name;
  } __isset = {};
  bool operator==(const DropFTIndexReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const DropFTIndexReq& __x, const DropFTIndexReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const DropFTIndexReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const DropFTIndexReq& __x, const DropFTIndexReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const DropFTIndexReq& __x, const DropFTIndexReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const DropFTIndexReq& __x, const DropFTIndexReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fulltext_index_name_ref() const& {
    return {this->fulltext_index_name, __isset.fulltext_index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fulltext_index_name_ref() const&& {
    return {std::move(this->fulltext_index_name), __isset.fulltext_index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fulltext_index_name_ref() & {
    return {this->fulltext_index_name, __isset.fulltext_index_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fulltext_index_name_ref() && {
    return {std::move(this->fulltext_index_name), __isset.fulltext_index_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  const ::std::string& get_fulltext_index_name() const& {
    return fulltext_index_name;
  }

  ::std::string get_fulltext_index_name() && {
    return std::move(fulltext_index_name);
  }

  template <typename T_DropFTIndexReq_fulltext_index_name_struct_setter = ::std::string>
  ::std::string& set_fulltext_index_name(T_DropFTIndexReq_fulltext_index_name_struct_setter&& fulltext_index_name_) {
    fulltext_index_name = std::forward<T_DropFTIndexReq_fulltext_index_name_struct_setter>(fulltext_index_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fulltext_index_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fulltext_index_name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< DropFTIndexReq >;
  friend void swap(DropFTIndexReq& a, DropFTIndexReq& b);
};

template <class Protocol_>
uint32_t DropFTIndexReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListFTIndexesReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListFTIndexesReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListFTIndexesReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListFTIndexesReq(apache::thrift::FragileConstructor);

  ListFTIndexesReq(ListFTIndexesReq&&) = default;

  ListFTIndexesReq(const ListFTIndexesReq&) = default;


  ListFTIndexesReq& operator=(ListFTIndexesReq&&) = default;

  ListFTIndexesReq& operator=(const ListFTIndexesReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
  bool operator==(const ListFTIndexesReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListFTIndexesReq& __x, const ListFTIndexesReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListFTIndexesReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListFTIndexesReq& __x, const ListFTIndexesReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListFTIndexesReq& __x, const ListFTIndexesReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListFTIndexesReq& __x, const ListFTIndexesReq& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListFTIndexesReq >;
  friend void swap(ListFTIndexesReq& a, ListFTIndexesReq& b);
};

template <class Protocol_>
uint32_t ListFTIndexesReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListFTIndexesResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListFTIndexesResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListFTIndexesResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListFTIndexesResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, std::unordered_map<::std::string,  ::nebula::meta::cpp2::FTIndex> indexes__arg);

  ListFTIndexesResp(ListFTIndexesResp&&) = default;

  ListFTIndexesResp(const ListFTIndexesResp&) = default;


  ListFTIndexesResp& operator=(ListFTIndexesResp&&) = default;

  ListFTIndexesResp& operator=(const ListFTIndexesResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  std::unordered_map<::std::string,  ::nebula::meta::cpp2::FTIndex> indexes;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool indexes;
  } __isset = {};
  bool operator==(const ListFTIndexesResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListFTIndexesResp& __x, const ListFTIndexesResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListFTIndexesResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListFTIndexesResp& __x, const ListFTIndexesResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListFTIndexesResp& __x, const ListFTIndexesResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListFTIndexesResp& __x, const ListFTIndexesResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map<::std::string,  ::nebula::meta::cpp2::FTIndex>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> indexes_ref() const& {
    return {this->indexes, __isset.indexes};
  }

  template <typename..., typename T = std::unordered_map<::std::string,  ::nebula::meta::cpp2::FTIndex>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> indexes_ref() const&& {
    return {std::move(this->indexes), __isset.indexes};
  }

  template <typename..., typename T = std::unordered_map<::std::string,  ::nebula::meta::cpp2::FTIndex>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> indexes_ref() & {
    return {this->indexes, __isset.indexes};
  }

  template <typename..., typename T = std::unordered_map<::std::string,  ::nebula::meta::cpp2::FTIndex>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> indexes_ref() && {
    return {std::move(this->indexes), __isset.indexes};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_ListFTIndexesResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_ListFTIndexesResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_ListFTIndexesResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const std::unordered_map<::std::string,  ::nebula::meta::cpp2::FTIndex>& get_indexes() const&;
  std::unordered_map<::std::string,  ::nebula::meta::cpp2::FTIndex> get_indexes() &&;

  template <typename T_ListFTIndexesResp_indexes_struct_setter = std::unordered_map<::std::string,  ::nebula::meta::cpp2::FTIndex>>
  std::unordered_map<::std::string,  ::nebula::meta::cpp2::FTIndex>& set_indexes(T_ListFTIndexesResp_indexes_struct_setter&& indexes_) {
    indexes = std::forward<T_ListFTIndexesResp_indexes_struct_setter>(indexes_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.indexes = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return indexes;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListFTIndexesResp >;
  friend void swap(ListFTIndexesResp& a, ListFTIndexesResp& b);
};

template <class Protocol_>
uint32_t ListFTIndexesResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class QueryDesc final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = QueryDesc;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  QueryDesc();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  QueryDesc(apache::thrift::FragileConstructor,  ::nebula::cpp2::Timestamp start_time__arg,  ::nebula::meta::cpp2::QueryStatus status__arg, int64_t duration__arg, ::std::string query__arg, nebula::HostAddr graph_addr__arg);

  QueryDesc(QueryDesc&&) = default;

  QueryDesc(const QueryDesc&) = default;


  QueryDesc& operator=(QueryDesc&&) = default;

  QueryDesc& operator=(const QueryDesc&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~QueryDesc();

 private:
   ::nebula::cpp2::Timestamp start_time;
 private:
   ::nebula::meta::cpp2::QueryStatus status;
 private:
  int64_t duration;
 private:
  ::std::string query;
 private:
  nebula::HostAddr graph_addr;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool start_time;
    bool status;
    bool duration;
    bool query;
    bool graph_addr;
  } __isset = {};
  bool operator==(const QueryDesc& rhs) const;
#ifndef SWIG
  friend bool operator!=(const QueryDesc& __x, const QueryDesc& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const QueryDesc& rhs) const;
#ifndef SWIG
  friend bool operator>(const QueryDesc& __x, const QueryDesc& __y) {
    return __y < __x;
  }
  friend bool operator<=(const QueryDesc& __x, const QueryDesc& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const QueryDesc& __x, const QueryDesc& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::Timestamp>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> start_time_ref() const& {
    return {this->start_time, __isset.start_time};
  }

  template <typename..., typename T =  ::nebula::cpp2::Timestamp>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> start_time_ref() const&& {
    return {std::move(this->start_time), __isset.start_time};
  }

  template <typename..., typename T =  ::nebula::cpp2::Timestamp>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> start_time_ref() & {
    return {this->start_time, __isset.start_time};
  }

  template <typename..., typename T =  ::nebula::cpp2::Timestamp>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> start_time_ref() && {
    return {std::move(this->start_time), __isset.start_time};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::QueryStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> status_ref() const& {
    return {this->status, __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::QueryStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> status_ref() const&& {
    return {std::move(this->status), __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::QueryStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> status_ref() & {
    return {this->status, __isset.status};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::QueryStatus>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> status_ref() && {
    return {std::move(this->status), __isset.status};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> duration_ref() const& {
    return {this->duration, __isset.duration};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> duration_ref() const&& {
    return {std::move(this->duration), __isset.duration};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> duration_ref() & {
    return {this->duration, __isset.duration};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> duration_ref() && {
    return {std::move(this->duration), __isset.duration};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> query_ref() const& {
    return {this->query, __isset.query};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> query_ref() const&& {
    return {std::move(this->query), __isset.query};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> query_ref() & {
    return {this->query, __isset.query};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> query_ref() && {
    return {std::move(this->query), __isset.query};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> graph_addr_ref() const& {
    return {this->graph_addr, __isset.graph_addr};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> graph_addr_ref() const&& {
    return {std::move(this->graph_addr), __isset.graph_addr};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> graph_addr_ref() & {
    return {this->graph_addr, __isset.graph_addr};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> graph_addr_ref() && {
    return {std::move(this->graph_addr), __isset.graph_addr};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::Timestamp get_start_time() const {
    return start_time;
  }

   ::nebula::cpp2::Timestamp& set_start_time( ::nebula::cpp2::Timestamp start_time_) {
    start_time = start_time_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.start_time = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return start_time;
  }

   ::nebula::meta::cpp2::QueryStatus get_status() const {
    return status;
  }

   ::nebula::meta::cpp2::QueryStatus& set_status( ::nebula::meta::cpp2::QueryStatus status_) {
    status = status_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.status = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return status;
  }

  int64_t get_duration() const {
    return duration;
  }

  int64_t& set_duration(int64_t duration_) {
    duration = duration_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.duration = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return duration;
  }

  const ::std::string& get_query() const& {
    return query;
  }

  ::std::string get_query() && {
    return std::move(query);
  }

  template <typename T_QueryDesc_query_struct_setter = ::std::string>
  ::std::string& set_query(T_QueryDesc_query_struct_setter&& query_) {
    query = std::forward<T_QueryDesc_query_struct_setter>(query_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.query = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return query;
  }
  const nebula::HostAddr& get_graph_addr() const&;
  nebula::HostAddr get_graph_addr() &&;

  template <typename T_QueryDesc_graph_addr_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_graph_addr(T_QueryDesc_graph_addr_struct_setter&& graph_addr_) {
    graph_addr = std::forward<T_QueryDesc_graph_addr_struct_setter>(graph_addr_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.graph_addr = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return graph_addr;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< QueryDesc >;
  friend void swap(QueryDesc& a, QueryDesc& b);
};

template <class Protocol_>
uint32_t QueryDesc::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class Session final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Session;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  Session();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Session(apache::thrift::FragileConstructor,  ::nebula::cpp2::SessionID session_id__arg,  ::nebula::cpp2::Timestamp create_time__arg,  ::nebula::cpp2::Timestamp update_time__arg, ::std::string user_name__arg, ::std::string space_name__arg, nebula::HostAddr graph_addr__arg, int32_t timezone__arg, ::std::string client_ip__arg, std::unordered_map<::std::string, nebula::Value> configs__arg, std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc> queries__arg);

  Session(Session&&) = default;

  Session(const Session&) = default;


  Session& operator=(Session&&) = default;

  Session& operator=(const Session&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~Session();

 private:
   ::nebula::cpp2::SessionID session_id;
 private:
   ::nebula::cpp2::Timestamp create_time;
 private:
   ::nebula::cpp2::Timestamp update_time;
 private:
  ::std::string user_name;
 private:
  ::std::string space_name;
 private:
  nebula::HostAddr graph_addr;
 private:
  int32_t timezone;
 private:
  ::std::string client_ip;
 private:
  std::unordered_map<::std::string, nebula::Value> configs;
 private:
  std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc> queries;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool session_id;
    bool create_time;
    bool update_time;
    bool user_name;
    bool space_name;
    bool graph_addr;
    bool timezone;
    bool client_ip;
    bool configs;
    bool queries;
  } __isset = {};
  bool operator==(const Session& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Session& __x, const Session& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Session& rhs) const;
#ifndef SWIG
  friend bool operator>(const Session& __x, const Session& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Session& __x, const Session& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Session& __x, const Session& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::SessionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> session_id_ref() const& {
    return {this->session_id, __isset.session_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::SessionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> session_id_ref() const&& {
    return {std::move(this->session_id), __isset.session_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::SessionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> session_id_ref() & {
    return {this->session_id, __isset.session_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::SessionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> session_id_ref() && {
    return {std::move(this->session_id), __isset.session_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::Timestamp>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> create_time_ref() const& {
    return {this->create_time, __isset.create_time};
  }

  template <typename..., typename T =  ::nebula::cpp2::Timestamp>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> create_time_ref() const&& {
    return {std::move(this->create_time), __isset.create_time};
  }

  template <typename..., typename T =  ::nebula::cpp2::Timestamp>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> create_time_ref() & {
    return {this->create_time, __isset.create_time};
  }

  template <typename..., typename T =  ::nebula::cpp2::Timestamp>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> create_time_ref() && {
    return {std::move(this->create_time), __isset.create_time};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::Timestamp>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> update_time_ref() const& {
    return {this->update_time, __isset.update_time};
  }

  template <typename..., typename T =  ::nebula::cpp2::Timestamp>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> update_time_ref() const&& {
    return {std::move(this->update_time), __isset.update_time};
  }

  template <typename..., typename T =  ::nebula::cpp2::Timestamp>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> update_time_ref() & {
    return {this->update_time, __isset.update_time};
  }

  template <typename..., typename T =  ::nebula::cpp2::Timestamp>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> update_time_ref() && {
    return {std::move(this->update_time), __isset.update_time};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> user_name_ref() const& {
    return {this->user_name, __isset.user_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> user_name_ref() const&& {
    return {std::move(this->user_name), __isset.user_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> user_name_ref() & {
    return {this->user_name, __isset.user_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> user_name_ref() && {
    return {std::move(this->user_name), __isset.user_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_name_ref() const& {
    return {this->space_name, __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_name_ref() const&& {
    return {std::move(this->space_name), __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_name_ref() & {
    return {this->space_name, __isset.space_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_name_ref() && {
    return {std::move(this->space_name), __isset.space_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> graph_addr_ref() const& {
    return {this->graph_addr, __isset.graph_addr};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> graph_addr_ref() const&& {
    return {std::move(this->graph_addr), __isset.graph_addr};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> graph_addr_ref() & {
    return {this->graph_addr, __isset.graph_addr};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> graph_addr_ref() && {
    return {std::move(this->graph_addr), __isset.graph_addr};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> timezone_ref() const& {
    return {this->timezone, __isset.timezone};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> timezone_ref() const&& {
    return {std::move(this->timezone), __isset.timezone};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> timezone_ref() & {
    return {this->timezone, __isset.timezone};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> timezone_ref() && {
    return {std::move(this->timezone), __isset.timezone};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> client_ip_ref() const& {
    return {this->client_ip, __isset.client_ip};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> client_ip_ref() const&& {
    return {std::move(this->client_ip), __isset.client_ip};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> client_ip_ref() & {
    return {this->client_ip, __isset.client_ip};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> client_ip_ref() && {
    return {std::move(this->client_ip), __isset.client_ip};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> configs_ref() const& {
    return {this->configs, __isset.configs};
  }

  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> configs_ref() const&& {
    return {std::move(this->configs), __isset.configs};
  }

  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> configs_ref() & {
    return {this->configs, __isset.configs};
  }

  template <typename..., typename T = std::unordered_map<::std::string, nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> configs_ref() && {
    return {std::move(this->configs), __isset.configs};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> queries_ref() const& {
    return {this->queries, __isset.queries};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> queries_ref() const&& {
    return {std::move(this->queries), __isset.queries};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> queries_ref() & {
    return {this->queries, __isset.queries};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> queries_ref() && {
    return {std::move(this->queries), __isset.queries};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::SessionID get_session_id() const {
    return session_id;
  }

   ::nebula::cpp2::SessionID& set_session_id( ::nebula::cpp2::SessionID session_id_) {
    session_id = session_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.session_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return session_id;
  }

   ::nebula::cpp2::Timestamp get_create_time() const {
    return create_time;
  }

   ::nebula::cpp2::Timestamp& set_create_time( ::nebula::cpp2::Timestamp create_time_) {
    create_time = create_time_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.create_time = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return create_time;
  }

   ::nebula::cpp2::Timestamp get_update_time() const {
    return update_time;
  }

   ::nebula::cpp2::Timestamp& set_update_time( ::nebula::cpp2::Timestamp update_time_) {
    update_time = update_time_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.update_time = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return update_time;
  }

  const ::std::string& get_user_name() const& {
    return user_name;
  }

  ::std::string get_user_name() && {
    return std::move(user_name);
  }

  template <typename T_Session_user_name_struct_setter = ::std::string>
  ::std::string& set_user_name(T_Session_user_name_struct_setter&& user_name_) {
    user_name = std::forward<T_Session_user_name_struct_setter>(user_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.user_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return user_name;
  }

  const ::std::string& get_space_name() const& {
    return space_name;
  }

  ::std::string get_space_name() && {
    return std::move(space_name);
  }

  template <typename T_Session_space_name_struct_setter = ::std::string>
  ::std::string& set_space_name(T_Session_space_name_struct_setter&& space_name_) {
    space_name = std::forward<T_Session_space_name_struct_setter>(space_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_name;
  }
  const nebula::HostAddr& get_graph_addr() const&;
  nebula::HostAddr get_graph_addr() &&;

  template <typename T_Session_graph_addr_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_graph_addr(T_Session_graph_addr_struct_setter&& graph_addr_) {
    graph_addr = std::forward<T_Session_graph_addr_struct_setter>(graph_addr_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.graph_addr = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return graph_addr;
  }

  int32_t get_timezone() const {
    return timezone;
  }

  int32_t& set_timezone(int32_t timezone_) {
    timezone = timezone_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.timezone = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return timezone;
  }

  const ::std::string& get_client_ip() const& {
    return client_ip;
  }

  ::std::string get_client_ip() && {
    return std::move(client_ip);
  }

  template <typename T_Session_client_ip_struct_setter = ::std::string>
  ::std::string& set_client_ip(T_Session_client_ip_struct_setter&& client_ip_) {
    client_ip = std::forward<T_Session_client_ip_struct_setter>(client_ip_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.client_ip = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return client_ip;
  }
  const std::unordered_map<::std::string, nebula::Value>& get_configs() const&;
  std::unordered_map<::std::string, nebula::Value> get_configs() &&;

  template <typename T_Session_configs_struct_setter = std::unordered_map<::std::string, nebula::Value>>
  std::unordered_map<::std::string, nebula::Value>& set_configs(T_Session_configs_struct_setter&& configs_) {
    configs = std::forward<T_Session_configs_struct_setter>(configs_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.configs = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return configs;
  }
  const std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>& get_queries() const&;
  std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc> get_queries() &&;

  template <typename T_Session_queries_struct_setter = std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>>
  std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>& set_queries(T_Session_queries_struct_setter&& queries_) {
    queries = std::forward<T_Session_queries_struct_setter>(queries_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.queries = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return queries;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Session >;
  friend void swap(Session& a, Session& b);
};

template <class Protocol_>
uint32_t Session::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class CreateSessionReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CreateSessionReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  CreateSessionReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CreateSessionReq(apache::thrift::FragileConstructor, ::std::string user__arg, nebula::HostAddr graph_addr__arg, ::std::string client_ip__arg);

  CreateSessionReq(CreateSessionReq&&) = default;

  CreateSessionReq(const CreateSessionReq&) = default;


  CreateSessionReq& operator=(CreateSessionReq&&) = default;

  CreateSessionReq& operator=(const CreateSessionReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string user;
 private:
  nebula::HostAddr graph_addr;
 private:
  ::std::string client_ip;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool user;
    bool graph_addr;
    bool client_ip;
  } __isset = {};
  bool operator==(const CreateSessionReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CreateSessionReq& __x, const CreateSessionReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CreateSessionReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const CreateSessionReq& __x, const CreateSessionReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CreateSessionReq& __x, const CreateSessionReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CreateSessionReq& __x, const CreateSessionReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> user_ref() const& {
    return {this->user, __isset.user};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> user_ref() const&& {
    return {std::move(this->user), __isset.user};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> user_ref() & {
    return {this->user, __isset.user};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> user_ref() && {
    return {std::move(this->user), __isset.user};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> graph_addr_ref() const& {
    return {this->graph_addr, __isset.graph_addr};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> graph_addr_ref() const&& {
    return {std::move(this->graph_addr), __isset.graph_addr};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> graph_addr_ref() & {
    return {this->graph_addr, __isset.graph_addr};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> graph_addr_ref() && {
    return {std::move(this->graph_addr), __isset.graph_addr};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> client_ip_ref() const& {
    return {this->client_ip, __isset.client_ip};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> client_ip_ref() const&& {
    return {std::move(this->client_ip), __isset.client_ip};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> client_ip_ref() & {
    return {this->client_ip, __isset.client_ip};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> client_ip_ref() && {
    return {std::move(this->client_ip), __isset.client_ip};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_user() const& {
    return user;
  }

  ::std::string get_user() && {
    return std::move(user);
  }

  template <typename T_CreateSessionReq_user_struct_setter = ::std::string>
  ::std::string& set_user(T_CreateSessionReq_user_struct_setter&& user_) {
    user = std::forward<T_CreateSessionReq_user_struct_setter>(user_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.user = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return user;
  }
  const nebula::HostAddr& get_graph_addr() const&;
  nebula::HostAddr get_graph_addr() &&;

  template <typename T_CreateSessionReq_graph_addr_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_graph_addr(T_CreateSessionReq_graph_addr_struct_setter&& graph_addr_) {
    graph_addr = std::forward<T_CreateSessionReq_graph_addr_struct_setter>(graph_addr_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.graph_addr = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return graph_addr;
  }

  const ::std::string& get_client_ip() const& {
    return client_ip;
  }

  ::std::string get_client_ip() && {
    return std::move(client_ip);
  }

  template <typename T_CreateSessionReq_client_ip_struct_setter = ::std::string>
  ::std::string& set_client_ip(T_CreateSessionReq_client_ip_struct_setter&& client_ip_) {
    client_ip = std::forward<T_CreateSessionReq_client_ip_struct_setter>(client_ip_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.client_ip = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return client_ip;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CreateSessionReq >;
  friend void swap(CreateSessionReq& a, CreateSessionReq& b);
};

template <class Protocol_>
uint32_t CreateSessionReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class CreateSessionResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CreateSessionResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  CreateSessionResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CreateSessionResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::Session session__arg);

  CreateSessionResp(CreateSessionResp&&) = default;

  CreateSessionResp(const CreateSessionResp&) = default;


  CreateSessionResp& operator=(CreateSessionResp&&) = default;

  CreateSessionResp& operator=(const CreateSessionResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
   ::nebula::meta::cpp2::Session session;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool session;
  } __isset = {};
  bool operator==(const CreateSessionResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CreateSessionResp& __x, const CreateSessionResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CreateSessionResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const CreateSessionResp& __x, const CreateSessionResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CreateSessionResp& __x, const CreateSessionResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CreateSessionResp& __x, const CreateSessionResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::Session>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> session_ref() const& {
    return {this->session, __isset.session};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Session>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> session_ref() const&& {
    return {std::move(this->session), __isset.session};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Session>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> session_ref() & {
    return {this->session, __isset.session};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Session>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> session_ref() && {
    return {std::move(this->session), __isset.session};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_CreateSessionResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_CreateSessionResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_CreateSessionResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const  ::nebula::meta::cpp2::Session& get_session() const&;
   ::nebula::meta::cpp2::Session get_session() &&;

  template <typename T_CreateSessionResp_session_struct_setter =  ::nebula::meta::cpp2::Session>
   ::nebula::meta::cpp2::Session& set_session(T_CreateSessionResp_session_struct_setter&& session_) {
    session = std::forward<T_CreateSessionResp_session_struct_setter>(session_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.session = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return session;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CreateSessionResp >;
  friend void swap(CreateSessionResp& a, CreateSessionResp& b);
};

template <class Protocol_>
uint32_t CreateSessionResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class UpdateSessionsReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = UpdateSessionsReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  UpdateSessionsReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  UpdateSessionsReq(apache::thrift::FragileConstructor, ::std::vector< ::nebula::meta::cpp2::Session> sessions__arg);

  UpdateSessionsReq(UpdateSessionsReq&&) = default;

  UpdateSessionsReq(const UpdateSessionsReq&) = default;


  UpdateSessionsReq& operator=(UpdateSessionsReq&&) = default;

  UpdateSessionsReq& operator=(const UpdateSessionsReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector< ::nebula::meta::cpp2::Session> sessions;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool sessions;
  } __isset = {};
  bool operator==(const UpdateSessionsReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const UpdateSessionsReq& __x, const UpdateSessionsReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const UpdateSessionsReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const UpdateSessionsReq& __x, const UpdateSessionsReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const UpdateSessionsReq& __x, const UpdateSessionsReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const UpdateSessionsReq& __x, const UpdateSessionsReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::Session>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> sessions_ref() const& {
    return {this->sessions, __isset.sessions};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::Session>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> sessions_ref() const&& {
    return {std::move(this->sessions), __isset.sessions};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::Session>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> sessions_ref() & {
    return {this->sessions, __isset.sessions};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::Session>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> sessions_ref() && {
    return {std::move(this->sessions), __isset.sessions};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector< ::nebula::meta::cpp2::Session>& get_sessions() const&;
  ::std::vector< ::nebula::meta::cpp2::Session> get_sessions() &&;

  template <typename T_UpdateSessionsReq_sessions_struct_setter = ::std::vector< ::nebula::meta::cpp2::Session>>
  ::std::vector< ::nebula::meta::cpp2::Session>& set_sessions(T_UpdateSessionsReq_sessions_struct_setter&& sessions_) {
    sessions = std::forward<T_UpdateSessionsReq_sessions_struct_setter>(sessions_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.sessions = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return sessions;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< UpdateSessionsReq >;
  friend void swap(UpdateSessionsReq& a, UpdateSessionsReq& b);
};

template <class Protocol_>
uint32_t UpdateSessionsReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class UpdateSessionsResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = UpdateSessionsResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  UpdateSessionsResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  UpdateSessionsResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>> killed_queries__arg, ::std::vector< ::nebula::cpp2::SessionID> killed_sessions__arg);

  UpdateSessionsResp(UpdateSessionsResp&&) = default;

  UpdateSessionsResp(const UpdateSessionsResp&) = default;


  UpdateSessionsResp& operator=(UpdateSessionsResp&&) = default;

  UpdateSessionsResp& operator=(const UpdateSessionsResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>> killed_queries;
 private:
  ::std::vector< ::nebula::cpp2::SessionID> killed_sessions;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool killed_queries;
    bool killed_sessions;
  } __isset = {};
  bool operator==(const UpdateSessionsResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const UpdateSessionsResp& __x, const UpdateSessionsResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const UpdateSessionsResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const UpdateSessionsResp& __x, const UpdateSessionsResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const UpdateSessionsResp& __x, const UpdateSessionsResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const UpdateSessionsResp& __x, const UpdateSessionsResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> killed_queries_ref() const& {
    return {this->killed_queries, __isset.killed_queries};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> killed_queries_ref() const&& {
    return {std::move(this->killed_queries), __isset.killed_queries};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> killed_queries_ref() & {
    return {this->killed_queries, __isset.killed_queries};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> killed_queries_ref() && {
    return {std::move(this->killed_queries), __isset.killed_queries};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::cpp2::SessionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> killed_sessions_ref() const& {
    return {this->killed_sessions, __isset.killed_sessions};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::SessionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> killed_sessions_ref() const&& {
    return {std::move(this->killed_sessions), __isset.killed_sessions};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::SessionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> killed_sessions_ref() & {
    return {this->killed_sessions, __isset.killed_sessions};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::SessionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> killed_sessions_ref() && {
    return {std::move(this->killed_sessions), __isset.killed_sessions};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_UpdateSessionsResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_UpdateSessionsResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_UpdateSessionsResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>>& get_killed_queries() const&;
  std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>> get_killed_queries() &&;

  template <typename T_UpdateSessionsResp_killed_queries_struct_setter = std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>>>
  std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>>& set_killed_queries(T_UpdateSessionsResp_killed_queries_struct_setter&& killed_queries_) {
    killed_queries = std::forward<T_UpdateSessionsResp_killed_queries_struct_setter>(killed_queries_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.killed_queries = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return killed_queries;
  }
  const ::std::vector< ::nebula::cpp2::SessionID>& get_killed_sessions() const&;
  ::std::vector< ::nebula::cpp2::SessionID> get_killed_sessions() &&;

  template <typename T_UpdateSessionsResp_killed_sessions_struct_setter = ::std::vector< ::nebula::cpp2::SessionID>>
  ::std::vector< ::nebula::cpp2::SessionID>& set_killed_sessions(T_UpdateSessionsResp_killed_sessions_struct_setter&& killed_sessions_) {
    killed_sessions = std::forward<T_UpdateSessionsResp_killed_sessions_struct_setter>(killed_sessions_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.killed_sessions = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return killed_sessions;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< UpdateSessionsResp >;
  friend void swap(UpdateSessionsResp& a, UpdateSessionsResp& b);
};

template <class Protocol_>
uint32_t UpdateSessionsResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListSessionsReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListSessionsReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListSessionsReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListSessionsReq(apache::thrift::FragileConstructor);

  ListSessionsReq(ListSessionsReq&&) = default;

  ListSessionsReq(const ListSessionsReq&) = default;


  ListSessionsReq& operator=(ListSessionsReq&&) = default;

  ListSessionsReq& operator=(const ListSessionsReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
  bool operator==(const ListSessionsReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListSessionsReq& __x, const ListSessionsReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListSessionsReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListSessionsReq& __x, const ListSessionsReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListSessionsReq& __x, const ListSessionsReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListSessionsReq& __x, const ListSessionsReq& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListSessionsReq >;
  friend void swap(ListSessionsReq& a, ListSessionsReq& b);
};

template <class Protocol_>
uint32_t ListSessionsReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListSessionsResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListSessionsResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListSessionsResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListSessionsResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::Session> sessions__arg);

  ListSessionsResp(ListSessionsResp&&) = default;

  ListSessionsResp(const ListSessionsResp&) = default;


  ListSessionsResp& operator=(ListSessionsResp&&) = default;

  ListSessionsResp& operator=(const ListSessionsResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::vector< ::nebula::meta::cpp2::Session> sessions;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool sessions;
  } __isset = {};
  bool operator==(const ListSessionsResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListSessionsResp& __x, const ListSessionsResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListSessionsResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListSessionsResp& __x, const ListSessionsResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListSessionsResp& __x, const ListSessionsResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListSessionsResp& __x, const ListSessionsResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::Session>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> sessions_ref() const& {
    return {this->sessions, __isset.sessions};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::Session>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> sessions_ref() const&& {
    return {std::move(this->sessions), __isset.sessions};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::Session>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> sessions_ref() & {
    return {this->sessions, __isset.sessions};
  }

  template <typename..., typename T = ::std::vector< ::nebula::meta::cpp2::Session>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> sessions_ref() && {
    return {std::move(this->sessions), __isset.sessions};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_ListSessionsResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_ListSessionsResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_ListSessionsResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const ::std::vector< ::nebula::meta::cpp2::Session>& get_sessions() const&;
  ::std::vector< ::nebula::meta::cpp2::Session> get_sessions() &&;

  template <typename T_ListSessionsResp_sessions_struct_setter = ::std::vector< ::nebula::meta::cpp2::Session>>
  ::std::vector< ::nebula::meta::cpp2::Session>& set_sessions(T_ListSessionsResp_sessions_struct_setter&& sessions_) {
    sessions = std::forward<T_ListSessionsResp_sessions_struct_setter>(sessions_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.sessions = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return sessions;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListSessionsResp >;
  friend void swap(ListSessionsResp& a, ListSessionsResp& b);
};

template <class Protocol_>
uint32_t ListSessionsResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetSessionReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetSessionReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetSessionReq() :
      session_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetSessionReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::SessionID session_id__arg);

  GetSessionReq(GetSessionReq&&) = default;

  GetSessionReq(const GetSessionReq&) = default;


  GetSessionReq& operator=(GetSessionReq&&) = default;

  GetSessionReq& operator=(const GetSessionReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::SessionID session_id;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool session_id;
  } __isset = {};
  bool operator==(const GetSessionReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetSessionReq& __x, const GetSessionReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetSessionReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetSessionReq& __x, const GetSessionReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetSessionReq& __x, const GetSessionReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetSessionReq& __x, const GetSessionReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::SessionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> session_id_ref() const& {
    return {this->session_id, __isset.session_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::SessionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> session_id_ref() const&& {
    return {std::move(this->session_id), __isset.session_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::SessionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> session_id_ref() & {
    return {this->session_id, __isset.session_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::SessionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> session_id_ref() && {
    return {std::move(this->session_id), __isset.session_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::SessionID get_session_id() const {
    return session_id;
  }

   ::nebula::cpp2::SessionID& set_session_id( ::nebula::cpp2::SessionID session_id_) {
    session_id = session_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.session_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return session_id;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetSessionReq >;
  friend void swap(GetSessionReq& a, GetSessionReq& b);
};

template <class Protocol_>
uint32_t GetSessionReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetSessionResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetSessionResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetSessionResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetSessionResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::Session session__arg);

  GetSessionResp(GetSessionResp&&) = default;

  GetSessionResp(const GetSessionResp&) = default;


  GetSessionResp& operator=(GetSessionResp&&) = default;

  GetSessionResp& operator=(const GetSessionResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
   ::nebula::meta::cpp2::Session session;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool session;
  } __isset = {};
  bool operator==(const GetSessionResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetSessionResp& __x, const GetSessionResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetSessionResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetSessionResp& __x, const GetSessionResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetSessionResp& __x, const GetSessionResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetSessionResp& __x, const GetSessionResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::Session>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> session_ref() const& {
    return {this->session, __isset.session};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Session>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> session_ref() const&& {
    return {std::move(this->session), __isset.session};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Session>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> session_ref() & {
    return {this->session, __isset.session};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::Session>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> session_ref() && {
    return {std::move(this->session), __isset.session};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_GetSessionResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_GetSessionResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_GetSessionResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const  ::nebula::meta::cpp2::Session& get_session() const&;
   ::nebula::meta::cpp2::Session get_session() &&;

  template <typename T_GetSessionResp_session_struct_setter =  ::nebula::meta::cpp2::Session>
   ::nebula::meta::cpp2::Session& set_session(T_GetSessionResp_session_struct_setter&& session_) {
    session = std::forward<T_GetSessionResp_session_struct_setter>(session_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.session = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return session;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetSessionResp >;
  friend void swap(GetSessionResp& a, GetSessionResp& b);
};

template <class Protocol_>
uint32_t GetSessionResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class RemoveSessionReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = RemoveSessionReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  RemoveSessionReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RemoveSessionReq(apache::thrift::FragileConstructor, ::std::vector< ::nebula::cpp2::SessionID> session_ids__arg);

  RemoveSessionReq(RemoveSessionReq&&) = default;

  RemoveSessionReq(const RemoveSessionReq&) = default;


  RemoveSessionReq& operator=(RemoveSessionReq&&) = default;

  RemoveSessionReq& operator=(const RemoveSessionReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector< ::nebula::cpp2::SessionID> session_ids;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool session_ids;
  } __isset = {};
  bool operator==(const RemoveSessionReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const RemoveSessionReq& __x, const RemoveSessionReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const RemoveSessionReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const RemoveSessionReq& __x, const RemoveSessionReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const RemoveSessionReq& __x, const RemoveSessionReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const RemoveSessionReq& __x, const RemoveSessionReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::cpp2::SessionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> session_ids_ref() const& {
    return {this->session_ids, __isset.session_ids};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::SessionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> session_ids_ref() const&& {
    return {std::move(this->session_ids), __isset.session_ids};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::SessionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> session_ids_ref() & {
    return {this->session_ids, __isset.session_ids};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::SessionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> session_ids_ref() && {
    return {std::move(this->session_ids), __isset.session_ids};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector< ::nebula::cpp2::SessionID>& get_session_ids() const&;
  ::std::vector< ::nebula::cpp2::SessionID> get_session_ids() &&;

  template <typename T_RemoveSessionReq_session_ids_struct_setter = ::std::vector< ::nebula::cpp2::SessionID>>
  ::std::vector< ::nebula::cpp2::SessionID>& set_session_ids(T_RemoveSessionReq_session_ids_struct_setter&& session_ids_) {
    session_ids = std::forward<T_RemoveSessionReq_session_ids_struct_setter>(session_ids_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.session_ids = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return session_ids;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< RemoveSessionReq >;
  friend void swap(RemoveSessionReq& a, RemoveSessionReq& b);
};

template <class Protocol_>
uint32_t RemoveSessionReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class RemoveSessionResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = RemoveSessionResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  RemoveSessionResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RemoveSessionResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::cpp2::SessionID> removed_session_ids__arg);

  RemoveSessionResp(RemoveSessionResp&&) = default;

  RemoveSessionResp(const RemoveSessionResp&) = default;


  RemoveSessionResp& operator=(RemoveSessionResp&&) = default;

  RemoveSessionResp& operator=(const RemoveSessionResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::vector< ::nebula::cpp2::SessionID> removed_session_ids;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool removed_session_ids;
  } __isset = {};
  bool operator==(const RemoveSessionResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const RemoveSessionResp& __x, const RemoveSessionResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const RemoveSessionResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const RemoveSessionResp& __x, const RemoveSessionResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const RemoveSessionResp& __x, const RemoveSessionResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const RemoveSessionResp& __x, const RemoveSessionResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::cpp2::SessionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> removed_session_ids_ref() const& {
    return {this->removed_session_ids, __isset.removed_session_ids};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::SessionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> removed_session_ids_ref() const&& {
    return {std::move(this->removed_session_ids), __isset.removed_session_ids};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::SessionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> removed_session_ids_ref() & {
    return {this->removed_session_ids, __isset.removed_session_ids};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::SessionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> removed_session_ids_ref() && {
    return {std::move(this->removed_session_ids), __isset.removed_session_ids};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_RemoveSessionResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_RemoveSessionResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_RemoveSessionResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const ::std::vector< ::nebula::cpp2::SessionID>& get_removed_session_ids() const&;
  ::std::vector< ::nebula::cpp2::SessionID> get_removed_session_ids() &&;

  template <typename T_RemoveSessionResp_removed_session_ids_struct_setter = ::std::vector< ::nebula::cpp2::SessionID>>
  ::std::vector< ::nebula::cpp2::SessionID>& set_removed_session_ids(T_RemoveSessionResp_removed_session_ids_struct_setter&& removed_session_ids_) {
    removed_session_ids = std::forward<T_RemoveSessionResp_removed_session_ids_struct_setter>(removed_session_ids_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.removed_session_ids = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return removed_session_ids;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< RemoveSessionResp >;
  friend void swap(RemoveSessionResp& a, RemoveSessionResp& b);
};

template <class Protocol_>
uint32_t RemoveSessionResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class KillQueryReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = KillQueryReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  KillQueryReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  KillQueryReq(apache::thrift::FragileConstructor, std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_set< ::nebula::cpp2::ExecutionPlanID>> kill_queries__arg);

  KillQueryReq(KillQueryReq&&) = default;

  KillQueryReq(const KillQueryReq&) = default;


  KillQueryReq& operator=(KillQueryReq&&) = default;

  KillQueryReq& operator=(const KillQueryReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_set< ::nebula::cpp2::ExecutionPlanID>> kill_queries;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool kill_queries;
  } __isset = {};
  bool operator==(const KillQueryReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const KillQueryReq& __x, const KillQueryReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const KillQueryReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const KillQueryReq& __x, const KillQueryReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const KillQueryReq& __x, const KillQueryReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const KillQueryReq& __x, const KillQueryReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_set< ::nebula::cpp2::ExecutionPlanID>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> kill_queries_ref() const& {
    return {this->kill_queries, __isset.kill_queries};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_set< ::nebula::cpp2::ExecutionPlanID>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> kill_queries_ref() const&& {
    return {std::move(this->kill_queries), __isset.kill_queries};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_set< ::nebula::cpp2::ExecutionPlanID>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> kill_queries_ref() & {
    return {this->kill_queries, __isset.kill_queries};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_set< ::nebula::cpp2::ExecutionPlanID>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> kill_queries_ref() && {
    return {std::move(this->kill_queries), __isset.kill_queries};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_set< ::nebula::cpp2::ExecutionPlanID>>& get_kill_queries() const&;
  std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_set< ::nebula::cpp2::ExecutionPlanID>> get_kill_queries() &&;

  template <typename T_KillQueryReq_kill_queries_struct_setter = std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_set< ::nebula::cpp2::ExecutionPlanID>>>
  std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_set< ::nebula::cpp2::ExecutionPlanID>>& set_kill_queries(T_KillQueryReq_kill_queries_struct_setter&& kill_queries_) {
    kill_queries = std::forward<T_KillQueryReq_kill_queries_struct_setter>(kill_queries_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.kill_queries = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return kill_queries;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< KillQueryReq >;
  friend void swap(KillQueryReq& a, KillQueryReq& b);
};

template <class Protocol_>
uint32_t KillQueryReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ReportTaskReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ReportTaskReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ReportTaskReq() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED),
      space_id(0),
      job_id(0),
      task_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ReportTaskReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg,  ::nebula::cpp2::GraphSpaceID space_id__arg, int32_t job_id__arg, int32_t task_id__arg,  ::nebula::meta::cpp2::StatsItem stats__arg);

  ReportTaskReq(ReportTaskReq&&) = default;

  ReportTaskReq(const ReportTaskReq&) = default;


  ReportTaskReq& operator=(ReportTaskReq&&) = default;

  ReportTaskReq& operator=(const ReportTaskReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  int32_t job_id;
 private:
  int32_t task_id;
 private:
   ::nebula::meta::cpp2::StatsItem stats;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool space_id;
    bool job_id;
    bool task_id;
    bool stats;
  } __isset = {};
  bool operator==(const ReportTaskReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ReportTaskReq& __x, const ReportTaskReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ReportTaskReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ReportTaskReq& __x, const ReportTaskReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ReportTaskReq& __x, const ReportTaskReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ReportTaskReq& __x, const ReportTaskReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> job_id_ref() const& {
    return {this->job_id, __isset.job_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> job_id_ref() const&& {
    return {std::move(this->job_id), __isset.job_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> job_id_ref() & {
    return {this->job_id, __isset.job_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> job_id_ref() && {
    return {std::move(this->job_id), __isset.job_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> task_id_ref() const& {
    return {this->task_id, __isset.task_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> task_id_ref() const&& {
    return {std::move(this->task_id), __isset.task_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> task_id_ref() & {
    return {this->task_id, __isset.task_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> task_id_ref() && {
    return {std::move(this->task_id), __isset.task_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::StatsItem>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> stats_ref() const& {
    return {this->stats, __isset.stats};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::StatsItem>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> stats_ref() const&& {
    return {std::move(this->stats), __isset.stats};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::StatsItem>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> stats_ref() & {
    return {this->stats, __isset.stats};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::StatsItem>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> stats_ref() && {
    return {std::move(this->stats), __isset.stats};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

  int32_t get_job_id() const {
    return job_id;
  }

  int32_t& set_job_id(int32_t job_id_) {
    job_id = job_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.job_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return job_id;
  }

  int32_t get_task_id() const {
    return task_id;
  }

  int32_t& set_task_id(int32_t task_id_) {
    task_id = task_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.task_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return task_id;
  }
  const  ::nebula::meta::cpp2::StatsItem* get_stats() const&;
   ::nebula::meta::cpp2::StatsItem* get_stats() &;
   ::nebula::meta::cpp2::StatsItem* get_stats() && = delete;

  template <typename T_ReportTaskReq_stats_struct_setter =  ::nebula::meta::cpp2::StatsItem>
   ::nebula::meta::cpp2::StatsItem& set_stats(T_ReportTaskReq_stats_struct_setter&& stats_) {
    stats = std::forward<T_ReportTaskReq_stats_struct_setter>(stats_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.stats = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return stats;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ReportTaskReq >;
  friend void swap(ReportTaskReq& a, ReportTaskReq& b);
};

template <class Protocol_>
uint32_t ReportTaskReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListClusterInfoResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListClusterInfoResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListClusterInfoResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListClusterInfoResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, std::unordered_map<::std::string, ::std::vector< ::nebula::meta::cpp2::ServiceInfo>> host_services__arg);

  ListClusterInfoResp(ListClusterInfoResp&&) = default;

  ListClusterInfoResp(const ListClusterInfoResp&) = default;


  ListClusterInfoResp& operator=(ListClusterInfoResp&&) = default;

  ListClusterInfoResp& operator=(const ListClusterInfoResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  std::unordered_map<::std::string, ::std::vector< ::nebula::meta::cpp2::ServiceInfo>> host_services;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool host_services;
  } __isset = {};
  bool operator==(const ListClusterInfoResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListClusterInfoResp& __x, const ListClusterInfoResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListClusterInfoResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListClusterInfoResp& __x, const ListClusterInfoResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListClusterInfoResp& __x, const ListClusterInfoResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListClusterInfoResp& __x, const ListClusterInfoResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map<::std::string, ::std::vector< ::nebula::meta::cpp2::ServiceInfo>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> host_services_ref() const& {
    return {this->host_services, __isset.host_services};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::vector< ::nebula::meta::cpp2::ServiceInfo>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> host_services_ref() const&& {
    return {std::move(this->host_services), __isset.host_services};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::vector< ::nebula::meta::cpp2::ServiceInfo>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> host_services_ref() & {
    return {this->host_services, __isset.host_services};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::vector< ::nebula::meta::cpp2::ServiceInfo>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> host_services_ref() && {
    return {std::move(this->host_services), __isset.host_services};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_ListClusterInfoResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_ListClusterInfoResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_ListClusterInfoResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }
  const std::unordered_map<::std::string, ::std::vector< ::nebula::meta::cpp2::ServiceInfo>>& get_host_services() const&;
  std::unordered_map<::std::string, ::std::vector< ::nebula::meta::cpp2::ServiceInfo>> get_host_services() &&;

  template <typename T_ListClusterInfoResp_host_services_struct_setter = std::unordered_map<::std::string, ::std::vector< ::nebula::meta::cpp2::ServiceInfo>>>
  std::unordered_map<::std::string, ::std::vector< ::nebula::meta::cpp2::ServiceInfo>>& set_host_services(T_ListClusterInfoResp_host_services_struct_setter&& host_services_) {
    host_services = std::forward<T_ListClusterInfoResp_host_services_struct_setter>(host_services_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.host_services = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return host_services;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListClusterInfoResp >;
  friend void swap(ListClusterInfoResp& a, ListClusterInfoResp& b);
};

template <class Protocol_>
uint32_t ListClusterInfoResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class ListClusterInfoReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListClusterInfoReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListClusterInfoReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListClusterInfoReq(apache::thrift::FragileConstructor);

  ListClusterInfoReq(ListClusterInfoReq&&) = default;

  ListClusterInfoReq(const ListClusterInfoReq&) = default;


  ListClusterInfoReq& operator=(ListClusterInfoReq&&) = default;

  ListClusterInfoReq& operator=(const ListClusterInfoReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
  bool operator==(const ListClusterInfoReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListClusterInfoReq& __x, const ListClusterInfoReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListClusterInfoReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListClusterInfoReq& __x, const ListClusterInfoReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListClusterInfoReq& __x, const ListClusterInfoReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListClusterInfoReq& __x, const ListClusterInfoReq& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListClusterInfoReq >;
  friend void swap(ListClusterInfoReq& a, ListClusterInfoReq& b);
};

template <class Protocol_>
uint32_t ListClusterInfoReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetMetaDirInfoResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetMetaDirInfoResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetMetaDirInfoResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetMetaDirInfoResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg,  ::nebula::cpp2::DirInfo dir__arg);

  GetMetaDirInfoResp(GetMetaDirInfoResp&&) = default;

  GetMetaDirInfoResp(const GetMetaDirInfoResp&) = default;


  GetMetaDirInfoResp& operator=(GetMetaDirInfoResp&&) = default;

  GetMetaDirInfoResp& operator=(const GetMetaDirInfoResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
   ::nebula::cpp2::DirInfo dir;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool dir;
  } __isset = {};
  bool operator==(const GetMetaDirInfoResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetMetaDirInfoResp& __x, const GetMetaDirInfoResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetMetaDirInfoResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetMetaDirInfoResp& __x, const GetMetaDirInfoResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetMetaDirInfoResp& __x, const GetMetaDirInfoResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetMetaDirInfoResp& __x, const GetMetaDirInfoResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::DirInfo>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> dir_ref() const& {
    return {this->dir, __isset.dir};
  }

  template <typename..., typename T =  ::nebula::cpp2::DirInfo>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> dir_ref() const&& {
    return {std::move(this->dir), __isset.dir};
  }

  template <typename..., typename T =  ::nebula::cpp2::DirInfo>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> dir_ref() & {
    return {this->dir, __isset.dir};
  }

  template <typename..., typename T =  ::nebula::cpp2::DirInfo>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> dir_ref() && {
    return {std::move(this->dir), __isset.dir};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const  ::nebula::cpp2::DirInfo& get_dir() const&;
   ::nebula::cpp2::DirInfo get_dir() &&;

  template <typename T_GetMetaDirInfoResp_dir_struct_setter =  ::nebula::cpp2::DirInfo>
   ::nebula::cpp2::DirInfo& set_dir(T_GetMetaDirInfoResp_dir_struct_setter&& dir_) {
    dir = std::forward<T_GetMetaDirInfoResp_dir_struct_setter>(dir_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.dir = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return dir;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetMetaDirInfoResp >;
  friend void swap(GetMetaDirInfoResp& a, GetMetaDirInfoResp& b);
};

template <class Protocol_>
uint32_t GetMetaDirInfoResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class GetMetaDirInfoReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetMetaDirInfoReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetMetaDirInfoReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetMetaDirInfoReq(apache::thrift::FragileConstructor);

  GetMetaDirInfoReq(GetMetaDirInfoReq&&) = default;

  GetMetaDirInfoReq(const GetMetaDirInfoReq&) = default;


  GetMetaDirInfoReq& operator=(GetMetaDirInfoReq&&) = default;

  GetMetaDirInfoReq& operator=(const GetMetaDirInfoReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
  bool operator==(const GetMetaDirInfoReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetMetaDirInfoReq& __x, const GetMetaDirInfoReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetMetaDirInfoReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetMetaDirInfoReq& __x, const GetMetaDirInfoReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetMetaDirInfoReq& __x, const GetMetaDirInfoReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetMetaDirInfoReq& __x, const GetMetaDirInfoReq& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetMetaDirInfoReq >;
  friend void swap(GetMetaDirInfoReq& a, GetMetaDirInfoReq& b);
};

template <class Protocol_>
uint32_t GetMetaDirInfoReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class VerifyClientVersionResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = VerifyClientVersionResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  VerifyClientVersionResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  VerifyClientVersionResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::string error_msg__arg);

  VerifyClientVersionResp(VerifyClientVersionResp&&) = default;

  VerifyClientVersionResp(const VerifyClientVersionResp&) = default;


  VerifyClientVersionResp& operator=(VerifyClientVersionResp&&) = default;

  VerifyClientVersionResp& operator=(const VerifyClientVersionResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::string error_msg;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool error_msg;
  } __isset = {};
  bool operator==(const VerifyClientVersionResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const VerifyClientVersionResp& __x, const VerifyClientVersionResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const VerifyClientVersionResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const VerifyClientVersionResp& __x, const VerifyClientVersionResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const VerifyClientVersionResp& __x, const VerifyClientVersionResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const VerifyClientVersionResp& __x, const VerifyClientVersionResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> error_msg_ref() const& {
    return {this->error_msg, __isset.error_msg};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> error_msg_ref() const&& {
    return {std::move(this->error_msg), __isset.error_msg};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> error_msg_ref() & {
    return {this->error_msg, __isset.error_msg};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> error_msg_ref() && {
    return {std::move(this->error_msg), __isset.error_msg};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_VerifyClientVersionResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_VerifyClientVersionResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_VerifyClientVersionResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }

  const ::std::string* get_error_msg() const& {
    return error_msg_ref() ? std::addressof(error_msg) : nullptr;
  }

  ::std::string* get_error_msg() & {
    return error_msg_ref() ? std::addressof(error_msg) : nullptr;
  }
  ::std::string* get_error_msg() && = delete;

  template <typename T_VerifyClientVersionResp_error_msg_struct_setter = ::std::string>
  ::std::string& set_error_msg(T_VerifyClientVersionResp_error_msg_struct_setter&& error_msg_) {
    error_msg = std::forward<T_VerifyClientVersionResp_error_msg_struct_setter>(error_msg_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.error_msg = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return error_msg;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< VerifyClientVersionResp >;
  friend void swap(VerifyClientVersionResp& a, VerifyClientVersionResp& b);
};

template <class Protocol_>
uint32_t VerifyClientVersionResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class VerifyClientVersionReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = VerifyClientVersionReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  VerifyClientVersionReq() :
      client_version(apache::thrift::StringTraits< std::string>::fromStringLiteral("3.0.0")) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  VerifyClientVersionReq(apache::thrift::FragileConstructor, ::std::string client_version__arg, nebula::HostAddr host__arg, ::std::string build_version__arg);

  VerifyClientVersionReq(VerifyClientVersionReq&&) = default;

  VerifyClientVersionReq(const VerifyClientVersionReq&) = default;


  VerifyClientVersionReq& operator=(VerifyClientVersionReq&&) = default;

  VerifyClientVersionReq& operator=(const VerifyClientVersionReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
  ::std::string client_version;
 private:
  nebula::HostAddr host;
 private:
  ::std::string build_version;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool host;
    bool build_version;
  } __isset = {};
  bool operator==(const VerifyClientVersionReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const VerifyClientVersionReq& __x, const VerifyClientVersionReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const VerifyClientVersionReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const VerifyClientVersionReq& __x, const VerifyClientVersionReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const VerifyClientVersionReq& __x, const VerifyClientVersionReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const VerifyClientVersionReq& __x, const VerifyClientVersionReq& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> client_version_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->client_version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> client_version_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->client_version)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> client_version_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->client_version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> client_version_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->client_version)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> host_ref() const& {
    return {this->host, __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> host_ref() const&& {
    return {std::move(this->host), __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> host_ref() & {
    return {this->host, __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> host_ref() && {
    return {std::move(this->host), __isset.host};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> build_version_ref() const& {
    return {this->build_version, __isset.build_version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> build_version_ref() const&& {
    return {std::move(this->build_version), __isset.build_version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> build_version_ref() & {
    return {this->build_version, __isset.build_version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> build_version_ref() && {
    return {std::move(this->build_version), __isset.build_version};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_client_version() const& {
    return client_version;
  }

  ::std::string get_client_version() && {
    return std::move(client_version);
  }

  template <typename T_VerifyClientVersionReq_client_version_struct_setter = ::std::string>
  ::std::string& set_client_version(T_VerifyClientVersionReq_client_version_struct_setter&& client_version_) {
    client_version = std::forward<T_VerifyClientVersionReq_client_version_struct_setter>(client_version_);
    return client_version;
  }
  const nebula::HostAddr& get_host() const&;
  nebula::HostAddr get_host() &&;

  template <typename T_VerifyClientVersionReq_host_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_host(T_VerifyClientVersionReq_host_struct_setter&& host_) {
    host = std::forward<T_VerifyClientVersionReq_host_struct_setter>(host_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.host = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return host;
  }

  const ::std::string& get_build_version() const& {
    return build_version;
  }

  ::std::string get_build_version() && {
    return std::move(build_version);
  }

  template <typename T_VerifyClientVersionReq_build_version_struct_setter = ::std::string>
  ::std::string& set_build_version(T_VerifyClientVersionReq_build_version_struct_setter&& build_version_) {
    build_version = std::forward<T_VerifyClientVersionReq_build_version_struct_setter>(build_version_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.build_version = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return build_version;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< VerifyClientVersionReq >;
  friend void swap(VerifyClientVersionReq& a, VerifyClientVersionReq& b);
};

template <class Protocol_>
uint32_t VerifyClientVersionReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class SaveGraphVersionResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = SaveGraphVersionResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  SaveGraphVersionResp() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  SaveGraphVersionResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::string error_msg__arg);

  SaveGraphVersionResp(SaveGraphVersionResp&&) = default;

  SaveGraphVersionResp(const SaveGraphVersionResp&) = default;


  SaveGraphVersionResp& operator=(SaveGraphVersionResp&&) = default;

  SaveGraphVersionResp& operator=(const SaveGraphVersionResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::ErrorCode code;
 private:
  nebula::HostAddr leader;
 private:
  ::std::string error_msg;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool leader;
    bool error_msg;
  } __isset = {};
  bool operator==(const SaveGraphVersionResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const SaveGraphVersionResp& __x, const SaveGraphVersionResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const SaveGraphVersionResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const SaveGraphVersionResp& __x, const SaveGraphVersionResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const SaveGraphVersionResp& __x, const SaveGraphVersionResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const SaveGraphVersionResp& __x, const SaveGraphVersionResp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> error_msg_ref() const& {
    return {this->error_msg, __isset.error_msg};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> error_msg_ref() const&& {
    return {std::move(this->error_msg), __isset.error_msg};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> error_msg_ref() & {
    return {this->error_msg, __isset.error_msg};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> error_msg_ref() && {
    return {std::move(this->error_msg), __isset.error_msg};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }
  const nebula::HostAddr& get_leader() const&;
  nebula::HostAddr get_leader() &&;

  template <typename T_SaveGraphVersionResp_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_SaveGraphVersionResp_leader_struct_setter&& leader_) {
    leader = std::forward<T_SaveGraphVersionResp_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }

  const ::std::string* get_error_msg() const& {
    return error_msg_ref() ? std::addressof(error_msg) : nullptr;
  }

  ::std::string* get_error_msg() & {
    return error_msg_ref() ? std::addressof(error_msg) : nullptr;
  }
  ::std::string* get_error_msg() && = delete;

  template <typename T_SaveGraphVersionResp_error_msg_struct_setter = ::std::string>
  ::std::string& set_error_msg(T_SaveGraphVersionResp_error_msg_struct_setter&& error_msg_) {
    error_msg = std::forward<T_SaveGraphVersionResp_error_msg_struct_setter>(error_msg_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.error_msg = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return error_msg;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< SaveGraphVersionResp >;
  friend void swap(SaveGraphVersionResp& a, SaveGraphVersionResp& b);
};

template <class Protocol_>
uint32_t SaveGraphVersionResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2
namespace nebula { namespace meta { namespace cpp2 {
class SaveGraphVersionReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = SaveGraphVersionReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  SaveGraphVersionReq() :
      client_version(apache::thrift::StringTraits< std::string>::fromStringLiteral("3.0.0")) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  SaveGraphVersionReq(apache::thrift::FragileConstructor, ::std::string client_version__arg, nebula::HostAddr host__arg, ::std::string build_version__arg);

  SaveGraphVersionReq(SaveGraphVersionReq&&) = default;

  SaveGraphVersionReq(const SaveGraphVersionReq&) = default;


  SaveGraphVersionReq& operator=(SaveGraphVersionReq&&) = default;

  SaveGraphVersionReq& operator=(const SaveGraphVersionReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
  ::std::string client_version;
 private:
  nebula::HostAddr host;
 private:
  ::std::string build_version;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool host;
    bool build_version;
  } __isset = {};
  bool operator==(const SaveGraphVersionReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const SaveGraphVersionReq& __x, const SaveGraphVersionReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const SaveGraphVersionReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const SaveGraphVersionReq& __x, const SaveGraphVersionReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const SaveGraphVersionReq& __x, const SaveGraphVersionReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const SaveGraphVersionReq& __x, const SaveGraphVersionReq& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> client_version_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->client_version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> client_version_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->client_version)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> client_version_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->client_version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> client_version_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->client_version)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> host_ref() const& {
    return {this->host, __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> host_ref() const&& {
    return {std::move(this->host), __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> host_ref() & {
    return {this->host, __isset.host};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> host_ref() && {
    return {std::move(this->host), __isset.host};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> build_version_ref() const& {
    return {this->build_version, __isset.build_version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> build_version_ref() const&& {
    return {std::move(this->build_version), __isset.build_version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> build_version_ref() & {
    return {this->build_version, __isset.build_version};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> build_version_ref() && {
    return {std::move(this->build_version), __isset.build_version};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_client_version() const& {
    return client_version;
  }

  ::std::string get_client_version() && {
    return std::move(client_version);
  }

  template <typename T_SaveGraphVersionReq_client_version_struct_setter = ::std::string>
  ::std::string& set_client_version(T_SaveGraphVersionReq_client_version_struct_setter&& client_version_) {
    client_version = std::forward<T_SaveGraphVersionReq_client_version_struct_setter>(client_version_);
    return client_version;
  }
  const nebula::HostAddr& get_host() const&;
  nebula::HostAddr get_host() &&;

  template <typename T_SaveGraphVersionReq_host_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_host(T_SaveGraphVersionReq_host_struct_setter&& host_) {
    host = std::forward<T_SaveGraphVersionReq_host_struct_setter>(host_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.host = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return host;
  }

  const ::std::string& get_build_version() const& {
    return build_version;
  }

  ::std::string get_build_version() && {
    return std::move(build_version);
  }

  template <typename T_SaveGraphVersionReq_build_version_struct_setter = ::std::string>
  ::std::string& set_build_version(T_SaveGraphVersionReq_build_version_struct_setter&& build_version_) {
    build_version = std::forward<T_SaveGraphVersionReq_build_version_struct_setter>(build_version_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.build_version = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return build_version;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< SaveGraphVersionReq >;
  friend void swap(SaveGraphVersionReq& a, SaveGraphVersionReq& b);
};

template <class Protocol_>
uint32_t SaveGraphVersionReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::meta::cpp2

namespace apache { namespace thrift {

template <> struct TEnumDataStorage<::nebula::meta::cpp2::ID::Type>;

template <> struct TEnumTraits<::nebula::meta::cpp2::ID::Type> {
  using type = ::nebula::meta::cpp2::ID::Type;

  static constexpr std::size_t const size = 5;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};
}} // apache::thrift
