/**
 * Autogenerated by Thrift for storage.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "storage_types.h"
#include "storage_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "storage_data.h"


namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::storage::cpp2::StatType>::size;
folly::Range<::nebula::storage::cpp2::StatType const*> const TEnumTraits<::nebula::storage::cpp2::StatType>::values = folly::range(TEnumDataStorage<::nebula::storage::cpp2::StatType>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::storage::cpp2::StatType>::names = folly::range(TEnumDataStorage<::nebula::storage::cpp2::StatType>::names);

char const* TEnumTraits<::nebula::storage::cpp2::StatType>::findName(type value) {
  using factory = ::nebula::storage::cpp2::_StatType_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::storage::cpp2::StatType>::findValue(char const* name, type* out) {
  using factory = ::nebula::storage::cpp2::_StatType_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace storage { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _StatType_EnumMapFactory::ValuesToNamesMapType _StatType_VALUES_TO_NAMES = _StatType_EnumMapFactory::makeValuesToNamesMap();
const _StatType_EnumMapFactory::NamesToValuesMapType _StatType_NAMES_TO_VALUES = _StatType_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::storage::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::storage::cpp2::OrderDirection>::size;
folly::Range<::nebula::storage::cpp2::OrderDirection const*> const TEnumTraits<::nebula::storage::cpp2::OrderDirection>::values = folly::range(TEnumDataStorage<::nebula::storage::cpp2::OrderDirection>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::storage::cpp2::OrderDirection>::names = folly::range(TEnumDataStorage<::nebula::storage::cpp2::OrderDirection>::names);

char const* TEnumTraits<::nebula::storage::cpp2::OrderDirection>::findName(type value) {
  using factory = ::nebula::storage::cpp2::_OrderDirection_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::storage::cpp2::OrderDirection>::findValue(char const* name, type* out) {
  using factory = ::nebula::storage::cpp2::_OrderDirection_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace storage { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _OrderDirection_EnumMapFactory::ValuesToNamesMapType _OrderDirection_VALUES_TO_NAMES = _OrderDirection_EnumMapFactory::makeValuesToNamesMap();
const _OrderDirection_EnumMapFactory::NamesToValuesMapType _OrderDirection_NAMES_TO_VALUES = _OrderDirection_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::storage::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::storage::cpp2::EdgeDirection>::size;
folly::Range<::nebula::storage::cpp2::EdgeDirection const*> const TEnumTraits<::nebula::storage::cpp2::EdgeDirection>::values = folly::range(TEnumDataStorage<::nebula::storage::cpp2::EdgeDirection>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::storage::cpp2::EdgeDirection>::names = folly::range(TEnumDataStorage<::nebula::storage::cpp2::EdgeDirection>::names);

char const* TEnumTraits<::nebula::storage::cpp2::EdgeDirection>::findName(type value) {
  using factory = ::nebula::storage::cpp2::_EdgeDirection_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::storage::cpp2::EdgeDirection>::findValue(char const* name, type* out) {
  using factory = ::nebula::storage::cpp2::_EdgeDirection_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace storage { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _EdgeDirection_EnumMapFactory::ValuesToNamesMapType _EdgeDirection_VALUES_TO_NAMES = _EdgeDirection_EnumMapFactory::makeValuesToNamesMap();
const _EdgeDirection_EnumMapFactory::NamesToValuesMapType _EdgeDirection_NAMES_TO_VALUES = _EdgeDirection_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::storage::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::storage::cpp2::ScanType>::size;
folly::Range<::nebula::storage::cpp2::ScanType const*> const TEnumTraits<::nebula::storage::cpp2::ScanType>::values = folly::range(TEnumDataStorage<::nebula::storage::cpp2::ScanType>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::storage::cpp2::ScanType>::names = folly::range(TEnumDataStorage<::nebula::storage::cpp2::ScanType>::names);

char const* TEnumTraits<::nebula::storage::cpp2::ScanType>::findName(type value) {
  using factory = ::nebula::storage::cpp2::_ScanType_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::storage::cpp2::ScanType>::findValue(char const* name, type* out) {
  using factory = ::nebula::storage::cpp2::_ScanType_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace storage { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _ScanType_EnumMapFactory::ValuesToNamesMapType _ScanType_VALUES_TO_NAMES = _ScanType_EnumMapFactory::makeValuesToNamesMap();
const _ScanType_EnumMapFactory::NamesToValuesMapType _ScanType_NAMES_TO_VALUES = _ScanType_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::storage::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::storage::cpp2::EngineSignType>::size;
folly::Range<::nebula::storage::cpp2::EngineSignType const*> const TEnumTraits<::nebula::storage::cpp2::EngineSignType>::values = folly::range(TEnumDataStorage<::nebula::storage::cpp2::EngineSignType>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::storage::cpp2::EngineSignType>::names = folly::range(TEnumDataStorage<::nebula::storage::cpp2::EngineSignType>::names);

char const* TEnumTraits<::nebula::storage::cpp2::EngineSignType>::findName(type value) {
  using factory = ::nebula::storage::cpp2::_EngineSignType_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::storage::cpp2::EngineSignType>::findValue(char const* name, type* out) {
  using factory = ::nebula::storage::cpp2::_EngineSignType_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace storage { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _EngineSignType_EnumMapFactory::ValuesToNamesMapType _EngineSignType_VALUES_TO_NAMES = _EngineSignType_EnumMapFactory::makeValuesToNamesMap();
const _EngineSignType_EnumMapFactory::NamesToValuesMapType _EngineSignType_NAMES_TO_VALUES = _EngineSignType_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::RequestCommon>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::RequestCommon>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RequestCommon::RequestCommon(apache::thrift::FragileConstructor,  ::nebula::cpp2::SessionID session_id__arg,  ::nebula::cpp2::ExecutionPlanID plan_id__arg, bool profile_detail__arg) :
    session_id(std::move(session_id__arg)),
    plan_id(std::move(plan_id__arg)),
    profile_detail(std::move(profile_detail__arg)) {
  __isset.session_id = true;
  __isset.plan_id = true;
  __isset.profile_detail = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void RequestCommon::__clear() {
  // clear all fields
  session_id = 0;
  plan_id = 0;
  profile_detail = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool RequestCommon::operator==(const RequestCommon& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.session_id_ref() != rhs.session_id_ref()) {
    return false;
  }
  if (lhs.plan_id_ref() != rhs.plan_id_ref()) {
    return false;
  }
  if (lhs.profile_detail_ref() != rhs.profile_detail_ref()) {
    return false;
  }
  return true;
}

bool RequestCommon::operator<(const RequestCommon& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.session_id_ref() != rhs.session_id_ref()) {
    return lhs.session_id_ref() < rhs.session_id_ref();
  }
  if (lhs.plan_id_ref() != rhs.plan_id_ref()) {
    return lhs.plan_id_ref() < rhs.plan_id_ref();
  }
  if (lhs.profile_detail_ref() != rhs.profile_detail_ref()) {
    return lhs.profile_detail_ref() < rhs.profile_detail_ref();
  }
  return false;
}


void swap(RequestCommon& a, RequestCommon& b) {
  using ::std::swap;
  swap(a.session_id_ref().value_unchecked(), b.session_id_ref().value_unchecked());
  swap(a.plan_id_ref().value_unchecked(), b.plan_id_ref().value_unchecked());
  swap(a.profile_detail_ref().value_unchecked(), b.profile_detail_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void RequestCommon::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RequestCommon::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RequestCommon::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RequestCommon::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RequestCommon::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RequestCommon::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RequestCommon::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RequestCommon::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::PartitionResult>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::PartitionResult>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PartitionResult::PartitionResult(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg,  ::nebula::cpp2::PartitionID part_id__arg, nebula::HostAddr leader__arg) :
    code(std::move(code__arg)),
    part_id(std::move(part_id__arg)),
    leader(std::move(leader__arg)) {
  __isset.leader = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void PartitionResult::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  part_id = 0;
  leader.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool PartitionResult::operator==(const PartitionResult& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return false;
  }
  if (lhs.leader_ref() != rhs.leader_ref()) {
    return false;
  }
  return true;
}

bool PartitionResult::operator<(const PartitionResult& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return lhs.part_id < rhs.part_id;
  }
  if (lhs.leader_ref() != rhs.leader_ref()) {
    return lhs.leader_ref() < rhs.leader_ref();
  }
  return false;
}

const nebula::HostAddr* PartitionResult::get_leader() const& {
  return leader_ref().has_value() ? std::addressof(leader) : nullptr;
}

nebula::HostAddr* PartitionResult::get_leader() & {
  return leader_ref().has_value() ? std::addressof(leader) : nullptr;
}


void swap(PartitionResult& a, PartitionResult& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.part_id_ref().value(), b.part_id_ref().value());
  swap(a.leader_ref().value_unchecked(), b.leader_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void PartitionResult::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PartitionResult::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PartitionResult::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PartitionResult::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PartitionResult::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PartitionResult::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PartitionResult::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PartitionResult::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PartitionResult,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PartitionResult,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::ResponseCommon>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::ResponseCommon>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ResponseCommon::ResponseCommon(apache::thrift::FragileConstructor, ::std::vector< ::nebula::storage::cpp2::PartitionResult> failed_parts__arg, int64_t latency_in_us__arg, ::std::map<::std::string, int32_t> latency_detail_us__arg) :
    failed_parts(std::move(failed_parts__arg)),
    latency_in_us(std::move(latency_in_us__arg)),
    latency_detail_us(std::move(latency_detail_us__arg)) {
  __isset.latency_detail_us = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ResponseCommon::__clear() {
  // clear all fields
  failed_parts.clear();
  latency_in_us = 0;
  latency_detail_us.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ResponseCommon::operator==(const ResponseCommon& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.failed_parts == rhs.failed_parts)) {
    return false;
  }
  if (!(lhs.latency_in_us == rhs.latency_in_us)) {
    return false;
  }
  if (lhs.latency_detail_us_ref() != rhs.latency_detail_us_ref()) {
    return false;
  }
  return true;
}

bool ResponseCommon::operator<(const ResponseCommon& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.failed_parts == rhs.failed_parts)) {
    return lhs.failed_parts < rhs.failed_parts;
  }
  if (!(lhs.latency_in_us == rhs.latency_in_us)) {
    return lhs.latency_in_us < rhs.latency_in_us;
  }
  if (lhs.latency_detail_us_ref() != rhs.latency_detail_us_ref()) {
    return lhs.latency_detail_us_ref() < rhs.latency_detail_us_ref();
  }
  return false;
}

const ::std::vector< ::nebula::storage::cpp2::PartitionResult>& ResponseCommon::get_failed_parts() const& {
  return failed_parts;
}

::std::vector< ::nebula::storage::cpp2::PartitionResult> ResponseCommon::get_failed_parts() && {
  return std::move(failed_parts);
}

const ::std::map<::std::string, int32_t>* ResponseCommon::get_latency_detail_us() const& {
  return latency_detail_us_ref().has_value() ? std::addressof(latency_detail_us) : nullptr;
}

::std::map<::std::string, int32_t>* ResponseCommon::get_latency_detail_us() & {
  return latency_detail_us_ref().has_value() ? std::addressof(latency_detail_us) : nullptr;
}


void swap(ResponseCommon& a, ResponseCommon& b) {
  using ::std::swap;
  swap(a.failed_parts_ref().value(), b.failed_parts_ref().value());
  swap(a.latency_in_us_ref().value(), b.latency_in_us_ref().value());
  swap(a.latency_detail_us_ref().value_unchecked(), b.latency_detail_us_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ResponseCommon::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ResponseCommon::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ResponseCommon::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ResponseCommon::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ResponseCommon::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ResponseCommon::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ResponseCommon::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ResponseCommon::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ResponseCommon,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::PartitionResult>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ResponseCommon,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::PartitionResult>>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::StatProp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::StatProp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StatProp::StatProp(apache::thrift::FragileConstructor, ::std::string alias__arg, ::std::string prop__arg,  ::nebula::storage::cpp2::StatType stat__arg) :
    alias(std::move(alias__arg)),
    prop(std::move(prop__arg)),
    stat(std::move(stat__arg)) {
  __isset.alias = true;
  __isset.prop = true;
  __isset.stat = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void StatProp::__clear() {
  // clear all fields
  alias = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  prop = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  stat = static_cast< ::nebula::storage::cpp2::StatType>(0);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool StatProp::operator==(const StatProp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.alias, rhs.alias)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.prop, rhs.prop)) {
    return false;
  }
  if (!(lhs.stat == rhs.stat)) {
    return false;
  }
  return true;
}

bool StatProp::operator<(const StatProp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.alias, rhs.alias)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.alias, rhs.alias);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.prop, rhs.prop)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.prop, rhs.prop);
  }
  if (!(lhs.stat == rhs.stat)) {
    return lhs.stat < rhs.stat;
  }
  return false;
}


void swap(StatProp& a, StatProp& b) {
  using ::std::swap;
  swap(a.alias_ref().value(), b.alias_ref().value());
  swap(a.prop_ref().value(), b.prop_ref().value());
  swap(a.stat_ref().value(), b.stat_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void StatProp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StatProp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StatProp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StatProp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StatProp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StatProp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StatProp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StatProp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::Expr>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::Expr>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Expr::Expr(apache::thrift::FragileConstructor, ::std::string alias__arg, ::std::string expr__arg) :
    alias(std::move(alias__arg)),
    expr(std::move(expr__arg)) {
  __isset.alias = true;
  __isset.expr = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Expr::__clear() {
  // clear all fields
  alias = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  expr = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool Expr::operator==(const Expr& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.alias, rhs.alias)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.expr, rhs.expr)) {
    return false;
  }
  return true;
}

bool Expr::operator<(const Expr& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.alias, rhs.alias)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.alias, rhs.alias);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.expr, rhs.expr)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.expr, rhs.expr);
  }
  return false;
}


void swap(Expr& a, Expr& b) {
  using ::std::swap;
  swap(a.alias_ref().value(), b.alias_ref().value());
  swap(a.expr_ref().value(), b.expr_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void Expr::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Expr::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Expr::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Expr::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Expr::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Expr::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Expr::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Expr::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::EdgeProp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::EdgeProp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
EdgeProp::EdgeProp(apache::thrift::FragileConstructor,  ::nebula::cpp2::EdgeType type__arg, ::std::vector<::std::string> props__arg) :
    type(std::move(type__arg)),
    props(std::move(props__arg)) {
  __isset.type = true;
  __isset.props = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void EdgeProp::__clear() {
  // clear all fields
  type = 0;
  props.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool EdgeProp::operator==(const EdgeProp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.type == rhs.type)) {
    return false;
  }
  if (!(lhs.props == rhs.props)) {
    return false;
  }
  return true;
}

bool EdgeProp::operator<(const EdgeProp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.type == rhs.type)) {
    return lhs.type < rhs.type;
  }
  if (!(lhs.props == rhs.props)) {
    return lhs.props < rhs.props;
  }
  return false;
}

const ::std::vector<::std::string>& EdgeProp::get_props() const& {
  return props;
}

::std::vector<::std::string> EdgeProp::get_props() && {
  return std::move(props);
}


void swap(EdgeProp& a, EdgeProp& b) {
  using ::std::swap;
  swap(a.type_ref().value(), b.type_ref().value());
  swap(a.props_ref().value(), b.props_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void EdgeProp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t EdgeProp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t EdgeProp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t EdgeProp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void EdgeProp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t EdgeProp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t EdgeProp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t EdgeProp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::VertexProp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::VertexProp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
VertexProp::VertexProp(apache::thrift::FragileConstructor,  ::nebula::cpp2::TagID tag__arg, ::std::vector<::std::string> props__arg) :
    tag(std::move(tag__arg)),
    props(std::move(props__arg)) {
  __isset.tag = true;
  __isset.props = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void VertexProp::__clear() {
  // clear all fields
  tag = 0;
  props.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool VertexProp::operator==(const VertexProp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.tag == rhs.tag)) {
    return false;
  }
  if (!(lhs.props == rhs.props)) {
    return false;
  }
  return true;
}

bool VertexProp::operator<(const VertexProp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.tag == rhs.tag)) {
    return lhs.tag < rhs.tag;
  }
  if (!(lhs.props == rhs.props)) {
    return lhs.props < rhs.props;
  }
  return false;
}

const ::std::vector<::std::string>& VertexProp::get_props() const& {
  return props;
}

::std::vector<::std::string> VertexProp::get_props() && {
  return std::move(props);
}


void swap(VertexProp& a, VertexProp& b) {
  using ::std::swap;
  swap(a.tag_ref().value(), b.tag_ref().value());
  swap(a.props_ref().value(), b.props_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void VertexProp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t VertexProp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t VertexProp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t VertexProp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void VertexProp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t VertexProp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t VertexProp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t VertexProp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::OrderBy>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::OrderBy>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
OrderBy::OrderBy(apache::thrift::FragileConstructor, ::std::string prop__arg,  ::nebula::storage::cpp2::OrderDirection direction__arg) :
    prop(std::move(prop__arg)),
    direction(std::move(direction__arg)) {
  __isset.prop = true;
  __isset.direction = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void OrderBy::__clear() {
  // clear all fields
  prop = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  direction = static_cast< ::nebula::storage::cpp2::OrderDirection>(0);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool OrderBy::operator==(const OrderBy& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.prop, rhs.prop)) {
    return false;
  }
  if (!(lhs.direction == rhs.direction)) {
    return false;
  }
  return true;
}

bool OrderBy::operator<(const OrderBy& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.prop, rhs.prop)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.prop, rhs.prop);
  }
  if (!(lhs.direction == rhs.direction)) {
    return lhs.direction < rhs.direction;
  }
  return false;
}


void swap(OrderBy& a, OrderBy& b) {
  using ::std::swap;
  swap(a.prop_ref().value(), b.prop_ref().value());
  swap(a.direction_ref().value(), b.direction_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void OrderBy::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t OrderBy::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t OrderBy::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t OrderBy::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void OrderBy::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t OrderBy::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t OrderBy::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t OrderBy::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::TraverseSpec>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::TraverseSpec>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
TraverseSpec::TraverseSpec() :
      edge_direction( ::nebula::storage::cpp2::EdgeDirection::BOTH),
      dedup(false),
      random(0),
      limit(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


TraverseSpec::~TraverseSpec() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
TraverseSpec::TraverseSpec(apache::thrift::FragileConstructor, ::std::vector< ::nebula::cpp2::EdgeType> edge_types__arg,  ::nebula::storage::cpp2::EdgeDirection edge_direction__arg, bool dedup__arg, ::std::vector< ::nebula::storage::cpp2::StatProp> stat_props__arg, ::std::vector< ::nebula::storage::cpp2::VertexProp> vertex_props__arg, ::std::vector< ::nebula::storage::cpp2::EdgeProp> edge_props__arg, ::std::vector< ::nebula::storage::cpp2::Expr> expressions__arg, ::std::vector< ::nebula::storage::cpp2::OrderBy> order_by__arg, bool random__arg, int64_t limit__arg, ::std::string filter__arg, ::std::string tag_filter__arg) :
    edge_types(std::move(edge_types__arg)),
    edge_direction(std::move(edge_direction__arg)),
    dedup(std::move(dedup__arg)),
    stat_props(std::move(stat_props__arg)),
    vertex_props(std::move(vertex_props__arg)),
    edge_props(std::move(edge_props__arg)),
    expressions(std::move(expressions__arg)),
    order_by(std::move(order_by__arg)),
    random(std::move(random__arg)),
    limit(std::move(limit__arg)),
    filter(std::move(filter__arg)),
    tag_filter(std::move(tag_filter__arg)) {
  __isset.edge_types = true;
  __isset.edge_direction = true;
  __isset.dedup = true;
  __isset.stat_props = true;
  __isset.vertex_props = true;
  __isset.edge_props = true;
  __isset.expressions = true;
  __isset.order_by = true;
  __isset.random = true;
  __isset.limit = true;
  __isset.filter = true;
  __isset.tag_filter = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void TraverseSpec::__clear() {
  // clear all fields
  edge_types.clear();
  edge_direction =  ::nebula::storage::cpp2::EdgeDirection::BOTH;
  dedup = false;
  stat_props.clear();
  vertex_props.clear();
  edge_props.clear();
  expressions.clear();
  order_by.clear();
  random = 0;
  limit = 0;
  filter = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  tag_filter = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool TraverseSpec::operator==(const TraverseSpec& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.edge_types == rhs.edge_types)) {
    return false;
  }
  if (!(lhs.edge_direction == rhs.edge_direction)) {
    return false;
  }
  if (!(lhs.dedup == rhs.dedup)) {
    return false;
  }
  if (lhs.stat_props_ref() != rhs.stat_props_ref()) {
    return false;
  }
  if (lhs.vertex_props_ref() != rhs.vertex_props_ref()) {
    return false;
  }
  if (lhs.edge_props_ref() != rhs.edge_props_ref()) {
    return false;
  }
  if (lhs.expressions_ref() != rhs.expressions_ref()) {
    return false;
  }
  if (lhs.order_by_ref() != rhs.order_by_ref()) {
    return false;
  }
  if (lhs.random_ref() != rhs.random_ref()) {
    return false;
  }
  if (lhs.limit_ref() != rhs.limit_ref()) {
    return false;
  }
  if (lhs.filter_ref().has_value() != rhs.filter_ref().has_value()) {
    return false;
  }
  if (lhs.filter_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.filter, rhs.filter)) {
      return false;
    }
  }
  if (lhs.tag_filter_ref().has_value() != rhs.tag_filter_ref().has_value()) {
    return false;
  }
  if (lhs.tag_filter_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.tag_filter, rhs.tag_filter)) {
      return false;
    }
  }
  return true;
}

bool TraverseSpec::operator<(const TraverseSpec& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.edge_types == rhs.edge_types)) {
    return lhs.edge_types < rhs.edge_types;
  }
  if (!(lhs.edge_direction == rhs.edge_direction)) {
    return lhs.edge_direction < rhs.edge_direction;
  }
  if (!(lhs.dedup == rhs.dedup)) {
    return lhs.dedup < rhs.dedup;
  }
  if (lhs.stat_props_ref() != rhs.stat_props_ref()) {
    return lhs.stat_props_ref() < rhs.stat_props_ref();
  }
  if (lhs.vertex_props_ref() != rhs.vertex_props_ref()) {
    return lhs.vertex_props_ref() < rhs.vertex_props_ref();
  }
  if (lhs.edge_props_ref() != rhs.edge_props_ref()) {
    return lhs.edge_props_ref() < rhs.edge_props_ref();
  }
  if (lhs.expressions_ref() != rhs.expressions_ref()) {
    return lhs.expressions_ref() < rhs.expressions_ref();
  }
  if (lhs.order_by_ref() != rhs.order_by_ref()) {
    return lhs.order_by_ref() < rhs.order_by_ref();
  }
  if (lhs.random_ref() != rhs.random_ref()) {
    return lhs.random_ref() < rhs.random_ref();
  }
  if (lhs.limit_ref() != rhs.limit_ref()) {
    return lhs.limit_ref() < rhs.limit_ref();
  }
  if (lhs.filter_ref().has_value() != rhs.filter_ref().has_value()) {
    return lhs.filter_ref().has_value() < rhs.filter_ref().has_value();
  }
  if (lhs.filter_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.filter, rhs.filter)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.filter, rhs.filter);
    }
  }
  if (lhs.tag_filter_ref().has_value() != rhs.tag_filter_ref().has_value()) {
    return lhs.tag_filter_ref().has_value() < rhs.tag_filter_ref().has_value();
  }
  if (lhs.tag_filter_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.tag_filter, rhs.tag_filter)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.tag_filter, rhs.tag_filter);
    }
  }
  return false;
}

const ::std::vector< ::nebula::cpp2::EdgeType>& TraverseSpec::get_edge_types() const& {
  return edge_types;
}

::std::vector< ::nebula::cpp2::EdgeType> TraverseSpec::get_edge_types() && {
  return std::move(edge_types);
}

const ::std::vector< ::nebula::storage::cpp2::StatProp>* TraverseSpec::get_stat_props() const& {
  return stat_props_ref().has_value() ? std::addressof(stat_props) : nullptr;
}

::std::vector< ::nebula::storage::cpp2::StatProp>* TraverseSpec::get_stat_props() & {
  return stat_props_ref().has_value() ? std::addressof(stat_props) : nullptr;
}

const ::std::vector< ::nebula::storage::cpp2::VertexProp>* TraverseSpec::get_vertex_props() const& {
  return vertex_props_ref().has_value() ? std::addressof(vertex_props) : nullptr;
}

::std::vector< ::nebula::storage::cpp2::VertexProp>* TraverseSpec::get_vertex_props() & {
  return vertex_props_ref().has_value() ? std::addressof(vertex_props) : nullptr;
}

const ::std::vector< ::nebula::storage::cpp2::EdgeProp>* TraverseSpec::get_edge_props() const& {
  return edge_props_ref().has_value() ? std::addressof(edge_props) : nullptr;
}

::std::vector< ::nebula::storage::cpp2::EdgeProp>* TraverseSpec::get_edge_props() & {
  return edge_props_ref().has_value() ? std::addressof(edge_props) : nullptr;
}

const ::std::vector< ::nebula::storage::cpp2::Expr>* TraverseSpec::get_expressions() const& {
  return expressions_ref().has_value() ? std::addressof(expressions) : nullptr;
}

::std::vector< ::nebula::storage::cpp2::Expr>* TraverseSpec::get_expressions() & {
  return expressions_ref().has_value() ? std::addressof(expressions) : nullptr;
}

const ::std::vector< ::nebula::storage::cpp2::OrderBy>* TraverseSpec::get_order_by() const& {
  return order_by_ref().has_value() ? std::addressof(order_by) : nullptr;
}

::std::vector< ::nebula::storage::cpp2::OrderBy>* TraverseSpec::get_order_by() & {
  return order_by_ref().has_value() ? std::addressof(order_by) : nullptr;
}


void swap(TraverseSpec& a, TraverseSpec& b) {
  using ::std::swap;
  swap(a.edge_types_ref().value(), b.edge_types_ref().value());
  swap(a.edge_direction_ref().value(), b.edge_direction_ref().value());
  swap(a.dedup_ref().value(), b.dedup_ref().value());
  swap(a.stat_props_ref().value_unchecked(), b.stat_props_ref().value_unchecked());
  swap(a.vertex_props_ref().value_unchecked(), b.vertex_props_ref().value_unchecked());
  swap(a.edge_props_ref().value_unchecked(), b.edge_props_ref().value_unchecked());
  swap(a.expressions_ref().value_unchecked(), b.expressions_ref().value_unchecked());
  swap(a.order_by_ref().value_unchecked(), b.order_by_ref().value_unchecked());
  swap(a.random_ref().value_unchecked(), b.random_ref().value_unchecked());
  swap(a.limit_ref().value_unchecked(), b.limit_ref().value_unchecked());
  swap(a.filter_ref().value_unchecked(), b.filter_ref().value_unchecked());
  swap(a.tag_filter_ref().value_unchecked(), b.tag_filter_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void TraverseSpec::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TraverseSpec::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TraverseSpec::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TraverseSpec::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TraverseSpec::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TraverseSpec::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TraverseSpec::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TraverseSpec::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        TraverseSpec,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::StatProp>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        TraverseSpec,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::VertexProp>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        TraverseSpec,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::EdgeProp>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        TraverseSpec,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::Expr>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        TraverseSpec,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::OrderBy>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        TraverseSpec,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::StatProp>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        TraverseSpec,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::VertexProp>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        TraverseSpec,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::EdgeProp>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        TraverseSpec,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::Expr>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        TraverseSpec,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::OrderBy>>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::GetNeighborsRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::GetNeighborsRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetNeighborsRequest::GetNeighborsRequest() :
      space_id(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


GetNeighborsRequest::~GetNeighborsRequest() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetNeighborsRequest::GetNeighborsRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::vector<::std::string> column_names__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>> parts__arg,  ::nebula::storage::cpp2::TraverseSpec traverse_spec__arg,  ::nebula::storage::cpp2::RequestCommon common__arg) :
    space_id(std::move(space_id__arg)),
    column_names(std::move(column_names__arg)),
    parts(std::move(parts__arg)),
    traverse_spec(std::move(traverse_spec__arg)),
    common(std::move(common__arg)) {
  __isset.space_id = true;
  __isset.column_names = true;
  __isset.parts = true;
  __isset.traverse_spec = true;
  __isset.common = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetNeighborsRequest::__clear() {
  // clear all fields
  space_id = 0;
  column_names.clear();
  parts.clear();
  traverse_spec.__clear();
  common.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetNeighborsRequest::operator==(const GetNeighborsRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.column_names == rhs.column_names)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  if (!(lhs.traverse_spec == rhs.traverse_spec)) {
    return false;
  }
  if (lhs.common_ref() != rhs.common_ref()) {
    return false;
  }
  return true;
}

const ::std::vector<::std::string>& GetNeighborsRequest::get_column_names() const& {
  return column_names;
}

::std::vector<::std::string> GetNeighborsRequest::get_column_names() && {
  return std::move(column_names);
}

const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>& GetNeighborsRequest::get_parts() const& {
  return parts;
}

std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>> GetNeighborsRequest::get_parts() && {
  return std::move(parts);
}

const  ::nebula::storage::cpp2::TraverseSpec& GetNeighborsRequest::get_traverse_spec() const& {
  return traverse_spec;
}

 ::nebula::storage::cpp2::TraverseSpec GetNeighborsRequest::get_traverse_spec() && {
  return std::move(traverse_spec);
}

const  ::nebula::storage::cpp2::RequestCommon* GetNeighborsRequest::get_common() const& {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}

 ::nebula::storage::cpp2::RequestCommon* GetNeighborsRequest::get_common() & {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}


void swap(GetNeighborsRequest& a, GetNeighborsRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.column_names_ref().value(), b.column_names_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
  swap(a.traverse_spec_ref().value(), b.traverse_spec_ref().value());
  swap(a.common_ref().value_unchecked(), b.common_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetNeighborsRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetNeighborsRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetNeighborsRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetNeighborsRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetNeighborsRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetNeighborsRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetNeighborsRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetNeighborsRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetNeighborsRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetNeighborsRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::TraverseSpec>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetNeighborsRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetNeighborsRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetNeighborsRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::TraverseSpec>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetNeighborsRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::GetNeighborsResponse>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::GetNeighborsResponse>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetNeighborsResponse::GetNeighborsResponse(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg, nebula::DataSet vertices__arg) :
    result(std::move(result__arg)),
    vertices(std::move(vertices__arg)) {
  __isset.vertices = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetNeighborsResponse::__clear() {
  // clear all fields
  result.__clear();
  vertices.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetNeighborsResponse::operator==(const GetNeighborsResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (lhs.vertices_ref() != rhs.vertices_ref()) {
    return false;
  }
  return true;
}

const  ::nebula::storage::cpp2::ResponseCommon& GetNeighborsResponse::get_result() const& {
  return result;
}

 ::nebula::storage::cpp2::ResponseCommon GetNeighborsResponse::get_result() && {
  return std::move(result);
}

const nebula::DataSet* GetNeighborsResponse::get_vertices() const& {
  return vertices_ref().has_value() ? std::addressof(vertices) : nullptr;
}

nebula::DataSet* GetNeighborsResponse::get_vertices() & {
  return vertices_ref().has_value() ? std::addressof(vertices) : nullptr;
}


void swap(GetNeighborsResponse& a, GetNeighborsResponse& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.vertices_ref().value_unchecked(), b.vertices_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetNeighborsResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetNeighborsResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetNeighborsResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetNeighborsResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetNeighborsResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetNeighborsResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetNeighborsResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetNeighborsResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetNeighborsResponse,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetNeighborsResponse,
        ::apache::thrift::type_class::structure,
        nebula::DataSet>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetNeighborsResponse,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetNeighborsResponse,
        ::apache::thrift::type_class::structure,
        nebula::DataSet>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::GetDstBySrcRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::GetDstBySrcRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetDstBySrcRequest::GetDstBySrcRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>> parts__arg, ::std::vector< ::nebula::cpp2::EdgeType> edge_types__arg,  ::nebula::storage::cpp2::RequestCommon common__arg) :
    space_id(std::move(space_id__arg)),
    parts(std::move(parts__arg)),
    edge_types(std::move(edge_types__arg)),
    common(std::move(common__arg)) {
  __isset.space_id = true;
  __isset.parts = true;
  __isset.edge_types = true;
  __isset.common = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetDstBySrcRequest::__clear() {
  // clear all fields
  space_id = 0;
  parts.clear();
  edge_types.clear();
  common.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetDstBySrcRequest::operator==(const GetDstBySrcRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  if (!(lhs.edge_types == rhs.edge_types)) {
    return false;
  }
  if (lhs.common_ref() != rhs.common_ref()) {
    return false;
  }
  return true;
}

const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>& GetDstBySrcRequest::get_parts() const& {
  return parts;
}

std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>> GetDstBySrcRequest::get_parts() && {
  return std::move(parts);
}

const ::std::vector< ::nebula::cpp2::EdgeType>& GetDstBySrcRequest::get_edge_types() const& {
  return edge_types;
}

::std::vector< ::nebula::cpp2::EdgeType> GetDstBySrcRequest::get_edge_types() && {
  return std::move(edge_types);
}

const  ::nebula::storage::cpp2::RequestCommon* GetDstBySrcRequest::get_common() const& {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}

 ::nebula::storage::cpp2::RequestCommon* GetDstBySrcRequest::get_common() & {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}


void swap(GetDstBySrcRequest& a, GetDstBySrcRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
  swap(a.edge_types_ref().value(), b.edge_types_ref().value());
  swap(a.common_ref().value_unchecked(), b.common_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetDstBySrcRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetDstBySrcRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetDstBySrcRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetDstBySrcRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetDstBySrcRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetDstBySrcRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetDstBySrcRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetDstBySrcRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetDstBySrcRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetDstBySrcRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetDstBySrcRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetDstBySrcRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::GetDstBySrcResponse>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::GetDstBySrcResponse>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetDstBySrcResponse::GetDstBySrcResponse(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg, nebula::DataSet dsts__arg) :
    result(std::move(result__arg)),
    dsts(std::move(dsts__arg)) {
  __isset.dsts = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetDstBySrcResponse::__clear() {
  // clear all fields
  result.__clear();
  dsts.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetDstBySrcResponse::operator==(const GetDstBySrcResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (lhs.dsts_ref() != rhs.dsts_ref()) {
    return false;
  }
  return true;
}

const  ::nebula::storage::cpp2::ResponseCommon& GetDstBySrcResponse::get_result() const& {
  return result;
}

 ::nebula::storage::cpp2::ResponseCommon GetDstBySrcResponse::get_result() && {
  return std::move(result);
}

const nebula::DataSet* GetDstBySrcResponse::get_dsts() const& {
  return dsts_ref().has_value() ? std::addressof(dsts) : nullptr;
}

nebula::DataSet* GetDstBySrcResponse::get_dsts() & {
  return dsts_ref().has_value() ? std::addressof(dsts) : nullptr;
}


void swap(GetDstBySrcResponse& a, GetDstBySrcResponse& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.dsts_ref().value_unchecked(), b.dsts_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetDstBySrcResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetDstBySrcResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetDstBySrcResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetDstBySrcResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetDstBySrcResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetDstBySrcResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetDstBySrcResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetDstBySrcResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetDstBySrcResponse,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetDstBySrcResponse,
        ::apache::thrift::type_class::structure,
        nebula::DataSet>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetDstBySrcResponse,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetDstBySrcResponse,
        ::apache::thrift::type_class::structure,
        nebula::DataSet>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::ExecResponse>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::ExecResponse>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ExecResponse::ExecResponse(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg) :
    result(std::move(result__arg)) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ExecResponse::__clear() {
  // clear all fields
  result.__clear();
}

bool ExecResponse::operator==(const ExecResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  return true;
}

bool ExecResponse::operator<(const ExecResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  return false;
}

const  ::nebula::storage::cpp2::ResponseCommon& ExecResponse::get_result() const& {
  return result;
}

 ::nebula::storage::cpp2::ResponseCommon ExecResponse::get_result() && {
  return std::move(result);
}


void swap(ExecResponse& a, ExecResponse& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
}

template void ExecResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ExecResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ExecResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ExecResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ExecResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ExecResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ExecResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ExecResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ExecResponse,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ExecResponse,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::GetPropRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::GetPropRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetPropRequest::GetPropRequest() :
      space_id(0),
      dedup(false),
      limit(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


GetPropRequest::~GetPropRequest() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetPropRequest::GetPropRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>> parts__arg, ::std::vector< ::nebula::storage::cpp2::VertexProp> vertex_props__arg, ::std::vector< ::nebula::storage::cpp2::EdgeProp> edge_props__arg, ::std::vector< ::nebula::storage::cpp2::Expr> expressions__arg, bool dedup__arg, ::std::vector< ::nebula::storage::cpp2::OrderBy> order_by__arg, int64_t limit__arg, ::std::string filter__arg,  ::nebula::storage::cpp2::RequestCommon common__arg) :
    space_id(std::move(space_id__arg)),
    parts(std::move(parts__arg)),
    vertex_props(std::move(vertex_props__arg)),
    edge_props(std::move(edge_props__arg)),
    expressions(std::move(expressions__arg)),
    dedup(std::move(dedup__arg)),
    order_by(std::move(order_by__arg)),
    limit(std::move(limit__arg)),
    filter(std::move(filter__arg)),
    common(std::move(common__arg)) {
  __isset.space_id = true;
  __isset.parts = true;
  __isset.vertex_props = true;
  __isset.edge_props = true;
  __isset.expressions = true;
  __isset.dedup = true;
  __isset.order_by = true;
  __isset.limit = true;
  __isset.filter = true;
  __isset.common = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetPropRequest::__clear() {
  // clear all fields
  space_id = 0;
  parts.clear();
  vertex_props.clear();
  edge_props.clear();
  expressions.clear();
  dedup = false;
  order_by.clear();
  limit = 0;
  filter = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  common.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetPropRequest::operator==(const GetPropRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  if (lhs.vertex_props_ref() != rhs.vertex_props_ref()) {
    return false;
  }
  if (lhs.edge_props_ref() != rhs.edge_props_ref()) {
    return false;
  }
  if (lhs.expressions_ref() != rhs.expressions_ref()) {
    return false;
  }
  if (!(lhs.dedup == rhs.dedup)) {
    return false;
  }
  if (lhs.order_by_ref() != rhs.order_by_ref()) {
    return false;
  }
  if (lhs.limit_ref() != rhs.limit_ref()) {
    return false;
  }
  if (lhs.filter_ref().has_value() != rhs.filter_ref().has_value()) {
    return false;
  }
  if (lhs.filter_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.filter, rhs.filter)) {
      return false;
    }
  }
  if (lhs.common_ref() != rhs.common_ref()) {
    return false;
  }
  return true;
}

const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>& GetPropRequest::get_parts() const& {
  return parts;
}

std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>> GetPropRequest::get_parts() && {
  return std::move(parts);
}

const ::std::vector< ::nebula::storage::cpp2::VertexProp>* GetPropRequest::get_vertex_props() const& {
  return vertex_props_ref().has_value() ? std::addressof(vertex_props) : nullptr;
}

::std::vector< ::nebula::storage::cpp2::VertexProp>* GetPropRequest::get_vertex_props() & {
  return vertex_props_ref().has_value() ? std::addressof(vertex_props) : nullptr;
}

const ::std::vector< ::nebula::storage::cpp2::EdgeProp>* GetPropRequest::get_edge_props() const& {
  return edge_props_ref().has_value() ? std::addressof(edge_props) : nullptr;
}

::std::vector< ::nebula::storage::cpp2::EdgeProp>* GetPropRequest::get_edge_props() & {
  return edge_props_ref().has_value() ? std::addressof(edge_props) : nullptr;
}

const ::std::vector< ::nebula::storage::cpp2::Expr>* GetPropRequest::get_expressions() const& {
  return expressions_ref().has_value() ? std::addressof(expressions) : nullptr;
}

::std::vector< ::nebula::storage::cpp2::Expr>* GetPropRequest::get_expressions() & {
  return expressions_ref().has_value() ? std::addressof(expressions) : nullptr;
}

const ::std::vector< ::nebula::storage::cpp2::OrderBy>* GetPropRequest::get_order_by() const& {
  return order_by_ref().has_value() ? std::addressof(order_by) : nullptr;
}

::std::vector< ::nebula::storage::cpp2::OrderBy>* GetPropRequest::get_order_by() & {
  return order_by_ref().has_value() ? std::addressof(order_by) : nullptr;
}

const  ::nebula::storage::cpp2::RequestCommon* GetPropRequest::get_common() const& {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}

 ::nebula::storage::cpp2::RequestCommon* GetPropRequest::get_common() & {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}


void swap(GetPropRequest& a, GetPropRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
  swap(a.vertex_props_ref().value_unchecked(), b.vertex_props_ref().value_unchecked());
  swap(a.edge_props_ref().value_unchecked(), b.edge_props_ref().value_unchecked());
  swap(a.expressions_ref().value_unchecked(), b.expressions_ref().value_unchecked());
  swap(a.dedup_ref().value(), b.dedup_ref().value());
  swap(a.order_by_ref().value_unchecked(), b.order_by_ref().value_unchecked());
  swap(a.limit_ref().value_unchecked(), b.limit_ref().value_unchecked());
  swap(a.filter_ref().value_unchecked(), b.filter_ref().value_unchecked());
  swap(a.common_ref().value_unchecked(), b.common_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetPropRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetPropRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetPropRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetPropRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetPropRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetPropRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetPropRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetPropRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetPropRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetPropRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::VertexProp>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetPropRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::EdgeProp>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetPropRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::Expr>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetPropRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::OrderBy>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetPropRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetPropRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetPropRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::VertexProp>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetPropRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::EdgeProp>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetPropRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::Expr>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetPropRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::OrderBy>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetPropRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::GetPropResponse>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::GetPropResponse>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetPropResponse::GetPropResponse(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg, nebula::DataSet props__arg) :
    result(std::move(result__arg)),
    props(std::move(props__arg)) {
  __isset.result = true;
  __isset.props = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetPropResponse::__clear() {
  // clear all fields
  result.__clear();
  props.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetPropResponse::operator==(const GetPropResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (lhs.props_ref() != rhs.props_ref()) {
    return false;
  }
  return true;
}

const  ::nebula::storage::cpp2::ResponseCommon& GetPropResponse::get_result() const& {
  return result;
}

 ::nebula::storage::cpp2::ResponseCommon GetPropResponse::get_result() && {
  return std::move(result);
}

const nebula::DataSet* GetPropResponse::get_props() const& {
  return props_ref().has_value() ? std::addressof(props) : nullptr;
}

nebula::DataSet* GetPropResponse::get_props() & {
  return props_ref().has_value() ? std::addressof(props) : nullptr;
}


void swap(GetPropResponse& a, GetPropResponse& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.props_ref().value_unchecked(), b.props_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetPropResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetPropResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetPropResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetPropResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetPropResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetPropResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetPropResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetPropResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetPropResponse,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetPropResponse,
        ::apache::thrift::type_class::structure,
        nebula::DataSet>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetPropResponse,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetPropResponse,
        ::apache::thrift::type_class::structure,
        nebula::DataSet>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::NewTag>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::NewTag>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
NewTag::NewTag(apache::thrift::FragileConstructor,  ::nebula::cpp2::TagID tag_id__arg, ::std::vector<nebula::Value> props__arg) :
    tag_id(std::move(tag_id__arg)),
    props(std::move(props__arg)) {
  __isset.tag_id = true;
  __isset.props = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void NewTag::__clear() {
  // clear all fields
  tag_id = 0;
  props.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool NewTag::operator==(const NewTag& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.tag_id == rhs.tag_id)) {
    return false;
  }
  if (!(lhs.props == rhs.props)) {
    return false;
  }
  return true;
}

const ::std::vector<nebula::Value>& NewTag::get_props() const& {
  return props;
}

::std::vector<nebula::Value> NewTag::get_props() && {
  return std::move(props);
}


void swap(NewTag& a, NewTag& b) {
  using ::std::swap;
  swap(a.tag_id_ref().value(), b.tag_id_ref().value());
  swap(a.props_ref().value(), b.props_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void NewTag::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t NewTag::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t NewTag::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t NewTag::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void NewTag::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t NewTag::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t NewTag::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t NewTag::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        NewTag,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>,
        ::std::vector<nebula::Value>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        NewTag,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>,
        ::std::vector<nebula::Value>>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::NewVertex>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::NewVertex>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
NewVertex::NewVertex(apache::thrift::FragileConstructor, nebula::Value id__arg, ::std::vector< ::nebula::storage::cpp2::NewTag> tags__arg) :
    id(std::move(id__arg)),
    tags(std::move(tags__arg)) {
  __isset.id = true;
  __isset.tags = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void NewVertex::__clear() {
  // clear all fields
  id.__clear();
  tags.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool NewVertex::operator==(const NewVertex& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.id == rhs.id)) {
    return false;
  }
  if (!(lhs.tags == rhs.tags)) {
    return false;
  }
  return true;
}

const nebula::Value& NewVertex::get_id() const& {
  return id;
}

nebula::Value NewVertex::get_id() && {
  return std::move(id);
}

const ::std::vector< ::nebula::storage::cpp2::NewTag>& NewVertex::get_tags() const& {
  return tags;
}

::std::vector< ::nebula::storage::cpp2::NewTag> NewVertex::get_tags() && {
  return std::move(tags);
}


void swap(NewVertex& a, NewVertex& b) {
  using ::std::swap;
  swap(a.id_ref().value(), b.id_ref().value());
  swap(a.tags_ref().value(), b.tags_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void NewVertex::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t NewVertex::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t NewVertex::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t NewVertex::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void NewVertex::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t NewVertex::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t NewVertex::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t NewVertex::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        NewVertex,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        NewVertex,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::NewTag>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        NewVertex,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        NewVertex,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::NewTag>>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::EdgeKey>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::EdgeKey>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
EdgeKey::EdgeKey(apache::thrift::FragileConstructor, nebula::Value src__arg,  ::nebula::cpp2::EdgeType edge_type__arg,  ::nebula::cpp2::EdgeRanking ranking__arg, nebula::Value dst__arg) :
    src(std::move(src__arg)),
    edge_type(std::move(edge_type__arg)),
    ranking(std::move(ranking__arg)),
    dst(std::move(dst__arg)) {
  __isset.src = true;
  __isset.edge_type = true;
  __isset.ranking = true;
  __isset.dst = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void EdgeKey::__clear() {
  // clear all fields
  src.__clear();
  edge_type = 0;
  ranking = 0;
  dst.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool EdgeKey::operator==(const EdgeKey& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.src == rhs.src)) {
    return false;
  }
  if (!(lhs.edge_type == rhs.edge_type)) {
    return false;
  }
  if (!(lhs.ranking == rhs.ranking)) {
    return false;
  }
  if (!(lhs.dst == rhs.dst)) {
    return false;
  }
  return true;
}

const nebula::Value& EdgeKey::get_src() const& {
  return src;
}

nebula::Value EdgeKey::get_src() && {
  return std::move(src);
}

const nebula::Value& EdgeKey::get_dst() const& {
  return dst;
}

nebula::Value EdgeKey::get_dst() && {
  return std::move(dst);
}


void swap(EdgeKey& a, EdgeKey& b) {
  using ::std::swap;
  swap(a.src_ref().value(), b.src_ref().value());
  swap(a.edge_type_ref().value(), b.edge_type_ref().value());
  swap(a.ranking_ref().value(), b.ranking_ref().value());
  swap(a.dst_ref().value(), b.dst_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void EdgeKey::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t EdgeKey::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t EdgeKey::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t EdgeKey::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void EdgeKey::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t EdgeKey::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t EdgeKey::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t EdgeKey::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        EdgeKey,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        EdgeKey,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        EdgeKey,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        EdgeKey,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::NewEdge>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::NewEdge>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
NewEdge::NewEdge(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::EdgeKey key__arg, ::std::vector<nebula::Value> props__arg) :
    key(std::move(key__arg)),
    props(std::move(props__arg)) {
  __isset.key = true;
  __isset.props = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void NewEdge::__clear() {
  // clear all fields
  key.__clear();
  props.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool NewEdge::operator==(const NewEdge& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.key == rhs.key)) {
    return false;
  }
  if (!(lhs.props == rhs.props)) {
    return false;
  }
  return true;
}

const  ::nebula::storage::cpp2::EdgeKey& NewEdge::get_key() const& {
  return key;
}

 ::nebula::storage::cpp2::EdgeKey NewEdge::get_key() && {
  return std::move(key);
}

const ::std::vector<nebula::Value>& NewEdge::get_props() const& {
  return props;
}

::std::vector<nebula::Value> NewEdge::get_props() && {
  return std::move(props);
}


void swap(NewEdge& a, NewEdge& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.props_ref().value(), b.props_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void NewEdge::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t NewEdge::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t NewEdge::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t NewEdge::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void NewEdge::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t NewEdge::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t NewEdge::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t NewEdge::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        NewEdge,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::EdgeKey>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        NewEdge,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>,
        ::std::vector<nebula::Value>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        NewEdge,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::EdgeKey>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        NewEdge,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>,
        ::std::vector<nebula::Value>>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::AddVerticesRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::AddVerticesRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AddVerticesRequest::AddVerticesRequest() :
      space_id(0),
      if_not_exists(0),
      ignore_existed_index(false) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


AddVerticesRequest::~AddVerticesRequest() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AddVerticesRequest::AddVerticesRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>> parts__arg, std::unordered_map< ::nebula::cpp2::TagID, ::std::vector<::std::string>> prop_names__arg, bool if_not_exists__arg, bool ignore_existed_index__arg,  ::nebula::storage::cpp2::RequestCommon common__arg) :
    space_id(std::move(space_id__arg)),
    parts(std::move(parts__arg)),
    prop_names(std::move(prop_names__arg)),
    if_not_exists(std::move(if_not_exists__arg)),
    ignore_existed_index(std::move(ignore_existed_index__arg)),
    common(std::move(common__arg)) {
  __isset.space_id = true;
  __isset.parts = true;
  __isset.prop_names = true;
  __isset.if_not_exists = true;
  __isset.ignore_existed_index = true;
  __isset.common = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AddVerticesRequest::__clear() {
  // clear all fields
  space_id = 0;
  parts.clear();
  prop_names.clear();
  if_not_exists = 0;
  ignore_existed_index = false;
  common.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AddVerticesRequest::operator==(const AddVerticesRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  if (!(lhs.prop_names == rhs.prop_names)) {
    return false;
  }
  if (!(lhs.if_not_exists == rhs.if_not_exists)) {
    return false;
  }
  if (!(lhs.ignore_existed_index == rhs.ignore_existed_index)) {
    return false;
  }
  if (lhs.common_ref() != rhs.common_ref()) {
    return false;
  }
  return true;
}

const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>>& AddVerticesRequest::get_parts() const& {
  return parts;
}

std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>> AddVerticesRequest::get_parts() && {
  return std::move(parts);
}

const std::unordered_map< ::nebula::cpp2::TagID, ::std::vector<::std::string>>& AddVerticesRequest::get_prop_names() const& {
  return prop_names;
}

std::unordered_map< ::nebula::cpp2::TagID, ::std::vector<::std::string>> AddVerticesRequest::get_prop_names() && {
  return std::move(prop_names);
}

const  ::nebula::storage::cpp2::RequestCommon* AddVerticesRequest::get_common() const& {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}

 ::nebula::storage::cpp2::RequestCommon* AddVerticesRequest::get_common() & {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}


void swap(AddVerticesRequest& a, AddVerticesRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
  swap(a.prop_names_ref().value(), b.prop_names_ref().value());
  swap(a.if_not_exists_ref().value(), b.if_not_exists_ref().value());
  swap(a.ignore_existed_index_ref().value(), b.ignore_existed_index_ref().value());
  swap(a.common_ref().value_unchecked(), b.common_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AddVerticesRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AddVerticesRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AddVerticesRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AddVerticesRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AddVerticesRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AddVerticesRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AddVerticesRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AddVerticesRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AddVerticesRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AddVerticesRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AddVerticesRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AddVerticesRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::AddEdgesRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::AddEdgesRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AddEdgesRequest::AddEdgesRequest() :
      space_id(0),
      if_not_exists(0),
      ignore_existed_index(false) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


AddEdgesRequest::~AddEdgesRequest() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AddEdgesRequest::AddEdgesRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>> parts__arg, ::std::vector<::std::string> prop_names__arg, bool if_not_exists__arg, bool ignore_existed_index__arg,  ::nebula::storage::cpp2::RequestCommon common__arg) :
    space_id(std::move(space_id__arg)),
    parts(std::move(parts__arg)),
    prop_names(std::move(prop_names__arg)),
    if_not_exists(std::move(if_not_exists__arg)),
    ignore_existed_index(std::move(ignore_existed_index__arg)),
    common(std::move(common__arg)) {
  __isset.space_id = true;
  __isset.parts = true;
  __isset.prop_names = true;
  __isset.if_not_exists = true;
  __isset.ignore_existed_index = true;
  __isset.common = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AddEdgesRequest::__clear() {
  // clear all fields
  space_id = 0;
  parts.clear();
  prop_names.clear();
  if_not_exists = 0;
  ignore_existed_index = false;
  common.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AddEdgesRequest::operator==(const AddEdgesRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  if (!(lhs.prop_names == rhs.prop_names)) {
    return false;
  }
  if (!(lhs.if_not_exists == rhs.if_not_exists)) {
    return false;
  }
  if (!(lhs.ignore_existed_index == rhs.ignore_existed_index)) {
    return false;
  }
  if (lhs.common_ref() != rhs.common_ref()) {
    return false;
  }
  return true;
}

const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>& AddEdgesRequest::get_parts() const& {
  return parts;
}

std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>> AddEdgesRequest::get_parts() && {
  return std::move(parts);
}

const ::std::vector<::std::string>& AddEdgesRequest::get_prop_names() const& {
  return prop_names;
}

::std::vector<::std::string> AddEdgesRequest::get_prop_names() && {
  return std::move(prop_names);
}

const  ::nebula::storage::cpp2::RequestCommon* AddEdgesRequest::get_common() const& {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}

 ::nebula::storage::cpp2::RequestCommon* AddEdgesRequest::get_common() & {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}


void swap(AddEdgesRequest& a, AddEdgesRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
  swap(a.prop_names_ref().value(), b.prop_names_ref().value());
  swap(a.if_not_exists_ref().value(), b.if_not_exists_ref().value());
  swap(a.ignore_existed_index_ref().value(), b.ignore_existed_index_ref().value());
  swap(a.common_ref().value_unchecked(), b.common_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AddEdgesRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AddEdgesRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AddEdgesRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AddEdgesRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AddEdgesRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AddEdgesRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AddEdgesRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AddEdgesRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AddEdgesRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AddEdgesRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AddEdgesRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AddEdgesRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::DeleteVerticesRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::DeleteVerticesRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DeleteVerticesRequest::DeleteVerticesRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>> parts__arg,  ::nebula::storage::cpp2::RequestCommon common__arg) :
    space_id(std::move(space_id__arg)),
    parts(std::move(parts__arg)),
    common(std::move(common__arg)) {
  __isset.space_id = true;
  __isset.parts = true;
  __isset.common = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void DeleteVerticesRequest::__clear() {
  // clear all fields
  space_id = 0;
  parts.clear();
  common.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DeleteVerticesRequest::operator==(const DeleteVerticesRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  if (lhs.common_ref() != rhs.common_ref()) {
    return false;
  }
  return true;
}

const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>& DeleteVerticesRequest::get_parts() const& {
  return parts;
}

std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>> DeleteVerticesRequest::get_parts() && {
  return std::move(parts);
}

const  ::nebula::storage::cpp2::RequestCommon* DeleteVerticesRequest::get_common() const& {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}

 ::nebula::storage::cpp2::RequestCommon* DeleteVerticesRequest::get_common() & {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}


void swap(DeleteVerticesRequest& a, DeleteVerticesRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
  swap(a.common_ref().value_unchecked(), b.common_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DeleteVerticesRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DeleteVerticesRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DeleteVerticesRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DeleteVerticesRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DeleteVerticesRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DeleteVerticesRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DeleteVerticesRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DeleteVerticesRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        DeleteVerticesRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        DeleteVerticesRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        DeleteVerticesRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::variant>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        DeleteVerticesRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::DeleteEdgesRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::DeleteEdgesRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DeleteEdgesRequest::DeleteEdgesRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>> parts__arg,  ::nebula::storage::cpp2::RequestCommon common__arg) :
    space_id(std::move(space_id__arg)),
    parts(std::move(parts__arg)),
    common(std::move(common__arg)) {
  __isset.space_id = true;
  __isset.parts = true;
  __isset.common = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void DeleteEdgesRequest::__clear() {
  // clear all fields
  space_id = 0;
  parts.clear();
  common.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DeleteEdgesRequest::operator==(const DeleteEdgesRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  if (lhs.common_ref() != rhs.common_ref()) {
    return false;
  }
  return true;
}

const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>& DeleteEdgesRequest::get_parts() const& {
  return parts;
}

std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>> DeleteEdgesRequest::get_parts() && {
  return std::move(parts);
}

const  ::nebula::storage::cpp2::RequestCommon* DeleteEdgesRequest::get_common() const& {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}

 ::nebula::storage::cpp2::RequestCommon* DeleteEdgesRequest::get_common() & {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}


void swap(DeleteEdgesRequest& a, DeleteEdgesRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
  swap(a.common_ref().value_unchecked(), b.common_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DeleteEdgesRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DeleteEdgesRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DeleteEdgesRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DeleteEdgesRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DeleteEdgesRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DeleteEdgesRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DeleteEdgesRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DeleteEdgesRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        DeleteEdgesRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        DeleteEdgesRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        DeleteEdgesRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        DeleteEdgesRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::DelTags>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::DelTags>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DelTags::DelTags(apache::thrift::FragileConstructor, nebula::Value id__arg, ::std::vector< ::nebula::cpp2::TagID> tags__arg) :
    id(std::move(id__arg)),
    tags(std::move(tags__arg)) {
  __isset.id = true;
  __isset.tags = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void DelTags::__clear() {
  // clear all fields
  id.__clear();
  tags.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DelTags::operator==(const DelTags& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.id == rhs.id)) {
    return false;
  }
  if (!(lhs.tags == rhs.tags)) {
    return false;
  }
  return true;
}

const nebula::Value& DelTags::get_id() const& {
  return id;
}

nebula::Value DelTags::get_id() && {
  return std::move(id);
}

const ::std::vector< ::nebula::cpp2::TagID>& DelTags::get_tags() const& {
  return tags;
}

::std::vector< ::nebula::cpp2::TagID> DelTags::get_tags() && {
  return std::move(tags);
}


void swap(DelTags& a, DelTags& b) {
  using ::std::swap;
  swap(a.id_ref().value(), b.id_ref().value());
  swap(a.tags_ref().value(), b.tags_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DelTags::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DelTags::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DelTags::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DelTags::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DelTags::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DelTags::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DelTags::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DelTags::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        DelTags,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        DelTags,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::DeleteTagsRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::DeleteTagsRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DeleteTagsRequest::DeleteTagsRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>> parts__arg,  ::nebula::storage::cpp2::RequestCommon common__arg) :
    space_id(std::move(space_id__arg)),
    parts(std::move(parts__arg)),
    common(std::move(common__arg)) {
  __isset.space_id = true;
  __isset.parts = true;
  __isset.common = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void DeleteTagsRequest::__clear() {
  // clear all fields
  space_id = 0;
  parts.clear();
  common.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DeleteTagsRequest::operator==(const DeleteTagsRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  if (lhs.common_ref() != rhs.common_ref()) {
    return false;
  }
  return true;
}

const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>>& DeleteTagsRequest::get_parts() const& {
  return parts;
}

std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>> DeleteTagsRequest::get_parts() && {
  return std::move(parts);
}

const  ::nebula::storage::cpp2::RequestCommon* DeleteTagsRequest::get_common() const& {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}

 ::nebula::storage::cpp2::RequestCommon* DeleteTagsRequest::get_common() & {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}


void swap(DeleteTagsRequest& a, DeleteTagsRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
  swap(a.common_ref().value_unchecked(), b.common_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DeleteTagsRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DeleteTagsRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DeleteTagsRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DeleteTagsRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DeleteTagsRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DeleteTagsRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DeleteTagsRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DeleteTagsRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        DeleteTagsRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        DeleteTagsRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        DeleteTagsRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        DeleteTagsRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::UpdateResponse>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::UpdateResponse>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
UpdateResponse::UpdateResponse(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg, nebula::DataSet props__arg) :
    result(std::move(result__arg)),
    props(std::move(props__arg)) {
  __isset.props = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void UpdateResponse::__clear() {
  // clear all fields
  result.__clear();
  props.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool UpdateResponse::operator==(const UpdateResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (lhs.props_ref() != rhs.props_ref()) {
    return false;
  }
  return true;
}

const  ::nebula::storage::cpp2::ResponseCommon& UpdateResponse::get_result() const& {
  return result;
}

 ::nebula::storage::cpp2::ResponseCommon UpdateResponse::get_result() && {
  return std::move(result);
}

const nebula::DataSet* UpdateResponse::get_props() const& {
  return props_ref().has_value() ? std::addressof(props) : nullptr;
}

nebula::DataSet* UpdateResponse::get_props() & {
  return props_ref().has_value() ? std::addressof(props) : nullptr;
}


void swap(UpdateResponse& a, UpdateResponse& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.props_ref().value_unchecked(), b.props_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void UpdateResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t UpdateResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t UpdateResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t UpdateResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void UpdateResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t UpdateResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t UpdateResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t UpdateResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        UpdateResponse,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        UpdateResponse,
        ::apache::thrift::type_class::structure,
        nebula::DataSet>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        UpdateResponse,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        UpdateResponse,
        ::apache::thrift::type_class::structure,
        nebula::DataSet>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::UpdatedProp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::UpdatedProp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
UpdatedProp::UpdatedProp(apache::thrift::FragileConstructor, ::std::string name__arg, ::std::string value__arg) :
    name(std::move(name__arg)),
    value(std::move(value__arg)) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void UpdatedProp::__clear() {
  // clear all fields
  name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  value = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
}

bool UpdatedProp::operator==(const UpdatedProp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.value, rhs.value)) {
    return false;
  }
  return true;
}

bool UpdatedProp::operator<(const UpdatedProp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.name, rhs.name);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.value, rhs.value)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.value, rhs.value);
  }
  return false;
}


void swap(UpdatedProp& a, UpdatedProp& b) {
  using ::std::swap;
  swap(a.name_ref().value(), b.name_ref().value());
  swap(a.value_ref().value(), b.value_ref().value());
}

template void UpdatedProp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t UpdatedProp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t UpdatedProp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t UpdatedProp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void UpdatedProp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t UpdatedProp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t UpdatedProp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t UpdatedProp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::UpdateVertexRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::UpdateVertexRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
UpdateVertexRequest::UpdateVertexRequest() :
      space_id(0),
      part_id(0),
      tag_id(0),
      insertable(false) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


UpdateVertexRequest::~UpdateVertexRequest() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
UpdateVertexRequest::UpdateVertexRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg, nebula::Value vertex_id__arg,  ::nebula::cpp2::TagID tag_id__arg, ::std::vector< ::nebula::storage::cpp2::UpdatedProp> updated_props__arg, bool insertable__arg, ::std::vector<::std::string> return_props__arg, ::std::string condition__arg,  ::nebula::storage::cpp2::RequestCommon common__arg) :
    space_id(std::move(space_id__arg)),
    part_id(std::move(part_id__arg)),
    vertex_id(std::move(vertex_id__arg)),
    tag_id(std::move(tag_id__arg)),
    updated_props(std::move(updated_props__arg)),
    insertable(std::move(insertable__arg)),
    return_props(std::move(return_props__arg)),
    condition(std::move(condition__arg)),
    common(std::move(common__arg)) {
  __isset.space_id = true;
  __isset.part_id = true;
  __isset.vertex_id = true;
  __isset.updated_props = true;
  __isset.insertable = true;
  __isset.return_props = true;
  __isset.condition = true;
  __isset.common = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void UpdateVertexRequest::__clear() {
  // clear all fields
  space_id = 0;
  part_id = 0;
  vertex_id.__clear();
  tag_id = 0;
  updated_props.clear();
  insertable = false;
  return_props.clear();
  condition = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  common.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool UpdateVertexRequest::operator==(const UpdateVertexRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return false;
  }
  if (!(lhs.vertex_id == rhs.vertex_id)) {
    return false;
  }
  if (!(lhs.tag_id == rhs.tag_id)) {
    return false;
  }
  if (!(lhs.updated_props == rhs.updated_props)) {
    return false;
  }
  if (lhs.insertable_ref() != rhs.insertable_ref()) {
    return false;
  }
  if (lhs.return_props_ref() != rhs.return_props_ref()) {
    return false;
  }
  if (lhs.condition_ref().has_value() != rhs.condition_ref().has_value()) {
    return false;
  }
  if (lhs.condition_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.condition, rhs.condition)) {
      return false;
    }
  }
  if (lhs.common_ref() != rhs.common_ref()) {
    return false;
  }
  return true;
}

const nebula::Value& UpdateVertexRequest::get_vertex_id() const& {
  return vertex_id;
}

nebula::Value UpdateVertexRequest::get_vertex_id() && {
  return std::move(vertex_id);
}

const ::std::vector< ::nebula::storage::cpp2::UpdatedProp>& UpdateVertexRequest::get_updated_props() const& {
  return updated_props;
}

::std::vector< ::nebula::storage::cpp2::UpdatedProp> UpdateVertexRequest::get_updated_props() && {
  return std::move(updated_props);
}

const ::std::vector<::std::string>* UpdateVertexRequest::get_return_props() const& {
  return return_props_ref().has_value() ? std::addressof(return_props) : nullptr;
}

::std::vector<::std::string>* UpdateVertexRequest::get_return_props() & {
  return return_props_ref().has_value() ? std::addressof(return_props) : nullptr;
}

const  ::nebula::storage::cpp2::RequestCommon* UpdateVertexRequest::get_common() const& {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}

 ::nebula::storage::cpp2::RequestCommon* UpdateVertexRequest::get_common() & {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}


void swap(UpdateVertexRequest& a, UpdateVertexRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.part_id_ref().value(), b.part_id_ref().value());
  swap(a.vertex_id_ref().value(), b.vertex_id_ref().value());
  swap(a.tag_id_ref().value(), b.tag_id_ref().value());
  swap(a.updated_props_ref().value(), b.updated_props_ref().value());
  swap(a.insertable_ref().value_unchecked(), b.insertable_ref().value_unchecked());
  swap(a.return_props_ref().value_unchecked(), b.return_props_ref().value_unchecked());
  swap(a.condition_ref().value_unchecked(), b.condition_ref().value_unchecked());
  swap(a.common_ref().value_unchecked(), b.common_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void UpdateVertexRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t UpdateVertexRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t UpdateVertexRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t UpdateVertexRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void UpdateVertexRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t UpdateVertexRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t UpdateVertexRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t UpdateVertexRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        UpdateVertexRequest,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        UpdateVertexRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        UpdateVertexRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        UpdateVertexRequest,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        UpdateVertexRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        UpdateVertexRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::UpdateEdgeRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::UpdateEdgeRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
UpdateEdgeRequest::UpdateEdgeRequest() :
      space_id(0),
      part_id(0),
      insertable(false) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


UpdateEdgeRequest::~UpdateEdgeRequest() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
UpdateEdgeRequest::UpdateEdgeRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg,  ::nebula::storage::cpp2::EdgeKey edge_key__arg, ::std::vector< ::nebula::storage::cpp2::UpdatedProp> updated_props__arg, bool insertable__arg, ::std::vector<::std::string> return_props__arg, ::std::string condition__arg,  ::nebula::storage::cpp2::RequestCommon common__arg) :
    space_id(std::move(space_id__arg)),
    part_id(std::move(part_id__arg)),
    edge_key(std::move(edge_key__arg)),
    updated_props(std::move(updated_props__arg)),
    insertable(std::move(insertable__arg)),
    return_props(std::move(return_props__arg)),
    condition(std::move(condition__arg)),
    common(std::move(common__arg)) {
  __isset.space_id = true;
  __isset.part_id = true;
  __isset.edge_key = true;
  __isset.updated_props = true;
  __isset.insertable = true;
  __isset.return_props = true;
  __isset.condition = true;
  __isset.common = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void UpdateEdgeRequest::__clear() {
  // clear all fields
  space_id = 0;
  part_id = 0;
  edge_key.__clear();
  updated_props.clear();
  insertable = false;
  return_props.clear();
  condition = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  common.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool UpdateEdgeRequest::operator==(const UpdateEdgeRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return false;
  }
  if (!(lhs.edge_key == rhs.edge_key)) {
    return false;
  }
  if (!(lhs.updated_props == rhs.updated_props)) {
    return false;
  }
  if (lhs.insertable_ref() != rhs.insertable_ref()) {
    return false;
  }
  if (lhs.return_props_ref() != rhs.return_props_ref()) {
    return false;
  }
  if (lhs.condition_ref().has_value() != rhs.condition_ref().has_value()) {
    return false;
  }
  if (lhs.condition_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.condition, rhs.condition)) {
      return false;
    }
  }
  if (lhs.common_ref() != rhs.common_ref()) {
    return false;
  }
  return true;
}

const  ::nebula::storage::cpp2::EdgeKey& UpdateEdgeRequest::get_edge_key() const& {
  return edge_key;
}

 ::nebula::storage::cpp2::EdgeKey UpdateEdgeRequest::get_edge_key() && {
  return std::move(edge_key);
}

const ::std::vector< ::nebula::storage::cpp2::UpdatedProp>& UpdateEdgeRequest::get_updated_props() const& {
  return updated_props;
}

::std::vector< ::nebula::storage::cpp2::UpdatedProp> UpdateEdgeRequest::get_updated_props() && {
  return std::move(updated_props);
}

const ::std::vector<::std::string>* UpdateEdgeRequest::get_return_props() const& {
  return return_props_ref().has_value() ? std::addressof(return_props) : nullptr;
}

::std::vector<::std::string>* UpdateEdgeRequest::get_return_props() & {
  return return_props_ref().has_value() ? std::addressof(return_props) : nullptr;
}

const  ::nebula::storage::cpp2::RequestCommon* UpdateEdgeRequest::get_common() const& {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}

 ::nebula::storage::cpp2::RequestCommon* UpdateEdgeRequest::get_common() & {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}


void swap(UpdateEdgeRequest& a, UpdateEdgeRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.part_id_ref().value(), b.part_id_ref().value());
  swap(a.edge_key_ref().value(), b.edge_key_ref().value());
  swap(a.updated_props_ref().value(), b.updated_props_ref().value());
  swap(a.insertable_ref().value_unchecked(), b.insertable_ref().value_unchecked());
  swap(a.return_props_ref().value_unchecked(), b.return_props_ref().value_unchecked());
  swap(a.condition_ref().value_unchecked(), b.condition_ref().value_unchecked());
  swap(a.common_ref().value_unchecked(), b.common_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void UpdateEdgeRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t UpdateEdgeRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t UpdateEdgeRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t UpdateEdgeRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void UpdateEdgeRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t UpdateEdgeRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t UpdateEdgeRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t UpdateEdgeRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        UpdateEdgeRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::EdgeKey>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        UpdateEdgeRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        UpdateEdgeRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        UpdateEdgeRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::EdgeKey>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        UpdateEdgeRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        UpdateEdgeRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::GetUUIDReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::GetUUIDReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetUUIDReq::GetUUIDReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg, ::std::string name__arg,  ::nebula::storage::cpp2::RequestCommon common__arg) :
    space_id(std::move(space_id__arg)),
    part_id(std::move(part_id__arg)),
    name(std::move(name__arg)),
    common(std::move(common__arg)) {
  __isset.space_id = true;
  __isset.part_id = true;
  __isset.name = true;
  __isset.common = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetUUIDReq::__clear() {
  // clear all fields
  space_id = 0;
  part_id = 0;
  name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  common.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetUUIDReq::operator==(const GetUUIDReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return false;
  }
  if (lhs.common_ref() != rhs.common_ref()) {
    return false;
  }
  return true;
}

bool GetUUIDReq::operator<(const GetUUIDReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return lhs.part_id < rhs.part_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.name, rhs.name);
  }
  if (lhs.common_ref() != rhs.common_ref()) {
    return lhs.common_ref() < rhs.common_ref();
  }
  return false;
}

const  ::nebula::storage::cpp2::RequestCommon* GetUUIDReq::get_common() const& {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}

 ::nebula::storage::cpp2::RequestCommon* GetUUIDReq::get_common() & {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}


void swap(GetUUIDReq& a, GetUUIDReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.part_id_ref().value(), b.part_id_ref().value());
  swap(a.name_ref().value(), b.name_ref().value());
  swap(a.common_ref().value_unchecked(), b.common_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetUUIDReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetUUIDReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetUUIDReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetUUIDReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetUUIDReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetUUIDReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetUUIDReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetUUIDReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetUUIDReq,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetUUIDReq,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::GetUUIDResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::GetUUIDResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetUUIDResp::GetUUIDResp(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg, nebula::Value id__arg) :
    result(std::move(result__arg)),
    id(std::move(id__arg)) {
  __isset.id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetUUIDResp::__clear() {
  // clear all fields
  result.__clear();
  id.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetUUIDResp::operator==(const GetUUIDResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.id == rhs.id)) {
    return false;
  }
  return true;
}

const  ::nebula::storage::cpp2::ResponseCommon& GetUUIDResp::get_result() const& {
  return result;
}

 ::nebula::storage::cpp2::ResponseCommon GetUUIDResp::get_result() && {
  return std::move(result);
}

const nebula::Value& GetUUIDResp::get_id() const& {
  return id;
}

nebula::Value GetUUIDResp::get_id() && {
  return std::move(id);
}


void swap(GetUUIDResp& a, GetUUIDResp& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.id_ref().value(), b.id_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetUUIDResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetUUIDResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetUUIDResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetUUIDResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetUUIDResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetUUIDResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetUUIDResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetUUIDResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetUUIDResp,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetUUIDResp,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetUUIDResp,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetUUIDResp,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::LookupIndexResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::LookupIndexResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
LookupIndexResp::LookupIndexResp(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg, nebula::DataSet data__arg, nebula::DataSet stat_data__arg) :
    result(std::move(result__arg)),
    data(std::move(data__arg)),
    stat_data(std::move(stat_data__arg)) {
  __isset.data = true;
  __isset.stat_data = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void LookupIndexResp::__clear() {
  // clear all fields
  result.__clear();
  data.__clear();
  stat_data.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool LookupIndexResp::operator==(const LookupIndexResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (lhs.data_ref() != rhs.data_ref()) {
    return false;
  }
  if (lhs.stat_data_ref() != rhs.stat_data_ref()) {
    return false;
  }
  return true;
}

const  ::nebula::storage::cpp2::ResponseCommon& LookupIndexResp::get_result() const& {
  return result;
}

 ::nebula::storage::cpp2::ResponseCommon LookupIndexResp::get_result() && {
  return std::move(result);
}

const nebula::DataSet* LookupIndexResp::get_data() const& {
  return data_ref().has_value() ? std::addressof(data) : nullptr;
}

nebula::DataSet* LookupIndexResp::get_data() & {
  return data_ref().has_value() ? std::addressof(data) : nullptr;
}

const nebula::DataSet* LookupIndexResp::get_stat_data() const& {
  return stat_data_ref().has_value() ? std::addressof(stat_data) : nullptr;
}

nebula::DataSet* LookupIndexResp::get_stat_data() & {
  return stat_data_ref().has_value() ? std::addressof(stat_data) : nullptr;
}


void swap(LookupIndexResp& a, LookupIndexResp& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.data_ref().value_unchecked(), b.data_ref().value_unchecked());
  swap(a.stat_data_ref().value_unchecked(), b.stat_data_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void LookupIndexResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t LookupIndexResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t LookupIndexResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t LookupIndexResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void LookupIndexResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t LookupIndexResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t LookupIndexResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t LookupIndexResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        LookupIndexResp,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        LookupIndexResp,
        ::apache::thrift::type_class::structure,
        nebula::DataSet>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        LookupIndexResp,
        ::apache::thrift::type_class::structure,
        nebula::DataSet>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        LookupIndexResp,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        LookupIndexResp,
        ::apache::thrift::type_class::structure,
        nebula::DataSet>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        LookupIndexResp,
        ::apache::thrift::type_class::structure,
        nebula::DataSet>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::IndexColumnHint>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::IndexColumnHint>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
IndexColumnHint::IndexColumnHint() :
      scan_type(static_cast< ::nebula::storage::cpp2::ScanType>(0)),
      include_begin(true),
      include_end(false) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


IndexColumnHint::~IndexColumnHint() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
IndexColumnHint::IndexColumnHint(apache::thrift::FragileConstructor, ::std::string column_name__arg,  ::nebula::storage::cpp2::ScanType scan_type__arg, nebula::Value begin_value__arg, nebula::Value end_value__arg, bool include_begin__arg, bool include_end__arg) :
    column_name(std::move(column_name__arg)),
    scan_type(std::move(scan_type__arg)),
    begin_value(std::move(begin_value__arg)),
    end_value(std::move(end_value__arg)),
    include_begin(std::move(include_begin__arg)),
    include_end(std::move(include_end__arg)) {
  __isset.column_name = true;
  __isset.scan_type = true;
  __isset.begin_value = true;
  __isset.end_value = true;
  __isset.include_begin = true;
  __isset.include_end = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void IndexColumnHint::__clear() {
  // clear all fields
  column_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  scan_type = static_cast< ::nebula::storage::cpp2::ScanType>(0);
  begin_value.__clear();
  end_value.__clear();
  include_begin = true;
  include_end = false;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool IndexColumnHint::operator==(const IndexColumnHint& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.column_name, rhs.column_name)) {
    return false;
  }
  if (!(lhs.scan_type == rhs.scan_type)) {
    return false;
  }
  if (!(lhs.begin_value == rhs.begin_value)) {
    return false;
  }
  if (!(lhs.end_value == rhs.end_value)) {
    return false;
  }
  if (!(lhs.include_begin == rhs.include_begin)) {
    return false;
  }
  if (!(lhs.include_end == rhs.include_end)) {
    return false;
  }
  return true;
}

const nebula::Value& IndexColumnHint::get_begin_value() const& {
  return begin_value;
}

nebula::Value IndexColumnHint::get_begin_value() && {
  return std::move(begin_value);
}

const nebula::Value& IndexColumnHint::get_end_value() const& {
  return end_value;
}

nebula::Value IndexColumnHint::get_end_value() && {
  return std::move(end_value);
}


void swap(IndexColumnHint& a, IndexColumnHint& b) {
  using ::std::swap;
  swap(a.column_name_ref().value(), b.column_name_ref().value());
  swap(a.scan_type_ref().value(), b.scan_type_ref().value());
  swap(a.begin_value_ref().value(), b.begin_value_ref().value());
  swap(a.end_value_ref().value(), b.end_value_ref().value());
  swap(a.include_begin_ref().value(), b.include_begin_ref().value());
  swap(a.include_end_ref().value(), b.include_end_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void IndexColumnHint::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t IndexColumnHint::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t IndexColumnHint::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t IndexColumnHint::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void IndexColumnHint::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t IndexColumnHint::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t IndexColumnHint::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t IndexColumnHint::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        IndexColumnHint,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        IndexColumnHint,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        IndexColumnHint,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        IndexColumnHint,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::IndexQueryContext>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::IndexQueryContext>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
IndexQueryContext::IndexQueryContext(apache::thrift::FragileConstructor,  ::nebula::cpp2::IndexID index_id__arg, ::std::string filter__arg, ::std::vector< ::nebula::storage::cpp2::IndexColumnHint> column_hints__arg) :
    index_id(std::move(index_id__arg)),
    filter(std::move(filter__arg)),
    column_hints(std::move(column_hints__arg)) {
  __isset.index_id = true;
  __isset.filter = true;
  __isset.column_hints = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void IndexQueryContext::__clear() {
  // clear all fields
  index_id = 0;
  filter = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  column_hints.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool IndexQueryContext::operator==(const IndexQueryContext& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.index_id == rhs.index_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.filter, rhs.filter)) {
    return false;
  }
  if (!(lhs.column_hints == rhs.column_hints)) {
    return false;
  }
  return true;
}

const ::std::vector< ::nebula::storage::cpp2::IndexColumnHint>& IndexQueryContext::get_column_hints() const& {
  return column_hints;
}

::std::vector< ::nebula::storage::cpp2::IndexColumnHint> IndexQueryContext::get_column_hints() && {
  return std::move(column_hints);
}


void swap(IndexQueryContext& a, IndexQueryContext& b) {
  using ::std::swap;
  swap(a.index_id_ref().value(), b.index_id_ref().value());
  swap(a.filter_ref().value(), b.filter_ref().value());
  swap(a.column_hints_ref().value(), b.column_hints_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void IndexQueryContext::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t IndexQueryContext::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t IndexQueryContext::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t IndexQueryContext::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void IndexQueryContext::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t IndexQueryContext::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t IndexQueryContext::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t IndexQueryContext::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        IndexQueryContext,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::IndexColumnHint>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        IndexQueryContext,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::IndexColumnHint>>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::IndexSpec>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::IndexSpec>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
IndexSpec::IndexSpec(apache::thrift::FragileConstructor, ::std::vector< ::nebula::storage::cpp2::IndexQueryContext> contexts__arg,  ::nebula::cpp2::SchemaID schema_id__arg) :
    contexts(std::move(contexts__arg)),
    schema_id(std::move(schema_id__arg)) {
  __isset.schema_id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void IndexSpec::__clear() {
  // clear all fields
  contexts.clear();
  schema_id.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool IndexSpec::operator==(const IndexSpec& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.contexts == rhs.contexts)) {
    return false;
  }
  if (!(lhs.schema_id == rhs.schema_id)) {
    return false;
  }
  return true;
}

const ::std::vector< ::nebula::storage::cpp2::IndexQueryContext>& IndexSpec::get_contexts() const& {
  return contexts;
}

::std::vector< ::nebula::storage::cpp2::IndexQueryContext> IndexSpec::get_contexts() && {
  return std::move(contexts);
}

const  ::nebula::cpp2::SchemaID& IndexSpec::get_schema_id() const& {
  return schema_id;
}

 ::nebula::cpp2::SchemaID IndexSpec::get_schema_id() && {
  return std::move(schema_id);
}


void swap(IndexSpec& a, IndexSpec& b) {
  using ::std::swap;
  swap(a.contexts_ref().value(), b.contexts_ref().value());
  swap(a.schema_id_ref().value(), b.schema_id_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void IndexSpec::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t IndexSpec::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t IndexSpec::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t IndexSpec::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void IndexSpec::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t IndexSpec::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t IndexSpec::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t IndexSpec::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        IndexSpec,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::IndexQueryContext>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        IndexSpec,
        ::apache::thrift::type_class::variant,
         ::nebula::cpp2::SchemaID>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        IndexSpec,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::IndexQueryContext>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        IndexSpec,
        ::apache::thrift::type_class::variant,
         ::nebula::cpp2::SchemaID>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::LookupIndexRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::LookupIndexRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
LookupIndexRequest::LookupIndexRequest() :
      space_id(0),
      limit(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


LookupIndexRequest::~LookupIndexRequest() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
LookupIndexRequest::LookupIndexRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::vector< ::nebula::cpp2::PartitionID> parts__arg,  ::nebula::storage::cpp2::IndexSpec indices__arg, ::std::vector<::std::string> return_columns__arg,  ::nebula::storage::cpp2::RequestCommon common__arg, int64_t limit__arg, ::std::vector< ::nebula::storage::cpp2::OrderBy> order_by__arg, ::std::vector< ::nebula::storage::cpp2::StatProp> stat_columns__arg) :
    space_id(std::move(space_id__arg)),
    parts(std::move(parts__arg)),
    indices(std::move(indices__arg)),
    return_columns(std::move(return_columns__arg)),
    common(std::move(common__arg)),
    limit(std::move(limit__arg)),
    order_by(std::move(order_by__arg)),
    stat_columns(std::move(stat_columns__arg)) {
  __isset.indices = true;
  __isset.return_columns = true;
  __isset.common = true;
  __isset.limit = true;
  __isset.order_by = true;
  __isset.stat_columns = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void LookupIndexRequest::__clear() {
  // clear all fields
  space_id = 0;
  parts.clear();
  indices.__clear();
  return_columns.clear();
  common.__clear();
  limit = 0;
  order_by.clear();
  stat_columns.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool LookupIndexRequest::operator==(const LookupIndexRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  if (!(lhs.indices == rhs.indices)) {
    return false;
  }
  if (lhs.return_columns_ref() != rhs.return_columns_ref()) {
    return false;
  }
  if (lhs.common_ref() != rhs.common_ref()) {
    return false;
  }
  if (lhs.limit_ref() != rhs.limit_ref()) {
    return false;
  }
  if (lhs.order_by_ref() != rhs.order_by_ref()) {
    return false;
  }
  if (lhs.stat_columns_ref() != rhs.stat_columns_ref()) {
    return false;
  }
  return true;
}

const ::std::vector< ::nebula::cpp2::PartitionID>& LookupIndexRequest::get_parts() const& {
  return parts;
}

::std::vector< ::nebula::cpp2::PartitionID> LookupIndexRequest::get_parts() && {
  return std::move(parts);
}

const  ::nebula::storage::cpp2::IndexSpec& LookupIndexRequest::get_indices() const& {
  return indices;
}

 ::nebula::storage::cpp2::IndexSpec LookupIndexRequest::get_indices() && {
  return std::move(indices);
}

const ::std::vector<::std::string>* LookupIndexRequest::get_return_columns() const& {
  return return_columns_ref().has_value() ? std::addressof(return_columns) : nullptr;
}

::std::vector<::std::string>* LookupIndexRequest::get_return_columns() & {
  return return_columns_ref().has_value() ? std::addressof(return_columns) : nullptr;
}

const  ::nebula::storage::cpp2::RequestCommon* LookupIndexRequest::get_common() const& {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}

 ::nebula::storage::cpp2::RequestCommon* LookupIndexRequest::get_common() & {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}

const ::std::vector< ::nebula::storage::cpp2::OrderBy>* LookupIndexRequest::get_order_by() const& {
  return order_by_ref().has_value() ? std::addressof(order_by) : nullptr;
}

::std::vector< ::nebula::storage::cpp2::OrderBy>* LookupIndexRequest::get_order_by() & {
  return order_by_ref().has_value() ? std::addressof(order_by) : nullptr;
}

const ::std::vector< ::nebula::storage::cpp2::StatProp>* LookupIndexRequest::get_stat_columns() const& {
  return stat_columns_ref().has_value() ? std::addressof(stat_columns) : nullptr;
}

::std::vector< ::nebula::storage::cpp2::StatProp>* LookupIndexRequest::get_stat_columns() & {
  return stat_columns_ref().has_value() ? std::addressof(stat_columns) : nullptr;
}


void swap(LookupIndexRequest& a, LookupIndexRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
  swap(a.indices_ref().value(), b.indices_ref().value());
  swap(a.return_columns_ref().value_unchecked(), b.return_columns_ref().value_unchecked());
  swap(a.common_ref().value_unchecked(), b.common_ref().value_unchecked());
  swap(a.limit_ref().value_unchecked(), b.limit_ref().value_unchecked());
  swap(a.order_by_ref().value_unchecked(), b.order_by_ref().value_unchecked());
  swap(a.stat_columns_ref().value_unchecked(), b.stat_columns_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void LookupIndexRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t LookupIndexRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t LookupIndexRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t LookupIndexRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void LookupIndexRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t LookupIndexRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t LookupIndexRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t LookupIndexRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        LookupIndexRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::IndexSpec>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        LookupIndexRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        LookupIndexRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::OrderBy>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        LookupIndexRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::StatProp>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        LookupIndexRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::IndexSpec>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        LookupIndexRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        LookupIndexRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::OrderBy>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        LookupIndexRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::StatProp>>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::LookupAndTraverseRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::LookupAndTraverseRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
LookupAndTraverseRequest::LookupAndTraverseRequest() :
      space_id(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


LookupAndTraverseRequest::~LookupAndTraverseRequest() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
LookupAndTraverseRequest::LookupAndTraverseRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::vector< ::nebula::cpp2::PartitionID> parts__arg,  ::nebula::storage::cpp2::IndexSpec indices__arg,  ::nebula::storage::cpp2::TraverseSpec traverse_spec__arg,  ::nebula::storage::cpp2::RequestCommon common__arg) :
    space_id(std::move(space_id__arg)),
    parts(std::move(parts__arg)),
    indices(std::move(indices__arg)),
    traverse_spec(std::move(traverse_spec__arg)),
    common(std::move(common__arg)) {
  __isset.indices = true;
  __isset.traverse_spec = true;
  __isset.common = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void LookupAndTraverseRequest::__clear() {
  // clear all fields
  space_id = 0;
  parts.clear();
  indices.__clear();
  traverse_spec.__clear();
  common.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool LookupAndTraverseRequest::operator==(const LookupAndTraverseRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  if (!(lhs.indices == rhs.indices)) {
    return false;
  }
  if (!(lhs.traverse_spec == rhs.traverse_spec)) {
    return false;
  }
  if (lhs.common_ref() != rhs.common_ref()) {
    return false;
  }
  return true;
}

const ::std::vector< ::nebula::cpp2::PartitionID>& LookupAndTraverseRequest::get_parts() const& {
  return parts;
}

::std::vector< ::nebula::cpp2::PartitionID> LookupAndTraverseRequest::get_parts() && {
  return std::move(parts);
}

const  ::nebula::storage::cpp2::IndexSpec& LookupAndTraverseRequest::get_indices() const& {
  return indices;
}

 ::nebula::storage::cpp2::IndexSpec LookupAndTraverseRequest::get_indices() && {
  return std::move(indices);
}

const  ::nebula::storage::cpp2::TraverseSpec& LookupAndTraverseRequest::get_traverse_spec() const& {
  return traverse_spec;
}

 ::nebula::storage::cpp2::TraverseSpec LookupAndTraverseRequest::get_traverse_spec() && {
  return std::move(traverse_spec);
}

const  ::nebula::storage::cpp2::RequestCommon* LookupAndTraverseRequest::get_common() const& {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}

 ::nebula::storage::cpp2::RequestCommon* LookupAndTraverseRequest::get_common() & {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}


void swap(LookupAndTraverseRequest& a, LookupAndTraverseRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
  swap(a.indices_ref().value(), b.indices_ref().value());
  swap(a.traverse_spec_ref().value(), b.traverse_spec_ref().value());
  swap(a.common_ref().value_unchecked(), b.common_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void LookupAndTraverseRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t LookupAndTraverseRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t LookupAndTraverseRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t LookupAndTraverseRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void LookupAndTraverseRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t LookupAndTraverseRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t LookupAndTraverseRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t LookupAndTraverseRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        LookupAndTraverseRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::IndexSpec>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        LookupAndTraverseRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::TraverseSpec>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        LookupAndTraverseRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        LookupAndTraverseRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::IndexSpec>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        LookupAndTraverseRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::TraverseSpec>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        LookupAndTraverseRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::ScanCursor>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::ScanCursor>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ScanCursor::ScanCursor(apache::thrift::FragileConstructor, ::std::string next_cursor__arg) :
    next_cursor(std::move(next_cursor__arg)) {
  __isset.next_cursor = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ScanCursor::__clear() {
  // clear all fields
  next_cursor = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ScanCursor::operator==(const ScanCursor& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.next_cursor_ref().has_value() != rhs.next_cursor_ref().has_value()) {
    return false;
  }
  if (lhs.next_cursor_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.next_cursor, rhs.next_cursor)) {
      return false;
    }
  }
  return true;
}

bool ScanCursor::operator<(const ScanCursor& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.next_cursor_ref().has_value() != rhs.next_cursor_ref().has_value()) {
    return lhs.next_cursor_ref().has_value() < rhs.next_cursor_ref().has_value();
  }
  if (lhs.next_cursor_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.next_cursor, rhs.next_cursor)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.next_cursor, rhs.next_cursor);
    }
  }
  return false;
}


void swap(ScanCursor& a, ScanCursor& b) {
  using ::std::swap;
  swap(a.next_cursor_ref().value_unchecked(), b.next_cursor_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ScanCursor::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ScanCursor::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ScanCursor::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ScanCursor::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ScanCursor::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ScanCursor::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ScanCursor::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ScanCursor::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::ScanVertexRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::ScanVertexRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ScanVertexRequest::ScanVertexRequest() :
      space_id(0),
      limit(0),
      start_time(0),
      end_time(0),
      only_latest_version(false),
      enable_read_from_follower(true),
      need_authenticate(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


ScanVertexRequest::~ScanVertexRequest() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ScanVertexRequest::ScanVertexRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor> parts__arg, ::std::vector< ::nebula::storage::cpp2::VertexProp> return_columns__arg, int64_t limit__arg, int64_t start_time__arg, int64_t end_time__arg, ::std::string filter__arg, bool only_latest_version__arg, bool enable_read_from_follower__arg,  ::nebula::storage::cpp2::RequestCommon common__arg, ::std::string username__arg, ::std::string password__arg, bool need_authenticate__arg) :
    space_id(std::move(space_id__arg)),
    parts(std::move(parts__arg)),
    return_columns(std::move(return_columns__arg)),
    limit(std::move(limit__arg)),
    start_time(std::move(start_time__arg)),
    end_time(std::move(end_time__arg)),
    filter(std::move(filter__arg)),
    only_latest_version(std::move(only_latest_version__arg)),
    enable_read_from_follower(std::move(enable_read_from_follower__arg)),
    common(std::move(common__arg)),
    username(std::move(username__arg)),
    password(std::move(password__arg)),
    need_authenticate(std::move(need_authenticate__arg)) {
  __isset.space_id = true;
  __isset.parts = true;
  __isset.return_columns = true;
  __isset.limit = true;
  __isset.start_time = true;
  __isset.end_time = true;
  __isset.filter = true;
  __isset.only_latest_version = true;
  __isset.enable_read_from_follower = true;
  __isset.common = true;
  __isset.username = true;
  __isset.password = true;
  __isset.need_authenticate = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ScanVertexRequest::__clear() {
  // clear all fields
  space_id = 0;
  parts.clear();
  return_columns.clear();
  limit = 0;
  start_time = 0;
  end_time = 0;
  filter = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  only_latest_version = false;
  enable_read_from_follower = true;
  common.__clear();
  username = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  password = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  need_authenticate = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ScanVertexRequest::operator==(const ScanVertexRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  if (!(lhs.return_columns == rhs.return_columns)) {
    return false;
  }
  if (!(lhs.limit == rhs.limit)) {
    return false;
  }
  if (lhs.start_time_ref() != rhs.start_time_ref()) {
    return false;
  }
  if (lhs.end_time_ref() != rhs.end_time_ref()) {
    return false;
  }
  if (lhs.filter_ref().has_value() != rhs.filter_ref().has_value()) {
    return false;
  }
  if (lhs.filter_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.filter, rhs.filter)) {
      return false;
    }
  }
  if (!(lhs.only_latest_version == rhs.only_latest_version)) {
    return false;
  }
  if (!(lhs.enable_read_from_follower == rhs.enable_read_from_follower)) {
    return false;
  }
  if (lhs.common_ref() != rhs.common_ref()) {
    return false;
  }
  if (lhs.username_ref().has_value() != rhs.username_ref().has_value()) {
    return false;
  }
  if (lhs.username_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.username, rhs.username)) {
      return false;
    }
  }
  if (lhs.password_ref().has_value() != rhs.password_ref().has_value()) {
    return false;
  }
  if (lhs.password_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.password, rhs.password)) {
      return false;
    }
  }
  if (lhs.need_authenticate_ref() != rhs.need_authenticate_ref()) {
    return false;
  }
  return true;
}

const std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>& ScanVertexRequest::get_parts() const& {
  return parts;
}

std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor> ScanVertexRequest::get_parts() && {
  return std::move(parts);
}

const ::std::vector< ::nebula::storage::cpp2::VertexProp>& ScanVertexRequest::get_return_columns() const& {
  return return_columns;
}

::std::vector< ::nebula::storage::cpp2::VertexProp> ScanVertexRequest::get_return_columns() && {
  return std::move(return_columns);
}

const  ::nebula::storage::cpp2::RequestCommon* ScanVertexRequest::get_common() const& {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}

 ::nebula::storage::cpp2::RequestCommon* ScanVertexRequest::get_common() & {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}


void swap(ScanVertexRequest& a, ScanVertexRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
  swap(a.return_columns_ref().value(), b.return_columns_ref().value());
  swap(a.limit_ref().value(), b.limit_ref().value());
  swap(a.start_time_ref().value_unchecked(), b.start_time_ref().value_unchecked());
  swap(a.end_time_ref().value_unchecked(), b.end_time_ref().value_unchecked());
  swap(a.filter_ref().value_unchecked(), b.filter_ref().value_unchecked());
  swap(a.only_latest_version_ref().value(), b.only_latest_version_ref().value());
  swap(a.enable_read_from_follower_ref().value(), b.enable_read_from_follower_ref().value());
  swap(a.common_ref().value_unchecked(), b.common_ref().value_unchecked());
  swap(a.username_ref().value_unchecked(), b.username_ref().value_unchecked());
  swap(a.password_ref().value_unchecked(), b.password_ref().value_unchecked());
  swap(a.need_authenticate_ref().value_unchecked(), b.need_authenticate_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ScanVertexRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ScanVertexRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ScanVertexRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ScanVertexRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ScanVertexRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ScanVertexRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ScanVertexRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ScanVertexRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ScanVertexRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ScanVertexRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::VertexProp>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ScanVertexRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ScanVertexRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ScanVertexRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::VertexProp>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ScanVertexRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::ScanEdgeRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::ScanEdgeRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ScanEdgeRequest::ScanEdgeRequest() :
      space_id(0),
      limit(0),
      start_time(0),
      end_time(0),
      only_latest_version(false),
      enable_read_from_follower(true),
      need_authenticate(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


ScanEdgeRequest::~ScanEdgeRequest() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ScanEdgeRequest::ScanEdgeRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor> parts__arg, ::std::vector< ::nebula::storage::cpp2::EdgeProp> return_columns__arg, int64_t limit__arg, int64_t start_time__arg, int64_t end_time__arg, ::std::string filter__arg, bool only_latest_version__arg, bool enable_read_from_follower__arg,  ::nebula::storage::cpp2::RequestCommon common__arg, ::std::string username__arg, ::std::string password__arg, bool need_authenticate__arg) :
    space_id(std::move(space_id__arg)),
    parts(std::move(parts__arg)),
    return_columns(std::move(return_columns__arg)),
    limit(std::move(limit__arg)),
    start_time(std::move(start_time__arg)),
    end_time(std::move(end_time__arg)),
    filter(std::move(filter__arg)),
    only_latest_version(std::move(only_latest_version__arg)),
    enable_read_from_follower(std::move(enable_read_from_follower__arg)),
    common(std::move(common__arg)),
    username(std::move(username__arg)),
    password(std::move(password__arg)),
    need_authenticate(std::move(need_authenticate__arg)) {
  __isset.space_id = true;
  __isset.parts = true;
  __isset.return_columns = true;
  __isset.limit = true;
  __isset.start_time = true;
  __isset.end_time = true;
  __isset.filter = true;
  __isset.only_latest_version = true;
  __isset.enable_read_from_follower = true;
  __isset.common = true;
  __isset.username = true;
  __isset.password = true;
  __isset.need_authenticate = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ScanEdgeRequest::__clear() {
  // clear all fields
  space_id = 0;
  parts.clear();
  return_columns.clear();
  limit = 0;
  start_time = 0;
  end_time = 0;
  filter = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  only_latest_version = false;
  enable_read_from_follower = true;
  common.__clear();
  username = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  password = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  need_authenticate = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ScanEdgeRequest::operator==(const ScanEdgeRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  if (!(lhs.return_columns == rhs.return_columns)) {
    return false;
  }
  if (!(lhs.limit == rhs.limit)) {
    return false;
  }
  if (lhs.start_time_ref() != rhs.start_time_ref()) {
    return false;
  }
  if (lhs.end_time_ref() != rhs.end_time_ref()) {
    return false;
  }
  if (lhs.filter_ref().has_value() != rhs.filter_ref().has_value()) {
    return false;
  }
  if (lhs.filter_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.filter, rhs.filter)) {
      return false;
    }
  }
  if (!(lhs.only_latest_version == rhs.only_latest_version)) {
    return false;
  }
  if (!(lhs.enable_read_from_follower == rhs.enable_read_from_follower)) {
    return false;
  }
  if (lhs.common_ref() != rhs.common_ref()) {
    return false;
  }
  if (lhs.username_ref().has_value() != rhs.username_ref().has_value()) {
    return false;
  }
  if (lhs.username_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.username, rhs.username)) {
      return false;
    }
  }
  if (lhs.password_ref().has_value() != rhs.password_ref().has_value()) {
    return false;
  }
  if (lhs.password_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.password, rhs.password)) {
      return false;
    }
  }
  if (lhs.need_authenticate_ref() != rhs.need_authenticate_ref()) {
    return false;
  }
  return true;
}

const std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>& ScanEdgeRequest::get_parts() const& {
  return parts;
}

std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor> ScanEdgeRequest::get_parts() && {
  return std::move(parts);
}

const ::std::vector< ::nebula::storage::cpp2::EdgeProp>& ScanEdgeRequest::get_return_columns() const& {
  return return_columns;
}

::std::vector< ::nebula::storage::cpp2::EdgeProp> ScanEdgeRequest::get_return_columns() && {
  return std::move(return_columns);
}

const  ::nebula::storage::cpp2::RequestCommon* ScanEdgeRequest::get_common() const& {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}

 ::nebula::storage::cpp2::RequestCommon* ScanEdgeRequest::get_common() & {
  return common_ref().has_value() ? std::addressof(common) : nullptr;
}


void swap(ScanEdgeRequest& a, ScanEdgeRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
  swap(a.return_columns_ref().value(), b.return_columns_ref().value());
  swap(a.limit_ref().value(), b.limit_ref().value());
  swap(a.start_time_ref().value_unchecked(), b.start_time_ref().value_unchecked());
  swap(a.end_time_ref().value_unchecked(), b.end_time_ref().value_unchecked());
  swap(a.filter_ref().value_unchecked(), b.filter_ref().value_unchecked());
  swap(a.only_latest_version_ref().value(), b.only_latest_version_ref().value());
  swap(a.enable_read_from_follower_ref().value(), b.enable_read_from_follower_ref().value());
  swap(a.common_ref().value_unchecked(), b.common_ref().value_unchecked());
  swap(a.username_ref().value_unchecked(), b.username_ref().value_unchecked());
  swap(a.password_ref().value_unchecked(), b.password_ref().value_unchecked());
  swap(a.need_authenticate_ref().value_unchecked(), b.need_authenticate_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ScanEdgeRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ScanEdgeRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ScanEdgeRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ScanEdgeRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ScanEdgeRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ScanEdgeRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ScanEdgeRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ScanEdgeRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ScanEdgeRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ScanEdgeRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::EdgeProp>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ScanEdgeRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ScanEdgeRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ScanEdgeRequest,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::storage::cpp2::EdgeProp>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ScanEdgeRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::RequestCommon>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::ScanResponse>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::ScanResponse>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ScanResponse::ScanResponse(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg, nebula::DataSet props__arg, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor> cursors__arg) :
    result(std::move(result__arg)),
    props(std::move(props__arg)),
    cursors(std::move(cursors__arg)) {
  __isset.props = true;
  __isset.cursors = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ScanResponse::__clear() {
  // clear all fields
  result.__clear();
  props.__clear();
  cursors.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ScanResponse::operator==(const ScanResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (lhs.props_ref() != rhs.props_ref()) {
    return false;
  }
  if (!(lhs.cursors == rhs.cursors)) {
    return false;
  }
  return true;
}

const  ::nebula::storage::cpp2::ResponseCommon& ScanResponse::get_result() const& {
  return result;
}

 ::nebula::storage::cpp2::ResponseCommon ScanResponse::get_result() && {
  return std::move(result);
}

const nebula::DataSet* ScanResponse::get_props() const& {
  return props_ref().has_value() ? std::addressof(props) : nullptr;
}

nebula::DataSet* ScanResponse::get_props() & {
  return props_ref().has_value() ? std::addressof(props) : nullptr;
}

const std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>& ScanResponse::get_cursors() const& {
  return cursors;
}

std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor> ScanResponse::get_cursors() && {
  return std::move(cursors);
}


void swap(ScanResponse& a, ScanResponse& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.props_ref().value_unchecked(), b.props_ref().value_unchecked());
  swap(a.cursors_ref().value(), b.cursors_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ScanResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ScanResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ScanResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ScanResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ScanResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ScanResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ScanResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ScanResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ScanResponse,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ScanResponse,
        ::apache::thrift::type_class::structure,
        nebula::DataSet>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ScanResponse,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ScanResponse,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ScanResponse,
        ::apache::thrift::type_class::structure,
        nebula::DataSet>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ScanResponse,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::TaskPara>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::TaskPara>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
TaskPara::TaskPara(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::vector< ::nebula::cpp2::PartitionID> parts__arg, ::std::vector<::std::string> task_specific_paras__arg) :
    space_id(std::move(space_id__arg)),
    parts(std::move(parts__arg)),
    task_specific_paras(std::move(task_specific_paras__arg)) {
  __isset.space_id = true;
  __isset.parts = true;
  __isset.task_specific_paras = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void TaskPara::__clear() {
  // clear all fields
  space_id = 0;
  parts.clear();
  task_specific_paras.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool TaskPara::operator==(const TaskPara& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (lhs.parts_ref() != rhs.parts_ref()) {
    return false;
  }
  if (lhs.task_specific_paras_ref() != rhs.task_specific_paras_ref()) {
    return false;
  }
  return true;
}

bool TaskPara::operator<(const TaskPara& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (lhs.parts_ref() != rhs.parts_ref()) {
    return lhs.parts_ref() < rhs.parts_ref();
  }
  if (lhs.task_specific_paras_ref() != rhs.task_specific_paras_ref()) {
    return lhs.task_specific_paras_ref() < rhs.task_specific_paras_ref();
  }
  return false;
}

const ::std::vector< ::nebula::cpp2::PartitionID>* TaskPara::get_parts() const& {
  return parts_ref().has_value() ? std::addressof(parts) : nullptr;
}

::std::vector< ::nebula::cpp2::PartitionID>* TaskPara::get_parts() & {
  return parts_ref().has_value() ? std::addressof(parts) : nullptr;
}

const ::std::vector<::std::string>* TaskPara::get_task_specific_paras() const& {
  return task_specific_paras_ref().has_value() ? std::addressof(task_specific_paras) : nullptr;
}

::std::vector<::std::string>* TaskPara::get_task_specific_paras() & {
  return task_specific_paras_ref().has_value() ? std::addressof(task_specific_paras) : nullptr;
}


void swap(TaskPara& a, TaskPara& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.parts_ref().value_unchecked(), b.parts_ref().value_unchecked());
  swap(a.task_specific_paras_ref().value_unchecked(), b.task_specific_paras_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void TaskPara::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TaskPara::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TaskPara::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TaskPara::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TaskPara::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TaskPara::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TaskPara::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TaskPara::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::KVGetRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::KVGetRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
KVGetRequest::KVGetRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>> parts__arg, bool return_partly__arg) :
    space_id(std::move(space_id__arg)),
    parts(std::move(parts__arg)),
    return_partly(std::move(return_partly__arg)) {
  __isset.space_id = true;
  __isset.parts = true;
  __isset.return_partly = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void KVGetRequest::__clear() {
  // clear all fields
  space_id = 0;
  parts.clear();
  return_partly = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool KVGetRequest::operator==(const KVGetRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  if (!(lhs.return_partly == rhs.return_partly)) {
    return false;
  }
  return true;
}

const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>& KVGetRequest::get_parts() const& {
  return parts;
}

std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>> KVGetRequest::get_parts() && {
  return std::move(parts);
}


void swap(KVGetRequest& a, KVGetRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
  swap(a.return_partly_ref().value(), b.return_partly_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void KVGetRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t KVGetRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t KVGetRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t KVGetRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void KVGetRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t KVGetRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t KVGetRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t KVGetRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::KVGetResponse>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::KVGetResponse>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
KVGetResponse::KVGetResponse(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg, std::unordered_map<::std::string, ::std::string> key_values__arg) :
    result(std::move(result__arg)),
    key_values(std::move(key_values__arg)) {
  __isset.key_values = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void KVGetResponse::__clear() {
  // clear all fields
  result.__clear();
  key_values.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool KVGetResponse::operator==(const KVGetResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.key_values == rhs.key_values)) {
    return false;
  }
  return true;
}

const  ::nebula::storage::cpp2::ResponseCommon& KVGetResponse::get_result() const& {
  return result;
}

 ::nebula::storage::cpp2::ResponseCommon KVGetResponse::get_result() && {
  return std::move(result);
}

const std::unordered_map<::std::string, ::std::string>& KVGetResponse::get_key_values() const& {
  return key_values;
}

std::unordered_map<::std::string, ::std::string> KVGetResponse::get_key_values() && {
  return std::move(key_values);
}


void swap(KVGetResponse& a, KVGetResponse& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.key_values_ref().value(), b.key_values_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void KVGetResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t KVGetResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t KVGetResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t KVGetResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void KVGetResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t KVGetResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t KVGetResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t KVGetResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        KVGetResponse,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        KVGetResponse,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::KVPutRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::KVPutRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
KVPutRequest::KVPutRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>> parts__arg) :
    space_id(std::move(space_id__arg)),
    parts(std::move(parts__arg)) {
  __isset.space_id = true;
  __isset.parts = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void KVPutRequest::__clear() {
  // clear all fields
  space_id = 0;
  parts.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool KVPutRequest::operator==(const KVPutRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  return true;
}

const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>>& KVPutRequest::get_parts() const& {
  return parts;
}

std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>> KVPutRequest::get_parts() && {
  return std::move(parts);
}


void swap(KVPutRequest& a, KVPutRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void KVPutRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t KVPutRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t KVPutRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t KVPutRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void KVPutRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t KVPutRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t KVPutRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t KVPutRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        KVPutRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        KVPutRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>>>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::KVRemoveRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::KVRemoveRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
KVRemoveRequest::KVRemoveRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>> parts__arg) :
    space_id(std::move(space_id__arg)),
    parts(std::move(parts__arg)) {
  __isset.space_id = true;
  __isset.parts = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void KVRemoveRequest::__clear() {
  // clear all fields
  space_id = 0;
  parts.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool KVRemoveRequest::operator==(const KVRemoveRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  return true;
}

const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>& KVRemoveRequest::get_parts() const& {
  return parts;
}

std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>> KVRemoveRequest::get_parts() && {
  return std::move(parts);
}


void swap(KVRemoveRequest& a, KVRemoveRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void KVRemoveRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t KVRemoveRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t KVRemoveRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t KVRemoveRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void KVRemoveRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t KVRemoveRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t KVRemoveRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t KVRemoveRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::AdminExecResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::AdminExecResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AdminExecResp::AdminExecResp(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg,  ::nebula::meta::cpp2::StatsItem stats__arg) :
    result(std::move(result__arg)),
    stats(std::move(stats__arg)) {
  __isset.stats = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AdminExecResp::__clear() {
  // clear all fields
  result.__clear();
  stats.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AdminExecResp::operator==(const AdminExecResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (lhs.stats_ref() != rhs.stats_ref()) {
    return false;
  }
  return true;
}

const  ::nebula::storage::cpp2::ResponseCommon& AdminExecResp::get_result() const& {
  return result;
}

 ::nebula::storage::cpp2::ResponseCommon AdminExecResp::get_result() && {
  return std::move(result);
}

const  ::nebula::meta::cpp2::StatsItem* AdminExecResp::get_stats() const& {
  return stats_ref().has_value() ? std::addressof(stats) : nullptr;
}

 ::nebula::meta::cpp2::StatsItem* AdminExecResp::get_stats() & {
  return stats_ref().has_value() ? std::addressof(stats) : nullptr;
}


void swap(AdminExecResp& a, AdminExecResp& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.stats_ref().value_unchecked(), b.stats_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AdminExecResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AdminExecResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AdminExecResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AdminExecResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AdminExecResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AdminExecResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AdminExecResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AdminExecResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AdminExecResp,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AdminExecResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::StatsItem>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AdminExecResp,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AdminExecResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::StatsItem>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::TransLeaderReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::TransLeaderReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
TransLeaderReq::TransLeaderReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg, nebula::HostAddr new_leader__arg) :
    space_id(std::move(space_id__arg)),
    part_id(std::move(part_id__arg)),
    new_leader(std::move(new_leader__arg)) {
  __isset.space_id = true;
  __isset.part_id = true;
  __isset.new_leader = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void TransLeaderReq::__clear() {
  // clear all fields
  space_id = 0;
  part_id = 0;
  new_leader.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool TransLeaderReq::operator==(const TransLeaderReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return false;
  }
  if (!(lhs.new_leader == rhs.new_leader)) {
    return false;
  }
  return true;
}

bool TransLeaderReq::operator<(const TransLeaderReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return lhs.part_id < rhs.part_id;
  }
  if (!(lhs.new_leader == rhs.new_leader)) {
    return lhs.new_leader < rhs.new_leader;
  }
  return false;
}

const nebula::HostAddr& TransLeaderReq::get_new_leader() const& {
  return new_leader;
}

nebula::HostAddr TransLeaderReq::get_new_leader() && {
  return std::move(new_leader);
}


void swap(TransLeaderReq& a, TransLeaderReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.part_id_ref().value(), b.part_id_ref().value());
  swap(a.new_leader_ref().value(), b.new_leader_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void TransLeaderReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TransLeaderReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TransLeaderReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TransLeaderReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TransLeaderReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TransLeaderReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TransLeaderReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TransLeaderReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        TransLeaderReq,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        TransLeaderReq,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::AddPartReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::AddPartReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AddPartReq::AddPartReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg, bool as_learner__arg, ::std::vector<nebula::HostAddr> peers__arg) :
    space_id(std::move(space_id__arg)),
    part_id(std::move(part_id__arg)),
    as_learner(std::move(as_learner__arg)),
    peers(std::move(peers__arg)) {
  __isset.space_id = true;
  __isset.part_id = true;
  __isset.as_learner = true;
  __isset.peers = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AddPartReq::__clear() {
  // clear all fields
  space_id = 0;
  part_id = 0;
  as_learner = 0;
  peers.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AddPartReq::operator==(const AddPartReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return false;
  }
  if (!(lhs.as_learner == rhs.as_learner)) {
    return false;
  }
  if (!(lhs.peers == rhs.peers)) {
    return false;
  }
  return true;
}

bool AddPartReq::operator<(const AddPartReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return lhs.part_id < rhs.part_id;
  }
  if (!(lhs.as_learner == rhs.as_learner)) {
    return lhs.as_learner < rhs.as_learner;
  }
  if (!(lhs.peers == rhs.peers)) {
    return lhs.peers < rhs.peers;
  }
  return false;
}

const ::std::vector<nebula::HostAddr>& AddPartReq::get_peers() const& {
  return peers;
}

::std::vector<nebula::HostAddr> AddPartReq::get_peers() && {
  return std::move(peers);
}


void swap(AddPartReq& a, AddPartReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.part_id_ref().value(), b.part_id_ref().value());
  swap(a.as_learner_ref().value(), b.as_learner_ref().value());
  swap(a.peers_ref().value(), b.peers_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AddPartReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AddPartReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AddPartReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AddPartReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AddPartReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AddPartReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AddPartReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AddPartReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AddPartReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::HostAddr>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AddPartReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::HostAddr>>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::AddLearnerReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::AddLearnerReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AddLearnerReq::AddLearnerReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg, nebula::HostAddr learner__arg) :
    space_id(std::move(space_id__arg)),
    part_id(std::move(part_id__arg)),
    learner(std::move(learner__arg)) {
  __isset.space_id = true;
  __isset.part_id = true;
  __isset.learner = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AddLearnerReq::__clear() {
  // clear all fields
  space_id = 0;
  part_id = 0;
  learner.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AddLearnerReq::operator==(const AddLearnerReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return false;
  }
  if (!(lhs.learner == rhs.learner)) {
    return false;
  }
  return true;
}

bool AddLearnerReq::operator<(const AddLearnerReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return lhs.part_id < rhs.part_id;
  }
  if (!(lhs.learner == rhs.learner)) {
    return lhs.learner < rhs.learner;
  }
  return false;
}

const nebula::HostAddr& AddLearnerReq::get_learner() const& {
  return learner;
}

nebula::HostAddr AddLearnerReq::get_learner() && {
  return std::move(learner);
}


void swap(AddLearnerReq& a, AddLearnerReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.part_id_ref().value(), b.part_id_ref().value());
  swap(a.learner_ref().value(), b.learner_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AddLearnerReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AddLearnerReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AddLearnerReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AddLearnerReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AddLearnerReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AddLearnerReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AddLearnerReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AddLearnerReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AddLearnerReq,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AddLearnerReq,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::RemovePartReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::RemovePartReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RemovePartReq::RemovePartReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg) :
    space_id(std::move(space_id__arg)),
    part_id(std::move(part_id__arg)) {
  __isset.space_id = true;
  __isset.part_id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void RemovePartReq::__clear() {
  // clear all fields
  space_id = 0;
  part_id = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool RemovePartReq::operator==(const RemovePartReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return false;
  }
  return true;
}

bool RemovePartReq::operator<(const RemovePartReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return lhs.part_id < rhs.part_id;
  }
  return false;
}


void swap(RemovePartReq& a, RemovePartReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.part_id_ref().value(), b.part_id_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void RemovePartReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RemovePartReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RemovePartReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RemovePartReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RemovePartReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RemovePartReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RemovePartReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RemovePartReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::MemberChangeReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::MemberChangeReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MemberChangeReq::MemberChangeReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg, nebula::HostAddr peer__arg, bool add__arg) :
    space_id(std::move(space_id__arg)),
    part_id(std::move(part_id__arg)),
    peer(std::move(peer__arg)),
    add(std::move(add__arg)) {
  __isset.space_id = true;
  __isset.part_id = true;
  __isset.peer = true;
  __isset.add = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void MemberChangeReq::__clear() {
  // clear all fields
  space_id = 0;
  part_id = 0;
  peer.__clear();
  add = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool MemberChangeReq::operator==(const MemberChangeReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return false;
  }
  if (!(lhs.peer == rhs.peer)) {
    return false;
  }
  if (!(lhs.add == rhs.add)) {
    return false;
  }
  return true;
}

bool MemberChangeReq::operator<(const MemberChangeReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return lhs.part_id < rhs.part_id;
  }
  if (!(lhs.peer == rhs.peer)) {
    return lhs.peer < rhs.peer;
  }
  if (!(lhs.add == rhs.add)) {
    return lhs.add < rhs.add;
  }
  return false;
}

const nebula::HostAddr& MemberChangeReq::get_peer() const& {
  return peer;
}

nebula::HostAddr MemberChangeReq::get_peer() && {
  return std::move(peer);
}


void swap(MemberChangeReq& a, MemberChangeReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.part_id_ref().value(), b.part_id_ref().value());
  swap(a.peer_ref().value(), b.peer_ref().value());
  swap(a.add_ref().value(), b.add_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void MemberChangeReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MemberChangeReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MemberChangeReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MemberChangeReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MemberChangeReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MemberChangeReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MemberChangeReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MemberChangeReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MemberChangeReq,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MemberChangeReq,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::CatchUpDataReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::CatchUpDataReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CatchUpDataReq::CatchUpDataReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg, nebula::HostAddr target__arg) :
    space_id(std::move(space_id__arg)),
    part_id(std::move(part_id__arg)),
    target(std::move(target__arg)) {
  __isset.space_id = true;
  __isset.part_id = true;
  __isset.target = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CatchUpDataReq::__clear() {
  // clear all fields
  space_id = 0;
  part_id = 0;
  target.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CatchUpDataReq::operator==(const CatchUpDataReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return false;
  }
  if (!(lhs.target == rhs.target)) {
    return false;
  }
  return true;
}

bool CatchUpDataReq::operator<(const CatchUpDataReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return lhs.part_id < rhs.part_id;
  }
  if (!(lhs.target == rhs.target)) {
    return lhs.target < rhs.target;
  }
  return false;
}

const nebula::HostAddr& CatchUpDataReq::get_target() const& {
  return target;
}

nebula::HostAddr CatchUpDataReq::get_target() && {
  return std::move(target);
}


void swap(CatchUpDataReq& a, CatchUpDataReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.part_id_ref().value(), b.part_id_ref().value());
  swap(a.target_ref().value(), b.target_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CatchUpDataReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CatchUpDataReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CatchUpDataReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CatchUpDataReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CatchUpDataReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CatchUpDataReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CatchUpDataReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CatchUpDataReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CatchUpDataReq,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CatchUpDataReq,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::GetLeaderReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::GetLeaderReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetLeaderReq::GetLeaderReq(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetLeaderReq::__clear() {
  // clear all fields
}

bool GetLeaderReq::operator==(const GetLeaderReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool GetLeaderReq::operator<(const GetLeaderReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(GetLeaderReq& a, GetLeaderReq& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void GetLeaderReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetLeaderReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetLeaderReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetLeaderReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetLeaderReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetLeaderReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetLeaderReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetLeaderReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::CreateCPRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::CreateCPRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CreateCPRequest::CreateCPRequest(apache::thrift::FragileConstructor, ::std::vector< ::nebula::cpp2::GraphSpaceID> space_ids__arg, ::std::string name__arg) :
    space_ids(std::move(space_ids__arg)),
    name(std::move(name__arg)) {
  __isset.space_ids = true;
  __isset.name = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CreateCPRequest::__clear() {
  // clear all fields
  space_ids.clear();
  name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CreateCPRequest::operator==(const CreateCPRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_ids == rhs.space_ids)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return false;
  }
  return true;
}

bool CreateCPRequest::operator<(const CreateCPRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_ids == rhs.space_ids)) {
    return lhs.space_ids < rhs.space_ids;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.name, rhs.name);
  }
  return false;
}

const ::std::vector< ::nebula::cpp2::GraphSpaceID>& CreateCPRequest::get_space_ids() const& {
  return space_ids;
}

::std::vector< ::nebula::cpp2::GraphSpaceID> CreateCPRequest::get_space_ids() && {
  return std::move(space_ids);
}


void swap(CreateCPRequest& a, CreateCPRequest& b) {
  using ::std::swap;
  swap(a.space_ids_ref().value(), b.space_ids_ref().value());
  swap(a.name_ref().value(), b.name_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CreateCPRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CreateCPRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CreateCPRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CreateCPRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CreateCPRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CreateCPRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CreateCPRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CreateCPRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::CreateCPResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::CreateCPResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CreateCPResp::CreateCPResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, ::std::vector< ::nebula::cpp2::CheckpointInfo> info__arg) :
    code(std::move(code__arg)),
    info(std::move(info__arg)) {
  __isset.code = true;
  __isset.info = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CreateCPResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  info.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CreateCPResp::operator==(const CreateCPResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.info == rhs.info)) {
    return false;
  }
  return true;
}

const ::std::vector< ::nebula::cpp2::CheckpointInfo>& CreateCPResp::get_info() const& {
  return info;
}

::std::vector< ::nebula::cpp2::CheckpointInfo> CreateCPResp::get_info() && {
  return std::move(info);
}


void swap(CreateCPResp& a, CreateCPResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.info_ref().value(), b.info_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CreateCPResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CreateCPResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CreateCPResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CreateCPResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CreateCPResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CreateCPResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CreateCPResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CreateCPResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CreateCPResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::cpp2::CheckpointInfo>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CreateCPResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::cpp2::CheckpointInfo>>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::DropCPRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::DropCPRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DropCPRequest::DropCPRequest(apache::thrift::FragileConstructor, ::std::vector< ::nebula::cpp2::GraphSpaceID> space_ids__arg, ::std::string name__arg) :
    space_ids(std::move(space_ids__arg)),
    name(std::move(name__arg)) {
  __isset.space_ids = true;
  __isset.name = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void DropCPRequest::__clear() {
  // clear all fields
  space_ids.clear();
  name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DropCPRequest::operator==(const DropCPRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_ids == rhs.space_ids)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return false;
  }
  return true;
}

bool DropCPRequest::operator<(const DropCPRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_ids == rhs.space_ids)) {
    return lhs.space_ids < rhs.space_ids;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.name, rhs.name);
  }
  return false;
}

const ::std::vector< ::nebula::cpp2::GraphSpaceID>& DropCPRequest::get_space_ids() const& {
  return space_ids;
}

::std::vector< ::nebula::cpp2::GraphSpaceID> DropCPRequest::get_space_ids() && {
  return std::move(space_ids);
}


void swap(DropCPRequest& a, DropCPRequest& b) {
  using ::std::swap;
  swap(a.space_ids_ref().value(), b.space_ids_ref().value());
  swap(a.name_ref().value(), b.name_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DropCPRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DropCPRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DropCPRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DropCPRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DropCPRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DropCPRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DropCPRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DropCPRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::DropCPResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::DropCPResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DropCPResp::DropCPResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg) :
    code(std::move(code__arg)) {
  __isset.code = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void DropCPResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DropCPResp::operator==(const DropCPResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  return true;
}

bool DropCPResp::operator<(const DropCPResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  return false;
}


void swap(DropCPResp& a, DropCPResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DropCPResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DropCPResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DropCPResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DropCPResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DropCPResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DropCPResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DropCPResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DropCPResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::BlockingSignRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::BlockingSignRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
BlockingSignRequest::BlockingSignRequest(apache::thrift::FragileConstructor, ::std::vector< ::nebula::cpp2::GraphSpaceID> space_ids__arg,  ::nebula::storage::cpp2::EngineSignType sign__arg) :
    space_ids(std::move(space_ids__arg)),
    sign(std::move(sign__arg)) {
  __isset.space_ids = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void BlockingSignRequest::__clear() {
  // clear all fields
  space_ids.clear();
  sign = static_cast< ::nebula::storage::cpp2::EngineSignType>(0);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool BlockingSignRequest::operator==(const BlockingSignRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_ids == rhs.space_ids)) {
    return false;
  }
  if (!(lhs.sign == rhs.sign)) {
    return false;
  }
  return true;
}

bool BlockingSignRequest::operator<(const BlockingSignRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_ids == rhs.space_ids)) {
    return lhs.space_ids < rhs.space_ids;
  }
  if (!(lhs.sign == rhs.sign)) {
    return lhs.sign < rhs.sign;
  }
  return false;
}

const ::std::vector< ::nebula::cpp2::GraphSpaceID>& BlockingSignRequest::get_space_ids() const& {
  return space_ids;
}

::std::vector< ::nebula::cpp2::GraphSpaceID> BlockingSignRequest::get_space_ids() && {
  return std::move(space_ids);
}


void swap(BlockingSignRequest& a, BlockingSignRequest& b) {
  using ::std::swap;
  swap(a.space_ids_ref().value(), b.space_ids_ref().value());
  swap(a.sign_ref().value(), b.sign_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void BlockingSignRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t BlockingSignRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t BlockingSignRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t BlockingSignRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void BlockingSignRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t BlockingSignRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t BlockingSignRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t BlockingSignRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::BlockingSignResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::BlockingSignResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
BlockingSignResp::BlockingSignResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg) :
    code(std::move(code__arg)) {
  __isset.code = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void BlockingSignResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool BlockingSignResp::operator==(const BlockingSignResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  return true;
}

bool BlockingSignResp::operator<(const BlockingSignResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  return false;
}


void swap(BlockingSignResp& a, BlockingSignResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void BlockingSignResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t BlockingSignResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t BlockingSignResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t BlockingSignResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void BlockingSignResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t BlockingSignResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t BlockingSignResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t BlockingSignResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::GetLeaderPartsResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::GetLeaderPartsResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetLeaderPartsResp::GetLeaderPartsResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::cpp2::PartitionID>> leader_parts__arg) :
    code(std::move(code__arg)),
    leader_parts(std::move(leader_parts__arg)) {
  __isset.code = true;
  __isset.leader_parts = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetLeaderPartsResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader_parts.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetLeaderPartsResp::operator==(const GetLeaderPartsResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader_parts == rhs.leader_parts)) {
    return false;
  }
  return true;
}

const std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::cpp2::PartitionID>>& GetLeaderPartsResp::get_leader_parts() const& {
  return leader_parts;
}

std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::cpp2::PartitionID>> GetLeaderPartsResp::get_leader_parts() && {
  return std::move(leader_parts);
}


void swap(GetLeaderPartsResp& a, GetLeaderPartsResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_parts_ref().value(), b.leader_parts_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetLeaderPartsResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetLeaderPartsResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetLeaderPartsResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetLeaderPartsResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetLeaderPartsResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetLeaderPartsResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetLeaderPartsResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetLeaderPartsResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::CheckPeersReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::CheckPeersReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CheckPeersReq::CheckPeersReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg, ::std::vector<nebula::HostAddr> peers__arg) :
    space_id(std::move(space_id__arg)),
    part_id(std::move(part_id__arg)),
    peers(std::move(peers__arg)) {
  __isset.space_id = true;
  __isset.part_id = true;
  __isset.peers = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CheckPeersReq::__clear() {
  // clear all fields
  space_id = 0;
  part_id = 0;
  peers.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CheckPeersReq::operator==(const CheckPeersReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return false;
  }
  if (!(lhs.peers == rhs.peers)) {
    return false;
  }
  return true;
}

bool CheckPeersReq::operator<(const CheckPeersReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return lhs.part_id < rhs.part_id;
  }
  if (!(lhs.peers == rhs.peers)) {
    return lhs.peers < rhs.peers;
  }
  return false;
}

const ::std::vector<nebula::HostAddr>& CheckPeersReq::get_peers() const& {
  return peers;
}

::std::vector<nebula::HostAddr> CheckPeersReq::get_peers() && {
  return std::move(peers);
}


void swap(CheckPeersReq& a, CheckPeersReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.part_id_ref().value(), b.part_id_ref().value());
  swap(a.peers_ref().value(), b.peers_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CheckPeersReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CheckPeersReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CheckPeersReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CheckPeersReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CheckPeersReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CheckPeersReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CheckPeersReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CheckPeersReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CheckPeersReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::HostAddr>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CheckPeersReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::HostAddr>>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::RebuildIndexRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::RebuildIndexRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RebuildIndexRequest::RebuildIndexRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::vector< ::nebula::cpp2::PartitionID> parts__arg,  ::nebula::cpp2::IndexID index_id__arg) :
    space_id(std::move(space_id__arg)),
    parts(std::move(parts__arg)),
    index_id(std::move(index_id__arg)) {
  __isset.space_id = true;
  __isset.parts = true;
  __isset.index_id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void RebuildIndexRequest::__clear() {
  // clear all fields
  space_id = 0;
  parts.clear();
  index_id = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool RebuildIndexRequest::operator==(const RebuildIndexRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  if (!(lhs.index_id == rhs.index_id)) {
    return false;
  }
  return true;
}

bool RebuildIndexRequest::operator<(const RebuildIndexRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!(lhs.parts == rhs.parts)) {
    return lhs.parts < rhs.parts;
  }
  if (!(lhs.index_id == rhs.index_id)) {
    return lhs.index_id < rhs.index_id;
  }
  return false;
}

const ::std::vector< ::nebula::cpp2::PartitionID>& RebuildIndexRequest::get_parts() const& {
  return parts;
}

::std::vector< ::nebula::cpp2::PartitionID> RebuildIndexRequest::get_parts() && {
  return std::move(parts);
}


void swap(RebuildIndexRequest& a, RebuildIndexRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
  swap(a.index_id_ref().value(), b.index_id_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void RebuildIndexRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RebuildIndexRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RebuildIndexRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RebuildIndexRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RebuildIndexRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RebuildIndexRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RebuildIndexRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RebuildIndexRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::ListClusterInfoResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::ListClusterInfoResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListClusterInfoResp::ListClusterInfoResp(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg,  ::nebula::cpp2::DirInfo dir__arg) :
    result(std::move(result__arg)),
    dir(std::move(dir__arg)) {
  __isset.dir = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListClusterInfoResp::__clear() {
  // clear all fields
  result.__clear();
  dir.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListClusterInfoResp::operator==(const ListClusterInfoResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.dir == rhs.dir)) {
    return false;
  }
  return true;
}

bool ListClusterInfoResp::operator<(const ListClusterInfoResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.dir == rhs.dir)) {
    return lhs.dir < rhs.dir;
  }
  return false;
}

const  ::nebula::storage::cpp2::ResponseCommon& ListClusterInfoResp::get_result() const& {
  return result;
}

 ::nebula::storage::cpp2::ResponseCommon ListClusterInfoResp::get_result() && {
  return std::move(result);
}

const  ::nebula::cpp2::DirInfo& ListClusterInfoResp::get_dir() const& {
  return dir;
}

 ::nebula::cpp2::DirInfo ListClusterInfoResp::get_dir() && {
  return std::move(dir);
}


void swap(ListClusterInfoResp& a, ListClusterInfoResp& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.dir_ref().value(), b.dir_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListClusterInfoResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListClusterInfoResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListClusterInfoResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListClusterInfoResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListClusterInfoResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListClusterInfoResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListClusterInfoResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListClusterInfoResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListClusterInfoResp,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListClusterInfoResp,
        ::apache::thrift::type_class::structure,
         ::nebula::cpp2::DirInfo>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListClusterInfoResp,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::ResponseCommon>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListClusterInfoResp,
        ::apache::thrift::type_class::structure,
         ::nebula::cpp2::DirInfo>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::ListClusterInfoReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::ListClusterInfoReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListClusterInfoReq::ListClusterInfoReq(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListClusterInfoReq::__clear() {
  // clear all fields
}

bool ListClusterInfoReq::operator==(const ListClusterInfoReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool ListClusterInfoReq::operator<(const ListClusterInfoReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(ListClusterInfoReq& a, ListClusterInfoReq& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void ListClusterInfoReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListClusterInfoReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListClusterInfoReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListClusterInfoReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListClusterInfoReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListClusterInfoReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListClusterInfoReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListClusterInfoReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::AddTaskRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::AddTaskRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AddTaskRequest::AddTaskRequest(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::JobType job_type__arg, int32_t job_id__arg, int32_t task_id__arg,  ::nebula::storage::cpp2::TaskPara para__arg) :
    job_type(std::move(job_type__arg)),
    job_id(std::move(job_id__arg)),
    task_id(std::move(task_id__arg)),
    para(std::move(para__arg)) {
  __isset.job_type = true;
  __isset.job_id = true;
  __isset.task_id = true;
  __isset.para = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AddTaskRequest::__clear() {
  // clear all fields
  job_type =  ::nebula::meta::cpp2::JobType::COMPACT;
  job_id = 0;
  task_id = 0;
  para.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AddTaskRequest::operator==(const AddTaskRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.job_type == rhs.job_type)) {
    return false;
  }
  if (!(lhs.job_id == rhs.job_id)) {
    return false;
  }
  if (!(lhs.task_id == rhs.task_id)) {
    return false;
  }
  if (!(lhs.para == rhs.para)) {
    return false;
  }
  return true;
}

bool AddTaskRequest::operator<(const AddTaskRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.job_type == rhs.job_type)) {
    return lhs.job_type < rhs.job_type;
  }
  if (!(lhs.job_id == rhs.job_id)) {
    return lhs.job_id < rhs.job_id;
  }
  if (!(lhs.task_id == rhs.task_id)) {
    return lhs.task_id < rhs.task_id;
  }
  if (!(lhs.para == rhs.para)) {
    return lhs.para < rhs.para;
  }
  return false;
}

const  ::nebula::storage::cpp2::TaskPara& AddTaskRequest::get_para() const& {
  return para;
}

 ::nebula::storage::cpp2::TaskPara AddTaskRequest::get_para() && {
  return std::move(para);
}


void swap(AddTaskRequest& a, AddTaskRequest& b) {
  using ::std::swap;
  swap(a.job_type_ref().value(), b.job_type_ref().value());
  swap(a.job_id_ref().value(), b.job_id_ref().value());
  swap(a.task_id_ref().value(), b.task_id_ref().value());
  swap(a.para_ref().value(), b.para_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AddTaskRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AddTaskRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AddTaskRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AddTaskRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AddTaskRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AddTaskRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AddTaskRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AddTaskRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AddTaskRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::TaskPara>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AddTaskRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::TaskPara>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::AddTaskResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::AddTaskResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AddTaskResp::AddTaskResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg) :
    code(std::move(code__arg)) {
  __isset.code = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AddTaskResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AddTaskResp::operator==(const AddTaskResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  return true;
}

bool AddTaskResp::operator<(const AddTaskResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  return false;
}


void swap(AddTaskResp& a, AddTaskResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AddTaskResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AddTaskResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AddTaskResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AddTaskResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AddTaskResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AddTaskResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AddTaskResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AddTaskResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::StopTaskRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::StopTaskRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StopTaskRequest::StopTaskRequest(apache::thrift::FragileConstructor, int32_t job_id__arg, int32_t task_id__arg) :
    job_id(std::move(job_id__arg)),
    task_id(std::move(task_id__arg)) {
  __isset.job_id = true;
  __isset.task_id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void StopTaskRequest::__clear() {
  // clear all fields
  job_id = 0;
  task_id = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool StopTaskRequest::operator==(const StopTaskRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.job_id == rhs.job_id)) {
    return false;
  }
  if (!(lhs.task_id == rhs.task_id)) {
    return false;
  }
  return true;
}

bool StopTaskRequest::operator<(const StopTaskRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.job_id == rhs.job_id)) {
    return lhs.job_id < rhs.job_id;
  }
  if (!(lhs.task_id == rhs.task_id)) {
    return lhs.task_id < rhs.task_id;
  }
  return false;
}


void swap(StopTaskRequest& a, StopTaskRequest& b) {
  using ::std::swap;
  swap(a.job_id_ref().value(), b.job_id_ref().value());
  swap(a.task_id_ref().value(), b.task_id_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void StopTaskRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StopTaskRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StopTaskRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StopTaskRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StopTaskRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StopTaskRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StopTaskRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StopTaskRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::StopTaskResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::StopTaskResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StopTaskResp::StopTaskResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg) :
    code(std::move(code__arg)) {
  __isset.code = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void StopTaskResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool StopTaskResp::operator==(const StopTaskResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  return true;
}

bool StopTaskResp::operator<(const StopTaskResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  return false;
}


void swap(StopTaskResp& a, StopTaskResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void StopTaskResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StopTaskResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StopTaskResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StopTaskResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StopTaskResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StopTaskResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StopTaskResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StopTaskResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::ClearSpaceReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::ClearSpaceReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ClearSpaceReq::ClearSpaceReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg) :
    space_id(std::move(space_id__arg)) {
  __isset.space_id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ClearSpaceReq::__clear() {
  // clear all fields
  space_id = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ClearSpaceReq::operator==(const ClearSpaceReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  return true;
}

bool ClearSpaceReq::operator<(const ClearSpaceReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  return false;
}


void swap(ClearSpaceReq& a, ClearSpaceReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ClearSpaceReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ClearSpaceReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ClearSpaceReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ClearSpaceReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ClearSpaceReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ClearSpaceReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ClearSpaceReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ClearSpaceReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::ClearSpaceResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::ClearSpaceResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ClearSpaceResp::ClearSpaceResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg) :
    code(std::move(code__arg)) {
  __isset.code = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ClearSpaceResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ClearSpaceResp::operator==(const ClearSpaceResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  return true;
}

bool ClearSpaceResp::operator<(const ClearSpaceResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  return false;
}


void swap(ClearSpaceResp& a, ClearSpaceResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ClearSpaceResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ClearSpaceResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ClearSpaceResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ClearSpaceResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ClearSpaceResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ClearSpaceResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ClearSpaceResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ClearSpaceResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::ChainAddEdgesRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::ChainAddEdgesRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ChainAddEdgesRequest::ChainAddEdgesRequest() :
      space_id(0),
      if_not_exists(0),
      term(0),
      edge_version(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


ChainAddEdgesRequest::~ChainAddEdgesRequest() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ChainAddEdgesRequest::ChainAddEdgesRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>> parts__arg, ::std::vector<::std::string> prop_names__arg, bool if_not_exists__arg, int64_t term__arg, int64_t edge_version__arg) :
    space_id(std::move(space_id__arg)),
    parts(std::move(parts__arg)),
    prop_names(std::move(prop_names__arg)),
    if_not_exists(std::move(if_not_exists__arg)),
    term(std::move(term__arg)),
    edge_version(std::move(edge_version__arg)) {
  __isset.space_id = true;
  __isset.parts = true;
  __isset.prop_names = true;
  __isset.if_not_exists = true;
  __isset.term = true;
  __isset.edge_version = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ChainAddEdgesRequest::__clear() {
  // clear all fields
  space_id = 0;
  parts.clear();
  prop_names.clear();
  if_not_exists = 0;
  term = 0;
  edge_version = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ChainAddEdgesRequest::operator==(const ChainAddEdgesRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  if (!(lhs.prop_names == rhs.prop_names)) {
    return false;
  }
  if (!(lhs.if_not_exists == rhs.if_not_exists)) {
    return false;
  }
  if (!(lhs.term == rhs.term)) {
    return false;
  }
  if (lhs.edge_version_ref() != rhs.edge_version_ref()) {
    return false;
  }
  return true;
}

const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>& ChainAddEdgesRequest::get_parts() const& {
  return parts;
}

std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>> ChainAddEdgesRequest::get_parts() && {
  return std::move(parts);
}

const ::std::vector<::std::string>& ChainAddEdgesRequest::get_prop_names() const& {
  return prop_names;
}

::std::vector<::std::string> ChainAddEdgesRequest::get_prop_names() && {
  return std::move(prop_names);
}


void swap(ChainAddEdgesRequest& a, ChainAddEdgesRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
  swap(a.prop_names_ref().value(), b.prop_names_ref().value());
  swap(a.if_not_exists_ref().value(), b.if_not_exists_ref().value());
  swap(a.term_ref().value(), b.term_ref().value());
  swap(a.edge_version_ref().value_unchecked(), b.edge_version_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ChainAddEdgesRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ChainAddEdgesRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ChainAddEdgesRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ChainAddEdgesRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ChainAddEdgesRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ChainAddEdgesRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ChainAddEdgesRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ChainAddEdgesRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ChainAddEdgesRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ChainAddEdgesRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::ChainUpdateEdgeRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::ChainUpdateEdgeRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ChainUpdateEdgeRequest::ChainUpdateEdgeRequest() :
      term(0),
      edge_version(0),
      space_id(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


ChainUpdateEdgeRequest::~ChainUpdateEdgeRequest() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ChainUpdateEdgeRequest::ChainUpdateEdgeRequest(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::UpdateEdgeRequest update_edge_request__arg, int64_t term__arg, int64_t edge_version__arg,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::vector< ::nebula::cpp2::PartitionID> parts__arg) :
    update_edge_request(std::move(update_edge_request__arg)),
    term(std::move(term__arg)),
    edge_version(std::move(edge_version__arg)),
    space_id(std::move(space_id__arg)),
    parts(std::move(parts__arg)) {
  __isset.update_edge_request = true;
  __isset.term = true;
  __isset.edge_version = true;
  __isset.space_id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ChainUpdateEdgeRequest::__clear() {
  // clear all fields
  update_edge_request.__clear();
  term = 0;
  edge_version = 0;
  space_id = 0;
  parts.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ChainUpdateEdgeRequest::operator==(const ChainUpdateEdgeRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.update_edge_request == rhs.update_edge_request)) {
    return false;
  }
  if (!(lhs.term == rhs.term)) {
    return false;
  }
  if (lhs.edge_version_ref() != rhs.edge_version_ref()) {
    return false;
  }
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  return true;
}

const  ::nebula::storage::cpp2::UpdateEdgeRequest& ChainUpdateEdgeRequest::get_update_edge_request() const& {
  return update_edge_request;
}

 ::nebula::storage::cpp2::UpdateEdgeRequest ChainUpdateEdgeRequest::get_update_edge_request() && {
  return std::move(update_edge_request);
}

const ::std::vector< ::nebula::cpp2::PartitionID>& ChainUpdateEdgeRequest::get_parts() const& {
  return parts;
}

::std::vector< ::nebula::cpp2::PartitionID> ChainUpdateEdgeRequest::get_parts() && {
  return std::move(parts);
}


void swap(ChainUpdateEdgeRequest& a, ChainUpdateEdgeRequest& b) {
  using ::std::swap;
  swap(a.update_edge_request_ref().value(), b.update_edge_request_ref().value());
  swap(a.term_ref().value(), b.term_ref().value());
  swap(a.edge_version_ref().value_unchecked(), b.edge_version_ref().value_unchecked());
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ChainUpdateEdgeRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ChainUpdateEdgeRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ChainUpdateEdgeRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ChainUpdateEdgeRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ChainUpdateEdgeRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ChainUpdateEdgeRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ChainUpdateEdgeRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ChainUpdateEdgeRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ChainUpdateEdgeRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::UpdateEdgeRequest>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ChainUpdateEdgeRequest,
        ::apache::thrift::type_class::structure,
         ::nebula::storage::cpp2::UpdateEdgeRequest>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::storage::cpp2::ChainDeleteEdgesRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::storage::cpp2::ChainDeleteEdgesRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace storage { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ChainDeleteEdgesRequest::ChainDeleteEdgesRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>> parts__arg, ::std::string txn_id__arg, int64_t term__arg) :
    space_id(std::move(space_id__arg)),
    parts(std::move(parts__arg)),
    txn_id(std::move(txn_id__arg)),
    term(std::move(term__arg)) {
  __isset.space_id = true;
  __isset.parts = true;
  __isset.txn_id = true;
  __isset.term = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ChainDeleteEdgesRequest::__clear() {
  // clear all fields
  space_id = 0;
  parts.clear();
  txn_id = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  term = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ChainDeleteEdgesRequest::operator==(const ChainDeleteEdgesRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.txn_id, rhs.txn_id)) {
    return false;
  }
  if (!(lhs.term == rhs.term)) {
    return false;
  }
  return true;
}

const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>& ChainDeleteEdgesRequest::get_parts() const& {
  return parts;
}

std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>> ChainDeleteEdgesRequest::get_parts() && {
  return std::move(parts);
}


void swap(ChainDeleteEdgesRequest& a, ChainDeleteEdgesRequest& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
  swap(a.txn_id_ref().value(), b.txn_id_ref().value());
  swap(a.term_ref().value(), b.term_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ChainDeleteEdgesRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ChainDeleteEdgesRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ChainDeleteEdgesRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ChainDeleteEdgesRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ChainDeleteEdgesRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ChainDeleteEdgesRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ChainDeleteEdgesRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ChainDeleteEdgesRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ChainDeleteEdgesRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ChainDeleteEdgesRequest,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>,
    "inconsistent use of nimble option");

}}} // nebula::storage::cpp2
