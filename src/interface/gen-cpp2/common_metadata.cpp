/**
 * Autogenerated by Thrift for common.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include <thrift/lib/cpp2/gen/module_metadata_cpp.h>
#include "common_metadata.h"

namespace apache {
namespace thrift {
namespace detail {
namespace md {
using ThriftMetadata = ::apache::thrift::metadata::ThriftMetadata;
using ThriftPrimitiveType = ::apache::thrift::metadata::ThriftPrimitiveType;
using ThriftType = ::apache::thrift::metadata::ThriftType;
using ThriftService = ::apache::thrift::metadata::ThriftService;
using ThriftServiceContext = ::apache::thrift::metadata::ThriftServiceContext;
using ThriftFunctionGenerator = void (*)(ThriftMetadata&, ThriftService&);

void EnumMetadata<::nebula::cpp2::NullType>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("common.NullType", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "common.NullType";
  using EnumTraits = TEnumTraits<::nebula::cpp2::NullType>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::cpp2::PropertyType>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("common.PropertyType", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "common.PropertyType";
  using EnumTraits = TEnumTraits<::nebula::cpp2::PropertyType>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::nebula::cpp2::ErrorCode>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("common.ErrorCode", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "common.ErrorCode";
  using EnumTraits = TEnumTraits<::nebula::cpp2::ErrorCode>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}

const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::SchemaID>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.SchemaID", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_SchemaID = res.first->second;
  common_SchemaID.name_ref() = "common.SchemaID";
  common_SchemaID.is_union_ref() = true;
  static const EncodedThriftField
  common_SchemaID_fields[] = {
    std::make_tuple(1, "tag_id", false, std::make_unique<Typedef>("common.TagID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "edge_type", false, std::make_unique<Typedef>("common.EdgeType", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_SchemaID_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_SchemaID.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::Date>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.Date", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_Date = res.first->second;
  common_Date.name_ref() = "common.Date";
  common_Date.is_union_ref() = false;
  static const EncodedThriftField
  common_Date_fields[] = {
    std::make_tuple(1, "year", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I16_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "month", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BYTE_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "day", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BYTE_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_Date_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_Date.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::Time>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.Time", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_Time = res.first->second;
  common_Time.name_ref() = "common.Time";
  common_Time.is_union_ref() = false;
  static const EncodedThriftField
  common_Time_fields[] = {
    std::make_tuple(1, "hour", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BYTE_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "minute", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BYTE_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "sec", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BYTE_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "microsec", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_Time_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_Time.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::DateTime>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.DateTime", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_DateTime = res.first->second;
  common_DateTime.name_ref() = "common.DateTime";
  common_DateTime.is_union_ref() = false;
  static const EncodedThriftField
  common_DateTime_fields[] = {
    std::make_tuple(1, "year", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I16_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "month", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BYTE_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "day", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BYTE_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "hour", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BYTE_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "minute", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BYTE_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "sec", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BYTE_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(7, "microsec", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_DateTime_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_DateTime.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::Value>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.Value", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_Value = res.first->second;
  common_Value.name_ref() = "common.Value";
  common_Value.is_union_ref() = true;
  static const EncodedThriftField
  common_Value_fields[] = {
    std::make_tuple(1, "nVal", false, std::make_unique<Enum< ::nebula::cpp2::NullType>>("common.NullType"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "bVal", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "iVal", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "fVal", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_DOUBLE_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "sVal", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "dVal", false, std::make_unique<Struct< ::nebula::cpp2::Date>>("common.Date"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(7, "tVal", false, std::make_unique<Struct< ::nebula::cpp2::Time>>("common.Time"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(8, "dtVal", false, std::make_unique<Struct< ::nebula::cpp2::DateTime>>("common.DateTime"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(9, "vVal", false, std::make_unique<Typedef>("common.Vertex", std::make_unique<Struct< ::nebula::cpp2::Vertex>>("common.Vertex")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(10, "eVal", false, std::make_unique<Typedef>("common.Edge", std::make_unique<Struct< ::nebula::cpp2::Edge>>("common.Edge")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(11, "pVal", false, std::make_unique<Typedef>("common.Path", std::make_unique<Struct< ::nebula::cpp2::Path>>("common.Path")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(12, "lVal", false, std::make_unique<Typedef>("common.NList", std::make_unique<Struct< ::nebula::cpp2::NList>>("common.NList")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(13, "mVal", false, std::make_unique<Typedef>("common.NMap", std::make_unique<Struct< ::nebula::cpp2::NMap>>("common.NMap")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(14, "uVal", false, std::make_unique<Typedef>("common.NSet", std::make_unique<Struct< ::nebula::cpp2::NSet>>("common.NSet")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(15, "gVal", false, std::make_unique<Typedef>("common.DataSet", std::make_unique<Struct< ::nebula::cpp2::DataSet>>("common.DataSet")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(16, "ggVal", false, std::make_unique<Typedef>("common.Geography", std::make_unique<Union< ::nebula::cpp2::Geography>>("common.Geography")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(17, "duVal", false, std::make_unique<Typedef>("common.Duration", std::make_unique<Struct< ::nebula::cpp2::Duration>>("common.Duration")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_Value_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_Value.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::NList>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.NList", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_NList = res.first->second;
  common_NList.name_ref() = "common.NList";
  common_NList.is_union_ref() = false;
  static const EncodedThriftField
  common_NList_fields[] = {
    std::make_tuple(1, "values", false, std::make_unique<List>(std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_NList_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_NList.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::NMap>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.NMap", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_NMap = res.first->second;
  common_NMap.name_ref() = "common.NMap";
  common_NMap.is_union_ref() = false;
  static const EncodedThriftField
  common_NMap_fields[] = {
    std::make_tuple(1, "kvs", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_NMap_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_NMap.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::NSet>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.NSet", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_NSet = res.first->second;
  common_NSet.name_ref() = "common.NSet";
  common_NSet.is_union_ref() = false;
  static const EncodedThriftField
  common_NSet_fields[] = {
    std::make_tuple(1, "values", false, std::make_unique<Set>(std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_NSet_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_NSet.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::Row>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.Row", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_Row = res.first->second;
  common_Row.name_ref() = "common.Row";
  common_Row.is_union_ref() = false;
  static const EncodedThriftField
  common_Row_fields[] = {
    std::make_tuple(1, "values", false, std::make_unique<List>(std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_Row_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_Row.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::DataSet>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.DataSet", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_DataSet = res.first->second;
  common_DataSet.name_ref() = "common.DataSet";
  common_DataSet.is_union_ref() = false;
  static const EncodedThriftField
  common_DataSet_fields[] = {
    std::make_tuple(1, "column_names", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "rows", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::Row>>("common.Row")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_DataSet_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_DataSet.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::Coordinate>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.Coordinate", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_Coordinate = res.first->second;
  common_Coordinate.name_ref() = "common.Coordinate";
  common_Coordinate.is_union_ref() = false;
  static const EncodedThriftField
  common_Coordinate_fields[] = {
    std::make_tuple(1, "x", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_DOUBLE_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "y", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_DOUBLE_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_Coordinate_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_Coordinate.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::Point>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.Point", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_Point = res.first->second;
  common_Point.name_ref() = "common.Point";
  common_Point.is_union_ref() = false;
  static const EncodedThriftField
  common_Point_fields[] = {
    std::make_tuple(1, "coord", false, std::make_unique<Struct< ::nebula::cpp2::Coordinate>>("common.Coordinate"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_Point_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_Point.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::LineString>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.LineString", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_LineString = res.first->second;
  common_LineString.name_ref() = "common.LineString";
  common_LineString.is_union_ref() = false;
  static const EncodedThriftField
  common_LineString_fields[] = {
    std::make_tuple(1, "coordList", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::Coordinate>>("common.Coordinate")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_LineString_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_LineString.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::Polygon>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.Polygon", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_Polygon = res.first->second;
  common_Polygon.name_ref() = "common.Polygon";
  common_Polygon.is_union_ref() = false;
  static const EncodedThriftField
  common_Polygon_fields[] = {
    std::make_tuple(1, "coordListList", false, std::make_unique<List>(std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::Coordinate>>("common.Coordinate"))), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_Polygon_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_Polygon.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::Geography>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.Geography", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_Geography = res.first->second;
  common_Geography.name_ref() = "common.Geography";
  common_Geography.is_union_ref() = true;
  static const EncodedThriftField
  common_Geography_fields[] = {
    std::make_tuple(1, "ptVal", false, std::make_unique<Struct< ::nebula::cpp2::Point>>("common.Point"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "lsVal", false, std::make_unique<Struct< ::nebula::cpp2::LineString>>("common.LineString"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "pgVal", false, std::make_unique<Struct< ::nebula::cpp2::Polygon>>("common.Polygon"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_Geography_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_Geography.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::Tag>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.Tag", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_Tag = res.first->second;
  common_Tag.name_ref() = "common.Tag";
  common_Tag.is_union_ref() = false;
  static const EncodedThriftField
  common_Tag_fields[] = {
    std::make_tuple(1, "name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "props", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_Tag_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_Tag.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::Vertex>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.Vertex", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_Vertex = res.first->second;
  common_Vertex.name_ref() = "common.Vertex";
  common_Vertex.is_union_ref() = false;
  static const EncodedThriftField
  common_Vertex_fields[] = {
    std::make_tuple(1, "vid", false, std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "tags", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::Tag>>("common.Tag")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_Vertex_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_Vertex.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::Edge>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.Edge", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_Edge = res.first->second;
  common_Edge.name_ref() = "common.Edge";
  common_Edge.is_union_ref() = false;
  static const EncodedThriftField
  common_Edge_fields[] = {
    std::make_tuple(1, "src", false, std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "dst", false, std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "type", false, std::make_unique<Typedef>("common.EdgeType", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "ranking", false, std::make_unique<Typedef>("common.EdgeRanking", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "props", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_Edge_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_Edge.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::Step>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.Step", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_Step = res.first->second;
  common_Step.name_ref() = "common.Step";
  common_Step.is_union_ref() = false;
  static const EncodedThriftField
  common_Step_fields[] = {
    std::make_tuple(1, "dst", false, std::make_unique<Struct< ::nebula::cpp2::Vertex>>("common.Vertex"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "type", false, std::make_unique<Typedef>("common.EdgeType", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "name", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "ranking", false, std::make_unique<Typedef>("common.EdgeRanking", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "props", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::make_unique<Union< ::nebula::cpp2::Value>>("common.Value")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_Step_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_Step.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::Path>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.Path", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_Path = res.first->second;
  common_Path.name_ref() = "common.Path";
  common_Path.is_union_ref() = false;
  static const EncodedThriftField
  common_Path_fields[] = {
    std::make_tuple(1, "src", false, std::make_unique<Struct< ::nebula::cpp2::Vertex>>("common.Vertex"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "steps", false, std::make_unique<List>(std::make_unique<Struct< ::nebula::cpp2::Step>>("common.Step")), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_Path_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_Path.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::HostAddr>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.HostAddr", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_HostAddr = res.first->second;
  common_HostAddr.name_ref() = "common.HostAddr";
  common_HostAddr.is_union_ref() = false;
  static const EncodedThriftField
  common_HostAddr_fields[] = {
    std::make_tuple(1, "host", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "port", false, std::make_unique<Typedef>("common.Port", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_HostAddr_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_HostAddr.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::KeyValue>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.KeyValue", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_KeyValue = res.first->second;
  common_KeyValue.name_ref() = "common.KeyValue";
  common_KeyValue.is_union_ref() = false;
  static const EncodedThriftField
  common_KeyValue_fields[] = {
    std::make_tuple(1, "key", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "value", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_KeyValue_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_KeyValue.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::Duration>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.Duration", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_Duration = res.first->second;
  common_Duration.name_ref() = "common.Duration";
  common_Duration.is_union_ref() = false;
  static const EncodedThriftField
  common_Duration_fields[] = {
    std::make_tuple(1, "seconds", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "microseconds", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "months", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_Duration_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_Duration.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::LogInfo>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.LogInfo", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_LogInfo = res.first->second;
  common_LogInfo.name_ref() = "common.LogInfo";
  common_LogInfo.is_union_ref() = false;
  static const EncodedThriftField
  common_LogInfo_fields[] = {
    std::make_tuple(1, "log_id", false, std::make_unique<Typedef>("common.LogID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "term_id", false, std::make_unique<Typedef>("common.TermID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_LogInfo_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_LogInfo.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::DirInfo>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.DirInfo", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_DirInfo = res.first->second;
  common_DirInfo.name_ref() = "common.DirInfo";
  common_DirInfo.is_union_ref() = false;
  static const EncodedThriftField
  common_DirInfo_fields[] = {
    std::make_tuple(1, "root", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "data", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_DirInfo_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_DirInfo.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::CheckpointInfo>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.CheckpointInfo", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_CheckpointInfo = res.first->second;
  common_CheckpointInfo.name_ref() = "common.CheckpointInfo";
  common_CheckpointInfo.is_union_ref() = false;
  static const EncodedThriftField
  common_CheckpointInfo_fields[] = {
    std::make_tuple(1, "space_id", false, std::make_unique<Typedef>("common.GraphSpaceID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "parts", false, std::make_unique<Map>(std::make_unique<Typedef>("common.PartitionID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::make_unique<Struct< ::nebula::cpp2::LogInfo>>("common.LogInfo")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "path", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_CheckpointInfo_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_CheckpointInfo.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::nebula::cpp2::LogEntry>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("common.LogEntry", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& common_LogEntry = res.first->second;
  common_LogEntry.name_ref() = "common.LogEntry";
  common_LogEntry.is_union_ref() = false;
  static const EncodedThriftField
  common_LogEntry_fields[] = {
    std::make_tuple(1, "cluster", false, std::make_unique<Typedef>("common.ClusterID", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "log_str", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : common_LogEntry_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    common_LogEntry.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}

} // namespace md
} // namespace detail
} // namespace thrift
} // namespace apache
