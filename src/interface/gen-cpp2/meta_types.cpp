/**
 * Autogenerated by Thrift for meta.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "meta_types.h"
#include "meta_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "meta_data.h"


namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::meta::cpp2::AlterSchemaOp>::size;
folly::Range<::nebula::meta::cpp2::AlterSchemaOp const*> const TEnumTraits<::nebula::meta::cpp2::AlterSchemaOp>::values = folly::range(TEnumDataStorage<::nebula::meta::cpp2::AlterSchemaOp>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::meta::cpp2::AlterSchemaOp>::names = folly::range(TEnumDataStorage<::nebula::meta::cpp2::AlterSchemaOp>::names);

char const* TEnumTraits<::nebula::meta::cpp2::AlterSchemaOp>::findName(type value) {
  using factory = ::nebula::meta::cpp2::_AlterSchemaOp_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::meta::cpp2::AlterSchemaOp>::findValue(char const* name, type* out) {
  using factory = ::nebula::meta::cpp2::_AlterSchemaOp_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace meta { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _AlterSchemaOp_EnumMapFactory::ValuesToNamesMapType _AlterSchemaOp_VALUES_TO_NAMES = _AlterSchemaOp_EnumMapFactory::makeValuesToNamesMap();
const _AlterSchemaOp_EnumMapFactory::NamesToValuesMapType _AlterSchemaOp_NAMES_TO_VALUES = _AlterSchemaOp_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::meta::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::meta::cpp2::RoleType>::size;
folly::Range<::nebula::meta::cpp2::RoleType const*> const TEnumTraits<::nebula::meta::cpp2::RoleType>::values = folly::range(TEnumDataStorage<::nebula::meta::cpp2::RoleType>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::meta::cpp2::RoleType>::names = folly::range(TEnumDataStorage<::nebula::meta::cpp2::RoleType>::names);

char const* TEnumTraits<::nebula::meta::cpp2::RoleType>::findName(type value) {
  using factory = ::nebula::meta::cpp2::_RoleType_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::meta::cpp2::RoleType>::findValue(char const* name, type* out) {
  using factory = ::nebula::meta::cpp2::_RoleType_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace meta { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _RoleType_EnumMapFactory::ValuesToNamesMapType _RoleType_VALUES_TO_NAMES = _RoleType_EnumMapFactory::makeValuesToNamesMap();
const _RoleType_EnumMapFactory::NamesToValuesMapType _RoleType_NAMES_TO_VALUES = _RoleType_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::meta::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::meta::cpp2::GeoShape>::size;
folly::Range<::nebula::meta::cpp2::GeoShape const*> const TEnumTraits<::nebula::meta::cpp2::GeoShape>::values = folly::range(TEnumDataStorage<::nebula::meta::cpp2::GeoShape>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::meta::cpp2::GeoShape>::names = folly::range(TEnumDataStorage<::nebula::meta::cpp2::GeoShape>::names);

char const* TEnumTraits<::nebula::meta::cpp2::GeoShape>::findName(type value) {
  using factory = ::nebula::meta::cpp2::_GeoShape_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::meta::cpp2::GeoShape>::findValue(char const* name, type* out) {
  using factory = ::nebula::meta::cpp2::_GeoShape_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace meta { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _GeoShape_EnumMapFactory::ValuesToNamesMapType _GeoShape_VALUES_TO_NAMES = _GeoShape_EnumMapFactory::makeValuesToNamesMap();
const _GeoShape_EnumMapFactory::NamesToValuesMapType _GeoShape_NAMES_TO_VALUES = _GeoShape_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::meta::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::meta::cpp2::IsolationLevel>::size;
folly::Range<::nebula::meta::cpp2::IsolationLevel const*> const TEnumTraits<::nebula::meta::cpp2::IsolationLevel>::values = folly::range(TEnumDataStorage<::nebula::meta::cpp2::IsolationLevel>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::meta::cpp2::IsolationLevel>::names = folly::range(TEnumDataStorage<::nebula::meta::cpp2::IsolationLevel>::names);

char const* TEnumTraits<::nebula::meta::cpp2::IsolationLevel>::findName(type value) {
  using factory = ::nebula::meta::cpp2::_IsolationLevel_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::meta::cpp2::IsolationLevel>::findValue(char const* name, type* out) {
  using factory = ::nebula::meta::cpp2::_IsolationLevel_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace meta { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _IsolationLevel_EnumMapFactory::ValuesToNamesMapType _IsolationLevel_VALUES_TO_NAMES = _IsolationLevel_EnumMapFactory::makeValuesToNamesMap();
const _IsolationLevel_EnumMapFactory::NamesToValuesMapType _IsolationLevel_NAMES_TO_VALUES = _IsolationLevel_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::meta::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::meta::cpp2::HostStatus>::size;
folly::Range<::nebula::meta::cpp2::HostStatus const*> const TEnumTraits<::nebula::meta::cpp2::HostStatus>::values = folly::range(TEnumDataStorage<::nebula::meta::cpp2::HostStatus>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::meta::cpp2::HostStatus>::names = folly::range(TEnumDataStorage<::nebula::meta::cpp2::HostStatus>::names);

char const* TEnumTraits<::nebula::meta::cpp2::HostStatus>::findName(type value) {
  using factory = ::nebula::meta::cpp2::_HostStatus_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::meta::cpp2::HostStatus>::findValue(char const* name, type* out) {
  using factory = ::nebula::meta::cpp2::_HostStatus_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace meta { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _HostStatus_EnumMapFactory::ValuesToNamesMapType _HostStatus_VALUES_TO_NAMES = _HostStatus_EnumMapFactory::makeValuesToNamesMap();
const _HostStatus_EnumMapFactory::NamesToValuesMapType _HostStatus_NAMES_TO_VALUES = _HostStatus_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::meta::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::meta::cpp2::SnapshotStatus>::size;
folly::Range<::nebula::meta::cpp2::SnapshotStatus const*> const TEnumTraits<::nebula::meta::cpp2::SnapshotStatus>::values = folly::range(TEnumDataStorage<::nebula::meta::cpp2::SnapshotStatus>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::meta::cpp2::SnapshotStatus>::names = folly::range(TEnumDataStorage<::nebula::meta::cpp2::SnapshotStatus>::names);

char const* TEnumTraits<::nebula::meta::cpp2::SnapshotStatus>::findName(type value) {
  using factory = ::nebula::meta::cpp2::_SnapshotStatus_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::meta::cpp2::SnapshotStatus>::findValue(char const* name, type* out) {
  using factory = ::nebula::meta::cpp2::_SnapshotStatus_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace meta { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _SnapshotStatus_EnumMapFactory::ValuesToNamesMapType _SnapshotStatus_VALUES_TO_NAMES = _SnapshotStatus_EnumMapFactory::makeValuesToNamesMap();
const _SnapshotStatus_EnumMapFactory::NamesToValuesMapType _SnapshotStatus_NAMES_TO_VALUES = _SnapshotStatus_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::meta::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::meta::cpp2::AdminJobOp>::size;
folly::Range<::nebula::meta::cpp2::AdminJobOp const*> const TEnumTraits<::nebula::meta::cpp2::AdminJobOp>::values = folly::range(TEnumDataStorage<::nebula::meta::cpp2::AdminJobOp>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::meta::cpp2::AdminJobOp>::names = folly::range(TEnumDataStorage<::nebula::meta::cpp2::AdminJobOp>::names);

char const* TEnumTraits<::nebula::meta::cpp2::AdminJobOp>::findName(type value) {
  using factory = ::nebula::meta::cpp2::_AdminJobOp_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::meta::cpp2::AdminJobOp>::findValue(char const* name, type* out) {
  using factory = ::nebula::meta::cpp2::_AdminJobOp_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace meta { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _AdminJobOp_EnumMapFactory::ValuesToNamesMapType _AdminJobOp_VALUES_TO_NAMES = _AdminJobOp_EnumMapFactory::makeValuesToNamesMap();
const _AdminJobOp_EnumMapFactory::NamesToValuesMapType _AdminJobOp_NAMES_TO_VALUES = _AdminJobOp_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::meta::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::meta::cpp2::AdminCmd>::size;
folly::Range<::nebula::meta::cpp2::AdminCmd const*> const TEnumTraits<::nebula::meta::cpp2::AdminCmd>::values = folly::range(TEnumDataStorage<::nebula::meta::cpp2::AdminCmd>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::meta::cpp2::AdminCmd>::names = folly::range(TEnumDataStorage<::nebula::meta::cpp2::AdminCmd>::names);

char const* TEnumTraits<::nebula::meta::cpp2::AdminCmd>::findName(type value) {
  using factory = ::nebula::meta::cpp2::_AdminCmd_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::meta::cpp2::AdminCmd>::findValue(char const* name, type* out) {
  using factory = ::nebula::meta::cpp2::_AdminCmd_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace meta { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _AdminCmd_EnumMapFactory::ValuesToNamesMapType _AdminCmd_VALUES_TO_NAMES = _AdminCmd_EnumMapFactory::makeValuesToNamesMap();
const _AdminCmd_EnumMapFactory::NamesToValuesMapType _AdminCmd_NAMES_TO_VALUES = _AdminCmd_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::meta::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::meta::cpp2::JobStatus>::size;
folly::Range<::nebula::meta::cpp2::JobStatus const*> const TEnumTraits<::nebula::meta::cpp2::JobStatus>::values = folly::range(TEnumDataStorage<::nebula::meta::cpp2::JobStatus>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::meta::cpp2::JobStatus>::names = folly::range(TEnumDataStorage<::nebula::meta::cpp2::JobStatus>::names);

char const* TEnumTraits<::nebula::meta::cpp2::JobStatus>::findName(type value) {
  using factory = ::nebula::meta::cpp2::_JobStatus_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::meta::cpp2::JobStatus>::findValue(char const* name, type* out) {
  using factory = ::nebula::meta::cpp2::_JobStatus_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace meta { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _JobStatus_EnumMapFactory::ValuesToNamesMapType _JobStatus_VALUES_TO_NAMES = _JobStatus_EnumMapFactory::makeValuesToNamesMap();
const _JobStatus_EnumMapFactory::NamesToValuesMapType _JobStatus_NAMES_TO_VALUES = _JobStatus_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::meta::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::meta::cpp2::ListHostType>::size;
folly::Range<::nebula::meta::cpp2::ListHostType const*> const TEnumTraits<::nebula::meta::cpp2::ListHostType>::values = folly::range(TEnumDataStorage<::nebula::meta::cpp2::ListHostType>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::meta::cpp2::ListHostType>::names = folly::range(TEnumDataStorage<::nebula::meta::cpp2::ListHostType>::names);

char const* TEnumTraits<::nebula::meta::cpp2::ListHostType>::findName(type value) {
  using factory = ::nebula::meta::cpp2::_ListHostType_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::meta::cpp2::ListHostType>::findValue(char const* name, type* out) {
  using factory = ::nebula::meta::cpp2::_ListHostType_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace meta { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _ListHostType_EnumMapFactory::ValuesToNamesMapType _ListHostType_VALUES_TO_NAMES = _ListHostType_EnumMapFactory::makeValuesToNamesMap();
const _ListHostType_EnumMapFactory::NamesToValuesMapType _ListHostType_NAMES_TO_VALUES = _ListHostType_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::meta::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::meta::cpp2::HostRole>::size;
folly::Range<::nebula::meta::cpp2::HostRole const*> const TEnumTraits<::nebula::meta::cpp2::HostRole>::values = folly::range(TEnumDataStorage<::nebula::meta::cpp2::HostRole>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::meta::cpp2::HostRole>::names = folly::range(TEnumDataStorage<::nebula::meta::cpp2::HostRole>::names);

char const* TEnumTraits<::nebula::meta::cpp2::HostRole>::findName(type value) {
  using factory = ::nebula::meta::cpp2::_HostRole_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::meta::cpp2::HostRole>::findValue(char const* name, type* out) {
  using factory = ::nebula::meta::cpp2::_HostRole_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace meta { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _HostRole_EnumMapFactory::ValuesToNamesMapType _HostRole_VALUES_TO_NAMES = _HostRole_EnumMapFactory::makeValuesToNamesMap();
const _HostRole_EnumMapFactory::NamesToValuesMapType _HostRole_NAMES_TO_VALUES = _HostRole_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::meta::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::meta::cpp2::TaskResult>::size;
folly::Range<::nebula::meta::cpp2::TaskResult const*> const TEnumTraits<::nebula::meta::cpp2::TaskResult>::values = folly::range(TEnumDataStorage<::nebula::meta::cpp2::TaskResult>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::meta::cpp2::TaskResult>::names = folly::range(TEnumDataStorage<::nebula::meta::cpp2::TaskResult>::names);

char const* TEnumTraits<::nebula::meta::cpp2::TaskResult>::findName(type value) {
  using factory = ::nebula::meta::cpp2::_TaskResult_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::meta::cpp2::TaskResult>::findValue(char const* name, type* out) {
  using factory = ::nebula::meta::cpp2::_TaskResult_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace meta { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _TaskResult_EnumMapFactory::ValuesToNamesMapType _TaskResult_VALUES_TO_NAMES = _TaskResult_EnumMapFactory::makeValuesToNamesMap();
const _TaskResult_EnumMapFactory::NamesToValuesMapType _TaskResult_NAMES_TO_VALUES = _TaskResult_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::meta::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::meta::cpp2::ConfigModule>::size;
folly::Range<::nebula::meta::cpp2::ConfigModule const*> const TEnumTraits<::nebula::meta::cpp2::ConfigModule>::values = folly::range(TEnumDataStorage<::nebula::meta::cpp2::ConfigModule>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::meta::cpp2::ConfigModule>::names = folly::range(TEnumDataStorage<::nebula::meta::cpp2::ConfigModule>::names);

char const* TEnumTraits<::nebula::meta::cpp2::ConfigModule>::findName(type value) {
  using factory = ::nebula::meta::cpp2::_ConfigModule_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::meta::cpp2::ConfigModule>::findValue(char const* name, type* out) {
  using factory = ::nebula::meta::cpp2::_ConfigModule_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace meta { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _ConfigModule_EnumMapFactory::ValuesToNamesMapType _ConfigModule_VALUES_TO_NAMES = _ConfigModule_EnumMapFactory::makeValuesToNamesMap();
const _ConfigModule_EnumMapFactory::NamesToValuesMapType _ConfigModule_NAMES_TO_VALUES = _ConfigModule_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::meta::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::meta::cpp2::ConfigMode>::size;
folly::Range<::nebula::meta::cpp2::ConfigMode const*> const TEnumTraits<::nebula::meta::cpp2::ConfigMode>::values = folly::range(TEnumDataStorage<::nebula::meta::cpp2::ConfigMode>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::meta::cpp2::ConfigMode>::names = folly::range(TEnumDataStorage<::nebula::meta::cpp2::ConfigMode>::names);

char const* TEnumTraits<::nebula::meta::cpp2::ConfigMode>::findName(type value) {
  using factory = ::nebula::meta::cpp2::_ConfigMode_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::meta::cpp2::ConfigMode>::findValue(char const* name, type* out) {
  using factory = ::nebula::meta::cpp2::_ConfigMode_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace meta { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _ConfigMode_EnumMapFactory::ValuesToNamesMapType _ConfigMode_VALUES_TO_NAMES = _ConfigMode_EnumMapFactory::makeValuesToNamesMap();
const _ConfigMode_EnumMapFactory::NamesToValuesMapType _ConfigMode_NAMES_TO_VALUES = _ConfigMode_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::meta::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::meta::cpp2::ListenerType>::size;
folly::Range<::nebula::meta::cpp2::ListenerType const*> const TEnumTraits<::nebula::meta::cpp2::ListenerType>::values = folly::range(TEnumDataStorage<::nebula::meta::cpp2::ListenerType>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::meta::cpp2::ListenerType>::names = folly::range(TEnumDataStorage<::nebula::meta::cpp2::ListenerType>::names);

char const* TEnumTraits<::nebula::meta::cpp2::ListenerType>::findName(type value) {
  using factory = ::nebula::meta::cpp2::_ListenerType_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::meta::cpp2::ListenerType>::findValue(char const* name, type* out) {
  using factory = ::nebula::meta::cpp2::_ListenerType_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace meta { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _ListenerType_EnumMapFactory::ValuesToNamesMapType _ListenerType_VALUES_TO_NAMES = _ListenerType_EnumMapFactory::makeValuesToNamesMap();
const _ListenerType_EnumMapFactory::NamesToValuesMapType _ListenerType_NAMES_TO_VALUES = _ListenerType_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::meta::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::meta::cpp2::FTServiceType>::size;
folly::Range<::nebula::meta::cpp2::FTServiceType const*> const TEnumTraits<::nebula::meta::cpp2::FTServiceType>::values = folly::range(TEnumDataStorage<::nebula::meta::cpp2::FTServiceType>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::meta::cpp2::FTServiceType>::names = folly::range(TEnumDataStorage<::nebula::meta::cpp2::FTServiceType>::names);

char const* TEnumTraits<::nebula::meta::cpp2::FTServiceType>::findName(type value) {
  using factory = ::nebula::meta::cpp2::_FTServiceType_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::meta::cpp2::FTServiceType>::findValue(char const* name, type* out) {
  using factory = ::nebula::meta::cpp2::_FTServiceType_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace meta { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _FTServiceType_EnumMapFactory::ValuesToNamesMapType _FTServiceType_VALUES_TO_NAMES = _FTServiceType_EnumMapFactory::makeValuesToNamesMap();
const _FTServiceType_EnumMapFactory::NamesToValuesMapType _FTServiceType_NAMES_TO_VALUES = _FTServiceType_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::meta::cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::meta::cpp2::QueryStatus>::size;
folly::Range<::nebula::meta::cpp2::QueryStatus const*> const TEnumTraits<::nebula::meta::cpp2::QueryStatus>::values = folly::range(TEnumDataStorage<::nebula::meta::cpp2::QueryStatus>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::meta::cpp2::QueryStatus>::names = folly::range(TEnumDataStorage<::nebula::meta::cpp2::QueryStatus>::names);

char const* TEnumTraits<::nebula::meta::cpp2::QueryStatus>::findName(type value) {
  using factory = ::nebula::meta::cpp2::_QueryStatus_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::meta::cpp2::QueryStatus>::findValue(char const* name, type* out) {
  using factory = ::nebula::meta::cpp2::_QueryStatus_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace nebula { namespace meta { namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _QueryStatus_EnumMapFactory::ValuesToNamesMapType _QueryStatus_VALUES_TO_NAMES = _QueryStatus_EnumMapFactory::makeValuesToNamesMap();
const _QueryStatus_EnumMapFactory::NamesToValuesMapType _QueryStatus_NAMES_TO_VALUES = _QueryStatus_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ID>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ID>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::nebula::meta::cpp2::ID::Type>::size;
folly::Range<::nebula::meta::cpp2::ID::Type const*> const TEnumTraits<::nebula::meta::cpp2::ID::Type>::values = folly::range(TEnumDataStorage<::nebula::meta::cpp2::ID::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::nebula::meta::cpp2::ID::Type>::names = folly::range(TEnumDataStorage<::nebula::meta::cpp2::ID::Type>::names);

char const* TEnumTraits<::nebula::meta::cpp2::ID::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::nebula::meta::cpp2::ID::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::nebula::meta::cpp2::ID::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::nebula::meta::cpp2::ID::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace nebula { namespace meta { namespace cpp2 {

void ID::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::space_id:
      destruct(value_.space_id);
      break;
    case Type::tag_id:
      destruct(value_.tag_id);
      break;
    case Type::edge_type:
      destruct(value_.edge_type);
      break;
    case Type::index_id:
      destruct(value_.index_id);
      break;
    case Type::cluster_id:
      destruct(value_.cluster_id);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool ID::operator==(const ID& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::space_id:
      return value_.space_id == rhs.value_.space_id;
    case Type::tag_id:
      return value_.tag_id == rhs.value_.tag_id;
    case Type::edge_type:
      return value_.edge_type == rhs.value_.edge_type;
    case Type::index_id:
      return value_.index_id == rhs.value_.index_id;
    case Type::cluster_id:
      return value_.cluster_id == rhs.value_.cluster_id;
    default:
      return true;
  }
}

bool ID::operator<(const ID& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::space_id:
      return lhs.value_.space_id < rhs.value_.space_id;
    case Type::tag_id:
      return lhs.value_.tag_id < rhs.value_.tag_id;
    case Type::edge_type:
      return lhs.value_.edge_type < rhs.value_.edge_type;
    case Type::index_id:
      return lhs.value_.index_id < rhs.value_.index_id;
    case Type::cluster_id:
      return lhs.value_.cluster_id < rhs.value_.cluster_id;
    default:
      return false;
  }
}

void swap(ID& a, ID& b) {
  ID temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void ID::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ID::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ID::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ID::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ID::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ID::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ID::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ID::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ColumnTypeDef>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ColumnTypeDef>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ColumnTypeDef::ColumnTypeDef(apache::thrift::FragileConstructor,  ::nebula::cpp2::PropertyType type__arg, int16_t type_length__arg,  ::nebula::meta::cpp2::GeoShape geo_shape__arg) :
    type(std::move(type__arg)),
    type_length(std::move(type_length__arg)),
    geo_shape(std::move(geo_shape__arg)) {
  __isset.type_length = true;
  __isset.geo_shape = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ColumnTypeDef::__clear() {
  // clear all fields
  type =  ::nebula::cpp2::PropertyType::UNKNOWN;
  type_length = static_cast<int16_t>(0);
  geo_shape =  ::nebula::meta::cpp2::GeoShape::ANY;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ColumnTypeDef::operator==(const ColumnTypeDef& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.type == rhs.type)) {
    return false;
  }
  if (lhs.type_length_ref() != rhs.type_length_ref()) {
    return false;
  }
  if (lhs.geo_shape_ref() != rhs.geo_shape_ref()) {
    return false;
  }
  return true;
}

bool ColumnTypeDef::operator<(const ColumnTypeDef& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.type == rhs.type)) {
    return lhs.type < rhs.type;
  }
  if (lhs.type_length_ref() != rhs.type_length_ref()) {
    return lhs.type_length_ref() < rhs.type_length_ref();
  }
  if (lhs.geo_shape_ref() != rhs.geo_shape_ref()) {
    return lhs.geo_shape_ref() < rhs.geo_shape_ref();
  }
  return false;
}


void swap(ColumnTypeDef& a, ColumnTypeDef& b) {
  using ::std::swap;
  swap(a.type_ref().value(), b.type_ref().value());
  swap(a.type_length_ref().value_unchecked(), b.type_length_ref().value_unchecked());
  swap(a.geo_shape_ref().value_unchecked(), b.geo_shape_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ColumnTypeDef::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ColumnTypeDef::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ColumnTypeDef::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ColumnTypeDef::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ColumnTypeDef::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ColumnTypeDef::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ColumnTypeDef::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ColumnTypeDef::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ColumnDef>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ColumnDef>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ColumnDef::ColumnDef() :
      nullable(false) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


ColumnDef::~ColumnDef() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ColumnDef::ColumnDef(apache::thrift::FragileConstructor, ::std::string name__arg,  ::nebula::meta::cpp2::ColumnTypeDef type__arg, ::std::string default_value__arg, bool nullable__arg, ::std::string comment__arg) :
    name(std::move(name__arg)),
    type(std::move(type__arg)),
    default_value(std::move(default_value__arg)),
    nullable(std::move(nullable__arg)),
    comment(std::move(comment__arg)) {
  __isset.default_value = true;
  __isset.nullable = true;
  __isset.comment = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ColumnDef::__clear() {
  // clear all fields
  name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  type.__clear();
  default_value = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  nullable = false;
  comment = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ColumnDef::operator==(const ColumnDef& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return false;
  }
  if (!(lhs.type == rhs.type)) {
    return false;
  }
  if (lhs.default_value_ref().has_value() != rhs.default_value_ref().has_value()) {
    return false;
  }
  if (lhs.default_value_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.default_value, rhs.default_value)) {
      return false;
    }
  }
  if (lhs.nullable_ref() != rhs.nullable_ref()) {
    return false;
  }
  if (lhs.comment_ref().has_value() != rhs.comment_ref().has_value()) {
    return false;
  }
  if (lhs.comment_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.comment, rhs.comment)) {
      return false;
    }
  }
  return true;
}

bool ColumnDef::operator<(const ColumnDef& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.name, rhs.name);
  }
  if (!(lhs.type == rhs.type)) {
    return lhs.type < rhs.type;
  }
  if (lhs.default_value_ref().has_value() != rhs.default_value_ref().has_value()) {
    return lhs.default_value_ref().has_value() < rhs.default_value_ref().has_value();
  }
  if (lhs.default_value_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.default_value, rhs.default_value)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.default_value, rhs.default_value);
    }
  }
  if (lhs.nullable_ref() != rhs.nullable_ref()) {
    return lhs.nullable_ref() < rhs.nullable_ref();
  }
  if (lhs.comment_ref().has_value() != rhs.comment_ref().has_value()) {
    return lhs.comment_ref().has_value() < rhs.comment_ref().has_value();
  }
  if (lhs.comment_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.comment, rhs.comment)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.comment, rhs.comment);
    }
  }
  return false;
}

const  ::nebula::meta::cpp2::ColumnTypeDef& ColumnDef::get_type() const& {
  return type;
}

 ::nebula::meta::cpp2::ColumnTypeDef ColumnDef::get_type() && {
  return std::move(type);
}


void swap(ColumnDef& a, ColumnDef& b) {
  using ::std::swap;
  swap(a.name_ref().value(), b.name_ref().value());
  swap(a.type_ref().value(), b.type_ref().value());
  swap(a.default_value_ref().value_unchecked(), b.default_value_ref().value_unchecked());
  swap(a.nullable_ref().value_unchecked(), b.nullable_ref().value_unchecked());
  swap(a.comment_ref().value_unchecked(), b.comment_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ColumnDef::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ColumnDef::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ColumnDef::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ColumnDef::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ColumnDef::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ColumnDef::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ColumnDef::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ColumnDef::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ColumnDef,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::ColumnTypeDef>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ColumnDef,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::ColumnTypeDef>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::SchemaProp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::SchemaProp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
SchemaProp::SchemaProp(apache::thrift::FragileConstructor, int64_t ttl_duration__arg, ::std::string ttl_col__arg, ::std::string comment__arg) :
    ttl_duration(std::move(ttl_duration__arg)),
    ttl_col(std::move(ttl_col__arg)),
    comment(std::move(comment__arg)) {
  __isset.ttl_duration = true;
  __isset.ttl_col = true;
  __isset.comment = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void SchemaProp::__clear() {
  // clear all fields
  ttl_duration = 0;
  ttl_col = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  comment = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool SchemaProp::operator==(const SchemaProp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.ttl_duration_ref() != rhs.ttl_duration_ref()) {
    return false;
  }
  if (lhs.ttl_col_ref().has_value() != rhs.ttl_col_ref().has_value()) {
    return false;
  }
  if (lhs.ttl_col_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.ttl_col, rhs.ttl_col)) {
      return false;
    }
  }
  if (lhs.comment_ref().has_value() != rhs.comment_ref().has_value()) {
    return false;
  }
  if (lhs.comment_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.comment, rhs.comment)) {
      return false;
    }
  }
  return true;
}

bool SchemaProp::operator<(const SchemaProp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.ttl_duration_ref() != rhs.ttl_duration_ref()) {
    return lhs.ttl_duration_ref() < rhs.ttl_duration_ref();
  }
  if (lhs.ttl_col_ref().has_value() != rhs.ttl_col_ref().has_value()) {
    return lhs.ttl_col_ref().has_value() < rhs.ttl_col_ref().has_value();
  }
  if (lhs.ttl_col_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.ttl_col, rhs.ttl_col)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.ttl_col, rhs.ttl_col);
    }
  }
  if (lhs.comment_ref().has_value() != rhs.comment_ref().has_value()) {
    return lhs.comment_ref().has_value() < rhs.comment_ref().has_value();
  }
  if (lhs.comment_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.comment, rhs.comment)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.comment, rhs.comment);
    }
  }
  return false;
}


void swap(SchemaProp& a, SchemaProp& b) {
  using ::std::swap;
  swap(a.ttl_duration_ref().value_unchecked(), b.ttl_duration_ref().value_unchecked());
  swap(a.ttl_col_ref().value_unchecked(), b.ttl_col_ref().value_unchecked());
  swap(a.comment_ref().value_unchecked(), b.comment_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void SchemaProp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t SchemaProp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t SchemaProp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t SchemaProp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void SchemaProp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t SchemaProp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t SchemaProp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t SchemaProp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::Schema>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::Schema>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Schema::Schema(apache::thrift::FragileConstructor, ::std::vector< ::nebula::meta::cpp2::ColumnDef> columns__arg,  ::nebula::meta::cpp2::SchemaProp schema_prop__arg) :
    columns(std::move(columns__arg)),
    schema_prop(std::move(schema_prop__arg)) {
  __isset.columns = true;
  __isset.schema_prop = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Schema::__clear() {
  // clear all fields
  columns.clear();
  schema_prop.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool Schema::operator==(const Schema& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.columns == rhs.columns)) {
    return false;
  }
  if (!(lhs.schema_prop == rhs.schema_prop)) {
    return false;
  }
  return true;
}

bool Schema::operator<(const Schema& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.columns == rhs.columns)) {
    return lhs.columns < rhs.columns;
  }
  if (!(lhs.schema_prop == rhs.schema_prop)) {
    return lhs.schema_prop < rhs.schema_prop;
  }
  return false;
}

const ::std::vector< ::nebula::meta::cpp2::ColumnDef>& Schema::get_columns() const& {
  return columns;
}

::std::vector< ::nebula::meta::cpp2::ColumnDef> Schema::get_columns() && {
  return std::move(columns);
}

const  ::nebula::meta::cpp2::SchemaProp& Schema::get_schema_prop() const& {
  return schema_prop;
}

 ::nebula::meta::cpp2::SchemaProp Schema::get_schema_prop() && {
  return std::move(schema_prop);
}


void swap(Schema& a, Schema& b) {
  using ::std::swap;
  swap(a.columns_ref().value(), b.columns_ref().value());
  swap(a.schema_prop_ref().value(), b.schema_prop_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void Schema::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Schema::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Schema::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Schema::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Schema::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Schema::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Schema::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Schema::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Schema,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::ColumnDef>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Schema,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::SchemaProp>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Schema,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::ColumnDef>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Schema,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::SchemaProp>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::IdName>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::IdName>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
IdName::IdName(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::ID id__arg, ::std::string name__arg) :
    id(std::move(id__arg)),
    name(std::move(name__arg)) {
  __isset.id = true;
  __isset.name = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void IdName::__clear() {
  // clear all fields
  id.__clear();
  name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool IdName::operator==(const IdName& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.id == rhs.id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return false;
  }
  return true;
}

bool IdName::operator<(const IdName& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.id == rhs.id)) {
    return lhs.id < rhs.id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.name, rhs.name);
  }
  return false;
}

const  ::nebula::meta::cpp2::ID& IdName::get_id() const& {
  return id;
}

 ::nebula::meta::cpp2::ID IdName::get_id() && {
  return std::move(id);
}


void swap(IdName& a, IdName& b) {
  using ::std::swap;
  swap(a.id_ref().value(), b.id_ref().value());
  swap(a.name_ref().value(), b.name_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void IdName::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t IdName::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t IdName::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t IdName::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void IdName::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t IdName::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t IdName::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t IdName::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        IdName,
        ::apache::thrift::type_class::variant,
         ::nebula::meta::cpp2::ID>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        IdName,
        ::apache::thrift::type_class::variant,
         ::nebula::meta::cpp2::ID>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::SpaceDesc>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::SpaceDesc>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
SpaceDesc::SpaceDesc() :
      partition_num(0),
      replica_factor(0),
      vid_type(::apache::thrift::detail::make_constant< ::nebula::meta::cpp2::ColumnTypeDef>(::apache::thrift::type_class::structure{}, ::apache::thrift::detail::wrap_struct_argument<::apache::thrift::tag::type>( ::nebula::cpp2::PropertyType::FIXED_STRING), ::apache::thrift::detail::wrap_struct_argument<::apache::thrift::tag::type_length>(static_cast<int16_t>(8)))),
      isolation_level( ::nebula::meta::cpp2::IsolationLevel::DEFAULT) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


SpaceDesc::~SpaceDesc() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
SpaceDesc::SpaceDesc(apache::thrift::FragileConstructor, ::std::string space_name__arg, int32_t partition_num__arg, int32_t replica_factor__arg, ::std::string charset_name__arg, ::std::string collate_name__arg,  ::nebula::meta::cpp2::ColumnTypeDef vid_type__arg, ::std::string group_name__arg,  ::nebula::meta::cpp2::IsolationLevel isolation_level__arg, ::std::string comment__arg) :
    space_name(std::move(space_name__arg)),
    partition_num(std::move(partition_num__arg)),
    replica_factor(std::move(replica_factor__arg)),
    charset_name(std::move(charset_name__arg)),
    collate_name(std::move(collate_name__arg)),
    vid_type(std::move(vid_type__arg)),
    group_name(std::move(group_name__arg)),
    isolation_level(std::move(isolation_level__arg)),
    comment(std::move(comment__arg)) {
  __isset.space_name = true;
  __isset.partition_num = true;
  __isset.replica_factor = true;
  __isset.charset_name = true;
  __isset.collate_name = true;
  __isset.vid_type = true;
  __isset.group_name = true;
  __isset.isolation_level = true;
  __isset.comment = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void SpaceDesc::__clear() {
  // clear all fields
  space_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  partition_num = 0;
  replica_factor = 0;
  charset_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  collate_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  vid_type.__clear();
  group_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  isolation_level =  ::nebula::meta::cpp2::IsolationLevel::DEFAULT;
  comment = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool SpaceDesc::operator==(const SpaceDesc& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.space_name, rhs.space_name)) {
    return false;
  }
  if (!(lhs.partition_num == rhs.partition_num)) {
    return false;
  }
  if (!(lhs.replica_factor == rhs.replica_factor)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.charset_name, rhs.charset_name)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.collate_name, rhs.collate_name)) {
    return false;
  }
  if (!(lhs.vid_type == rhs.vid_type)) {
    return false;
  }
  if (lhs.group_name_ref().has_value() != rhs.group_name_ref().has_value()) {
    return false;
  }
  if (lhs.group_name_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.group_name, rhs.group_name)) {
      return false;
    }
  }
  if (lhs.isolation_level_ref() != rhs.isolation_level_ref()) {
    return false;
  }
  if (lhs.comment_ref().has_value() != rhs.comment_ref().has_value()) {
    return false;
  }
  if (lhs.comment_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.comment, rhs.comment)) {
      return false;
    }
  }
  return true;
}

bool SpaceDesc::operator<(const SpaceDesc& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.space_name, rhs.space_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.space_name, rhs.space_name);
  }
  if (!(lhs.partition_num == rhs.partition_num)) {
    return lhs.partition_num < rhs.partition_num;
  }
  if (!(lhs.replica_factor == rhs.replica_factor)) {
    return lhs.replica_factor < rhs.replica_factor;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.charset_name, rhs.charset_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.charset_name, rhs.charset_name);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.collate_name, rhs.collate_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.collate_name, rhs.collate_name);
  }
  if (!(lhs.vid_type == rhs.vid_type)) {
    return lhs.vid_type < rhs.vid_type;
  }
  if (lhs.group_name_ref().has_value() != rhs.group_name_ref().has_value()) {
    return lhs.group_name_ref().has_value() < rhs.group_name_ref().has_value();
  }
  if (lhs.group_name_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.group_name, rhs.group_name)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.group_name, rhs.group_name);
    }
  }
  if (lhs.isolation_level_ref() != rhs.isolation_level_ref()) {
    return lhs.isolation_level_ref() < rhs.isolation_level_ref();
  }
  if (lhs.comment_ref().has_value() != rhs.comment_ref().has_value()) {
    return lhs.comment_ref().has_value() < rhs.comment_ref().has_value();
  }
  if (lhs.comment_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.comment, rhs.comment)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.comment, rhs.comment);
    }
  }
  return false;
}

const  ::nebula::meta::cpp2::ColumnTypeDef& SpaceDesc::get_vid_type() const& {
  return vid_type;
}

 ::nebula::meta::cpp2::ColumnTypeDef SpaceDesc::get_vid_type() && {
  return std::move(vid_type);
}


void swap(SpaceDesc& a, SpaceDesc& b) {
  using ::std::swap;
  swap(a.space_name_ref().value(), b.space_name_ref().value());
  swap(a.partition_num_ref().value(), b.partition_num_ref().value());
  swap(a.replica_factor_ref().value(), b.replica_factor_ref().value());
  swap(a.charset_name_ref().value(), b.charset_name_ref().value());
  swap(a.collate_name_ref().value(), b.collate_name_ref().value());
  swap(a.vid_type_ref().value(), b.vid_type_ref().value());
  swap(a.group_name_ref().value_unchecked(), b.group_name_ref().value_unchecked());
  swap(a.isolation_level_ref().value_unchecked(), b.isolation_level_ref().value_unchecked());
  swap(a.comment_ref().value_unchecked(), b.comment_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void SpaceDesc::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t SpaceDesc::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t SpaceDesc::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t SpaceDesc::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void SpaceDesc::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t SpaceDesc::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t SpaceDesc::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t SpaceDesc::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        SpaceDesc,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::ColumnTypeDef>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        SpaceDesc,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::ColumnTypeDef>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::SpaceItem>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::SpaceItem>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
SpaceItem::SpaceItem(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::meta::cpp2::SpaceDesc properties__arg) :
    space_id(std::move(space_id__arg)),
    properties(std::move(properties__arg)) {
  __isset.space_id = true;
  __isset.properties = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void SpaceItem::__clear() {
  // clear all fields
  space_id = 0;
  properties.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool SpaceItem::operator==(const SpaceItem& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.properties == rhs.properties)) {
    return false;
  }
  return true;
}

bool SpaceItem::operator<(const SpaceItem& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!(lhs.properties == rhs.properties)) {
    return lhs.properties < rhs.properties;
  }
  return false;
}

const  ::nebula::meta::cpp2::SpaceDesc& SpaceItem::get_properties() const& {
  return properties;
}

 ::nebula::meta::cpp2::SpaceDesc SpaceItem::get_properties() && {
  return std::move(properties);
}


void swap(SpaceItem& a, SpaceItem& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.properties_ref().value(), b.properties_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void SpaceItem::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t SpaceItem::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t SpaceItem::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t SpaceItem::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void SpaceItem::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t SpaceItem::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t SpaceItem::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t SpaceItem::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        SpaceItem,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::SpaceDesc>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        SpaceItem,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::SpaceDesc>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::TagItem>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::TagItem>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
TagItem::TagItem(apache::thrift::FragileConstructor,  ::nebula::cpp2::TagID tag_id__arg, ::std::string tag_name__arg,  ::nebula::meta::cpp2::SchemaVer version__arg,  ::nebula::meta::cpp2::Schema schema__arg) :
    tag_id(std::move(tag_id__arg)),
    tag_name(std::move(tag_name__arg)),
    version(std::move(version__arg)),
    schema(std::move(schema__arg)) {
  __isset.tag_id = true;
  __isset.tag_name = true;
  __isset.version = true;
  __isset.schema = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void TagItem::__clear() {
  // clear all fields
  tag_id = 0;
  tag_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  version = 0;
  schema.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool TagItem::operator==(const TagItem& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.tag_id == rhs.tag_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.tag_name, rhs.tag_name)) {
    return false;
  }
  if (!(lhs.version == rhs.version)) {
    return false;
  }
  if (!(lhs.schema == rhs.schema)) {
    return false;
  }
  return true;
}

bool TagItem::operator<(const TagItem& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.tag_id == rhs.tag_id)) {
    return lhs.tag_id < rhs.tag_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.tag_name, rhs.tag_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.tag_name, rhs.tag_name);
  }
  if (!(lhs.version == rhs.version)) {
    return lhs.version < rhs.version;
  }
  if (!(lhs.schema == rhs.schema)) {
    return lhs.schema < rhs.schema;
  }
  return false;
}

const  ::nebula::meta::cpp2::Schema& TagItem::get_schema() const& {
  return schema;
}

 ::nebula::meta::cpp2::Schema TagItem::get_schema() && {
  return std::move(schema);
}


void swap(TagItem& a, TagItem& b) {
  using ::std::swap;
  swap(a.tag_id_ref().value(), b.tag_id_ref().value());
  swap(a.tag_name_ref().value(), b.tag_name_ref().value());
  swap(a.version_ref().value(), b.version_ref().value());
  swap(a.schema_ref().value(), b.schema_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void TagItem::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TagItem::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TagItem::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TagItem::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TagItem::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TagItem::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TagItem::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TagItem::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        TagItem,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::Schema>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        TagItem,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::Schema>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::AlterSchemaItem>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::AlterSchemaItem>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AlterSchemaItem::AlterSchemaItem(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::AlterSchemaOp op__arg,  ::nebula::meta::cpp2::Schema schema__arg) :
    op(std::move(op__arg)),
    schema(std::move(schema__arg)) {
  __isset.op = true;
  __isset.schema = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AlterSchemaItem::__clear() {
  // clear all fields
  op = static_cast< ::nebula::meta::cpp2::AlterSchemaOp>(0);
  schema.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AlterSchemaItem::operator==(const AlterSchemaItem& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.op == rhs.op)) {
    return false;
  }
  if (!(lhs.schema == rhs.schema)) {
    return false;
  }
  return true;
}

bool AlterSchemaItem::operator<(const AlterSchemaItem& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.op == rhs.op)) {
    return lhs.op < rhs.op;
  }
  if (!(lhs.schema == rhs.schema)) {
    return lhs.schema < rhs.schema;
  }
  return false;
}

const  ::nebula::meta::cpp2::Schema& AlterSchemaItem::get_schema() const& {
  return schema;
}

 ::nebula::meta::cpp2::Schema AlterSchemaItem::get_schema() && {
  return std::move(schema);
}


void swap(AlterSchemaItem& a, AlterSchemaItem& b) {
  using ::std::swap;
  swap(a.op_ref().value(), b.op_ref().value());
  swap(a.schema_ref().value(), b.schema_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AlterSchemaItem::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AlterSchemaItem::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AlterSchemaItem::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AlterSchemaItem::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AlterSchemaItem::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AlterSchemaItem::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AlterSchemaItem::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AlterSchemaItem::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AlterSchemaItem,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::Schema>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AlterSchemaItem,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::Schema>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::EdgeItem>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::EdgeItem>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
EdgeItem::EdgeItem(apache::thrift::FragileConstructor,  ::nebula::cpp2::EdgeType edge_type__arg, ::std::string edge_name__arg,  ::nebula::meta::cpp2::SchemaVer version__arg,  ::nebula::meta::cpp2::Schema schema__arg) :
    edge_type(std::move(edge_type__arg)),
    edge_name(std::move(edge_name__arg)),
    version(std::move(version__arg)),
    schema(std::move(schema__arg)) {
  __isset.edge_type = true;
  __isset.edge_name = true;
  __isset.version = true;
  __isset.schema = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void EdgeItem::__clear() {
  // clear all fields
  edge_type = 0;
  edge_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  version = 0;
  schema.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool EdgeItem::operator==(const EdgeItem& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.edge_type == rhs.edge_type)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.edge_name, rhs.edge_name)) {
    return false;
  }
  if (!(lhs.version == rhs.version)) {
    return false;
  }
  if (!(lhs.schema == rhs.schema)) {
    return false;
  }
  return true;
}

bool EdgeItem::operator<(const EdgeItem& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.edge_type == rhs.edge_type)) {
    return lhs.edge_type < rhs.edge_type;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.edge_name, rhs.edge_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.edge_name, rhs.edge_name);
  }
  if (!(lhs.version == rhs.version)) {
    return lhs.version < rhs.version;
  }
  if (!(lhs.schema == rhs.schema)) {
    return lhs.schema < rhs.schema;
  }
  return false;
}

const  ::nebula::meta::cpp2::Schema& EdgeItem::get_schema() const& {
  return schema;
}

 ::nebula::meta::cpp2::Schema EdgeItem::get_schema() && {
  return std::move(schema);
}


void swap(EdgeItem& a, EdgeItem& b) {
  using ::std::swap;
  swap(a.edge_type_ref().value(), b.edge_type_ref().value());
  swap(a.edge_name_ref().value(), b.edge_name_ref().value());
  swap(a.version_ref().value(), b.version_ref().value());
  swap(a.schema_ref().value(), b.schema_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void EdgeItem::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t EdgeItem::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t EdgeItem::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t EdgeItem::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void EdgeItem::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t EdgeItem::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t EdgeItem::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t EdgeItem::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        EdgeItem,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::Schema>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        EdgeItem,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::Schema>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::IndexItem>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::IndexItem>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
IndexItem::IndexItem() :
      index_id(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


IndexItem::~IndexItem() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
IndexItem::IndexItem(apache::thrift::FragileConstructor,  ::nebula::cpp2::IndexID index_id__arg, ::std::string index_name__arg,  ::nebula::cpp2::SchemaID schema_id__arg, ::std::string schema_name__arg, ::std::vector< ::nebula::meta::cpp2::ColumnDef> fields__arg, ::std::string comment__arg) :
    index_id(std::move(index_id__arg)),
    index_name(std::move(index_name__arg)),
    schema_id(std::move(schema_id__arg)),
    schema_name(std::move(schema_name__arg)),
    fields(std::move(fields__arg)),
    comment(std::move(comment__arg)) {
  __isset.index_id = true;
  __isset.index_name = true;
  __isset.schema_id = true;
  __isset.schema_name = true;
  __isset.fields = true;
  __isset.comment = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void IndexItem::__clear() {
  // clear all fields
  index_id = 0;
  index_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  schema_id.__clear();
  schema_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  fields.clear();
  comment = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool IndexItem::operator==(const IndexItem& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.index_id == rhs.index_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.index_name, rhs.index_name)) {
    return false;
  }
  if (!(lhs.schema_id == rhs.schema_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.schema_name, rhs.schema_name)) {
    return false;
  }
  if (!(lhs.fields == rhs.fields)) {
    return false;
  }
  if (lhs.comment_ref().has_value() != rhs.comment_ref().has_value()) {
    return false;
  }
  if (lhs.comment_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.comment, rhs.comment)) {
      return false;
    }
  }
  return true;
}

bool IndexItem::operator<(const IndexItem& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.index_id == rhs.index_id)) {
    return lhs.index_id < rhs.index_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.index_name, rhs.index_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.index_name, rhs.index_name);
  }
  if (!(lhs.schema_id == rhs.schema_id)) {
    return lhs.schema_id < rhs.schema_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.schema_name, rhs.schema_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.schema_name, rhs.schema_name);
  }
  if (!(lhs.fields == rhs.fields)) {
    return lhs.fields < rhs.fields;
  }
  if (lhs.comment_ref().has_value() != rhs.comment_ref().has_value()) {
    return lhs.comment_ref().has_value() < rhs.comment_ref().has_value();
  }
  if (lhs.comment_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.comment, rhs.comment)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.comment, rhs.comment);
    }
  }
  return false;
}

const  ::nebula::cpp2::SchemaID& IndexItem::get_schema_id() const& {
  return schema_id;
}

 ::nebula::cpp2::SchemaID IndexItem::get_schema_id() && {
  return std::move(schema_id);
}

const ::std::vector< ::nebula::meta::cpp2::ColumnDef>& IndexItem::get_fields() const& {
  return fields;
}

::std::vector< ::nebula::meta::cpp2::ColumnDef> IndexItem::get_fields() && {
  return std::move(fields);
}


void swap(IndexItem& a, IndexItem& b) {
  using ::std::swap;
  swap(a.index_id_ref().value(), b.index_id_ref().value());
  swap(a.index_name_ref().value(), b.index_name_ref().value());
  swap(a.schema_id_ref().value(), b.schema_id_ref().value());
  swap(a.schema_name_ref().value(), b.schema_name_ref().value());
  swap(a.fields_ref().value(), b.fields_ref().value());
  swap(a.comment_ref().value_unchecked(), b.comment_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void IndexItem::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t IndexItem::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t IndexItem::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t IndexItem::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void IndexItem::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t IndexItem::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t IndexItem::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t IndexItem::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        IndexItem,
        ::apache::thrift::type_class::variant,
         ::nebula::cpp2::SchemaID>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        IndexItem,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::ColumnDef>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        IndexItem,
        ::apache::thrift::type_class::variant,
         ::nebula::cpp2::SchemaID>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        IndexItem,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::ColumnDef>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::HostItem>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::HostItem>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
HostItem::HostItem() :
      status( ::nebula::meta::cpp2::HostStatus::ONLINE),
      role( ::nebula::meta::cpp2::HostRole::GRAPH) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


HostItem::~HostItem() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
HostItem::HostItem(apache::thrift::FragileConstructor, nebula::HostAddr hostAddr__arg,  ::nebula::meta::cpp2::HostStatus status__arg, std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>> leader_parts__arg, std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>> all_parts__arg,  ::nebula::meta::cpp2::HostRole role__arg, ::std::string git_info_sha__arg, ::std::string zone_name__arg, ::std::string version__arg) :
    hostAddr(std::move(hostAddr__arg)),
    status(std::move(status__arg)),
    leader_parts(std::move(leader_parts__arg)),
    all_parts(std::move(all_parts__arg)),
    role(std::move(role__arg)),
    git_info_sha(std::move(git_info_sha__arg)),
    zone_name(std::move(zone_name__arg)),
    version(std::move(version__arg)) {
  __isset.hostAddr = true;
  __isset.status = true;
  __isset.leader_parts = true;
  __isset.all_parts = true;
  __isset.role = true;
  __isset.git_info_sha = true;
  __isset.zone_name = true;
  __isset.version = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void HostItem::__clear() {
  // clear all fields
  hostAddr.__clear();
  status =  ::nebula::meta::cpp2::HostStatus::ONLINE;
  leader_parts.clear();
  all_parts.clear();
  role =  ::nebula::meta::cpp2::HostRole::GRAPH;
  git_info_sha = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  zone_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  version = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool HostItem::operator==(const HostItem& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.hostAddr == rhs.hostAddr)) {
    return false;
  }
  if (!(lhs.status == rhs.status)) {
    return false;
  }
  if (!(lhs.leader_parts == rhs.leader_parts)) {
    return false;
  }
  if (!(lhs.all_parts == rhs.all_parts)) {
    return false;
  }
  if (!(lhs.role == rhs.role)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.git_info_sha, rhs.git_info_sha)) {
    return false;
  }
  if (lhs.zone_name_ref().has_value() != rhs.zone_name_ref().has_value()) {
    return false;
  }
  if (lhs.zone_name_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.zone_name, rhs.zone_name)) {
      return false;
    }
  }
  if (lhs.version_ref().has_value() != rhs.version_ref().has_value()) {
    return false;
  }
  if (lhs.version_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.version, rhs.version)) {
      return false;
    }
  }
  return true;
}

const nebula::HostAddr& HostItem::get_hostAddr() const& {
  return hostAddr;
}

nebula::HostAddr HostItem::get_hostAddr() && {
  return std::move(hostAddr);
}

const std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>>& HostItem::get_leader_parts() const& {
  return leader_parts;
}

std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>> HostItem::get_leader_parts() && {
  return std::move(leader_parts);
}

const std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>>& HostItem::get_all_parts() const& {
  return all_parts;
}

std::unordered_map<::std::string, ::std::vector< ::nebula::cpp2::PartitionID>> HostItem::get_all_parts() && {
  return std::move(all_parts);
}


void swap(HostItem& a, HostItem& b) {
  using ::std::swap;
  swap(a.hostAddr_ref().value(), b.hostAddr_ref().value());
  swap(a.status_ref().value(), b.status_ref().value());
  swap(a.leader_parts_ref().value(), b.leader_parts_ref().value());
  swap(a.all_parts_ref().value(), b.all_parts_ref().value());
  swap(a.role_ref().value(), b.role_ref().value());
  swap(a.git_info_sha_ref().value(), b.git_info_sha_ref().value());
  swap(a.zone_name_ref().value_unchecked(), b.zone_name_ref().value_unchecked());
  swap(a.version_ref().value_unchecked(), b.version_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void HostItem::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t HostItem::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t HostItem::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t HostItem::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void HostItem::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t HostItem::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t HostItem::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t HostItem::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        HostItem,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        HostItem,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::UserItem>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::UserItem>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
UserItem::UserItem() :
      is_lock(0),
      max_queries_per_hour(0),
      max_updates_per_hour(0),
      max_connections_per_hour(0),
      max_user_connections(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


UserItem::~UserItem() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
UserItem::UserItem(apache::thrift::FragileConstructor, ::std::string account__arg, bool is_lock__arg, int32_t max_queries_per_hour__arg, int32_t max_updates_per_hour__arg, int32_t max_connections_per_hour__arg, int32_t max_user_connections__arg) :
    account(std::move(account__arg)),
    is_lock(std::move(is_lock__arg)),
    max_queries_per_hour(std::move(max_queries_per_hour__arg)),
    max_updates_per_hour(std::move(max_updates_per_hour__arg)),
    max_connections_per_hour(std::move(max_connections_per_hour__arg)),
    max_user_connections(std::move(max_user_connections__arg)) {
  __isset.account = true;
  __isset.is_lock = true;
  __isset.max_queries_per_hour = true;
  __isset.max_updates_per_hour = true;
  __isset.max_connections_per_hour = true;
  __isset.max_user_connections = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void UserItem::__clear() {
  // clear all fields
  account = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  is_lock = 0;
  max_queries_per_hour = 0;
  max_updates_per_hour = 0;
  max_connections_per_hour = 0;
  max_user_connections = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool UserItem::operator==(const UserItem& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.account, rhs.account)) {
    return false;
  }
  if (!(lhs.is_lock == rhs.is_lock)) {
    return false;
  }
  if (!(lhs.max_queries_per_hour == rhs.max_queries_per_hour)) {
    return false;
  }
  if (!(lhs.max_updates_per_hour == rhs.max_updates_per_hour)) {
    return false;
  }
  if (!(lhs.max_connections_per_hour == rhs.max_connections_per_hour)) {
    return false;
  }
  if (!(lhs.max_user_connections == rhs.max_user_connections)) {
    return false;
  }
  return true;
}

bool UserItem::operator<(const UserItem& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.account, rhs.account)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.account, rhs.account);
  }
  if (!(lhs.is_lock == rhs.is_lock)) {
    return lhs.is_lock < rhs.is_lock;
  }
  if (!(lhs.max_queries_per_hour == rhs.max_queries_per_hour)) {
    return lhs.max_queries_per_hour < rhs.max_queries_per_hour;
  }
  if (!(lhs.max_updates_per_hour == rhs.max_updates_per_hour)) {
    return lhs.max_updates_per_hour < rhs.max_updates_per_hour;
  }
  if (!(lhs.max_connections_per_hour == rhs.max_connections_per_hour)) {
    return lhs.max_connections_per_hour < rhs.max_connections_per_hour;
  }
  if (!(lhs.max_user_connections == rhs.max_user_connections)) {
    return lhs.max_user_connections < rhs.max_user_connections;
  }
  return false;
}


void swap(UserItem& a, UserItem& b) {
  using ::std::swap;
  swap(a.account_ref().value(), b.account_ref().value());
  swap(a.is_lock_ref().value(), b.is_lock_ref().value());
  swap(a.max_queries_per_hour_ref().value(), b.max_queries_per_hour_ref().value());
  swap(a.max_updates_per_hour_ref().value(), b.max_updates_per_hour_ref().value());
  swap(a.max_connections_per_hour_ref().value(), b.max_connections_per_hour_ref().value());
  swap(a.max_user_connections_ref().value(), b.max_user_connections_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void UserItem::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t UserItem::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t UserItem::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t UserItem::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void UserItem::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t UserItem::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t UserItem::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t UserItem::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::RoleItem>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::RoleItem>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RoleItem::RoleItem(apache::thrift::FragileConstructor, ::std::string user_id__arg,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::meta::cpp2::RoleType role_type__arg) :
    user_id(std::move(user_id__arg)),
    space_id(std::move(space_id__arg)),
    role_type(std::move(role_type__arg)) {
  __isset.user_id = true;
  __isset.space_id = true;
  __isset.role_type = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void RoleItem::__clear() {
  // clear all fields
  user_id = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  space_id = 0;
  role_type = static_cast< ::nebula::meta::cpp2::RoleType>(0);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool RoleItem::operator==(const RoleItem& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.user_id, rhs.user_id)) {
    return false;
  }
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.role_type == rhs.role_type)) {
    return false;
  }
  return true;
}

bool RoleItem::operator<(const RoleItem& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.user_id, rhs.user_id)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.user_id, rhs.user_id);
  }
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!(lhs.role_type == rhs.role_type)) {
    return lhs.role_type < rhs.role_type;
  }
  return false;
}


void swap(RoleItem& a, RoleItem& b) {
  using ::std::swap;
  swap(a.user_id_ref().value(), b.user_id_ref().value());
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.role_type_ref().value(), b.role_type_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void RoleItem::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RoleItem::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RoleItem::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RoleItem::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RoleItem::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RoleItem::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RoleItem::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RoleItem::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ExecResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ExecResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ExecResp::ExecResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg,  ::nebula::meta::cpp2::ID id__arg, nebula::HostAddr leader__arg) :
    code(std::move(code__arg)),
    id(std::move(id__arg)),
    leader(std::move(leader__arg)) {
  __isset.code = true;
  __isset.id = true;
  __isset.leader = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ExecResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  id.__clear();
  leader.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ExecResp::operator==(const ExecResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.id == rhs.id)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  return true;
}

bool ExecResp::operator<(const ExecResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.id == rhs.id)) {
    return lhs.id < rhs.id;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  return false;
}

const  ::nebula::meta::cpp2::ID& ExecResp::get_id() const& {
  return id;
}

 ::nebula::meta::cpp2::ID ExecResp::get_id() && {
  return std::move(id);
}

const nebula::HostAddr& ExecResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ExecResp::get_leader() && {
  return std::move(leader);
}


void swap(ExecResp& a, ExecResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.id_ref().value(), b.id_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ExecResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ExecResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ExecResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ExecResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ExecResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ExecResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ExecResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ExecResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ExecResp,
        ::apache::thrift::type_class::variant,
         ::nebula::meta::cpp2::ID>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ExecResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ExecResp,
        ::apache::thrift::type_class::variant,
         ::nebula::meta::cpp2::ID>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ExecResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::AdminJobReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::AdminJobReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AdminJobReq::AdminJobReq(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::AdminJobOp op__arg,  ::nebula::meta::cpp2::AdminCmd cmd__arg, ::std::vector<::std::string> paras__arg) :
    op(std::move(op__arg)),
    cmd(std::move(cmd__arg)),
    paras(std::move(paras__arg)) {
  __isset.op = true;
  __isset.cmd = true;
  __isset.paras = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AdminJobReq::__clear() {
  // clear all fields
  op = static_cast< ::nebula::meta::cpp2::AdminJobOp>(0);
  cmd =  ::nebula::meta::cpp2::AdminCmd::COMPACT;
  paras.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AdminJobReq::operator==(const AdminJobReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.op == rhs.op)) {
    return false;
  }
  if (!(lhs.cmd == rhs.cmd)) {
    return false;
  }
  if (!(lhs.paras == rhs.paras)) {
    return false;
  }
  return true;
}

bool AdminJobReq::operator<(const AdminJobReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.op == rhs.op)) {
    return lhs.op < rhs.op;
  }
  if (!(lhs.cmd == rhs.cmd)) {
    return lhs.cmd < rhs.cmd;
  }
  if (!(lhs.paras == rhs.paras)) {
    return lhs.paras < rhs.paras;
  }
  return false;
}

const ::std::vector<::std::string>& AdminJobReq::get_paras() const& {
  return paras;
}

::std::vector<::std::string> AdminJobReq::get_paras() && {
  return std::move(paras);
}


void swap(AdminJobReq& a, AdminJobReq& b) {
  using ::std::swap;
  swap(a.op_ref().value(), b.op_ref().value());
  swap(a.cmd_ref().value(), b.cmd_ref().value());
  swap(a.paras_ref().value(), b.paras_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AdminJobReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AdminJobReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AdminJobReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AdminJobReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AdminJobReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AdminJobReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AdminJobReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AdminJobReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::JobDesc>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::JobDesc>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
JobDesc::JobDesc() :
      id(0),
      cmd( ::nebula::meta::cpp2::AdminCmd::COMPACT),
      status(static_cast< ::nebula::meta::cpp2::JobStatus>(0)),
      start_time(0),
      stop_time(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


JobDesc::~JobDesc() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
JobDesc::JobDesc(apache::thrift::FragileConstructor, int32_t id__arg,  ::nebula::meta::cpp2::AdminCmd cmd__arg, ::std::vector<::std::string> paras__arg,  ::nebula::meta::cpp2::JobStatus status__arg, int64_t start_time__arg, int64_t stop_time__arg) :
    id(std::move(id__arg)),
    cmd(std::move(cmd__arg)),
    paras(std::move(paras__arg)),
    status(std::move(status__arg)),
    start_time(std::move(start_time__arg)),
    stop_time(std::move(stop_time__arg)) {
  __isset.id = true;
  __isset.cmd = true;
  __isset.paras = true;
  __isset.status = true;
  __isset.start_time = true;
  __isset.stop_time = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void JobDesc::__clear() {
  // clear all fields
  id = 0;
  cmd =  ::nebula::meta::cpp2::AdminCmd::COMPACT;
  paras.clear();
  status = static_cast< ::nebula::meta::cpp2::JobStatus>(0);
  start_time = 0;
  stop_time = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool JobDesc::operator==(const JobDesc& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.id == rhs.id)) {
    return false;
  }
  if (!(lhs.cmd == rhs.cmd)) {
    return false;
  }
  if (!(lhs.paras == rhs.paras)) {
    return false;
  }
  if (!(lhs.status == rhs.status)) {
    return false;
  }
  if (!(lhs.start_time == rhs.start_time)) {
    return false;
  }
  if (!(lhs.stop_time == rhs.stop_time)) {
    return false;
  }
  return true;
}

bool JobDesc::operator<(const JobDesc& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.id == rhs.id)) {
    return lhs.id < rhs.id;
  }
  if (!(lhs.cmd == rhs.cmd)) {
    return lhs.cmd < rhs.cmd;
  }
  if (!(lhs.paras == rhs.paras)) {
    return lhs.paras < rhs.paras;
  }
  if (!(lhs.status == rhs.status)) {
    return lhs.status < rhs.status;
  }
  if (!(lhs.start_time == rhs.start_time)) {
    return lhs.start_time < rhs.start_time;
  }
  if (!(lhs.stop_time == rhs.stop_time)) {
    return lhs.stop_time < rhs.stop_time;
  }
  return false;
}

const ::std::vector<::std::string>& JobDesc::get_paras() const& {
  return paras;
}

::std::vector<::std::string> JobDesc::get_paras() && {
  return std::move(paras);
}


void swap(JobDesc& a, JobDesc& b) {
  using ::std::swap;
  swap(a.id_ref().value(), b.id_ref().value());
  swap(a.cmd_ref().value(), b.cmd_ref().value());
  swap(a.paras_ref().value(), b.paras_ref().value());
  swap(a.status_ref().value(), b.status_ref().value());
  swap(a.start_time_ref().value(), b.start_time_ref().value());
  swap(a.stop_time_ref().value(), b.stop_time_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void JobDesc::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t JobDesc::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t JobDesc::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t JobDesc::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void JobDesc::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t JobDesc::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t JobDesc::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t JobDesc::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::TaskDesc>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::TaskDesc>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
TaskDesc::TaskDesc(apache::thrift::FragileConstructor, int32_t task_id__arg, nebula::HostAddr host__arg,  ::nebula::meta::cpp2::JobStatus status__arg, int64_t start_time__arg, int64_t stop_time__arg, int32_t job_id__arg) :
    task_id(std::move(task_id__arg)),
    host(std::move(host__arg)),
    status(std::move(status__arg)),
    start_time(std::move(start_time__arg)),
    stop_time(std::move(stop_time__arg)),
    job_id(std::move(job_id__arg)) {
  __isset.task_id = true;
  __isset.host = true;
  __isset.status = true;
  __isset.start_time = true;
  __isset.stop_time = true;
  __isset.job_id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void TaskDesc::__clear() {
  // clear all fields
  task_id = 0;
  host.__clear();
  status = static_cast< ::nebula::meta::cpp2::JobStatus>(0);
  start_time = 0;
  stop_time = 0;
  job_id = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool TaskDesc::operator==(const TaskDesc& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.task_id == rhs.task_id)) {
    return false;
  }
  if (!(lhs.host == rhs.host)) {
    return false;
  }
  if (!(lhs.status == rhs.status)) {
    return false;
  }
  if (!(lhs.start_time == rhs.start_time)) {
    return false;
  }
  if (!(lhs.stop_time == rhs.stop_time)) {
    return false;
  }
  if (!(lhs.job_id == rhs.job_id)) {
    return false;
  }
  return true;
}

bool TaskDesc::operator<(const TaskDesc& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.task_id == rhs.task_id)) {
    return lhs.task_id < rhs.task_id;
  }
  if (!(lhs.host == rhs.host)) {
    return lhs.host < rhs.host;
  }
  if (!(lhs.status == rhs.status)) {
    return lhs.status < rhs.status;
  }
  if (!(lhs.start_time == rhs.start_time)) {
    return lhs.start_time < rhs.start_time;
  }
  if (!(lhs.stop_time == rhs.stop_time)) {
    return lhs.stop_time < rhs.stop_time;
  }
  if (!(lhs.job_id == rhs.job_id)) {
    return lhs.job_id < rhs.job_id;
  }
  return false;
}

const nebula::HostAddr& TaskDesc::get_host() const& {
  return host;
}

nebula::HostAddr TaskDesc::get_host() && {
  return std::move(host);
}


void swap(TaskDesc& a, TaskDesc& b) {
  using ::std::swap;
  swap(a.task_id_ref().value(), b.task_id_ref().value());
  swap(a.host_ref().value(), b.host_ref().value());
  swap(a.status_ref().value(), b.status_ref().value());
  swap(a.start_time_ref().value(), b.start_time_ref().value());
  swap(a.stop_time_ref().value(), b.stop_time_ref().value());
  swap(a.job_id_ref().value(), b.job_id_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void TaskDesc::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TaskDesc::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TaskDesc::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TaskDesc::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TaskDesc::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TaskDesc::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TaskDesc::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TaskDesc::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        TaskDesc,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        TaskDesc,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::AdminJobResult>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::AdminJobResult>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AdminJobResult::AdminJobResult(apache::thrift::FragileConstructor, int32_t job_id__arg, ::std::vector< ::nebula::meta::cpp2::JobDesc> job_desc__arg, ::std::vector< ::nebula::meta::cpp2::TaskDesc> task_desc__arg, int32_t recovered_job_num__arg) :
    job_id(std::move(job_id__arg)),
    job_desc(std::move(job_desc__arg)),
    task_desc(std::move(task_desc__arg)),
    recovered_job_num(std::move(recovered_job_num__arg)) {
  __isset.job_id = true;
  __isset.job_desc = true;
  __isset.task_desc = true;
  __isset.recovered_job_num = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AdminJobResult::__clear() {
  // clear all fields
  job_id = 0;
  job_desc.clear();
  task_desc.clear();
  recovered_job_num = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AdminJobResult::operator==(const AdminJobResult& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.job_id_ref() != rhs.job_id_ref()) {
    return false;
  }
  if (lhs.job_desc_ref() != rhs.job_desc_ref()) {
    return false;
  }
  if (lhs.task_desc_ref() != rhs.task_desc_ref()) {
    return false;
  }
  if (lhs.recovered_job_num_ref() != rhs.recovered_job_num_ref()) {
    return false;
  }
  return true;
}

bool AdminJobResult::operator<(const AdminJobResult& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.job_id_ref() != rhs.job_id_ref()) {
    return lhs.job_id_ref() < rhs.job_id_ref();
  }
  if (lhs.job_desc_ref() != rhs.job_desc_ref()) {
    return lhs.job_desc_ref() < rhs.job_desc_ref();
  }
  if (lhs.task_desc_ref() != rhs.task_desc_ref()) {
    return lhs.task_desc_ref() < rhs.task_desc_ref();
  }
  if (lhs.recovered_job_num_ref() != rhs.recovered_job_num_ref()) {
    return lhs.recovered_job_num_ref() < rhs.recovered_job_num_ref();
  }
  return false;
}

const ::std::vector< ::nebula::meta::cpp2::JobDesc>* AdminJobResult::get_job_desc() const& {
  return job_desc_ref().has_value() ? std::addressof(job_desc) : nullptr;
}

::std::vector< ::nebula::meta::cpp2::JobDesc>* AdminJobResult::get_job_desc() & {
  return job_desc_ref().has_value() ? std::addressof(job_desc) : nullptr;
}

const ::std::vector< ::nebula::meta::cpp2::TaskDesc>* AdminJobResult::get_task_desc() const& {
  return task_desc_ref().has_value() ? std::addressof(task_desc) : nullptr;
}

::std::vector< ::nebula::meta::cpp2::TaskDesc>* AdminJobResult::get_task_desc() & {
  return task_desc_ref().has_value() ? std::addressof(task_desc) : nullptr;
}


void swap(AdminJobResult& a, AdminJobResult& b) {
  using ::std::swap;
  swap(a.job_id_ref().value_unchecked(), b.job_id_ref().value_unchecked());
  swap(a.job_desc_ref().value_unchecked(), b.job_desc_ref().value_unchecked());
  swap(a.task_desc_ref().value_unchecked(), b.task_desc_ref().value_unchecked());
  swap(a.recovered_job_num_ref().value_unchecked(), b.recovered_job_num_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AdminJobResult::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AdminJobResult::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AdminJobResult::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AdminJobResult::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AdminJobResult::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AdminJobResult::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AdminJobResult::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AdminJobResult::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AdminJobResult,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::JobDesc>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AdminJobResult,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::TaskDesc>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AdminJobResult,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::JobDesc>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AdminJobResult,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::TaskDesc>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::AdminJobResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::AdminJobResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AdminJobResp::AdminJobResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::AdminJobResult result__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    result(std::move(result__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.result = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AdminJobResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  result.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AdminJobResp::operator==(const AdminJobResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  return true;
}

bool AdminJobResp::operator<(const AdminJobResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  return false;
}

const nebula::HostAddr& AdminJobResp::get_leader() const& {
  return leader;
}

nebula::HostAddr AdminJobResp::get_leader() && {
  return std::move(leader);
}

const  ::nebula::meta::cpp2::AdminJobResult& AdminJobResp::get_result() const& {
  return result;
}

 ::nebula::meta::cpp2::AdminJobResult AdminJobResp::get_result() && {
  return std::move(result);
}


void swap(AdminJobResp& a, AdminJobResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.result_ref().value(), b.result_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AdminJobResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AdminJobResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AdminJobResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AdminJobResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AdminJobResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AdminJobResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AdminJobResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AdminJobResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AdminJobResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AdminJobResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::AdminJobResult>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AdminJobResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AdminJobResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::AdminJobResult>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::Correlativity>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::Correlativity>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Correlativity::Correlativity(apache::thrift::FragileConstructor,  ::nebula::cpp2::PartitionID part_id__arg, double proportion__arg) :
    part_id(std::move(part_id__arg)),
    proportion(std::move(proportion__arg)) {
  __isset.part_id = true;
  __isset.proportion = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Correlativity::__clear() {
  // clear all fields
  part_id = 0;
  proportion = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool Correlativity::operator==(const Correlativity& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.part_id == rhs.part_id)) {
    return false;
  }
  if (!(lhs.proportion == rhs.proportion)) {
    return false;
  }
  return true;
}

bool Correlativity::operator<(const Correlativity& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.part_id == rhs.part_id)) {
    return lhs.part_id < rhs.part_id;
  }
  if (!(lhs.proportion == rhs.proportion)) {
    return lhs.proportion < rhs.proportion;
  }
  return false;
}


void swap(Correlativity& a, Correlativity& b) {
  using ::std::swap;
  swap(a.part_id_ref().value(), b.part_id_ref().value());
  swap(a.proportion_ref().value(), b.proportion_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void Correlativity::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Correlativity::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Correlativity::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Correlativity::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Correlativity::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Correlativity::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Correlativity::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Correlativity::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::StatsItem>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::StatsItem>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StatsItem::StatsItem() :
      space_vertices(0),
      space_edges(0),
      status(static_cast< ::nebula::meta::cpp2::JobStatus>(0)) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


StatsItem::~StatsItem() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StatsItem::StatsItem(apache::thrift::FragileConstructor, std::unordered_map<::std::string, int64_t> tag_vertices__arg, std::unordered_map<::std::string, int64_t> edges__arg, int64_t space_vertices__arg, int64_t space_edges__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>> positive_part_correlativity__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>> negative_part_correlativity__arg,  ::nebula::meta::cpp2::JobStatus status__arg) :
    tag_vertices(std::move(tag_vertices__arg)),
    edges(std::move(edges__arg)),
    space_vertices(std::move(space_vertices__arg)),
    space_edges(std::move(space_edges__arg)),
    positive_part_correlativity(std::move(positive_part_correlativity__arg)),
    negative_part_correlativity(std::move(negative_part_correlativity__arg)),
    status(std::move(status__arg)) {
  __isset.tag_vertices = true;
  __isset.edges = true;
  __isset.space_vertices = true;
  __isset.space_edges = true;
  __isset.positive_part_correlativity = true;
  __isset.negative_part_correlativity = true;
  __isset.status = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void StatsItem::__clear() {
  // clear all fields
  tag_vertices.clear();
  edges.clear();
  space_vertices = 0;
  space_edges = 0;
  positive_part_correlativity.clear();
  negative_part_correlativity.clear();
  status = static_cast< ::nebula::meta::cpp2::JobStatus>(0);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool StatsItem::operator==(const StatsItem& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.tag_vertices == rhs.tag_vertices)) {
    return false;
  }
  if (!(lhs.edges == rhs.edges)) {
    return false;
  }
  if (!(lhs.space_vertices == rhs.space_vertices)) {
    return false;
  }
  if (!(lhs.space_edges == rhs.space_edges)) {
    return false;
  }
  if (!(lhs.positive_part_correlativity == rhs.positive_part_correlativity)) {
    return false;
  }
  if (!(lhs.negative_part_correlativity == rhs.negative_part_correlativity)) {
    return false;
  }
  if (!(lhs.status == rhs.status)) {
    return false;
  }
  return true;
}

const std::unordered_map<::std::string, int64_t>& StatsItem::get_tag_vertices() const& {
  return tag_vertices;
}

std::unordered_map<::std::string, int64_t> StatsItem::get_tag_vertices() && {
  return std::move(tag_vertices);
}

const std::unordered_map<::std::string, int64_t>& StatsItem::get_edges() const& {
  return edges;
}

std::unordered_map<::std::string, int64_t> StatsItem::get_edges() && {
  return std::move(edges);
}

const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>& StatsItem::get_positive_part_correlativity() const& {
  return positive_part_correlativity;
}

std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>> StatsItem::get_positive_part_correlativity() && {
  return std::move(positive_part_correlativity);
}

const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>& StatsItem::get_negative_part_correlativity() const& {
  return negative_part_correlativity;
}

std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>> StatsItem::get_negative_part_correlativity() && {
  return std::move(negative_part_correlativity);
}


void swap(StatsItem& a, StatsItem& b) {
  using ::std::swap;
  swap(a.tag_vertices_ref().value(), b.tag_vertices_ref().value());
  swap(a.edges_ref().value(), b.edges_ref().value());
  swap(a.space_vertices_ref().value(), b.space_vertices_ref().value());
  swap(a.space_edges_ref().value(), b.space_edges_ref().value());
  swap(a.positive_part_correlativity_ref().value(), b.positive_part_correlativity_ref().value());
  swap(a.negative_part_correlativity_ref().value(), b.negative_part_correlativity_ref().value());
  swap(a.status_ref().value(), b.status_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void StatsItem::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StatsItem::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StatsItem::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StatsItem::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StatsItem::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StatsItem::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StatsItem::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StatsItem::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StatsItem,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StatsItem,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StatsItem,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StatsItem,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::meta::cpp2::Correlativity>>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::CreateSpaceReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::CreateSpaceReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CreateSpaceReq::CreateSpaceReq(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::SpaceDesc properties__arg, bool if_not_exists__arg) :
    properties(std::move(properties__arg)),
    if_not_exists(std::move(if_not_exists__arg)) {
  __isset.properties = true;
  __isset.if_not_exists = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CreateSpaceReq::__clear() {
  // clear all fields
  properties.__clear();
  if_not_exists = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CreateSpaceReq::operator==(const CreateSpaceReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.properties == rhs.properties)) {
    return false;
  }
  if (!(lhs.if_not_exists == rhs.if_not_exists)) {
    return false;
  }
  return true;
}

bool CreateSpaceReq::operator<(const CreateSpaceReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.properties == rhs.properties)) {
    return lhs.properties < rhs.properties;
  }
  if (!(lhs.if_not_exists == rhs.if_not_exists)) {
    return lhs.if_not_exists < rhs.if_not_exists;
  }
  return false;
}

const  ::nebula::meta::cpp2::SpaceDesc& CreateSpaceReq::get_properties() const& {
  return properties;
}

 ::nebula::meta::cpp2::SpaceDesc CreateSpaceReq::get_properties() && {
  return std::move(properties);
}


void swap(CreateSpaceReq& a, CreateSpaceReq& b) {
  using ::std::swap;
  swap(a.properties_ref().value(), b.properties_ref().value());
  swap(a.if_not_exists_ref().value(), b.if_not_exists_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CreateSpaceReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CreateSpaceReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CreateSpaceReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CreateSpaceReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CreateSpaceReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CreateSpaceReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CreateSpaceReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CreateSpaceReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CreateSpaceReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::SpaceDesc>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CreateSpaceReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::SpaceDesc>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::CreateSpaceAsReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::CreateSpaceAsReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CreateSpaceAsReq::CreateSpaceAsReq(apache::thrift::FragileConstructor, ::std::string old_space_name__arg, ::std::string new_space_name__arg) :
    old_space_name(std::move(old_space_name__arg)),
    new_space_name(std::move(new_space_name__arg)) {
  __isset.old_space_name = true;
  __isset.new_space_name = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CreateSpaceAsReq::__clear() {
  // clear all fields
  old_space_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  new_space_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CreateSpaceAsReq::operator==(const CreateSpaceAsReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.old_space_name, rhs.old_space_name)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.new_space_name, rhs.new_space_name)) {
    return false;
  }
  return true;
}

bool CreateSpaceAsReq::operator<(const CreateSpaceAsReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.old_space_name, rhs.old_space_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.old_space_name, rhs.old_space_name);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.new_space_name, rhs.new_space_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.new_space_name, rhs.new_space_name);
  }
  return false;
}


void swap(CreateSpaceAsReq& a, CreateSpaceAsReq& b) {
  using ::std::swap;
  swap(a.old_space_name_ref().value(), b.old_space_name_ref().value());
  swap(a.new_space_name_ref().value(), b.new_space_name_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CreateSpaceAsReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CreateSpaceAsReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CreateSpaceAsReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CreateSpaceAsReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CreateSpaceAsReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CreateSpaceAsReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CreateSpaceAsReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CreateSpaceAsReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::DropSpaceReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::DropSpaceReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DropSpaceReq::DropSpaceReq(apache::thrift::FragileConstructor, ::std::string space_name__arg, bool if_exists__arg) :
    space_name(std::move(space_name__arg)),
    if_exists(std::move(if_exists__arg)) {
  __isset.space_name = true;
  __isset.if_exists = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void DropSpaceReq::__clear() {
  // clear all fields
  space_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  if_exists = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DropSpaceReq::operator==(const DropSpaceReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.space_name, rhs.space_name)) {
    return false;
  }
  if (!(lhs.if_exists == rhs.if_exists)) {
    return false;
  }
  return true;
}

bool DropSpaceReq::operator<(const DropSpaceReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.space_name, rhs.space_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.space_name, rhs.space_name);
  }
  if (!(lhs.if_exists == rhs.if_exists)) {
    return lhs.if_exists < rhs.if_exists;
  }
  return false;
}


void swap(DropSpaceReq& a, DropSpaceReq& b) {
  using ::std::swap;
  swap(a.space_name_ref().value(), b.space_name_ref().value());
  swap(a.if_exists_ref().value(), b.if_exists_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DropSpaceReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DropSpaceReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DropSpaceReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DropSpaceReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DropSpaceReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DropSpaceReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DropSpaceReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DropSpaceReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListSpacesReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListSpacesReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListSpacesReq::ListSpacesReq(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListSpacesReq::__clear() {
  // clear all fields
}

bool ListSpacesReq::operator==(const ListSpacesReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool ListSpacesReq::operator<(const ListSpacesReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(ListSpacesReq& a, ListSpacesReq& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void ListSpacesReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListSpacesReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListSpacesReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListSpacesReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListSpacesReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListSpacesReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListSpacesReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListSpacesReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListSpacesResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListSpacesResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListSpacesResp::ListSpacesResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::IdName> spaces__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    spaces(std::move(spaces__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.spaces = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListSpacesResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  spaces.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListSpacesResp::operator==(const ListSpacesResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.spaces == rhs.spaces)) {
    return false;
  }
  return true;
}

bool ListSpacesResp::operator<(const ListSpacesResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.spaces == rhs.spaces)) {
    return lhs.spaces < rhs.spaces;
  }
  return false;
}

const nebula::HostAddr& ListSpacesResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ListSpacesResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector< ::nebula::meta::cpp2::IdName>& ListSpacesResp::get_spaces() const& {
  return spaces;
}

::std::vector< ::nebula::meta::cpp2::IdName> ListSpacesResp::get_spaces() && {
  return std::move(spaces);
}


void swap(ListSpacesResp& a, ListSpacesResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.spaces_ref().value(), b.spaces_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListSpacesResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListSpacesResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListSpacesResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListSpacesResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListSpacesResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListSpacesResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListSpacesResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListSpacesResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListSpacesResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListSpacesResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::IdName>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListSpacesResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListSpacesResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::IdName>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetSpaceReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetSpaceReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetSpaceReq::GetSpaceReq(apache::thrift::FragileConstructor, ::std::string space_name__arg) :
    space_name(std::move(space_name__arg)) {
  __isset.space_name = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetSpaceReq::__clear() {
  // clear all fields
  space_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetSpaceReq::operator==(const GetSpaceReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.space_name, rhs.space_name)) {
    return false;
  }
  return true;
}

bool GetSpaceReq::operator<(const GetSpaceReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.space_name, rhs.space_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.space_name, rhs.space_name);
  }
  return false;
}


void swap(GetSpaceReq& a, GetSpaceReq& b) {
  using ::std::swap;
  swap(a.space_name_ref().value(), b.space_name_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetSpaceReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetSpaceReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetSpaceReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetSpaceReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetSpaceReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetSpaceReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetSpaceReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetSpaceReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetSpaceResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetSpaceResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetSpaceResp::GetSpaceResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::SpaceItem item__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    item(std::move(item__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.item = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetSpaceResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  item.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetSpaceResp::operator==(const GetSpaceResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.item == rhs.item)) {
    return false;
  }
  return true;
}

bool GetSpaceResp::operator<(const GetSpaceResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.item == rhs.item)) {
    return lhs.item < rhs.item;
  }
  return false;
}

const nebula::HostAddr& GetSpaceResp::get_leader() const& {
  return leader;
}

nebula::HostAddr GetSpaceResp::get_leader() && {
  return std::move(leader);
}

const  ::nebula::meta::cpp2::SpaceItem& GetSpaceResp::get_item() const& {
  return item;
}

 ::nebula::meta::cpp2::SpaceItem GetSpaceResp::get_item() && {
  return std::move(item);
}


void swap(GetSpaceResp& a, GetSpaceResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.item_ref().value(), b.item_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetSpaceResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetSpaceResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetSpaceResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetSpaceResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetSpaceResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetSpaceResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetSpaceResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetSpaceResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetSpaceResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetSpaceResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::SpaceItem>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetSpaceResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetSpaceResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::SpaceItem>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::CreateTagReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::CreateTagReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CreateTagReq::CreateTagReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string tag_name__arg,  ::nebula::meta::cpp2::Schema schema__arg, bool if_not_exists__arg) :
    space_id(std::move(space_id__arg)),
    tag_name(std::move(tag_name__arg)),
    schema(std::move(schema__arg)),
    if_not_exists(std::move(if_not_exists__arg)) {
  __isset.space_id = true;
  __isset.tag_name = true;
  __isset.schema = true;
  __isset.if_not_exists = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CreateTagReq::__clear() {
  // clear all fields
  space_id = 0;
  tag_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  schema.__clear();
  if_not_exists = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CreateTagReq::operator==(const CreateTagReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.tag_name, rhs.tag_name)) {
    return false;
  }
  if (!(lhs.schema == rhs.schema)) {
    return false;
  }
  if (!(lhs.if_not_exists == rhs.if_not_exists)) {
    return false;
  }
  return true;
}

bool CreateTagReq::operator<(const CreateTagReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.tag_name, rhs.tag_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.tag_name, rhs.tag_name);
  }
  if (!(lhs.schema == rhs.schema)) {
    return lhs.schema < rhs.schema;
  }
  if (!(lhs.if_not_exists == rhs.if_not_exists)) {
    return lhs.if_not_exists < rhs.if_not_exists;
  }
  return false;
}

const  ::nebula::meta::cpp2::Schema& CreateTagReq::get_schema() const& {
  return schema;
}

 ::nebula::meta::cpp2::Schema CreateTagReq::get_schema() && {
  return std::move(schema);
}


void swap(CreateTagReq& a, CreateTagReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.tag_name_ref().value(), b.tag_name_ref().value());
  swap(a.schema_ref().value(), b.schema_ref().value());
  swap(a.if_not_exists_ref().value(), b.if_not_exists_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CreateTagReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CreateTagReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CreateTagReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CreateTagReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CreateTagReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CreateTagReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CreateTagReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CreateTagReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CreateTagReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::Schema>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CreateTagReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::Schema>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::AlterTagReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::AlterTagReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AlterTagReq::AlterTagReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string tag_name__arg, ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem> tag_items__arg,  ::nebula::meta::cpp2::SchemaProp schema_prop__arg) :
    space_id(std::move(space_id__arg)),
    tag_name(std::move(tag_name__arg)),
    tag_items(std::move(tag_items__arg)),
    schema_prop(std::move(schema_prop__arg)) {
  __isset.space_id = true;
  __isset.tag_name = true;
  __isset.tag_items = true;
  __isset.schema_prop = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AlterTagReq::__clear() {
  // clear all fields
  space_id = 0;
  tag_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  tag_items.clear();
  schema_prop.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AlterTagReq::operator==(const AlterTagReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.tag_name, rhs.tag_name)) {
    return false;
  }
  if (!(lhs.tag_items == rhs.tag_items)) {
    return false;
  }
  if (!(lhs.schema_prop == rhs.schema_prop)) {
    return false;
  }
  return true;
}

bool AlterTagReq::operator<(const AlterTagReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.tag_name, rhs.tag_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.tag_name, rhs.tag_name);
  }
  if (!(lhs.tag_items == rhs.tag_items)) {
    return lhs.tag_items < rhs.tag_items;
  }
  if (!(lhs.schema_prop == rhs.schema_prop)) {
    return lhs.schema_prop < rhs.schema_prop;
  }
  return false;
}

const ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>& AlterTagReq::get_tag_items() const& {
  return tag_items;
}

::std::vector< ::nebula::meta::cpp2::AlterSchemaItem> AlterTagReq::get_tag_items() && {
  return std::move(tag_items);
}

const  ::nebula::meta::cpp2::SchemaProp& AlterTagReq::get_schema_prop() const& {
  return schema_prop;
}

 ::nebula::meta::cpp2::SchemaProp AlterTagReq::get_schema_prop() && {
  return std::move(schema_prop);
}


void swap(AlterTagReq& a, AlterTagReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.tag_name_ref().value(), b.tag_name_ref().value());
  swap(a.tag_items_ref().value(), b.tag_items_ref().value());
  swap(a.schema_prop_ref().value(), b.schema_prop_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AlterTagReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AlterTagReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AlterTagReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AlterTagReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AlterTagReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AlterTagReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AlterTagReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AlterTagReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AlterTagReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AlterTagReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::SchemaProp>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AlterTagReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AlterTagReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::SchemaProp>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::DropTagReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::DropTagReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DropTagReq::DropTagReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string tag_name__arg, bool if_exists__arg) :
    space_id(std::move(space_id__arg)),
    tag_name(std::move(tag_name__arg)),
    if_exists(std::move(if_exists__arg)) {
  __isset.space_id = true;
  __isset.tag_name = true;
  __isset.if_exists = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void DropTagReq::__clear() {
  // clear all fields
  space_id = 0;
  tag_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  if_exists = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DropTagReq::operator==(const DropTagReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.tag_name, rhs.tag_name)) {
    return false;
  }
  if (!(lhs.if_exists == rhs.if_exists)) {
    return false;
  }
  return true;
}

bool DropTagReq::operator<(const DropTagReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.tag_name, rhs.tag_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.tag_name, rhs.tag_name);
  }
  if (!(lhs.if_exists == rhs.if_exists)) {
    return lhs.if_exists < rhs.if_exists;
  }
  return false;
}


void swap(DropTagReq& a, DropTagReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.tag_name_ref().value(), b.tag_name_ref().value());
  swap(a.if_exists_ref().value(), b.if_exists_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DropTagReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DropTagReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DropTagReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DropTagReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DropTagReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DropTagReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DropTagReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DropTagReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListTagsReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListTagsReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListTagsReq::ListTagsReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg) :
    space_id(std::move(space_id__arg)) {
  __isset.space_id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListTagsReq::__clear() {
  // clear all fields
  space_id = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListTagsReq::operator==(const ListTagsReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  return true;
}

bool ListTagsReq::operator<(const ListTagsReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  return false;
}


void swap(ListTagsReq& a, ListTagsReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListTagsReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListTagsReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListTagsReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListTagsReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListTagsReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListTagsReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListTagsReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListTagsReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListTagsResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListTagsResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListTagsResp::ListTagsResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::TagItem> tags__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    tags(std::move(tags__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.tags = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListTagsResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  tags.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListTagsResp::operator==(const ListTagsResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.tags == rhs.tags)) {
    return false;
  }
  return true;
}

bool ListTagsResp::operator<(const ListTagsResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.tags == rhs.tags)) {
    return lhs.tags < rhs.tags;
  }
  return false;
}

const nebula::HostAddr& ListTagsResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ListTagsResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector< ::nebula::meta::cpp2::TagItem>& ListTagsResp::get_tags() const& {
  return tags;
}

::std::vector< ::nebula::meta::cpp2::TagItem> ListTagsResp::get_tags() && {
  return std::move(tags);
}


void swap(ListTagsResp& a, ListTagsResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.tags_ref().value(), b.tags_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListTagsResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListTagsResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListTagsResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListTagsResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListTagsResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListTagsResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListTagsResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListTagsResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListTagsResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListTagsResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::TagItem>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListTagsResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListTagsResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::TagItem>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetTagReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetTagReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetTagReq::GetTagReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string tag_name__arg,  ::nebula::meta::cpp2::SchemaVer version__arg) :
    space_id(std::move(space_id__arg)),
    tag_name(std::move(tag_name__arg)),
    version(std::move(version__arg)) {
  __isset.space_id = true;
  __isset.tag_name = true;
  __isset.version = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetTagReq::__clear() {
  // clear all fields
  space_id = 0;
  tag_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  version = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetTagReq::operator==(const GetTagReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.tag_name, rhs.tag_name)) {
    return false;
  }
  if (!(lhs.version == rhs.version)) {
    return false;
  }
  return true;
}

bool GetTagReq::operator<(const GetTagReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.tag_name, rhs.tag_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.tag_name, rhs.tag_name);
  }
  if (!(lhs.version == rhs.version)) {
    return lhs.version < rhs.version;
  }
  return false;
}


void swap(GetTagReq& a, GetTagReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.tag_name_ref().value(), b.tag_name_ref().value());
  swap(a.version_ref().value(), b.version_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetTagReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetTagReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetTagReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetTagReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetTagReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetTagReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetTagReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetTagReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetTagResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetTagResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetTagResp::GetTagResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::Schema schema__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    schema(std::move(schema__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.schema = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetTagResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  schema.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetTagResp::operator==(const GetTagResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.schema == rhs.schema)) {
    return false;
  }
  return true;
}

bool GetTagResp::operator<(const GetTagResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.schema == rhs.schema)) {
    return lhs.schema < rhs.schema;
  }
  return false;
}

const nebula::HostAddr& GetTagResp::get_leader() const& {
  return leader;
}

nebula::HostAddr GetTagResp::get_leader() && {
  return std::move(leader);
}

const  ::nebula::meta::cpp2::Schema& GetTagResp::get_schema() const& {
  return schema;
}

 ::nebula::meta::cpp2::Schema GetTagResp::get_schema() && {
  return std::move(schema);
}


void swap(GetTagResp& a, GetTagResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.schema_ref().value(), b.schema_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetTagResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetTagResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetTagResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetTagResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetTagResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetTagResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetTagResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetTagResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetTagResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetTagResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::Schema>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetTagResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetTagResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::Schema>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::CreateEdgeReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::CreateEdgeReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CreateEdgeReq::CreateEdgeReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string edge_name__arg,  ::nebula::meta::cpp2::Schema schema__arg, bool if_not_exists__arg) :
    space_id(std::move(space_id__arg)),
    edge_name(std::move(edge_name__arg)),
    schema(std::move(schema__arg)),
    if_not_exists(std::move(if_not_exists__arg)) {
  __isset.space_id = true;
  __isset.edge_name = true;
  __isset.schema = true;
  __isset.if_not_exists = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CreateEdgeReq::__clear() {
  // clear all fields
  space_id = 0;
  edge_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  schema.__clear();
  if_not_exists = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CreateEdgeReq::operator==(const CreateEdgeReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.edge_name, rhs.edge_name)) {
    return false;
  }
  if (!(lhs.schema == rhs.schema)) {
    return false;
  }
  if (!(lhs.if_not_exists == rhs.if_not_exists)) {
    return false;
  }
  return true;
}

bool CreateEdgeReq::operator<(const CreateEdgeReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.edge_name, rhs.edge_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.edge_name, rhs.edge_name);
  }
  if (!(lhs.schema == rhs.schema)) {
    return lhs.schema < rhs.schema;
  }
  if (!(lhs.if_not_exists == rhs.if_not_exists)) {
    return lhs.if_not_exists < rhs.if_not_exists;
  }
  return false;
}

const  ::nebula::meta::cpp2::Schema& CreateEdgeReq::get_schema() const& {
  return schema;
}

 ::nebula::meta::cpp2::Schema CreateEdgeReq::get_schema() && {
  return std::move(schema);
}


void swap(CreateEdgeReq& a, CreateEdgeReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.edge_name_ref().value(), b.edge_name_ref().value());
  swap(a.schema_ref().value(), b.schema_ref().value());
  swap(a.if_not_exists_ref().value(), b.if_not_exists_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CreateEdgeReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CreateEdgeReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CreateEdgeReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CreateEdgeReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CreateEdgeReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CreateEdgeReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CreateEdgeReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CreateEdgeReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CreateEdgeReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::Schema>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CreateEdgeReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::Schema>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::AlterEdgeReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::AlterEdgeReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AlterEdgeReq::AlterEdgeReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string edge_name__arg, ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem> edge_items__arg,  ::nebula::meta::cpp2::SchemaProp schema_prop__arg) :
    space_id(std::move(space_id__arg)),
    edge_name(std::move(edge_name__arg)),
    edge_items(std::move(edge_items__arg)),
    schema_prop(std::move(schema_prop__arg)) {
  __isset.space_id = true;
  __isset.edge_name = true;
  __isset.edge_items = true;
  __isset.schema_prop = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AlterEdgeReq::__clear() {
  // clear all fields
  space_id = 0;
  edge_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  edge_items.clear();
  schema_prop.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AlterEdgeReq::operator==(const AlterEdgeReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.edge_name, rhs.edge_name)) {
    return false;
  }
  if (!(lhs.edge_items == rhs.edge_items)) {
    return false;
  }
  if (!(lhs.schema_prop == rhs.schema_prop)) {
    return false;
  }
  return true;
}

bool AlterEdgeReq::operator<(const AlterEdgeReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.edge_name, rhs.edge_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.edge_name, rhs.edge_name);
  }
  if (!(lhs.edge_items == rhs.edge_items)) {
    return lhs.edge_items < rhs.edge_items;
  }
  if (!(lhs.schema_prop == rhs.schema_prop)) {
    return lhs.schema_prop < rhs.schema_prop;
  }
  return false;
}

const ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>& AlterEdgeReq::get_edge_items() const& {
  return edge_items;
}

::std::vector< ::nebula::meta::cpp2::AlterSchemaItem> AlterEdgeReq::get_edge_items() && {
  return std::move(edge_items);
}

const  ::nebula::meta::cpp2::SchemaProp& AlterEdgeReq::get_schema_prop() const& {
  return schema_prop;
}

 ::nebula::meta::cpp2::SchemaProp AlterEdgeReq::get_schema_prop() && {
  return std::move(schema_prop);
}


void swap(AlterEdgeReq& a, AlterEdgeReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.edge_name_ref().value(), b.edge_name_ref().value());
  swap(a.edge_items_ref().value(), b.edge_items_ref().value());
  swap(a.schema_prop_ref().value(), b.schema_prop_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AlterEdgeReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AlterEdgeReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AlterEdgeReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AlterEdgeReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AlterEdgeReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AlterEdgeReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AlterEdgeReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AlterEdgeReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AlterEdgeReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AlterEdgeReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::SchemaProp>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AlterEdgeReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::AlterSchemaItem>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AlterEdgeReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::SchemaProp>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetEdgeReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetEdgeReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetEdgeReq::GetEdgeReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string edge_name__arg,  ::nebula::meta::cpp2::SchemaVer version__arg) :
    space_id(std::move(space_id__arg)),
    edge_name(std::move(edge_name__arg)),
    version(std::move(version__arg)) {
  __isset.space_id = true;
  __isset.edge_name = true;
  __isset.version = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetEdgeReq::__clear() {
  // clear all fields
  space_id = 0;
  edge_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  version = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetEdgeReq::operator==(const GetEdgeReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.edge_name, rhs.edge_name)) {
    return false;
  }
  if (!(lhs.version == rhs.version)) {
    return false;
  }
  return true;
}

bool GetEdgeReq::operator<(const GetEdgeReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.edge_name, rhs.edge_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.edge_name, rhs.edge_name);
  }
  if (!(lhs.version == rhs.version)) {
    return lhs.version < rhs.version;
  }
  return false;
}


void swap(GetEdgeReq& a, GetEdgeReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.edge_name_ref().value(), b.edge_name_ref().value());
  swap(a.version_ref().value(), b.version_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetEdgeReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetEdgeReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetEdgeReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetEdgeReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetEdgeReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetEdgeReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetEdgeReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetEdgeReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetEdgeResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetEdgeResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetEdgeResp::GetEdgeResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::Schema schema__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    schema(std::move(schema__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.schema = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetEdgeResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  schema.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetEdgeResp::operator==(const GetEdgeResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.schema == rhs.schema)) {
    return false;
  }
  return true;
}

bool GetEdgeResp::operator<(const GetEdgeResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.schema == rhs.schema)) {
    return lhs.schema < rhs.schema;
  }
  return false;
}

const nebula::HostAddr& GetEdgeResp::get_leader() const& {
  return leader;
}

nebula::HostAddr GetEdgeResp::get_leader() && {
  return std::move(leader);
}

const  ::nebula::meta::cpp2::Schema& GetEdgeResp::get_schema() const& {
  return schema;
}

 ::nebula::meta::cpp2::Schema GetEdgeResp::get_schema() && {
  return std::move(schema);
}


void swap(GetEdgeResp& a, GetEdgeResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.schema_ref().value(), b.schema_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetEdgeResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetEdgeResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetEdgeResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetEdgeResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetEdgeResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetEdgeResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetEdgeResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetEdgeResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetEdgeResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetEdgeResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::Schema>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetEdgeResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetEdgeResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::Schema>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::DropEdgeReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::DropEdgeReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DropEdgeReq::DropEdgeReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string edge_name__arg, bool if_exists__arg) :
    space_id(std::move(space_id__arg)),
    edge_name(std::move(edge_name__arg)),
    if_exists(std::move(if_exists__arg)) {
  __isset.space_id = true;
  __isset.edge_name = true;
  __isset.if_exists = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void DropEdgeReq::__clear() {
  // clear all fields
  space_id = 0;
  edge_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  if_exists = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DropEdgeReq::operator==(const DropEdgeReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.edge_name, rhs.edge_name)) {
    return false;
  }
  if (!(lhs.if_exists == rhs.if_exists)) {
    return false;
  }
  return true;
}

bool DropEdgeReq::operator<(const DropEdgeReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.edge_name, rhs.edge_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.edge_name, rhs.edge_name);
  }
  if (!(lhs.if_exists == rhs.if_exists)) {
    return lhs.if_exists < rhs.if_exists;
  }
  return false;
}


void swap(DropEdgeReq& a, DropEdgeReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.edge_name_ref().value(), b.edge_name_ref().value());
  swap(a.if_exists_ref().value(), b.if_exists_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DropEdgeReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DropEdgeReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DropEdgeReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DropEdgeReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DropEdgeReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DropEdgeReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DropEdgeReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DropEdgeReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListEdgesReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListEdgesReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListEdgesReq::ListEdgesReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg) :
    space_id(std::move(space_id__arg)) {
  __isset.space_id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListEdgesReq::__clear() {
  // clear all fields
  space_id = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListEdgesReq::operator==(const ListEdgesReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  return true;
}

bool ListEdgesReq::operator<(const ListEdgesReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  return false;
}


void swap(ListEdgesReq& a, ListEdgesReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListEdgesReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListEdgesReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListEdgesReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListEdgesReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListEdgesReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListEdgesReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListEdgesReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListEdgesReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListEdgesResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListEdgesResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListEdgesResp::ListEdgesResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::EdgeItem> edges__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    edges(std::move(edges__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.edges = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListEdgesResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  edges.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListEdgesResp::operator==(const ListEdgesResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.edges == rhs.edges)) {
    return false;
  }
  return true;
}

bool ListEdgesResp::operator<(const ListEdgesResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.edges == rhs.edges)) {
    return lhs.edges < rhs.edges;
  }
  return false;
}

const nebula::HostAddr& ListEdgesResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ListEdgesResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector< ::nebula::meta::cpp2::EdgeItem>& ListEdgesResp::get_edges() const& {
  return edges;
}

::std::vector< ::nebula::meta::cpp2::EdgeItem> ListEdgesResp::get_edges() && {
  return std::move(edges);
}


void swap(ListEdgesResp& a, ListEdgesResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.edges_ref().value(), b.edges_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListEdgesResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListEdgesResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListEdgesResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListEdgesResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListEdgesResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListEdgesResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListEdgesResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListEdgesResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListEdgesResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListEdgesResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::EdgeItem>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListEdgesResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListEdgesResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::EdgeItem>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListHostsReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListHostsReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListHostsReq::ListHostsReq(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::ListHostType type__arg) :
    type(std::move(type__arg)) {
  __isset.type = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListHostsReq::__clear() {
  // clear all fields
  type =  ::nebula::meta::cpp2::ListHostType::ALLOC;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListHostsReq::operator==(const ListHostsReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.type == rhs.type)) {
    return false;
  }
  return true;
}

bool ListHostsReq::operator<(const ListHostsReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.type == rhs.type)) {
    return lhs.type < rhs.type;
  }
  return false;
}


void swap(ListHostsReq& a, ListHostsReq& b) {
  using ::std::swap;
  swap(a.type_ref().value(), b.type_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListHostsReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListHostsReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListHostsReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListHostsReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListHostsReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListHostsReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListHostsReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListHostsReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListHostsResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListHostsResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListHostsResp::ListHostsResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::HostItem> hosts__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    hosts(std::move(hosts__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.hosts = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListHostsResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  hosts.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListHostsResp::operator==(const ListHostsResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.hosts == rhs.hosts)) {
    return false;
  }
  return true;
}

const nebula::HostAddr& ListHostsResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ListHostsResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector< ::nebula::meta::cpp2::HostItem>& ListHostsResp::get_hosts() const& {
  return hosts;
}

::std::vector< ::nebula::meta::cpp2::HostItem> ListHostsResp::get_hosts() && {
  return std::move(hosts);
}


void swap(ListHostsResp& a, ListHostsResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.hosts_ref().value(), b.hosts_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListHostsResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListHostsResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListHostsResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListHostsResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListHostsResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListHostsResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListHostsResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListHostsResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListHostsResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListHostsResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::HostItem>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListHostsResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListHostsResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::HostItem>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::PartItem>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::PartItem>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PartItem::PartItem(apache::thrift::FragileConstructor,  ::nebula::cpp2::PartitionID part_id__arg, nebula::HostAddr leader__arg, ::std::vector<nebula::HostAddr> peers__arg, ::std::vector<nebula::HostAddr> losts__arg) :
    part_id(std::move(part_id__arg)),
    leader(std::move(leader__arg)),
    peers(std::move(peers__arg)),
    losts(std::move(losts__arg)) {
  __isset.leader = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void PartItem::__clear() {
  // clear all fields
  part_id = 0;
  leader.__clear();
  peers.clear();
  losts.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool PartItem::operator==(const PartItem& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.part_id == rhs.part_id)) {
    return false;
  }
  if (lhs.leader_ref() != rhs.leader_ref()) {
    return false;
  }
  if (!(lhs.peers == rhs.peers)) {
    return false;
  }
  if (!(lhs.losts == rhs.losts)) {
    return false;
  }
  return true;
}

bool PartItem::operator<(const PartItem& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.part_id == rhs.part_id)) {
    return lhs.part_id < rhs.part_id;
  }
  if (lhs.leader_ref() != rhs.leader_ref()) {
    return lhs.leader_ref() < rhs.leader_ref();
  }
  if (!(lhs.peers == rhs.peers)) {
    return lhs.peers < rhs.peers;
  }
  if (!(lhs.losts == rhs.losts)) {
    return lhs.losts < rhs.losts;
  }
  return false;
}

const nebula::HostAddr* PartItem::get_leader() const& {
  return leader_ref().has_value() ? std::addressof(leader) : nullptr;
}

nebula::HostAddr* PartItem::get_leader() & {
  return leader_ref().has_value() ? std::addressof(leader) : nullptr;
}

const ::std::vector<nebula::HostAddr>& PartItem::get_peers() const& {
  return peers;
}

::std::vector<nebula::HostAddr> PartItem::get_peers() && {
  return std::move(peers);
}

const ::std::vector<nebula::HostAddr>& PartItem::get_losts() const& {
  return losts;
}

::std::vector<nebula::HostAddr> PartItem::get_losts() && {
  return std::move(losts);
}


void swap(PartItem& a, PartItem& b) {
  using ::std::swap;
  swap(a.part_id_ref().value(), b.part_id_ref().value());
  swap(a.leader_ref().value_unchecked(), b.leader_ref().value_unchecked());
  swap(a.peers_ref().value(), b.peers_ref().value());
  swap(a.losts_ref().value(), b.losts_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void PartItem::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PartItem::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PartItem::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PartItem::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PartItem::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PartItem::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PartItem::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PartItem::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PartItem,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PartItem,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::HostAddr>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PartItem,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::HostAddr>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PartItem,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PartItem,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::HostAddr>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PartItem,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::HostAddr>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListPartsReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListPartsReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListPartsReq::ListPartsReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::vector< ::nebula::cpp2::PartitionID> part_ids__arg) :
    space_id(std::move(space_id__arg)),
    part_ids(std::move(part_ids__arg)) {
  __isset.space_id = true;
  __isset.part_ids = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListPartsReq::__clear() {
  // clear all fields
  space_id = 0;
  part_ids.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListPartsReq::operator==(const ListPartsReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.part_ids == rhs.part_ids)) {
    return false;
  }
  return true;
}

bool ListPartsReq::operator<(const ListPartsReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!(lhs.part_ids == rhs.part_ids)) {
    return lhs.part_ids < rhs.part_ids;
  }
  return false;
}

const ::std::vector< ::nebula::cpp2::PartitionID>& ListPartsReq::get_part_ids() const& {
  return part_ids;
}

::std::vector< ::nebula::cpp2::PartitionID> ListPartsReq::get_part_ids() && {
  return std::move(part_ids);
}


void swap(ListPartsReq& a, ListPartsReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.part_ids_ref().value(), b.part_ids_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListPartsReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListPartsReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListPartsReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListPartsReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListPartsReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListPartsReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListPartsReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListPartsReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListPartsResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListPartsResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListPartsResp::ListPartsResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::PartItem> parts__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    parts(std::move(parts__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.parts = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListPartsResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  parts.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListPartsResp::operator==(const ListPartsResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  return true;
}

bool ListPartsResp::operator<(const ListPartsResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.parts == rhs.parts)) {
    return lhs.parts < rhs.parts;
  }
  return false;
}

const nebula::HostAddr& ListPartsResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ListPartsResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector< ::nebula::meta::cpp2::PartItem>& ListPartsResp::get_parts() const& {
  return parts;
}

::std::vector< ::nebula::meta::cpp2::PartItem> ListPartsResp::get_parts() && {
  return std::move(parts);
}


void swap(ListPartsResp& a, ListPartsResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListPartsResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListPartsResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListPartsResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListPartsResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListPartsResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListPartsResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListPartsResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListPartsResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListPartsResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListPartsResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::PartItem>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListPartsResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListPartsResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::PartItem>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetPartsAllocReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetPartsAllocReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetPartsAllocReq::GetPartsAllocReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg) :
    space_id(std::move(space_id__arg)) {
  __isset.space_id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetPartsAllocReq::__clear() {
  // clear all fields
  space_id = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetPartsAllocReq::operator==(const GetPartsAllocReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  return true;
}

bool GetPartsAllocReq::operator<(const GetPartsAllocReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  return false;
}


void swap(GetPartsAllocReq& a, GetPartsAllocReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetPartsAllocReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetPartsAllocReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetPartsAllocReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetPartsAllocReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetPartsAllocReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetPartsAllocReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetPartsAllocReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetPartsAllocReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetPartsAllocResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetPartsAllocResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetPartsAllocResp::GetPartsAllocResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::HostAddr>> parts__arg, std::unordered_map< ::nebula::cpp2::PartitionID, int64_t> terms__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    parts(std::move(parts__arg)),
    terms(std::move(terms__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.parts = true;
  __isset.terms = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetPartsAllocResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  parts.clear();
  terms.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetPartsAllocResp::operator==(const GetPartsAllocResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.parts == rhs.parts)) {
    return false;
  }
  if (lhs.terms_ref() != rhs.terms_ref()) {
    return false;
  }
  return true;
}

const nebula::HostAddr& GetPartsAllocResp::get_leader() const& {
  return leader;
}

nebula::HostAddr GetPartsAllocResp::get_leader() && {
  return std::move(leader);
}

const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::HostAddr>>& GetPartsAllocResp::get_parts() const& {
  return parts;
}

std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::HostAddr>> GetPartsAllocResp::get_parts() && {
  return std::move(parts);
}

const std::unordered_map< ::nebula::cpp2::PartitionID, int64_t>* GetPartsAllocResp::get_terms() const& {
  return terms_ref().has_value() ? std::addressof(terms) : nullptr;
}

std::unordered_map< ::nebula::cpp2::PartitionID, int64_t>* GetPartsAllocResp::get_terms() & {
  return terms_ref().has_value() ? std::addressof(terms) : nullptr;
}


void swap(GetPartsAllocResp& a, GetPartsAllocResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.parts_ref().value(), b.parts_ref().value());
  swap(a.terms_ref().value_unchecked(), b.terms_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetPartsAllocResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetPartsAllocResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetPartsAllocResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetPartsAllocResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetPartsAllocResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetPartsAllocResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetPartsAllocResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetPartsAllocResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetPartsAllocResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetPartsAllocResp,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::HostAddr>>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetPartsAllocResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetPartsAllocResp,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::HostAddr>>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::MultiPutReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::MultiPutReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MultiPutReq::MultiPutReq(apache::thrift::FragileConstructor, ::std::string segment__arg, ::std::vector<nebula::KeyValue> pairs__arg) :
    segment(std::move(segment__arg)),
    pairs(std::move(pairs__arg)) {
  __isset.segment = true;
  __isset.pairs = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void MultiPutReq::__clear() {
  // clear all fields
  segment = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  pairs.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool MultiPutReq::operator==(const MultiPutReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.segment, rhs.segment)) {
    return false;
  }
  if (!(lhs.pairs == rhs.pairs)) {
    return false;
  }
  return true;
}

bool MultiPutReq::operator<(const MultiPutReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.segment, rhs.segment)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.segment, rhs.segment);
  }
  if (!(lhs.pairs == rhs.pairs)) {
    return lhs.pairs < rhs.pairs;
  }
  return false;
}

const ::std::vector<nebula::KeyValue>& MultiPutReq::get_pairs() const& {
  return pairs;
}

::std::vector<nebula::KeyValue> MultiPutReq::get_pairs() && {
  return std::move(pairs);
}


void swap(MultiPutReq& a, MultiPutReq& b) {
  using ::std::swap;
  swap(a.segment_ref().value(), b.segment_ref().value());
  swap(a.pairs_ref().value(), b.pairs_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void MultiPutReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MultiPutReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MultiPutReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MultiPutReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MultiPutReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MultiPutReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MultiPutReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MultiPutReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MultiPutReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::KeyValue>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MultiPutReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::KeyValue>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetReq::GetReq(apache::thrift::FragileConstructor, ::std::string segment__arg, ::std::string key__arg) :
    segment(std::move(segment__arg)),
    key(std::move(key__arg)) {
  __isset.segment = true;
  __isset.key = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetReq::__clear() {
  // clear all fields
  segment = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  key = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetReq::operator==(const GetReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.segment, rhs.segment)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.key, rhs.key)) {
    return false;
  }
  return true;
}

bool GetReq::operator<(const GetReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.segment, rhs.segment)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.segment, rhs.segment);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.key, rhs.key)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.key, rhs.key);
  }
  return false;
}


void swap(GetReq& a, GetReq& b) {
  using ::std::swap;
  swap(a.segment_ref().value(), b.segment_ref().value());
  swap(a.key_ref().value(), b.key_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetResp::GetResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::string value__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    value(std::move(value__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.value = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  value = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetResp::operator==(const GetResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.value, rhs.value)) {
    return false;
  }
  return true;
}

bool GetResp::operator<(const GetResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.value, rhs.value)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.value, rhs.value);
  }
  return false;
}

const nebula::HostAddr& GetResp::get_leader() const& {
  return leader;
}

nebula::HostAddr GetResp::get_leader() && {
  return std::move(leader);
}


void swap(GetResp& a, GetResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.value_ref().value(), b.value_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::MultiGetReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::MultiGetReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MultiGetReq::MultiGetReq(apache::thrift::FragileConstructor, ::std::string segment__arg, ::std::vector<::std::string> keys__arg) :
    segment(std::move(segment__arg)),
    keys(std::move(keys__arg)) {
  __isset.segment = true;
  __isset.keys = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void MultiGetReq::__clear() {
  // clear all fields
  segment = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  keys.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool MultiGetReq::operator==(const MultiGetReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.segment, rhs.segment)) {
    return false;
  }
  if (!(lhs.keys == rhs.keys)) {
    return false;
  }
  return true;
}

bool MultiGetReq::operator<(const MultiGetReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.segment, rhs.segment)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.segment, rhs.segment);
  }
  if (!(lhs.keys == rhs.keys)) {
    return lhs.keys < rhs.keys;
  }
  return false;
}

const ::std::vector<::std::string>& MultiGetReq::get_keys() const& {
  return keys;
}

::std::vector<::std::string> MultiGetReq::get_keys() && {
  return std::move(keys);
}


void swap(MultiGetReq& a, MultiGetReq& b) {
  using ::std::swap;
  swap(a.segment_ref().value(), b.segment_ref().value());
  swap(a.keys_ref().value(), b.keys_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void MultiGetReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MultiGetReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MultiGetReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MultiGetReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MultiGetReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MultiGetReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MultiGetReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MultiGetReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::MultiGetResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::MultiGetResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MultiGetResp::MultiGetResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector<::std::string> values__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    values(std::move(values__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.values = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void MultiGetResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  values.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool MultiGetResp::operator==(const MultiGetResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.values == rhs.values)) {
    return false;
  }
  return true;
}

bool MultiGetResp::operator<(const MultiGetResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.values == rhs.values)) {
    return lhs.values < rhs.values;
  }
  return false;
}

const nebula::HostAddr& MultiGetResp::get_leader() const& {
  return leader;
}

nebula::HostAddr MultiGetResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector<::std::string>& MultiGetResp::get_values() const& {
  return values;
}

::std::vector<::std::string> MultiGetResp::get_values() && {
  return std::move(values);
}


void swap(MultiGetResp& a, MultiGetResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.values_ref().value(), b.values_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void MultiGetResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MultiGetResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MultiGetResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MultiGetResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MultiGetResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MultiGetResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MultiGetResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MultiGetResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MultiGetResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MultiGetResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::RemoveReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::RemoveReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RemoveReq::RemoveReq(apache::thrift::FragileConstructor, ::std::string segment__arg, ::std::string key__arg) :
    segment(std::move(segment__arg)),
    key(std::move(key__arg)) {
  __isset.segment = true;
  __isset.key = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void RemoveReq::__clear() {
  // clear all fields
  segment = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  key = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool RemoveReq::operator==(const RemoveReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.segment, rhs.segment)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.key, rhs.key)) {
    return false;
  }
  return true;
}

bool RemoveReq::operator<(const RemoveReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.segment, rhs.segment)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.segment, rhs.segment);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.key, rhs.key)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.key, rhs.key);
  }
  return false;
}


void swap(RemoveReq& a, RemoveReq& b) {
  using ::std::swap;
  swap(a.segment_ref().value(), b.segment_ref().value());
  swap(a.key_ref().value(), b.key_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void RemoveReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RemoveReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RemoveReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RemoveReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RemoveReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RemoveReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RemoveReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RemoveReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::RemoveRangeReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::RemoveRangeReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RemoveRangeReq::RemoveRangeReq(apache::thrift::FragileConstructor, ::std::string segment__arg, ::std::string start__arg, ::std::string end__arg) :
    segment(std::move(segment__arg)),
    start(std::move(start__arg)),
    end(std::move(end__arg)) {
  __isset.segment = true;
  __isset.start = true;
  __isset.end = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void RemoveRangeReq::__clear() {
  // clear all fields
  segment = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  start = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  end = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool RemoveRangeReq::operator==(const RemoveRangeReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.segment, rhs.segment)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.start, rhs.start)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.end, rhs.end)) {
    return false;
  }
  return true;
}

bool RemoveRangeReq::operator<(const RemoveRangeReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.segment, rhs.segment)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.segment, rhs.segment);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.start, rhs.start)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.start, rhs.start);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.end, rhs.end)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.end, rhs.end);
  }
  return false;
}


void swap(RemoveRangeReq& a, RemoveRangeReq& b) {
  using ::std::swap;
  swap(a.segment_ref().value(), b.segment_ref().value());
  swap(a.start_ref().value(), b.start_ref().value());
  swap(a.end_ref().value(), b.end_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void RemoveRangeReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RemoveRangeReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RemoveRangeReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RemoveRangeReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RemoveRangeReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RemoveRangeReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RemoveRangeReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RemoveRangeReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ScanReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ScanReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ScanReq::ScanReq(apache::thrift::FragileConstructor, ::std::string segment__arg, ::std::string start__arg, ::std::string end__arg) :
    segment(std::move(segment__arg)),
    start(std::move(start__arg)),
    end(std::move(end__arg)) {
  __isset.segment = true;
  __isset.start = true;
  __isset.end = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ScanReq::__clear() {
  // clear all fields
  segment = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  start = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  end = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ScanReq::operator==(const ScanReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.segment, rhs.segment)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.start, rhs.start)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.end, rhs.end)) {
    return false;
  }
  return true;
}

bool ScanReq::operator<(const ScanReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.segment, rhs.segment)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.segment, rhs.segment);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.start, rhs.start)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.start, rhs.start);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.end, rhs.end)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.end, rhs.end);
  }
  return false;
}


void swap(ScanReq& a, ScanReq& b) {
  using ::std::swap;
  swap(a.segment_ref().value(), b.segment_ref().value());
  swap(a.start_ref().value(), b.start_ref().value());
  swap(a.end_ref().value(), b.end_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ScanReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ScanReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ScanReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ScanReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ScanReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ScanReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ScanReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ScanReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ScanResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ScanResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ScanResp::ScanResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector<::std::string> values__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    values(std::move(values__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.values = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ScanResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  values.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ScanResp::operator==(const ScanResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.values == rhs.values)) {
    return false;
  }
  return true;
}

bool ScanResp::operator<(const ScanResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.values == rhs.values)) {
    return lhs.values < rhs.values;
  }
  return false;
}

const nebula::HostAddr& ScanResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ScanResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector<::std::string>& ScanResp::get_values() const& {
  return values;
}

::std::vector<::std::string> ScanResp::get_values() && {
  return std::move(values);
}


void swap(ScanResp& a, ScanResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.values_ref().value(), b.values_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ScanResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ScanResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ScanResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ScanResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ScanResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ScanResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ScanResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ScanResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ScanResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ScanResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::HBResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::HBResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
HBResp::HBResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::ClusterID cluster_id__arg, int64_t last_update_time_in_ms__arg, int32_t meta_version__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    cluster_id(std::move(cluster_id__arg)),
    last_update_time_in_ms(std::move(last_update_time_in_ms__arg)),
    meta_version(std::move(meta_version__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.cluster_id = true;
  __isset.last_update_time_in_ms = true;
  __isset.meta_version = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void HBResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  cluster_id = 0;
  last_update_time_in_ms = 0;
  meta_version = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool HBResp::operator==(const HBResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.cluster_id == rhs.cluster_id)) {
    return false;
  }
  if (!(lhs.last_update_time_in_ms == rhs.last_update_time_in_ms)) {
    return false;
  }
  if (!(lhs.meta_version == rhs.meta_version)) {
    return false;
  }
  return true;
}

bool HBResp::operator<(const HBResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.cluster_id == rhs.cluster_id)) {
    return lhs.cluster_id < rhs.cluster_id;
  }
  if (!(lhs.last_update_time_in_ms == rhs.last_update_time_in_ms)) {
    return lhs.last_update_time_in_ms < rhs.last_update_time_in_ms;
  }
  if (!(lhs.meta_version == rhs.meta_version)) {
    return lhs.meta_version < rhs.meta_version;
  }
  return false;
}

const nebula::HostAddr& HBResp::get_leader() const& {
  return leader;
}

nebula::HostAddr HBResp::get_leader() && {
  return std::move(leader);
}


void swap(HBResp& a, HBResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.cluster_id_ref().value(), b.cluster_id_ref().value());
  swap(a.last_update_time_in_ms_ref().value(), b.last_update_time_in_ms_ref().value());
  swap(a.meta_version_ref().value(), b.meta_version_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void HBResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t HBResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t HBResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t HBResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void HBResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t HBResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t HBResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t HBResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        HBResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        HBResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::LeaderInfo>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::LeaderInfo>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
LeaderInfo::LeaderInfo(apache::thrift::FragileConstructor,  ::nebula::cpp2::PartitionID part_id__arg, int64_t term__arg) :
    part_id(std::move(part_id__arg)),
    term(std::move(term__arg)) {
  __isset.part_id = true;
  __isset.term = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void LeaderInfo::__clear() {
  // clear all fields
  part_id = 0;
  term = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool LeaderInfo::operator==(const LeaderInfo& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.part_id == rhs.part_id)) {
    return false;
  }
  if (!(lhs.term == rhs.term)) {
    return false;
  }
  return true;
}

bool LeaderInfo::operator<(const LeaderInfo& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.part_id == rhs.part_id)) {
    return lhs.part_id < rhs.part_id;
  }
  if (!(lhs.term == rhs.term)) {
    return lhs.term < rhs.term;
  }
  return false;
}


void swap(LeaderInfo& a, LeaderInfo& b) {
  using ::std::swap;
  swap(a.part_id_ref().value(), b.part_id_ref().value());
  swap(a.term_ref().value(), b.term_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void LeaderInfo::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t LeaderInfo::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t LeaderInfo::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t LeaderInfo::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void LeaderInfo::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t LeaderInfo::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t LeaderInfo::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t LeaderInfo::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::PartitionList>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::PartitionList>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PartitionList::PartitionList(apache::thrift::FragileConstructor, ::std::vector< ::nebula::cpp2::PartitionID> part_list__arg) :
    part_list(std::move(part_list__arg)) {
  __isset.part_list = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void PartitionList::__clear() {
  // clear all fields
  part_list.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool PartitionList::operator==(const PartitionList& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.part_list == rhs.part_list)) {
    return false;
  }
  return true;
}

bool PartitionList::operator<(const PartitionList& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.part_list == rhs.part_list)) {
    return lhs.part_list < rhs.part_list;
  }
  return false;
}

const ::std::vector< ::nebula::cpp2::PartitionID>& PartitionList::get_part_list() const& {
  return part_list;
}

::std::vector< ::nebula::cpp2::PartitionID> PartitionList::get_part_list() && {
  return std::move(part_list);
}


void swap(PartitionList& a, PartitionList& b) {
  using ::std::swap;
  swap(a.part_list_ref().value(), b.part_list_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void PartitionList::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PartitionList::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PartitionList::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PartitionList::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PartitionList::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PartitionList::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PartitionList::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PartitionList::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::HBReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::HBReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
HBReq::HBReq() :
      role( ::nebula::meta::cpp2::HostRole::GRAPH),
      cluster_id(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


HBReq::~HBReq() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
HBReq::HBReq(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::HostRole role__arg, nebula::HostAddr host__arg,  ::nebula::meta::cpp2::ClusterID cluster_id__arg, std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::LeaderInfo>> leader_partIds__arg, ::std::string git_info_sha__arg, std::unordered_map< ::nebula::cpp2::GraphSpaceID, std::unordered_map<::std::string,  ::nebula::meta::cpp2::PartitionList>> disk_parts__arg) :
    role(std::move(role__arg)),
    host(std::move(host__arg)),
    cluster_id(std::move(cluster_id__arg)),
    leader_partIds(std::move(leader_partIds__arg)),
    git_info_sha(std::move(git_info_sha__arg)),
    disk_parts(std::move(disk_parts__arg)) {
  __isset.role = true;
  __isset.host = true;
  __isset.cluster_id = true;
  __isset.leader_partIds = true;
  __isset.git_info_sha = true;
  __isset.disk_parts = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void HBReq::__clear() {
  // clear all fields
  role =  ::nebula::meta::cpp2::HostRole::GRAPH;
  host.__clear();
  cluster_id = 0;
  leader_partIds.clear();
  git_info_sha = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  disk_parts.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool HBReq::operator==(const HBReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.role == rhs.role)) {
    return false;
  }
  if (!(lhs.host == rhs.host)) {
    return false;
  }
  if (!(lhs.cluster_id == rhs.cluster_id)) {
    return false;
  }
  if (lhs.leader_partIds_ref() != rhs.leader_partIds_ref()) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.git_info_sha, rhs.git_info_sha)) {
    return false;
  }
  if (lhs.disk_parts_ref() != rhs.disk_parts_ref()) {
    return false;
  }
  return true;
}

const nebula::HostAddr& HBReq::get_host() const& {
  return host;
}

nebula::HostAddr HBReq::get_host() && {
  return std::move(host);
}

const std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::LeaderInfo>>* HBReq::get_leader_partIds() const& {
  return leader_partIds_ref().has_value() ? std::addressof(leader_partIds) : nullptr;
}

std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::LeaderInfo>>* HBReq::get_leader_partIds() & {
  return leader_partIds_ref().has_value() ? std::addressof(leader_partIds) : nullptr;
}

const std::unordered_map< ::nebula::cpp2::GraphSpaceID, std::unordered_map<::std::string,  ::nebula::meta::cpp2::PartitionList>>* HBReq::get_disk_parts() const& {
  return disk_parts_ref().has_value() ? std::addressof(disk_parts) : nullptr;
}

std::unordered_map< ::nebula::cpp2::GraphSpaceID, std::unordered_map<::std::string,  ::nebula::meta::cpp2::PartitionList>>* HBReq::get_disk_parts() & {
  return disk_parts_ref().has_value() ? std::addressof(disk_parts) : nullptr;
}


void swap(HBReq& a, HBReq& b) {
  using ::std::swap;
  swap(a.role_ref().value(), b.role_ref().value());
  swap(a.host_ref().value(), b.host_ref().value());
  swap(a.cluster_id_ref().value(), b.cluster_id_ref().value());
  swap(a.leader_partIds_ref().value_unchecked(), b.leader_partIds_ref().value_unchecked());
  swap(a.git_info_sha_ref().value(), b.git_info_sha_ref().value());
  swap(a.disk_parts_ref().value_unchecked(), b.disk_parts_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void HBReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t HBReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t HBReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t HBReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void HBReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t HBReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t HBReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t HBReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        HBReq,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        HBReq,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::LeaderInfo>>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        HBReq,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::map<::apache::thrift::type_class::binary, ::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::GraphSpaceID, std::unordered_map<::std::string,  ::nebula::meta::cpp2::PartitionList>>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        HBReq,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        HBReq,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::meta::cpp2::LeaderInfo>>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        HBReq,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::map<::apache::thrift::type_class::binary, ::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::GraphSpaceID, std::unordered_map<::std::string,  ::nebula::meta::cpp2::PartitionList>>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::IndexFieldDef>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::IndexFieldDef>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
IndexFieldDef::IndexFieldDef(apache::thrift::FragileConstructor, ::std::string name__arg, int16_t type_length__arg) :
    name(std::move(name__arg)),
    type_length(std::move(type_length__arg)) {
  __isset.type_length = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void IndexFieldDef::__clear() {
  // clear all fields
  name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  type_length = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool IndexFieldDef::operator==(const IndexFieldDef& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return false;
  }
  if (lhs.type_length_ref() != rhs.type_length_ref()) {
    return false;
  }
  return true;
}

bool IndexFieldDef::operator<(const IndexFieldDef& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.name, rhs.name);
  }
  if (lhs.type_length_ref() != rhs.type_length_ref()) {
    return lhs.type_length_ref() < rhs.type_length_ref();
  }
  return false;
}


void swap(IndexFieldDef& a, IndexFieldDef& b) {
  using ::std::swap;
  swap(a.name_ref().value(), b.name_ref().value());
  swap(a.type_length_ref().value_unchecked(), b.type_length_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void IndexFieldDef::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t IndexFieldDef::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t IndexFieldDef::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t IndexFieldDef::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void IndexFieldDef::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t IndexFieldDef::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t IndexFieldDef::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t IndexFieldDef::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::CreateTagIndexReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::CreateTagIndexReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CreateTagIndexReq::CreateTagIndexReq() :
      space_id(0),
      if_not_exists(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


CreateTagIndexReq::~CreateTagIndexReq() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CreateTagIndexReq::CreateTagIndexReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string index_name__arg, ::std::string tag_name__arg, ::std::vector< ::nebula::meta::cpp2::IndexFieldDef> fields__arg, bool if_not_exists__arg, ::std::string comment__arg) :
    space_id(std::move(space_id__arg)),
    index_name(std::move(index_name__arg)),
    tag_name(std::move(tag_name__arg)),
    fields(std::move(fields__arg)),
    if_not_exists(std::move(if_not_exists__arg)),
    comment(std::move(comment__arg)) {
  __isset.space_id = true;
  __isset.index_name = true;
  __isset.tag_name = true;
  __isset.fields = true;
  __isset.if_not_exists = true;
  __isset.comment = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CreateTagIndexReq::__clear() {
  // clear all fields
  space_id = 0;
  index_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  tag_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  fields.clear();
  if_not_exists = 0;
  comment = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CreateTagIndexReq::operator==(const CreateTagIndexReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.index_name, rhs.index_name)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.tag_name, rhs.tag_name)) {
    return false;
  }
  if (!(lhs.fields == rhs.fields)) {
    return false;
  }
  if (!(lhs.if_not_exists == rhs.if_not_exists)) {
    return false;
  }
  if (lhs.comment_ref().has_value() != rhs.comment_ref().has_value()) {
    return false;
  }
  if (lhs.comment_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.comment, rhs.comment)) {
      return false;
    }
  }
  return true;
}

bool CreateTagIndexReq::operator<(const CreateTagIndexReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.index_name, rhs.index_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.index_name, rhs.index_name);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.tag_name, rhs.tag_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.tag_name, rhs.tag_name);
  }
  if (!(lhs.fields == rhs.fields)) {
    return lhs.fields < rhs.fields;
  }
  if (!(lhs.if_not_exists == rhs.if_not_exists)) {
    return lhs.if_not_exists < rhs.if_not_exists;
  }
  if (lhs.comment_ref().has_value() != rhs.comment_ref().has_value()) {
    return lhs.comment_ref().has_value() < rhs.comment_ref().has_value();
  }
  if (lhs.comment_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.comment, rhs.comment)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.comment, rhs.comment);
    }
  }
  return false;
}

const ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>& CreateTagIndexReq::get_fields() const& {
  return fields;
}

::std::vector< ::nebula::meta::cpp2::IndexFieldDef> CreateTagIndexReq::get_fields() && {
  return std::move(fields);
}


void swap(CreateTagIndexReq& a, CreateTagIndexReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.index_name_ref().value(), b.index_name_ref().value());
  swap(a.tag_name_ref().value(), b.tag_name_ref().value());
  swap(a.fields_ref().value(), b.fields_ref().value());
  swap(a.if_not_exists_ref().value(), b.if_not_exists_ref().value());
  swap(a.comment_ref().value_unchecked(), b.comment_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CreateTagIndexReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CreateTagIndexReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CreateTagIndexReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CreateTagIndexReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CreateTagIndexReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CreateTagIndexReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CreateTagIndexReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CreateTagIndexReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CreateTagIndexReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CreateTagIndexReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::DropTagIndexReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::DropTagIndexReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DropTagIndexReq::DropTagIndexReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string index_name__arg, bool if_exists__arg) :
    space_id(std::move(space_id__arg)),
    index_name(std::move(index_name__arg)),
    if_exists(std::move(if_exists__arg)) {
  __isset.space_id = true;
  __isset.index_name = true;
  __isset.if_exists = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void DropTagIndexReq::__clear() {
  // clear all fields
  space_id = 0;
  index_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  if_exists = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DropTagIndexReq::operator==(const DropTagIndexReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.index_name, rhs.index_name)) {
    return false;
  }
  if (!(lhs.if_exists == rhs.if_exists)) {
    return false;
  }
  return true;
}

bool DropTagIndexReq::operator<(const DropTagIndexReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.index_name, rhs.index_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.index_name, rhs.index_name);
  }
  if (!(lhs.if_exists == rhs.if_exists)) {
    return lhs.if_exists < rhs.if_exists;
  }
  return false;
}


void swap(DropTagIndexReq& a, DropTagIndexReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.index_name_ref().value(), b.index_name_ref().value());
  swap(a.if_exists_ref().value(), b.if_exists_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DropTagIndexReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DropTagIndexReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DropTagIndexReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DropTagIndexReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DropTagIndexReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DropTagIndexReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DropTagIndexReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DropTagIndexReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetTagIndexReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetTagIndexReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetTagIndexReq::GetTagIndexReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string index_name__arg) :
    space_id(std::move(space_id__arg)),
    index_name(std::move(index_name__arg)) {
  __isset.space_id = true;
  __isset.index_name = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetTagIndexReq::__clear() {
  // clear all fields
  space_id = 0;
  index_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetTagIndexReq::operator==(const GetTagIndexReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.index_name, rhs.index_name)) {
    return false;
  }
  return true;
}

bool GetTagIndexReq::operator<(const GetTagIndexReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.index_name, rhs.index_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.index_name, rhs.index_name);
  }
  return false;
}


void swap(GetTagIndexReq& a, GetTagIndexReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.index_name_ref().value(), b.index_name_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetTagIndexReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetTagIndexReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetTagIndexReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetTagIndexReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetTagIndexReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetTagIndexReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetTagIndexReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetTagIndexReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetTagIndexResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetTagIndexResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetTagIndexResp::GetTagIndexResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::IndexItem item__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    item(std::move(item__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.item = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetTagIndexResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  item.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetTagIndexResp::operator==(const GetTagIndexResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.item == rhs.item)) {
    return false;
  }
  return true;
}

bool GetTagIndexResp::operator<(const GetTagIndexResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.item == rhs.item)) {
    return lhs.item < rhs.item;
  }
  return false;
}

const nebula::HostAddr& GetTagIndexResp::get_leader() const& {
  return leader;
}

nebula::HostAddr GetTagIndexResp::get_leader() && {
  return std::move(leader);
}

const  ::nebula::meta::cpp2::IndexItem& GetTagIndexResp::get_item() const& {
  return item;
}

 ::nebula::meta::cpp2::IndexItem GetTagIndexResp::get_item() && {
  return std::move(item);
}


void swap(GetTagIndexResp& a, GetTagIndexResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.item_ref().value(), b.item_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetTagIndexResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetTagIndexResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetTagIndexResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetTagIndexResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetTagIndexResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetTagIndexResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetTagIndexResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetTagIndexResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetTagIndexResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetTagIndexResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::IndexItem>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetTagIndexResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetTagIndexResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::IndexItem>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListTagIndexesReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListTagIndexesReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListTagIndexesReq::ListTagIndexesReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg) :
    space_id(std::move(space_id__arg)) {
  __isset.space_id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListTagIndexesReq::__clear() {
  // clear all fields
  space_id = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListTagIndexesReq::operator==(const ListTagIndexesReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  return true;
}

bool ListTagIndexesReq::operator<(const ListTagIndexesReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  return false;
}


void swap(ListTagIndexesReq& a, ListTagIndexesReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListTagIndexesReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListTagIndexesReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListTagIndexesReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListTagIndexesReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListTagIndexesReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListTagIndexesReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListTagIndexesReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListTagIndexesReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListTagIndexesResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListTagIndexesResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListTagIndexesResp::ListTagIndexesResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::IndexItem> items__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    items(std::move(items__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.items = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListTagIndexesResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  items.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListTagIndexesResp::operator==(const ListTagIndexesResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.items == rhs.items)) {
    return false;
  }
  return true;
}

bool ListTagIndexesResp::operator<(const ListTagIndexesResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.items == rhs.items)) {
    return lhs.items < rhs.items;
  }
  return false;
}

const nebula::HostAddr& ListTagIndexesResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ListTagIndexesResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector< ::nebula::meta::cpp2::IndexItem>& ListTagIndexesResp::get_items() const& {
  return items;
}

::std::vector< ::nebula::meta::cpp2::IndexItem> ListTagIndexesResp::get_items() && {
  return std::move(items);
}


void swap(ListTagIndexesResp& a, ListTagIndexesResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.items_ref().value(), b.items_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListTagIndexesResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListTagIndexesResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListTagIndexesResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListTagIndexesResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListTagIndexesResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListTagIndexesResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListTagIndexesResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListTagIndexesResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListTagIndexesResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListTagIndexesResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::IndexItem>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListTagIndexesResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListTagIndexesResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::IndexItem>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::CreateEdgeIndexReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::CreateEdgeIndexReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CreateEdgeIndexReq::CreateEdgeIndexReq() :
      space_id(0),
      if_not_exists(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


CreateEdgeIndexReq::~CreateEdgeIndexReq() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CreateEdgeIndexReq::CreateEdgeIndexReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string index_name__arg, ::std::string edge_name__arg, ::std::vector< ::nebula::meta::cpp2::IndexFieldDef> fields__arg, bool if_not_exists__arg, ::std::string comment__arg) :
    space_id(std::move(space_id__arg)),
    index_name(std::move(index_name__arg)),
    edge_name(std::move(edge_name__arg)),
    fields(std::move(fields__arg)),
    if_not_exists(std::move(if_not_exists__arg)),
    comment(std::move(comment__arg)) {
  __isset.space_id = true;
  __isset.index_name = true;
  __isset.edge_name = true;
  __isset.fields = true;
  __isset.if_not_exists = true;
  __isset.comment = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CreateEdgeIndexReq::__clear() {
  // clear all fields
  space_id = 0;
  index_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  edge_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  fields.clear();
  if_not_exists = 0;
  comment = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CreateEdgeIndexReq::operator==(const CreateEdgeIndexReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.index_name, rhs.index_name)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.edge_name, rhs.edge_name)) {
    return false;
  }
  if (!(lhs.fields == rhs.fields)) {
    return false;
  }
  if (!(lhs.if_not_exists == rhs.if_not_exists)) {
    return false;
  }
  if (lhs.comment_ref().has_value() != rhs.comment_ref().has_value()) {
    return false;
  }
  if (lhs.comment_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.comment, rhs.comment)) {
      return false;
    }
  }
  return true;
}

bool CreateEdgeIndexReq::operator<(const CreateEdgeIndexReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.index_name, rhs.index_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.index_name, rhs.index_name);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.edge_name, rhs.edge_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.edge_name, rhs.edge_name);
  }
  if (!(lhs.fields == rhs.fields)) {
    return lhs.fields < rhs.fields;
  }
  if (!(lhs.if_not_exists == rhs.if_not_exists)) {
    return lhs.if_not_exists < rhs.if_not_exists;
  }
  if (lhs.comment_ref().has_value() != rhs.comment_ref().has_value()) {
    return lhs.comment_ref().has_value() < rhs.comment_ref().has_value();
  }
  if (lhs.comment_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.comment, rhs.comment)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.comment, rhs.comment);
    }
  }
  return false;
}

const ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>& CreateEdgeIndexReq::get_fields() const& {
  return fields;
}

::std::vector< ::nebula::meta::cpp2::IndexFieldDef> CreateEdgeIndexReq::get_fields() && {
  return std::move(fields);
}


void swap(CreateEdgeIndexReq& a, CreateEdgeIndexReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.index_name_ref().value(), b.index_name_ref().value());
  swap(a.edge_name_ref().value(), b.edge_name_ref().value());
  swap(a.fields_ref().value(), b.fields_ref().value());
  swap(a.if_not_exists_ref().value(), b.if_not_exists_ref().value());
  swap(a.comment_ref().value_unchecked(), b.comment_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CreateEdgeIndexReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CreateEdgeIndexReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CreateEdgeIndexReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CreateEdgeIndexReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CreateEdgeIndexReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CreateEdgeIndexReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CreateEdgeIndexReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CreateEdgeIndexReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CreateEdgeIndexReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CreateEdgeIndexReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::IndexFieldDef>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::DropEdgeIndexReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::DropEdgeIndexReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DropEdgeIndexReq::DropEdgeIndexReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string index_name__arg, bool if_exists__arg) :
    space_id(std::move(space_id__arg)),
    index_name(std::move(index_name__arg)),
    if_exists(std::move(if_exists__arg)) {
  __isset.space_id = true;
  __isset.index_name = true;
  __isset.if_exists = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void DropEdgeIndexReq::__clear() {
  // clear all fields
  space_id = 0;
  index_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  if_exists = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DropEdgeIndexReq::operator==(const DropEdgeIndexReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.index_name, rhs.index_name)) {
    return false;
  }
  if (!(lhs.if_exists == rhs.if_exists)) {
    return false;
  }
  return true;
}

bool DropEdgeIndexReq::operator<(const DropEdgeIndexReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.index_name, rhs.index_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.index_name, rhs.index_name);
  }
  if (!(lhs.if_exists == rhs.if_exists)) {
    return lhs.if_exists < rhs.if_exists;
  }
  return false;
}


void swap(DropEdgeIndexReq& a, DropEdgeIndexReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.index_name_ref().value(), b.index_name_ref().value());
  swap(a.if_exists_ref().value(), b.if_exists_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DropEdgeIndexReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DropEdgeIndexReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DropEdgeIndexReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DropEdgeIndexReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DropEdgeIndexReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DropEdgeIndexReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DropEdgeIndexReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DropEdgeIndexReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetEdgeIndexReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetEdgeIndexReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetEdgeIndexReq::GetEdgeIndexReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string index_name__arg) :
    space_id(std::move(space_id__arg)),
    index_name(std::move(index_name__arg)) {
  __isset.space_id = true;
  __isset.index_name = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetEdgeIndexReq::__clear() {
  // clear all fields
  space_id = 0;
  index_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetEdgeIndexReq::operator==(const GetEdgeIndexReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.index_name, rhs.index_name)) {
    return false;
  }
  return true;
}

bool GetEdgeIndexReq::operator<(const GetEdgeIndexReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.index_name, rhs.index_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.index_name, rhs.index_name);
  }
  return false;
}


void swap(GetEdgeIndexReq& a, GetEdgeIndexReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.index_name_ref().value(), b.index_name_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetEdgeIndexReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetEdgeIndexReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetEdgeIndexReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetEdgeIndexReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetEdgeIndexReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetEdgeIndexReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetEdgeIndexReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetEdgeIndexReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetEdgeIndexResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetEdgeIndexResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetEdgeIndexResp::GetEdgeIndexResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::IndexItem item__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    item(std::move(item__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.item = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetEdgeIndexResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  item.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetEdgeIndexResp::operator==(const GetEdgeIndexResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.item == rhs.item)) {
    return false;
  }
  return true;
}

bool GetEdgeIndexResp::operator<(const GetEdgeIndexResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.item == rhs.item)) {
    return lhs.item < rhs.item;
  }
  return false;
}

const nebula::HostAddr& GetEdgeIndexResp::get_leader() const& {
  return leader;
}

nebula::HostAddr GetEdgeIndexResp::get_leader() && {
  return std::move(leader);
}

const  ::nebula::meta::cpp2::IndexItem& GetEdgeIndexResp::get_item() const& {
  return item;
}

 ::nebula::meta::cpp2::IndexItem GetEdgeIndexResp::get_item() && {
  return std::move(item);
}


void swap(GetEdgeIndexResp& a, GetEdgeIndexResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.item_ref().value(), b.item_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetEdgeIndexResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetEdgeIndexResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetEdgeIndexResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetEdgeIndexResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetEdgeIndexResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetEdgeIndexResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetEdgeIndexResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetEdgeIndexResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetEdgeIndexResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetEdgeIndexResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::IndexItem>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetEdgeIndexResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetEdgeIndexResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::IndexItem>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListEdgeIndexesReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListEdgeIndexesReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListEdgeIndexesReq::ListEdgeIndexesReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg) :
    space_id(std::move(space_id__arg)) {
  __isset.space_id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListEdgeIndexesReq::__clear() {
  // clear all fields
  space_id = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListEdgeIndexesReq::operator==(const ListEdgeIndexesReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  return true;
}

bool ListEdgeIndexesReq::operator<(const ListEdgeIndexesReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  return false;
}


void swap(ListEdgeIndexesReq& a, ListEdgeIndexesReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListEdgeIndexesReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListEdgeIndexesReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListEdgeIndexesReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListEdgeIndexesReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListEdgeIndexesReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListEdgeIndexesReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListEdgeIndexesReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListEdgeIndexesReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListEdgeIndexesResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListEdgeIndexesResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListEdgeIndexesResp::ListEdgeIndexesResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::IndexItem> items__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    items(std::move(items__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.items = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListEdgeIndexesResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  items.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListEdgeIndexesResp::operator==(const ListEdgeIndexesResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.items == rhs.items)) {
    return false;
  }
  return true;
}

bool ListEdgeIndexesResp::operator<(const ListEdgeIndexesResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.items == rhs.items)) {
    return lhs.items < rhs.items;
  }
  return false;
}

const nebula::HostAddr& ListEdgeIndexesResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ListEdgeIndexesResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector< ::nebula::meta::cpp2::IndexItem>& ListEdgeIndexesResp::get_items() const& {
  return items;
}

::std::vector< ::nebula::meta::cpp2::IndexItem> ListEdgeIndexesResp::get_items() && {
  return std::move(items);
}


void swap(ListEdgeIndexesResp& a, ListEdgeIndexesResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.items_ref().value(), b.items_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListEdgeIndexesResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListEdgeIndexesResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListEdgeIndexesResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListEdgeIndexesResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListEdgeIndexesResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListEdgeIndexesResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListEdgeIndexesResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListEdgeIndexesResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListEdgeIndexesResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListEdgeIndexesResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::IndexItem>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListEdgeIndexesResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListEdgeIndexesResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::IndexItem>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::RebuildIndexReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::RebuildIndexReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RebuildIndexReq::RebuildIndexReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string index_name__arg) :
    space_id(std::move(space_id__arg)),
    index_name(std::move(index_name__arg)) {
  __isset.space_id = true;
  __isset.index_name = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void RebuildIndexReq::__clear() {
  // clear all fields
  space_id = 0;
  index_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool RebuildIndexReq::operator==(const RebuildIndexReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.index_name, rhs.index_name)) {
    return false;
  }
  return true;
}

bool RebuildIndexReq::operator<(const RebuildIndexReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.index_name, rhs.index_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.index_name, rhs.index_name);
  }
  return false;
}


void swap(RebuildIndexReq& a, RebuildIndexReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.index_name_ref().value(), b.index_name_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void RebuildIndexReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RebuildIndexReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RebuildIndexReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RebuildIndexReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RebuildIndexReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RebuildIndexReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RebuildIndexReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RebuildIndexReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::CreateUserReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::CreateUserReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CreateUserReq::CreateUserReq(apache::thrift::FragileConstructor, ::std::string account__arg, ::std::string encoded_pwd__arg, bool if_not_exists__arg) :
    account(std::move(account__arg)),
    encoded_pwd(std::move(encoded_pwd__arg)),
    if_not_exists(std::move(if_not_exists__arg)) {
  __isset.account = true;
  __isset.encoded_pwd = true;
  __isset.if_not_exists = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CreateUserReq::__clear() {
  // clear all fields
  account = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  encoded_pwd = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  if_not_exists = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CreateUserReq::operator==(const CreateUserReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.account, rhs.account)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.encoded_pwd, rhs.encoded_pwd)) {
    return false;
  }
  if (!(lhs.if_not_exists == rhs.if_not_exists)) {
    return false;
  }
  return true;
}

bool CreateUserReq::operator<(const CreateUserReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.account, rhs.account)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.account, rhs.account);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.encoded_pwd, rhs.encoded_pwd)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.encoded_pwd, rhs.encoded_pwd);
  }
  if (!(lhs.if_not_exists == rhs.if_not_exists)) {
    return lhs.if_not_exists < rhs.if_not_exists;
  }
  return false;
}


void swap(CreateUserReq& a, CreateUserReq& b) {
  using ::std::swap;
  swap(a.account_ref().value(), b.account_ref().value());
  swap(a.encoded_pwd_ref().value(), b.encoded_pwd_ref().value());
  swap(a.if_not_exists_ref().value(), b.if_not_exists_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CreateUserReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CreateUserReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CreateUserReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CreateUserReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CreateUserReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CreateUserReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CreateUserReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CreateUserReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::DropUserReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::DropUserReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DropUserReq::DropUserReq(apache::thrift::FragileConstructor, ::std::string account__arg, bool if_exists__arg) :
    account(std::move(account__arg)),
    if_exists(std::move(if_exists__arg)) {
  __isset.account = true;
  __isset.if_exists = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void DropUserReq::__clear() {
  // clear all fields
  account = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  if_exists = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DropUserReq::operator==(const DropUserReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.account, rhs.account)) {
    return false;
  }
  if (!(lhs.if_exists == rhs.if_exists)) {
    return false;
  }
  return true;
}

bool DropUserReq::operator<(const DropUserReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.account, rhs.account)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.account, rhs.account);
  }
  if (!(lhs.if_exists == rhs.if_exists)) {
    return lhs.if_exists < rhs.if_exists;
  }
  return false;
}


void swap(DropUserReq& a, DropUserReq& b) {
  using ::std::swap;
  swap(a.account_ref().value(), b.account_ref().value());
  swap(a.if_exists_ref().value(), b.if_exists_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DropUserReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DropUserReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DropUserReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DropUserReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DropUserReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DropUserReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DropUserReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DropUserReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::AlterUserReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::AlterUserReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AlterUserReq::AlterUserReq(apache::thrift::FragileConstructor, ::std::string account__arg, ::std::string encoded_pwd__arg) :
    account(std::move(account__arg)),
    encoded_pwd(std::move(encoded_pwd__arg)) {
  __isset.account = true;
  __isset.encoded_pwd = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AlterUserReq::__clear() {
  // clear all fields
  account = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  encoded_pwd = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AlterUserReq::operator==(const AlterUserReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.account, rhs.account)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.encoded_pwd, rhs.encoded_pwd)) {
    return false;
  }
  return true;
}

bool AlterUserReq::operator<(const AlterUserReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.account, rhs.account)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.account, rhs.account);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.encoded_pwd, rhs.encoded_pwd)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.encoded_pwd, rhs.encoded_pwd);
  }
  return false;
}


void swap(AlterUserReq& a, AlterUserReq& b) {
  using ::std::swap;
  swap(a.account_ref().value(), b.account_ref().value());
  swap(a.encoded_pwd_ref().value(), b.encoded_pwd_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AlterUserReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AlterUserReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AlterUserReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AlterUserReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AlterUserReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AlterUserReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AlterUserReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AlterUserReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GrantRoleReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GrantRoleReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GrantRoleReq::GrantRoleReq(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::RoleItem role_item__arg) :
    role_item(std::move(role_item__arg)) {
  __isset.role_item = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GrantRoleReq::__clear() {
  // clear all fields
  role_item.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GrantRoleReq::operator==(const GrantRoleReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.role_item == rhs.role_item)) {
    return false;
  }
  return true;
}

bool GrantRoleReq::operator<(const GrantRoleReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.role_item == rhs.role_item)) {
    return lhs.role_item < rhs.role_item;
  }
  return false;
}

const  ::nebula::meta::cpp2::RoleItem& GrantRoleReq::get_role_item() const& {
  return role_item;
}

 ::nebula::meta::cpp2::RoleItem GrantRoleReq::get_role_item() && {
  return std::move(role_item);
}


void swap(GrantRoleReq& a, GrantRoleReq& b) {
  using ::std::swap;
  swap(a.role_item_ref().value(), b.role_item_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GrantRoleReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GrantRoleReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GrantRoleReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GrantRoleReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GrantRoleReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GrantRoleReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GrantRoleReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GrantRoleReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GrantRoleReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::RoleItem>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GrantRoleReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::RoleItem>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::RevokeRoleReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::RevokeRoleReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RevokeRoleReq::RevokeRoleReq(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::RoleItem role_item__arg) :
    role_item(std::move(role_item__arg)) {
  __isset.role_item = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void RevokeRoleReq::__clear() {
  // clear all fields
  role_item.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool RevokeRoleReq::operator==(const RevokeRoleReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.role_item == rhs.role_item)) {
    return false;
  }
  return true;
}

bool RevokeRoleReq::operator<(const RevokeRoleReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.role_item == rhs.role_item)) {
    return lhs.role_item < rhs.role_item;
  }
  return false;
}

const  ::nebula::meta::cpp2::RoleItem& RevokeRoleReq::get_role_item() const& {
  return role_item;
}

 ::nebula::meta::cpp2::RoleItem RevokeRoleReq::get_role_item() && {
  return std::move(role_item);
}


void swap(RevokeRoleReq& a, RevokeRoleReq& b) {
  using ::std::swap;
  swap(a.role_item_ref().value(), b.role_item_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void RevokeRoleReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RevokeRoleReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RevokeRoleReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RevokeRoleReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RevokeRoleReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RevokeRoleReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RevokeRoleReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RevokeRoleReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        RevokeRoleReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::RoleItem>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        RevokeRoleReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::RoleItem>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListUsersReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListUsersReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListUsersReq::ListUsersReq(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListUsersReq::__clear() {
  // clear all fields
}

bool ListUsersReq::operator==(const ListUsersReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool ListUsersReq::operator<(const ListUsersReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(ListUsersReq& a, ListUsersReq& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void ListUsersReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListUsersReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListUsersReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListUsersReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListUsersReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListUsersReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListUsersReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListUsersReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListUsersResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListUsersResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListUsersResp::ListUsersResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, std::unordered_map<::std::string, ::std::string> users__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    users(std::move(users__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.users = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListUsersResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  users.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListUsersResp::operator==(const ListUsersResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.users == rhs.users)) {
    return false;
  }
  return true;
}

const nebula::HostAddr& ListUsersResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ListUsersResp::get_leader() && {
  return std::move(leader);
}

const std::unordered_map<::std::string, ::std::string>& ListUsersResp::get_users() const& {
  return users;
}

std::unordered_map<::std::string, ::std::string> ListUsersResp::get_users() && {
  return std::move(users);
}


void swap(ListUsersResp& a, ListUsersResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.users_ref().value(), b.users_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListUsersResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListUsersResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListUsersResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListUsersResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListUsersResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListUsersResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListUsersResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListUsersResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListUsersResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListUsersResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListRolesReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListRolesReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListRolesReq::ListRolesReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg) :
    space_id(std::move(space_id__arg)) {
  __isset.space_id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListRolesReq::__clear() {
  // clear all fields
  space_id = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListRolesReq::operator==(const ListRolesReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  return true;
}

bool ListRolesReq::operator<(const ListRolesReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  return false;
}


void swap(ListRolesReq& a, ListRolesReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListRolesReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListRolesReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListRolesReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListRolesReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListRolesReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListRolesReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListRolesReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListRolesReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListRolesResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListRolesResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListRolesResp::ListRolesResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::RoleItem> roles__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    roles(std::move(roles__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.roles = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListRolesResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  roles.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListRolesResp::operator==(const ListRolesResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.roles == rhs.roles)) {
    return false;
  }
  return true;
}

bool ListRolesResp::operator<(const ListRolesResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.roles == rhs.roles)) {
    return lhs.roles < rhs.roles;
  }
  return false;
}

const nebula::HostAddr& ListRolesResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ListRolesResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector< ::nebula::meta::cpp2::RoleItem>& ListRolesResp::get_roles() const& {
  return roles;
}

::std::vector< ::nebula::meta::cpp2::RoleItem> ListRolesResp::get_roles() && {
  return std::move(roles);
}


void swap(ListRolesResp& a, ListRolesResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.roles_ref().value(), b.roles_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListRolesResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListRolesResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListRolesResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListRolesResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListRolesResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListRolesResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListRolesResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListRolesResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListRolesResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListRolesResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::RoleItem>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListRolesResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListRolesResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::RoleItem>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetUserRolesReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetUserRolesReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetUserRolesReq::GetUserRolesReq(apache::thrift::FragileConstructor, ::std::string account__arg) :
    account(std::move(account__arg)) {
  __isset.account = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetUserRolesReq::__clear() {
  // clear all fields
  account = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetUserRolesReq::operator==(const GetUserRolesReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.account, rhs.account)) {
    return false;
  }
  return true;
}

bool GetUserRolesReq::operator<(const GetUserRolesReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.account, rhs.account)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.account, rhs.account);
  }
  return false;
}


void swap(GetUserRolesReq& a, GetUserRolesReq& b) {
  using ::std::swap;
  swap(a.account_ref().value(), b.account_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetUserRolesReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetUserRolesReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetUserRolesReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetUserRolesReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetUserRolesReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetUserRolesReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetUserRolesReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetUserRolesReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ChangePasswordReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ChangePasswordReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ChangePasswordReq::ChangePasswordReq(apache::thrift::FragileConstructor, ::std::string account__arg, ::std::string new_encoded_pwd__arg, ::std::string old_encoded_pwd__arg) :
    account(std::move(account__arg)),
    new_encoded_pwd(std::move(new_encoded_pwd__arg)),
    old_encoded_pwd(std::move(old_encoded_pwd__arg)) {
  __isset.account = true;
  __isset.new_encoded_pwd = true;
  __isset.old_encoded_pwd = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ChangePasswordReq::__clear() {
  // clear all fields
  account = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  new_encoded_pwd = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  old_encoded_pwd = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ChangePasswordReq::operator==(const ChangePasswordReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.account, rhs.account)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.new_encoded_pwd, rhs.new_encoded_pwd)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.old_encoded_pwd, rhs.old_encoded_pwd)) {
    return false;
  }
  return true;
}

bool ChangePasswordReq::operator<(const ChangePasswordReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.account, rhs.account)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.account, rhs.account);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.new_encoded_pwd, rhs.new_encoded_pwd)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.new_encoded_pwd, rhs.new_encoded_pwd);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.old_encoded_pwd, rhs.old_encoded_pwd)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.old_encoded_pwd, rhs.old_encoded_pwd);
  }
  return false;
}


void swap(ChangePasswordReq& a, ChangePasswordReq& b) {
  using ::std::swap;
  swap(a.account_ref().value(), b.account_ref().value());
  swap(a.new_encoded_pwd_ref().value(), b.new_encoded_pwd_ref().value());
  swap(a.old_encoded_pwd_ref().value(), b.old_encoded_pwd_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ChangePasswordReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ChangePasswordReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ChangePasswordReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ChangePasswordReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ChangePasswordReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ChangePasswordReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ChangePasswordReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ChangePasswordReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::BalanceTask>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::BalanceTask>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
BalanceTask::BalanceTask() :
      result( ::nebula::meta::cpp2::TaskResult::SUCCEEDED),
      start_time(0),
      stop_time(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


BalanceTask::~BalanceTask() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
BalanceTask::BalanceTask(apache::thrift::FragileConstructor, ::std::string id__arg, ::std::string command__arg,  ::nebula::meta::cpp2::TaskResult result__arg, int64_t start_time__arg, int64_t stop_time__arg) :
    id(std::move(id__arg)),
    command(std::move(command__arg)),
    result(std::move(result__arg)),
    start_time(std::move(start_time__arg)),
    stop_time(std::move(stop_time__arg)) {
  __isset.id = true;
  __isset.command = true;
  __isset.result = true;
  __isset.start_time = true;
  __isset.stop_time = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void BalanceTask::__clear() {
  // clear all fields
  id = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  command = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  result =  ::nebula::meta::cpp2::TaskResult::SUCCEEDED;
  start_time = 0;
  stop_time = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool BalanceTask::operator==(const BalanceTask& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.id, rhs.id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.command, rhs.command)) {
    return false;
  }
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.start_time == rhs.start_time)) {
    return false;
  }
  if (!(lhs.stop_time == rhs.stop_time)) {
    return false;
  }
  return true;
}

bool BalanceTask::operator<(const BalanceTask& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.id, rhs.id)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.id, rhs.id);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.command, rhs.command)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.command, rhs.command);
  }
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.start_time == rhs.start_time)) {
    return lhs.start_time < rhs.start_time;
  }
  if (!(lhs.stop_time == rhs.stop_time)) {
    return lhs.stop_time < rhs.stop_time;
  }
  return false;
}


void swap(BalanceTask& a, BalanceTask& b) {
  using ::std::swap;
  swap(a.id_ref().value(), b.id_ref().value());
  swap(a.command_ref().value(), b.command_ref().value());
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.start_time_ref().value(), b.start_time_ref().value());
  swap(a.stop_time_ref().value(), b.stop_time_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void BalanceTask::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t BalanceTask::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t BalanceTask::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t BalanceTask::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void BalanceTask::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t BalanceTask::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t BalanceTask::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t BalanceTask::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ConfigItem>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ConfigItem>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ConfigItem::ConfigItem(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::ConfigModule module__arg, ::std::string name__arg,  ::nebula::meta::cpp2::ConfigMode mode__arg, nebula::Value value__arg) :
    module(std::move(module__arg)),
    name(std::move(name__arg)),
    mode(std::move(mode__arg)),
    value(std::move(value__arg)) {
  __isset.module = true;
  __isset.name = true;
  __isset.mode = true;
  __isset.value = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ConfigItem::__clear() {
  // clear all fields
  module =  ::nebula::meta::cpp2::ConfigModule::UNKNOWN;
  name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  mode =  ::nebula::meta::cpp2::ConfigMode::IMMUTABLE;
  value.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ConfigItem::operator==(const ConfigItem& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.module == rhs.module)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return false;
  }
  if (!(lhs.mode == rhs.mode)) {
    return false;
  }
  if (!(lhs.value == rhs.value)) {
    return false;
  }
  return true;
}

const nebula::Value& ConfigItem::get_value() const& {
  return value;
}

nebula::Value ConfigItem::get_value() && {
  return std::move(value);
}


void swap(ConfigItem& a, ConfigItem& b) {
  using ::std::swap;
  swap(a.module_ref().value(), b.module_ref().value());
  swap(a.name_ref().value(), b.name_ref().value());
  swap(a.mode_ref().value(), b.mode_ref().value());
  swap(a.value_ref().value(), b.value_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ConfigItem::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ConfigItem::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ConfigItem::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ConfigItem::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ConfigItem::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ConfigItem::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ConfigItem::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ConfigItem::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ConfigItem,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ConfigItem,
        ::apache::thrift::type_class::variant,
        nebula::Value>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::RegConfigReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::RegConfigReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RegConfigReq::RegConfigReq(apache::thrift::FragileConstructor, ::std::vector< ::nebula::meta::cpp2::ConfigItem> items__arg) :
    items(std::move(items__arg)) {
  __isset.items = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void RegConfigReq::__clear() {
  // clear all fields
  items.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool RegConfigReq::operator==(const RegConfigReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.items == rhs.items)) {
    return false;
  }
  return true;
}

const ::std::vector< ::nebula::meta::cpp2::ConfigItem>& RegConfigReq::get_items() const& {
  return items;
}

::std::vector< ::nebula::meta::cpp2::ConfigItem> RegConfigReq::get_items() && {
  return std::move(items);
}


void swap(RegConfigReq& a, RegConfigReq& b) {
  using ::std::swap;
  swap(a.items_ref().value(), b.items_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void RegConfigReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RegConfigReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RegConfigReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RegConfigReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RegConfigReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RegConfigReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RegConfigReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RegConfigReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        RegConfigReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::ConfigItem>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        RegConfigReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::ConfigItem>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetConfigReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetConfigReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetConfigReq::GetConfigReq(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::ConfigItem item__arg) :
    item(std::move(item__arg)) {
  __isset.item = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetConfigReq::__clear() {
  // clear all fields
  item.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetConfigReq::operator==(const GetConfigReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.item == rhs.item)) {
    return false;
  }
  return true;
}

const  ::nebula::meta::cpp2::ConfigItem& GetConfigReq::get_item() const& {
  return item;
}

 ::nebula::meta::cpp2::ConfigItem GetConfigReq::get_item() && {
  return std::move(item);
}


void swap(GetConfigReq& a, GetConfigReq& b) {
  using ::std::swap;
  swap(a.item_ref().value(), b.item_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetConfigReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetConfigReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetConfigReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetConfigReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetConfigReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetConfigReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetConfigReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetConfigReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetConfigReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::ConfigItem>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetConfigReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::ConfigItem>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetConfigResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetConfigResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetConfigResp::GetConfigResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::ConfigItem> items__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    items(std::move(items__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.items = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetConfigResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  items.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetConfigResp::operator==(const GetConfigResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.items == rhs.items)) {
    return false;
  }
  return true;
}

const nebula::HostAddr& GetConfigResp::get_leader() const& {
  return leader;
}

nebula::HostAddr GetConfigResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector< ::nebula::meta::cpp2::ConfigItem>& GetConfigResp::get_items() const& {
  return items;
}

::std::vector< ::nebula::meta::cpp2::ConfigItem> GetConfigResp::get_items() && {
  return std::move(items);
}


void swap(GetConfigResp& a, GetConfigResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.items_ref().value(), b.items_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetConfigResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetConfigResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetConfigResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetConfigResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetConfigResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetConfigResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetConfigResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetConfigResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetConfigResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetConfigResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::ConfigItem>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetConfigResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetConfigResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::ConfigItem>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::SetConfigReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::SetConfigReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
SetConfigReq::SetConfigReq(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::ConfigItem item__arg) :
    item(std::move(item__arg)) {
  __isset.item = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void SetConfigReq::__clear() {
  // clear all fields
  item.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool SetConfigReq::operator==(const SetConfigReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.item == rhs.item)) {
    return false;
  }
  return true;
}

const  ::nebula::meta::cpp2::ConfigItem& SetConfigReq::get_item() const& {
  return item;
}

 ::nebula::meta::cpp2::ConfigItem SetConfigReq::get_item() && {
  return std::move(item);
}


void swap(SetConfigReq& a, SetConfigReq& b) {
  using ::std::swap;
  swap(a.item_ref().value(), b.item_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void SetConfigReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t SetConfigReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t SetConfigReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t SetConfigReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void SetConfigReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t SetConfigReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t SetConfigReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t SetConfigReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        SetConfigReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::ConfigItem>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        SetConfigReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::ConfigItem>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListConfigsReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListConfigsReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListConfigsReq::ListConfigsReq(apache::thrift::FragileConstructor, ::std::string space__arg,  ::nebula::meta::cpp2::ConfigModule module__arg) :
    space(std::move(space__arg)),
    module(std::move(module__arg)) {
  __isset.space = true;
  __isset.module = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListConfigsReq::__clear() {
  // clear all fields
  space = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  module =  ::nebula::meta::cpp2::ConfigModule::UNKNOWN;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListConfigsReq::operator==(const ListConfigsReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.space, rhs.space)) {
    return false;
  }
  if (!(lhs.module == rhs.module)) {
    return false;
  }
  return true;
}

bool ListConfigsReq::operator<(const ListConfigsReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.space, rhs.space)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.space, rhs.space);
  }
  if (!(lhs.module == rhs.module)) {
    return lhs.module < rhs.module;
  }
  return false;
}


void swap(ListConfigsReq& a, ListConfigsReq& b) {
  using ::std::swap;
  swap(a.space_ref().value(), b.space_ref().value());
  swap(a.module_ref().value(), b.module_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListConfigsReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListConfigsReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListConfigsReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListConfigsReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListConfigsReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListConfigsReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListConfigsReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListConfigsReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListConfigsResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListConfigsResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListConfigsResp::ListConfigsResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::ConfigItem> items__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    items(std::move(items__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.items = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListConfigsResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  items.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListConfigsResp::operator==(const ListConfigsResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.items == rhs.items)) {
    return false;
  }
  return true;
}

const nebula::HostAddr& ListConfigsResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ListConfigsResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector< ::nebula::meta::cpp2::ConfigItem>& ListConfigsResp::get_items() const& {
  return items;
}

::std::vector< ::nebula::meta::cpp2::ConfigItem> ListConfigsResp::get_items() && {
  return std::move(items);
}


void swap(ListConfigsResp& a, ListConfigsResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.items_ref().value(), b.items_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListConfigsResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListConfigsResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListConfigsResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListConfigsResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListConfigsResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListConfigsResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListConfigsResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListConfigsResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListConfigsResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListConfigsResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::ConfigItem>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListConfigsResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListConfigsResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::ConfigItem>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::CreateSnapshotReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::CreateSnapshotReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CreateSnapshotReq::CreateSnapshotReq(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CreateSnapshotReq::__clear() {
  // clear all fields
}

bool CreateSnapshotReq::operator==(const CreateSnapshotReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool CreateSnapshotReq::operator<(const CreateSnapshotReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(CreateSnapshotReq& a, CreateSnapshotReq& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void CreateSnapshotReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CreateSnapshotReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CreateSnapshotReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CreateSnapshotReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CreateSnapshotReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CreateSnapshotReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CreateSnapshotReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CreateSnapshotReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::DropSnapshotReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::DropSnapshotReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DropSnapshotReq::DropSnapshotReq(apache::thrift::FragileConstructor, ::std::string name__arg) :
    name(std::move(name__arg)) {
  __isset.name = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void DropSnapshotReq::__clear() {
  // clear all fields
  name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DropSnapshotReq::operator==(const DropSnapshotReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return false;
  }
  return true;
}

bool DropSnapshotReq::operator<(const DropSnapshotReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.name, rhs.name);
  }
  return false;
}


void swap(DropSnapshotReq& a, DropSnapshotReq& b) {
  using ::std::swap;
  swap(a.name_ref().value(), b.name_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DropSnapshotReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DropSnapshotReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DropSnapshotReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DropSnapshotReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DropSnapshotReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DropSnapshotReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DropSnapshotReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DropSnapshotReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListSnapshotsReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListSnapshotsReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListSnapshotsReq::ListSnapshotsReq(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListSnapshotsReq::__clear() {
  // clear all fields
}

bool ListSnapshotsReq::operator==(const ListSnapshotsReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool ListSnapshotsReq::operator<(const ListSnapshotsReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(ListSnapshotsReq& a, ListSnapshotsReq& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void ListSnapshotsReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListSnapshotsReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListSnapshotsReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListSnapshotsReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListSnapshotsReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListSnapshotsReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListSnapshotsReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListSnapshotsReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::Snapshot>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::Snapshot>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Snapshot::Snapshot(apache::thrift::FragileConstructor, ::std::string name__arg,  ::nebula::meta::cpp2::SnapshotStatus status__arg, ::std::string hosts__arg) :
    name(std::move(name__arg)),
    status(std::move(status__arg)),
    hosts(std::move(hosts__arg)) {
  __isset.name = true;
  __isset.status = true;
  __isset.hosts = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Snapshot::__clear() {
  // clear all fields
  name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  status =  ::nebula::meta::cpp2::SnapshotStatus::VALID;
  hosts = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool Snapshot::operator==(const Snapshot& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return false;
  }
  if (!(lhs.status == rhs.status)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.hosts, rhs.hosts)) {
    return false;
  }
  return true;
}

bool Snapshot::operator<(const Snapshot& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.name, rhs.name);
  }
  if (!(lhs.status == rhs.status)) {
    return lhs.status < rhs.status;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.hosts, rhs.hosts)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.hosts, rhs.hosts);
  }
  return false;
}


void swap(Snapshot& a, Snapshot& b) {
  using ::std::swap;
  swap(a.name_ref().value(), b.name_ref().value());
  swap(a.status_ref().value(), b.status_ref().value());
  swap(a.hosts_ref().value(), b.hosts_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void Snapshot::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Snapshot::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Snapshot::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Snapshot::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Snapshot::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Snapshot::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Snapshot::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Snapshot::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListSnapshotsResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListSnapshotsResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListSnapshotsResp::ListSnapshotsResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::Snapshot> snapshots__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    snapshots(std::move(snapshots__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.snapshots = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListSnapshotsResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  snapshots.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListSnapshotsResp::operator==(const ListSnapshotsResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.snapshots == rhs.snapshots)) {
    return false;
  }
  return true;
}

bool ListSnapshotsResp::operator<(const ListSnapshotsResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.snapshots == rhs.snapshots)) {
    return lhs.snapshots < rhs.snapshots;
  }
  return false;
}

const nebula::HostAddr& ListSnapshotsResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ListSnapshotsResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector< ::nebula::meta::cpp2::Snapshot>& ListSnapshotsResp::get_snapshots() const& {
  return snapshots;
}

::std::vector< ::nebula::meta::cpp2::Snapshot> ListSnapshotsResp::get_snapshots() && {
  return std::move(snapshots);
}


void swap(ListSnapshotsResp& a, ListSnapshotsResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.snapshots_ref().value(), b.snapshots_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListSnapshotsResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListSnapshotsResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListSnapshotsResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListSnapshotsResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListSnapshotsResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListSnapshotsResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListSnapshotsResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListSnapshotsResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListSnapshotsResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListSnapshotsResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::Snapshot>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListSnapshotsResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListSnapshotsResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::Snapshot>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListIndexStatusReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListIndexStatusReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListIndexStatusReq::ListIndexStatusReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg) :
    space_id(std::move(space_id__arg)) {
  __isset.space_id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListIndexStatusReq::__clear() {
  // clear all fields
  space_id = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListIndexStatusReq::operator==(const ListIndexStatusReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  return true;
}

bool ListIndexStatusReq::operator<(const ListIndexStatusReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  return false;
}


void swap(ListIndexStatusReq& a, ListIndexStatusReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListIndexStatusReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListIndexStatusReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListIndexStatusReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListIndexStatusReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListIndexStatusReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListIndexStatusReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListIndexStatusReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListIndexStatusReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::IndexStatus>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::IndexStatus>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
IndexStatus::IndexStatus(apache::thrift::FragileConstructor, ::std::string name__arg, ::std::string status__arg) :
    name(std::move(name__arg)),
    status(std::move(status__arg)) {
  __isset.name = true;
  __isset.status = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void IndexStatus::__clear() {
  // clear all fields
  name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  status = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool IndexStatus::operator==(const IndexStatus& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.status, rhs.status)) {
    return false;
  }
  return true;
}

bool IndexStatus::operator<(const IndexStatus& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.name, rhs.name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.name, rhs.name);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.status, rhs.status)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.status, rhs.status);
  }
  return false;
}


void swap(IndexStatus& a, IndexStatus& b) {
  using ::std::swap;
  swap(a.name_ref().value(), b.name_ref().value());
  swap(a.status_ref().value(), b.status_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void IndexStatus::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t IndexStatus::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t IndexStatus::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t IndexStatus::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void IndexStatus::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t IndexStatus::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t IndexStatus::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t IndexStatus::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListIndexStatusResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListIndexStatusResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListIndexStatusResp::ListIndexStatusResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::IndexStatus> statuses__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    statuses(std::move(statuses__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.statuses = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListIndexStatusResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  statuses.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListIndexStatusResp::operator==(const ListIndexStatusResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.statuses == rhs.statuses)) {
    return false;
  }
  return true;
}

bool ListIndexStatusResp::operator<(const ListIndexStatusResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.statuses == rhs.statuses)) {
    return lhs.statuses < rhs.statuses;
  }
  return false;
}

const nebula::HostAddr& ListIndexStatusResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ListIndexStatusResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector< ::nebula::meta::cpp2::IndexStatus>& ListIndexStatusResp::get_statuses() const& {
  return statuses;
}

::std::vector< ::nebula::meta::cpp2::IndexStatus> ListIndexStatusResp::get_statuses() && {
  return std::move(statuses);
}


void swap(ListIndexStatusResp& a, ListIndexStatusResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.statuses_ref().value(), b.statuses_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListIndexStatusResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListIndexStatusResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListIndexStatusResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListIndexStatusResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListIndexStatusResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListIndexStatusResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListIndexStatusResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListIndexStatusResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListIndexStatusResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListIndexStatusResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::IndexStatus>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListIndexStatusResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListIndexStatusResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::IndexStatus>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::AddZoneReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::AddZoneReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AddZoneReq::AddZoneReq(apache::thrift::FragileConstructor, ::std::string zone_name__arg, ::std::vector<nebula::HostAddr> nodes__arg) :
    zone_name(std::move(zone_name__arg)),
    nodes(std::move(nodes__arg)) {
  __isset.zone_name = true;
  __isset.nodes = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AddZoneReq::__clear() {
  // clear all fields
  zone_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  nodes.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AddZoneReq::operator==(const AddZoneReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.zone_name, rhs.zone_name)) {
    return false;
  }
  if (!(lhs.nodes == rhs.nodes)) {
    return false;
  }
  return true;
}

bool AddZoneReq::operator<(const AddZoneReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.zone_name, rhs.zone_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.zone_name, rhs.zone_name);
  }
  if (!(lhs.nodes == rhs.nodes)) {
    return lhs.nodes < rhs.nodes;
  }
  return false;
}

const ::std::vector<nebula::HostAddr>& AddZoneReq::get_nodes() const& {
  return nodes;
}

::std::vector<nebula::HostAddr> AddZoneReq::get_nodes() && {
  return std::move(nodes);
}


void swap(AddZoneReq& a, AddZoneReq& b) {
  using ::std::swap;
  swap(a.zone_name_ref().value(), b.zone_name_ref().value());
  swap(a.nodes_ref().value(), b.nodes_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AddZoneReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AddZoneReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AddZoneReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AddZoneReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AddZoneReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AddZoneReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AddZoneReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AddZoneReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AddZoneReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::HostAddr>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AddZoneReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::HostAddr>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::DropZoneReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::DropZoneReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DropZoneReq::DropZoneReq(apache::thrift::FragileConstructor, ::std::string zone_name__arg) :
    zone_name(std::move(zone_name__arg)) {
  __isset.zone_name = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void DropZoneReq::__clear() {
  // clear all fields
  zone_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DropZoneReq::operator==(const DropZoneReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.zone_name, rhs.zone_name)) {
    return false;
  }
  return true;
}

bool DropZoneReq::operator<(const DropZoneReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.zone_name, rhs.zone_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.zone_name, rhs.zone_name);
  }
  return false;
}


void swap(DropZoneReq& a, DropZoneReq& b) {
  using ::std::swap;
  swap(a.zone_name_ref().value(), b.zone_name_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DropZoneReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DropZoneReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DropZoneReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DropZoneReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DropZoneReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DropZoneReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DropZoneReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DropZoneReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::AddHostIntoZoneReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::AddHostIntoZoneReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AddHostIntoZoneReq::AddHostIntoZoneReq(apache::thrift::FragileConstructor, nebula::HostAddr node__arg, ::std::string zone_name__arg) :
    node(std::move(node__arg)),
    zone_name(std::move(zone_name__arg)) {
  __isset.node = true;
  __isset.zone_name = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AddHostIntoZoneReq::__clear() {
  // clear all fields
  node.__clear();
  zone_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AddHostIntoZoneReq::operator==(const AddHostIntoZoneReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.node == rhs.node)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.zone_name, rhs.zone_name)) {
    return false;
  }
  return true;
}

bool AddHostIntoZoneReq::operator<(const AddHostIntoZoneReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.node == rhs.node)) {
    return lhs.node < rhs.node;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.zone_name, rhs.zone_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.zone_name, rhs.zone_name);
  }
  return false;
}

const nebula::HostAddr& AddHostIntoZoneReq::get_node() const& {
  return node;
}

nebula::HostAddr AddHostIntoZoneReq::get_node() && {
  return std::move(node);
}


void swap(AddHostIntoZoneReq& a, AddHostIntoZoneReq& b) {
  using ::std::swap;
  swap(a.node_ref().value(), b.node_ref().value());
  swap(a.zone_name_ref().value(), b.zone_name_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AddHostIntoZoneReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AddHostIntoZoneReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AddHostIntoZoneReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AddHostIntoZoneReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AddHostIntoZoneReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AddHostIntoZoneReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AddHostIntoZoneReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AddHostIntoZoneReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AddHostIntoZoneReq,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AddHostIntoZoneReq,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::DropHostFromZoneReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::DropHostFromZoneReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DropHostFromZoneReq::DropHostFromZoneReq(apache::thrift::FragileConstructor, nebula::HostAddr node__arg, ::std::string zone_name__arg) :
    node(std::move(node__arg)),
    zone_name(std::move(zone_name__arg)) {
  __isset.node = true;
  __isset.zone_name = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void DropHostFromZoneReq::__clear() {
  // clear all fields
  node.__clear();
  zone_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DropHostFromZoneReq::operator==(const DropHostFromZoneReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.node == rhs.node)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.zone_name, rhs.zone_name)) {
    return false;
  }
  return true;
}

bool DropHostFromZoneReq::operator<(const DropHostFromZoneReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.node == rhs.node)) {
    return lhs.node < rhs.node;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.zone_name, rhs.zone_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.zone_name, rhs.zone_name);
  }
  return false;
}

const nebula::HostAddr& DropHostFromZoneReq::get_node() const& {
  return node;
}

nebula::HostAddr DropHostFromZoneReq::get_node() && {
  return std::move(node);
}


void swap(DropHostFromZoneReq& a, DropHostFromZoneReq& b) {
  using ::std::swap;
  swap(a.node_ref().value(), b.node_ref().value());
  swap(a.zone_name_ref().value(), b.zone_name_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DropHostFromZoneReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DropHostFromZoneReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DropHostFromZoneReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DropHostFromZoneReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DropHostFromZoneReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DropHostFromZoneReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DropHostFromZoneReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DropHostFromZoneReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        DropHostFromZoneReq,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        DropHostFromZoneReq,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetZoneReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetZoneReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetZoneReq::GetZoneReq(apache::thrift::FragileConstructor, ::std::string zone_name__arg) :
    zone_name(std::move(zone_name__arg)) {
  __isset.zone_name = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetZoneReq::__clear() {
  // clear all fields
  zone_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetZoneReq::operator==(const GetZoneReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.zone_name, rhs.zone_name)) {
    return false;
  }
  return true;
}

bool GetZoneReq::operator<(const GetZoneReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.zone_name, rhs.zone_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.zone_name, rhs.zone_name);
  }
  return false;
}


void swap(GetZoneReq& a, GetZoneReq& b) {
  using ::std::swap;
  swap(a.zone_name_ref().value(), b.zone_name_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetZoneReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetZoneReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetZoneReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetZoneReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetZoneReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetZoneReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetZoneReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetZoneReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetZoneResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetZoneResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetZoneResp::GetZoneResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector<nebula::HostAddr> hosts__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    hosts(std::move(hosts__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.hosts = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetZoneResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  hosts.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetZoneResp::operator==(const GetZoneResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.hosts == rhs.hosts)) {
    return false;
  }
  return true;
}

bool GetZoneResp::operator<(const GetZoneResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.hosts == rhs.hosts)) {
    return lhs.hosts < rhs.hosts;
  }
  return false;
}

const nebula::HostAddr& GetZoneResp::get_leader() const& {
  return leader;
}

nebula::HostAddr GetZoneResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector<nebula::HostAddr>& GetZoneResp::get_hosts() const& {
  return hosts;
}

::std::vector<nebula::HostAddr> GetZoneResp::get_hosts() && {
  return std::move(hosts);
}


void swap(GetZoneResp& a, GetZoneResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.hosts_ref().value(), b.hosts_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetZoneResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetZoneResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetZoneResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetZoneResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetZoneResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetZoneResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetZoneResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetZoneResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetZoneResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetZoneResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::HostAddr>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetZoneResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetZoneResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::HostAddr>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListZonesReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListZonesReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListZonesReq::ListZonesReq(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListZonesReq::__clear() {
  // clear all fields
}

bool ListZonesReq::operator==(const ListZonesReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool ListZonesReq::operator<(const ListZonesReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(ListZonesReq& a, ListZonesReq& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void ListZonesReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListZonesReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListZonesReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListZonesReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListZonesReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListZonesReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListZonesReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListZonesReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::Zone>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::Zone>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Zone::Zone(apache::thrift::FragileConstructor, ::std::string zone_name__arg, ::std::vector<nebula::HostAddr> nodes__arg) :
    zone_name(std::move(zone_name__arg)),
    nodes(std::move(nodes__arg)) {
  __isset.zone_name = true;
  __isset.nodes = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Zone::__clear() {
  // clear all fields
  zone_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  nodes.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool Zone::operator==(const Zone& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.zone_name, rhs.zone_name)) {
    return false;
  }
  if (!(lhs.nodes == rhs.nodes)) {
    return false;
  }
  return true;
}

bool Zone::operator<(const Zone& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.zone_name, rhs.zone_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.zone_name, rhs.zone_name);
  }
  if (!(lhs.nodes == rhs.nodes)) {
    return lhs.nodes < rhs.nodes;
  }
  return false;
}

const ::std::vector<nebula::HostAddr>& Zone::get_nodes() const& {
  return nodes;
}

::std::vector<nebula::HostAddr> Zone::get_nodes() && {
  return std::move(nodes);
}


void swap(Zone& a, Zone& b) {
  using ::std::swap;
  swap(a.zone_name_ref().value(), b.zone_name_ref().value());
  swap(a.nodes_ref().value(), b.nodes_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void Zone::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Zone::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Zone::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Zone::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Zone::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Zone::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Zone::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Zone::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Zone,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::HostAddr>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Zone,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::HostAddr>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListZonesResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListZonesResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListZonesResp::ListZonesResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::Zone> zones__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    zones(std::move(zones__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.zones = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListZonesResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  zones.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListZonesResp::operator==(const ListZonesResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.zones == rhs.zones)) {
    return false;
  }
  return true;
}

bool ListZonesResp::operator<(const ListZonesResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.zones == rhs.zones)) {
    return lhs.zones < rhs.zones;
  }
  return false;
}

const nebula::HostAddr& ListZonesResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ListZonesResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector< ::nebula::meta::cpp2::Zone>& ListZonesResp::get_zones() const& {
  return zones;
}

::std::vector< ::nebula::meta::cpp2::Zone> ListZonesResp::get_zones() && {
  return std::move(zones);
}


void swap(ListZonesResp& a, ListZonesResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.zones_ref().value(), b.zones_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListZonesResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListZonesResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListZonesResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListZonesResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListZonesResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListZonesResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListZonesResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListZonesResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListZonesResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListZonesResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::Zone>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListZonesResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListZonesResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::Zone>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::AddListenerReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::AddListenerReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AddListenerReq::AddListenerReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::meta::cpp2::ListenerType type__arg, ::std::vector<nebula::HostAddr> hosts__arg) :
    space_id(std::move(space_id__arg)),
    type(std::move(type__arg)),
    hosts(std::move(hosts__arg)) {
  __isset.space_id = true;
  __isset.type = true;
  __isset.hosts = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AddListenerReq::__clear() {
  // clear all fields
  space_id = 0;
  type =  ::nebula::meta::cpp2::ListenerType::UNKNOWN;
  hosts.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AddListenerReq::operator==(const AddListenerReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.type == rhs.type)) {
    return false;
  }
  if (!(lhs.hosts == rhs.hosts)) {
    return false;
  }
  return true;
}

bool AddListenerReq::operator<(const AddListenerReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!(lhs.type == rhs.type)) {
    return lhs.type < rhs.type;
  }
  if (!(lhs.hosts == rhs.hosts)) {
    return lhs.hosts < rhs.hosts;
  }
  return false;
}

const ::std::vector<nebula::HostAddr>& AddListenerReq::get_hosts() const& {
  return hosts;
}

::std::vector<nebula::HostAddr> AddListenerReq::get_hosts() && {
  return std::move(hosts);
}


void swap(AddListenerReq& a, AddListenerReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.type_ref().value(), b.type_ref().value());
  swap(a.hosts_ref().value(), b.hosts_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AddListenerReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AddListenerReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AddListenerReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AddListenerReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AddListenerReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AddListenerReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AddListenerReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AddListenerReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AddListenerReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::HostAddr>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AddListenerReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::HostAddr>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::RemoveListenerReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::RemoveListenerReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RemoveListenerReq::RemoveListenerReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::meta::cpp2::ListenerType type__arg) :
    space_id(std::move(space_id__arg)),
    type(std::move(type__arg)) {
  __isset.space_id = true;
  __isset.type = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void RemoveListenerReq::__clear() {
  // clear all fields
  space_id = 0;
  type =  ::nebula::meta::cpp2::ListenerType::UNKNOWN;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool RemoveListenerReq::operator==(const RemoveListenerReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.type == rhs.type)) {
    return false;
  }
  return true;
}

bool RemoveListenerReq::operator<(const RemoveListenerReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!(lhs.type == rhs.type)) {
    return lhs.type < rhs.type;
  }
  return false;
}


void swap(RemoveListenerReq& a, RemoveListenerReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.type_ref().value(), b.type_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void RemoveListenerReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RemoveListenerReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RemoveListenerReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RemoveListenerReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RemoveListenerReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RemoveListenerReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RemoveListenerReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RemoveListenerReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListListenerReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListListenerReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListListenerReq::ListListenerReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg) :
    space_id(std::move(space_id__arg)) {
  __isset.space_id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListListenerReq::__clear() {
  // clear all fields
  space_id = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListListenerReq::operator==(const ListListenerReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  return true;
}

bool ListListenerReq::operator<(const ListListenerReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  return false;
}


void swap(ListListenerReq& a, ListListenerReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListListenerReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListListenerReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListListenerReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListListenerReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListListenerReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListListenerReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListListenerReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListListenerReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListenerInfo>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListenerInfo>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListenerInfo::ListenerInfo(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::ListenerType type__arg, nebula::HostAddr host__arg,  ::nebula::cpp2::PartitionID part_id__arg,  ::nebula::meta::cpp2::HostStatus status__arg) :
    type(std::move(type__arg)),
    host(std::move(host__arg)),
    part_id(std::move(part_id__arg)),
    status(std::move(status__arg)) {
  __isset.type = true;
  __isset.host = true;
  __isset.part_id = true;
  __isset.status = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListenerInfo::__clear() {
  // clear all fields
  type =  ::nebula::meta::cpp2::ListenerType::UNKNOWN;
  host.__clear();
  part_id = 0;
  status =  ::nebula::meta::cpp2::HostStatus::ONLINE;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListenerInfo::operator==(const ListenerInfo& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.type == rhs.type)) {
    return false;
  }
  if (!(lhs.host == rhs.host)) {
    return false;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return false;
  }
  if (!(lhs.status == rhs.status)) {
    return false;
  }
  return true;
}

bool ListenerInfo::operator<(const ListenerInfo& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.type == rhs.type)) {
    return lhs.type < rhs.type;
  }
  if (!(lhs.host == rhs.host)) {
    return lhs.host < rhs.host;
  }
  if (!(lhs.part_id == rhs.part_id)) {
    return lhs.part_id < rhs.part_id;
  }
  if (!(lhs.status == rhs.status)) {
    return lhs.status < rhs.status;
  }
  return false;
}

const nebula::HostAddr& ListenerInfo::get_host() const& {
  return host;
}

nebula::HostAddr ListenerInfo::get_host() && {
  return std::move(host);
}


void swap(ListenerInfo& a, ListenerInfo& b) {
  using ::std::swap;
  swap(a.type_ref().value(), b.type_ref().value());
  swap(a.host_ref().value(), b.host_ref().value());
  swap(a.part_id_ref().value(), b.part_id_ref().value());
  swap(a.status_ref().value(), b.status_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListenerInfo::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListenerInfo::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListenerInfo::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListenerInfo::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListenerInfo::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListenerInfo::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListenerInfo::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListenerInfo::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListenerInfo,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListenerInfo,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListListenerResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListListenerResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListListenerResp::ListListenerResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::ListenerInfo> listeners__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    listeners(std::move(listeners__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.listeners = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListListenerResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  listeners.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListListenerResp::operator==(const ListListenerResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.listeners == rhs.listeners)) {
    return false;
  }
  return true;
}

bool ListListenerResp::operator<(const ListListenerResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.listeners == rhs.listeners)) {
    return lhs.listeners < rhs.listeners;
  }
  return false;
}

const nebula::HostAddr& ListListenerResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ListListenerResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector< ::nebula::meta::cpp2::ListenerInfo>& ListListenerResp::get_listeners() const& {
  return listeners;
}

::std::vector< ::nebula::meta::cpp2::ListenerInfo> ListListenerResp::get_listeners() && {
  return std::move(listeners);
}


void swap(ListListenerResp& a, ListListenerResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.listeners_ref().value(), b.listeners_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListListenerResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListListenerResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListListenerResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListListenerResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListListenerResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListListenerResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListListenerResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListListenerResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListListenerResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListListenerResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::ListenerInfo>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListListenerResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListListenerResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::ListenerInfo>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetStatsReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetStatsReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetStatsReq::GetStatsReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg) :
    space_id(std::move(space_id__arg)) {
  __isset.space_id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetStatsReq::__clear() {
  // clear all fields
  space_id = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetStatsReq::operator==(const GetStatsReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  return true;
}

bool GetStatsReq::operator<(const GetStatsReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  return false;
}


void swap(GetStatsReq& a, GetStatsReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetStatsReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetStatsReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetStatsReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetStatsReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetStatsReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetStatsReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetStatsReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetStatsReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetStatsResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetStatsResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetStatsResp::GetStatsResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::StatsItem stats__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    stats(std::move(stats__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.stats = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetStatsResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  stats.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetStatsResp::operator==(const GetStatsResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.stats == rhs.stats)) {
    return false;
  }
  return true;
}

const nebula::HostAddr& GetStatsResp::get_leader() const& {
  return leader;
}

nebula::HostAddr GetStatsResp::get_leader() && {
  return std::move(leader);
}

const  ::nebula::meta::cpp2::StatsItem& GetStatsResp::get_stats() const& {
  return stats;
}

 ::nebula::meta::cpp2::StatsItem GetStatsResp::get_stats() && {
  return std::move(stats);
}


void swap(GetStatsResp& a, GetStatsResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.stats_ref().value(), b.stats_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetStatsResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetStatsResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetStatsResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetStatsResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetStatsResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetStatsResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetStatsResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetStatsResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetStatsResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetStatsResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::StatsItem>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetStatsResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetStatsResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::StatsItem>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::BackupInfo>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::BackupInfo>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
BackupInfo::BackupInfo(apache::thrift::FragileConstructor, nebula::HostAddr host__arg, ::std::vector< ::nebula::cpp2::CheckpointInfo> info__arg) :
    host(std::move(host__arg)),
    info(std::move(info__arg)) {
  __isset.host = true;
  __isset.info = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void BackupInfo::__clear() {
  // clear all fields
  host.__clear();
  info.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool BackupInfo::operator==(const BackupInfo& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.host == rhs.host)) {
    return false;
  }
  if (!(lhs.info == rhs.info)) {
    return false;
  }
  return true;
}

const nebula::HostAddr& BackupInfo::get_host() const& {
  return host;
}

nebula::HostAddr BackupInfo::get_host() && {
  return std::move(host);
}

const ::std::vector< ::nebula::cpp2::CheckpointInfo>& BackupInfo::get_info() const& {
  return info;
}

::std::vector< ::nebula::cpp2::CheckpointInfo> BackupInfo::get_info() && {
  return std::move(info);
}


void swap(BackupInfo& a, BackupInfo& b) {
  using ::std::swap;
  swap(a.host_ref().value(), b.host_ref().value());
  swap(a.info_ref().value(), b.info_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void BackupInfo::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t BackupInfo::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t BackupInfo::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t BackupInfo::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void BackupInfo::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t BackupInfo::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t BackupInfo::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t BackupInfo::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        BackupInfo,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        BackupInfo,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::cpp2::CheckpointInfo>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        BackupInfo,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        BackupInfo,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::cpp2::CheckpointInfo>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::SpaceBackupInfo>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::SpaceBackupInfo>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
SpaceBackupInfo::SpaceBackupInfo(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::SpaceDesc space__arg, ::std::vector< ::nebula::meta::cpp2::BackupInfo> info__arg) :
    space(std::move(space__arg)),
    info(std::move(info__arg)) {
  __isset.space = true;
  __isset.info = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void SpaceBackupInfo::__clear() {
  // clear all fields
  space.__clear();
  info.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool SpaceBackupInfo::operator==(const SpaceBackupInfo& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space == rhs.space)) {
    return false;
  }
  if (!(lhs.info == rhs.info)) {
    return false;
  }
  return true;
}

const  ::nebula::meta::cpp2::SpaceDesc& SpaceBackupInfo::get_space() const& {
  return space;
}

 ::nebula::meta::cpp2::SpaceDesc SpaceBackupInfo::get_space() && {
  return std::move(space);
}

const ::std::vector< ::nebula::meta::cpp2::BackupInfo>& SpaceBackupInfo::get_info() const& {
  return info;
}

::std::vector< ::nebula::meta::cpp2::BackupInfo> SpaceBackupInfo::get_info() && {
  return std::move(info);
}


void swap(SpaceBackupInfo& a, SpaceBackupInfo& b) {
  using ::std::swap;
  swap(a.space_ref().value(), b.space_ref().value());
  swap(a.info_ref().value(), b.info_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void SpaceBackupInfo::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t SpaceBackupInfo::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t SpaceBackupInfo::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t SpaceBackupInfo::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void SpaceBackupInfo::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t SpaceBackupInfo::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t SpaceBackupInfo::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t SpaceBackupInfo::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        SpaceBackupInfo,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::SpaceDesc>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        SpaceBackupInfo,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::BackupInfo>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        SpaceBackupInfo,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::SpaceDesc>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        SpaceBackupInfo,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::BackupInfo>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::BackupMeta>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::BackupMeta>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
BackupMeta::BackupMeta() :
      full(0),
      include_system_space(0),
      create_time(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


BackupMeta::~BackupMeta() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
BackupMeta::BackupMeta(apache::thrift::FragileConstructor, std::unordered_map< ::nebula::cpp2::GraphSpaceID,  ::nebula::meta::cpp2::SpaceBackupInfo> backup_info__arg, ::std::vector<::std::string> meta_files__arg, ::std::string backup_name__arg, bool full__arg, bool include_system_space__arg, int64_t create_time__arg) :
    backup_info(std::move(backup_info__arg)),
    meta_files(std::move(meta_files__arg)),
    backup_name(std::move(backup_name__arg)),
    full(std::move(full__arg)),
    include_system_space(std::move(include_system_space__arg)),
    create_time(std::move(create_time__arg)) {
  __isset.backup_info = true;
  __isset.meta_files = true;
  __isset.backup_name = true;
  __isset.full = true;
  __isset.include_system_space = true;
  __isset.create_time = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void BackupMeta::__clear() {
  // clear all fields
  backup_info.clear();
  meta_files.clear();
  backup_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  full = 0;
  include_system_space = 0;
  create_time = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool BackupMeta::operator==(const BackupMeta& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.backup_info == rhs.backup_info)) {
    return false;
  }
  if (!(lhs.meta_files == rhs.meta_files)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.backup_name, rhs.backup_name)) {
    return false;
  }
  if (!(lhs.full == rhs.full)) {
    return false;
  }
  if (!(lhs.include_system_space == rhs.include_system_space)) {
    return false;
  }
  if (!(lhs.create_time == rhs.create_time)) {
    return false;
  }
  return true;
}

const std::unordered_map< ::nebula::cpp2::GraphSpaceID,  ::nebula::meta::cpp2::SpaceBackupInfo>& BackupMeta::get_backup_info() const& {
  return backup_info;
}

std::unordered_map< ::nebula::cpp2::GraphSpaceID,  ::nebula::meta::cpp2::SpaceBackupInfo> BackupMeta::get_backup_info() && {
  return std::move(backup_info);
}

const ::std::vector<::std::string>& BackupMeta::get_meta_files() const& {
  return meta_files;
}

::std::vector<::std::string> BackupMeta::get_meta_files() && {
  return std::move(meta_files);
}


void swap(BackupMeta& a, BackupMeta& b) {
  using ::std::swap;
  swap(a.backup_info_ref().value(), b.backup_info_ref().value());
  swap(a.meta_files_ref().value(), b.meta_files_ref().value());
  swap(a.backup_name_ref().value(), b.backup_name_ref().value());
  swap(a.full_ref().value(), b.full_ref().value());
  swap(a.include_system_space_ref().value(), b.include_system_space_ref().value());
  swap(a.create_time_ref().value(), b.create_time_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void BackupMeta::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t BackupMeta::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t BackupMeta::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t BackupMeta::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void BackupMeta::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t BackupMeta::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t BackupMeta::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t BackupMeta::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        BackupMeta,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        std::unordered_map< ::nebula::cpp2::GraphSpaceID,  ::nebula::meta::cpp2::SpaceBackupInfo>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        BackupMeta,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        std::unordered_map< ::nebula::cpp2::GraphSpaceID,  ::nebula::meta::cpp2::SpaceBackupInfo>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::CreateBackupReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::CreateBackupReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CreateBackupReq::CreateBackupReq(apache::thrift::FragileConstructor, ::std::vector<::std::string> spaces__arg) :
    spaces(std::move(spaces__arg)) {
  __isset.spaces = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CreateBackupReq::__clear() {
  // clear all fields
  spaces.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CreateBackupReq::operator==(const CreateBackupReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.spaces_ref() != rhs.spaces_ref()) {
    return false;
  }
  return true;
}

bool CreateBackupReq::operator<(const CreateBackupReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.spaces_ref() != rhs.spaces_ref()) {
    return lhs.spaces_ref() < rhs.spaces_ref();
  }
  return false;
}

const ::std::vector<::std::string>* CreateBackupReq::get_spaces() const& {
  return spaces_ref().has_value() ? std::addressof(spaces) : nullptr;
}

::std::vector<::std::string>* CreateBackupReq::get_spaces() & {
  return spaces_ref().has_value() ? std::addressof(spaces) : nullptr;
}


void swap(CreateBackupReq& a, CreateBackupReq& b) {
  using ::std::swap;
  swap(a.spaces_ref().value_unchecked(), b.spaces_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CreateBackupReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CreateBackupReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CreateBackupReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CreateBackupReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CreateBackupReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CreateBackupReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CreateBackupReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CreateBackupReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::CreateBackupResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::CreateBackupResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CreateBackupResp::CreateBackupResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::BackupMeta meta__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    meta(std::move(meta__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.meta = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CreateBackupResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  meta.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CreateBackupResp::operator==(const CreateBackupResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.meta == rhs.meta)) {
    return false;
  }
  return true;
}

const nebula::HostAddr& CreateBackupResp::get_leader() const& {
  return leader;
}

nebula::HostAddr CreateBackupResp::get_leader() && {
  return std::move(leader);
}

const  ::nebula::meta::cpp2::BackupMeta& CreateBackupResp::get_meta() const& {
  return meta;
}

 ::nebula::meta::cpp2::BackupMeta CreateBackupResp::get_meta() && {
  return std::move(meta);
}


void swap(CreateBackupResp& a, CreateBackupResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.meta_ref().value(), b.meta_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CreateBackupResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CreateBackupResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CreateBackupResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CreateBackupResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CreateBackupResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CreateBackupResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CreateBackupResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CreateBackupResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CreateBackupResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CreateBackupResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::BackupMeta>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CreateBackupResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CreateBackupResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::BackupMeta>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::HostPair>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::HostPair>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
HostPair::HostPair(apache::thrift::FragileConstructor, nebula::HostAddr from_host__arg, nebula::HostAddr to_host__arg) :
    from_host(std::move(from_host__arg)),
    to_host(std::move(to_host__arg)) {
  __isset.from_host = true;
  __isset.to_host = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void HostPair::__clear() {
  // clear all fields
  from_host.__clear();
  to_host.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool HostPair::operator==(const HostPair& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.from_host == rhs.from_host)) {
    return false;
  }
  if (!(lhs.to_host == rhs.to_host)) {
    return false;
  }
  return true;
}

bool HostPair::operator<(const HostPair& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.from_host == rhs.from_host)) {
    return lhs.from_host < rhs.from_host;
  }
  if (!(lhs.to_host == rhs.to_host)) {
    return lhs.to_host < rhs.to_host;
  }
  return false;
}

const nebula::HostAddr& HostPair::get_from_host() const& {
  return from_host;
}

nebula::HostAddr HostPair::get_from_host() && {
  return std::move(from_host);
}

const nebula::HostAddr& HostPair::get_to_host() const& {
  return to_host;
}

nebula::HostAddr HostPair::get_to_host() && {
  return std::move(to_host);
}


void swap(HostPair& a, HostPair& b) {
  using ::std::swap;
  swap(a.from_host_ref().value(), b.from_host_ref().value());
  swap(a.to_host_ref().value(), b.to_host_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void HostPair::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t HostPair::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t HostPair::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t HostPair::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void HostPair::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t HostPair::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t HostPair::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t HostPair::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        HostPair,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        HostPair,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        HostPair,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        HostPair,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::RestoreMetaReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::RestoreMetaReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RestoreMetaReq::RestoreMetaReq(apache::thrift::FragileConstructor, ::std::vector<::std::string> files__arg, ::std::vector< ::nebula::meta::cpp2::HostPair> hosts__arg) :
    files(std::move(files__arg)),
    hosts(std::move(hosts__arg)) {
  __isset.files = true;
  __isset.hosts = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void RestoreMetaReq::__clear() {
  // clear all fields
  files.clear();
  hosts.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool RestoreMetaReq::operator==(const RestoreMetaReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.files == rhs.files)) {
    return false;
  }
  if (!(lhs.hosts == rhs.hosts)) {
    return false;
  }
  return true;
}

bool RestoreMetaReq::operator<(const RestoreMetaReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.files == rhs.files)) {
    return lhs.files < rhs.files;
  }
  if (!(lhs.hosts == rhs.hosts)) {
    return lhs.hosts < rhs.hosts;
  }
  return false;
}

const ::std::vector<::std::string>& RestoreMetaReq::get_files() const& {
  return files;
}

::std::vector<::std::string> RestoreMetaReq::get_files() && {
  return std::move(files);
}

const ::std::vector< ::nebula::meta::cpp2::HostPair>& RestoreMetaReq::get_hosts() const& {
  return hosts;
}

::std::vector< ::nebula::meta::cpp2::HostPair> RestoreMetaReq::get_hosts() && {
  return std::move(hosts);
}


void swap(RestoreMetaReq& a, RestoreMetaReq& b) {
  using ::std::swap;
  swap(a.files_ref().value(), b.files_ref().value());
  swap(a.hosts_ref().value(), b.hosts_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void RestoreMetaReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RestoreMetaReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RestoreMetaReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RestoreMetaReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RestoreMetaReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RestoreMetaReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RestoreMetaReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RestoreMetaReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        RestoreMetaReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::HostPair>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        RestoreMetaReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::HostPair>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::FTClient>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::FTClient>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
FTClient::FTClient(apache::thrift::FragileConstructor, nebula::HostAddr host__arg, ::std::string user__arg, ::std::string pwd__arg, ::std::string conn_type__arg) :
    host(std::move(host__arg)),
    user(std::move(user__arg)),
    pwd(std::move(pwd__arg)),
    conn_type(std::move(conn_type__arg)) {
  __isset.user = true;
  __isset.pwd = true;
  __isset.conn_type = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void FTClient::__clear() {
  // clear all fields
  host.__clear();
  user = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  pwd = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  conn_type = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool FTClient::operator==(const FTClient& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.host == rhs.host)) {
    return false;
  }
  if (lhs.user_ref().has_value() != rhs.user_ref().has_value()) {
    return false;
  }
  if (lhs.user_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.user, rhs.user)) {
      return false;
    }
  }
  if (lhs.pwd_ref().has_value() != rhs.pwd_ref().has_value()) {
    return false;
  }
  if (lhs.pwd_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.pwd, rhs.pwd)) {
      return false;
    }
  }
  if (lhs.conn_type_ref().has_value() != rhs.conn_type_ref().has_value()) {
    return false;
  }
  if (lhs.conn_type_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.conn_type, rhs.conn_type)) {
      return false;
    }
  }
  return true;
}

bool FTClient::operator<(const FTClient& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.host == rhs.host)) {
    return lhs.host < rhs.host;
  }
  if (lhs.user_ref().has_value() != rhs.user_ref().has_value()) {
    return lhs.user_ref().has_value() < rhs.user_ref().has_value();
  }
  if (lhs.user_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.user, rhs.user)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.user, rhs.user);
    }
  }
  if (lhs.pwd_ref().has_value() != rhs.pwd_ref().has_value()) {
    return lhs.pwd_ref().has_value() < rhs.pwd_ref().has_value();
  }
  if (lhs.pwd_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.pwd, rhs.pwd)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.pwd, rhs.pwd);
    }
  }
  if (lhs.conn_type_ref().has_value() != rhs.conn_type_ref().has_value()) {
    return lhs.conn_type_ref().has_value() < rhs.conn_type_ref().has_value();
  }
  if (lhs.conn_type_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.conn_type, rhs.conn_type)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.conn_type, rhs.conn_type);
    }
  }
  return false;
}

const nebula::HostAddr& FTClient::get_host() const& {
  return host;
}

nebula::HostAddr FTClient::get_host() && {
  return std::move(host);
}


void swap(FTClient& a, FTClient& b) {
  using ::std::swap;
  swap(a.host_ref().value(), b.host_ref().value());
  swap(a.user_ref().value_unchecked(), b.user_ref().value_unchecked());
  swap(a.pwd_ref().value_unchecked(), b.pwd_ref().value_unchecked());
  swap(a.conn_type_ref().value_unchecked(), b.conn_type_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void FTClient::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t FTClient::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t FTClient::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t FTClient::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void FTClient::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t FTClient::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t FTClient::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t FTClient::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        FTClient,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        FTClient,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::SignInFTServiceReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::SignInFTServiceReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
SignInFTServiceReq::SignInFTServiceReq(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::FTServiceType type__arg, ::std::vector< ::nebula::meta::cpp2::FTClient> clients__arg) :
    type(std::move(type__arg)),
    clients(std::move(clients__arg)) {
  __isset.type = true;
  __isset.clients = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void SignInFTServiceReq::__clear() {
  // clear all fields
  type = static_cast< ::nebula::meta::cpp2::FTServiceType>(0);
  clients.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool SignInFTServiceReq::operator==(const SignInFTServiceReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.type == rhs.type)) {
    return false;
  }
  if (!(lhs.clients == rhs.clients)) {
    return false;
  }
  return true;
}

bool SignInFTServiceReq::operator<(const SignInFTServiceReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.type == rhs.type)) {
    return lhs.type < rhs.type;
  }
  if (!(lhs.clients == rhs.clients)) {
    return lhs.clients < rhs.clients;
  }
  return false;
}

const ::std::vector< ::nebula::meta::cpp2::FTClient>& SignInFTServiceReq::get_clients() const& {
  return clients;
}

::std::vector< ::nebula::meta::cpp2::FTClient> SignInFTServiceReq::get_clients() && {
  return std::move(clients);
}


void swap(SignInFTServiceReq& a, SignInFTServiceReq& b) {
  using ::std::swap;
  swap(a.type_ref().value(), b.type_ref().value());
  swap(a.clients_ref().value(), b.clients_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void SignInFTServiceReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t SignInFTServiceReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t SignInFTServiceReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t SignInFTServiceReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void SignInFTServiceReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t SignInFTServiceReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t SignInFTServiceReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t SignInFTServiceReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        SignInFTServiceReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::FTClient>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        SignInFTServiceReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::FTClient>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::SignOutFTServiceReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::SignOutFTServiceReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
SignOutFTServiceReq::SignOutFTServiceReq(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void SignOutFTServiceReq::__clear() {
  // clear all fields
}

bool SignOutFTServiceReq::operator==(const SignOutFTServiceReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool SignOutFTServiceReq::operator<(const SignOutFTServiceReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(SignOutFTServiceReq& a, SignOutFTServiceReq& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void SignOutFTServiceReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t SignOutFTServiceReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t SignOutFTServiceReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t SignOutFTServiceReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void SignOutFTServiceReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t SignOutFTServiceReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t SignOutFTServiceReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t SignOutFTServiceReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListFTClientsReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListFTClientsReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListFTClientsReq::ListFTClientsReq(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListFTClientsReq::__clear() {
  // clear all fields
}

bool ListFTClientsReq::operator==(const ListFTClientsReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool ListFTClientsReq::operator<(const ListFTClientsReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(ListFTClientsReq& a, ListFTClientsReq& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void ListFTClientsReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListFTClientsReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListFTClientsReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListFTClientsReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListFTClientsReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListFTClientsReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListFTClientsReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListFTClientsReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListFTClientsResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListFTClientsResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListFTClientsResp::ListFTClientsResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::FTClient> clients__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    clients(std::move(clients__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.clients = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListFTClientsResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  clients.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListFTClientsResp::operator==(const ListFTClientsResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.clients == rhs.clients)) {
    return false;
  }
  return true;
}

bool ListFTClientsResp::operator<(const ListFTClientsResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.clients == rhs.clients)) {
    return lhs.clients < rhs.clients;
  }
  return false;
}

const nebula::HostAddr& ListFTClientsResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ListFTClientsResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector< ::nebula::meta::cpp2::FTClient>& ListFTClientsResp::get_clients() const& {
  return clients;
}

::std::vector< ::nebula::meta::cpp2::FTClient> ListFTClientsResp::get_clients() && {
  return std::move(clients);
}


void swap(ListFTClientsResp& a, ListFTClientsResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.clients_ref().value(), b.clients_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListFTClientsResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListFTClientsResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListFTClientsResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListFTClientsResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListFTClientsResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListFTClientsResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListFTClientsResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListFTClientsResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListFTClientsResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListFTClientsResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::FTClient>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListFTClientsResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListFTClientsResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::FTClient>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::FTIndex>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::FTIndex>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
FTIndex::FTIndex(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::SchemaID depend_schema__arg, ::std::vector<::std::string> fields__arg) :
    space_id(std::move(space_id__arg)),
    depend_schema(std::move(depend_schema__arg)),
    fields(std::move(fields__arg)) {
  __isset.space_id = true;
  __isset.depend_schema = true;
  __isset.fields = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void FTIndex::__clear() {
  // clear all fields
  space_id = 0;
  depend_schema.__clear();
  fields.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool FTIndex::operator==(const FTIndex& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!(lhs.depend_schema == rhs.depend_schema)) {
    return false;
  }
  if (!(lhs.fields == rhs.fields)) {
    return false;
  }
  return true;
}

bool FTIndex::operator<(const FTIndex& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!(lhs.depend_schema == rhs.depend_schema)) {
    return lhs.depend_schema < rhs.depend_schema;
  }
  if (!(lhs.fields == rhs.fields)) {
    return lhs.fields < rhs.fields;
  }
  return false;
}

const  ::nebula::cpp2::SchemaID& FTIndex::get_depend_schema() const& {
  return depend_schema;
}

 ::nebula::cpp2::SchemaID FTIndex::get_depend_schema() && {
  return std::move(depend_schema);
}

const ::std::vector<::std::string>& FTIndex::get_fields() const& {
  return fields;
}

::std::vector<::std::string> FTIndex::get_fields() && {
  return std::move(fields);
}


void swap(FTIndex& a, FTIndex& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.depend_schema_ref().value(), b.depend_schema_ref().value());
  swap(a.fields_ref().value(), b.fields_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void FTIndex::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t FTIndex::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t FTIndex::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t FTIndex::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void FTIndex::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t FTIndex::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t FTIndex::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t FTIndex::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        FTIndex,
        ::apache::thrift::type_class::variant,
         ::nebula::cpp2::SchemaID>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        FTIndex,
        ::apache::thrift::type_class::variant,
         ::nebula::cpp2::SchemaID>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::CreateFTIndexReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::CreateFTIndexReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CreateFTIndexReq::CreateFTIndexReq(apache::thrift::FragileConstructor, ::std::string fulltext_index_name__arg,  ::nebula::meta::cpp2::FTIndex index__arg) :
    fulltext_index_name(std::move(fulltext_index_name__arg)),
    index(std::move(index__arg)) {
  __isset.fulltext_index_name = true;
  __isset.index = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CreateFTIndexReq::__clear() {
  // clear all fields
  fulltext_index_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  index.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CreateFTIndexReq::operator==(const CreateFTIndexReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.fulltext_index_name, rhs.fulltext_index_name)) {
    return false;
  }
  if (!(lhs.index == rhs.index)) {
    return false;
  }
  return true;
}

bool CreateFTIndexReq::operator<(const CreateFTIndexReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.fulltext_index_name, rhs.fulltext_index_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.fulltext_index_name, rhs.fulltext_index_name);
  }
  if (!(lhs.index == rhs.index)) {
    return lhs.index < rhs.index;
  }
  return false;
}

const  ::nebula::meta::cpp2::FTIndex& CreateFTIndexReq::get_index() const& {
  return index;
}

 ::nebula::meta::cpp2::FTIndex CreateFTIndexReq::get_index() && {
  return std::move(index);
}


void swap(CreateFTIndexReq& a, CreateFTIndexReq& b) {
  using ::std::swap;
  swap(a.fulltext_index_name_ref().value(), b.fulltext_index_name_ref().value());
  swap(a.index_ref().value(), b.index_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CreateFTIndexReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CreateFTIndexReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CreateFTIndexReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CreateFTIndexReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CreateFTIndexReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CreateFTIndexReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CreateFTIndexReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CreateFTIndexReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CreateFTIndexReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::FTIndex>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CreateFTIndexReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::FTIndex>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::DropFTIndexReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::DropFTIndexReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DropFTIndexReq::DropFTIndexReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::string fulltext_index_name__arg) :
    space_id(std::move(space_id__arg)),
    fulltext_index_name(std::move(fulltext_index_name__arg)) {
  __isset.space_id = true;
  __isset.fulltext_index_name = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void DropFTIndexReq::__clear() {
  // clear all fields
  space_id = 0;
  fulltext_index_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DropFTIndexReq::operator==(const DropFTIndexReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.fulltext_index_name, rhs.fulltext_index_name)) {
    return false;
  }
  return true;
}

bool DropFTIndexReq::operator<(const DropFTIndexReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.space_id == rhs.space_id)) {
    return lhs.space_id < rhs.space_id;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.fulltext_index_name, rhs.fulltext_index_name)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.fulltext_index_name, rhs.fulltext_index_name);
  }
  return false;
}


void swap(DropFTIndexReq& a, DropFTIndexReq& b) {
  using ::std::swap;
  swap(a.space_id_ref().value(), b.space_id_ref().value());
  swap(a.fulltext_index_name_ref().value(), b.fulltext_index_name_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DropFTIndexReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DropFTIndexReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DropFTIndexReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DropFTIndexReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DropFTIndexReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DropFTIndexReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DropFTIndexReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DropFTIndexReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListFTIndexesReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListFTIndexesReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListFTIndexesReq::ListFTIndexesReq(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListFTIndexesReq::__clear() {
  // clear all fields
}

bool ListFTIndexesReq::operator==(const ListFTIndexesReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool ListFTIndexesReq::operator<(const ListFTIndexesReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(ListFTIndexesReq& a, ListFTIndexesReq& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void ListFTIndexesReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListFTIndexesReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListFTIndexesReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListFTIndexesReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListFTIndexesReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListFTIndexesReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListFTIndexesReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListFTIndexesReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListFTIndexesResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListFTIndexesResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListFTIndexesResp::ListFTIndexesResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, std::unordered_map<::std::string,  ::nebula::meta::cpp2::FTIndex> indexes__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    indexes(std::move(indexes__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.indexes = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListFTIndexesResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  indexes.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListFTIndexesResp::operator==(const ListFTIndexesResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.indexes == rhs.indexes)) {
    return false;
  }
  return true;
}

const nebula::HostAddr& ListFTIndexesResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ListFTIndexesResp::get_leader() && {
  return std::move(leader);
}

const std::unordered_map<::std::string,  ::nebula::meta::cpp2::FTIndex>& ListFTIndexesResp::get_indexes() const& {
  return indexes;
}

std::unordered_map<::std::string,  ::nebula::meta::cpp2::FTIndex> ListFTIndexesResp::get_indexes() && {
  return std::move(indexes);
}


void swap(ListFTIndexesResp& a, ListFTIndexesResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.indexes_ref().value(), b.indexes_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListFTIndexesResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListFTIndexesResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListFTIndexesResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListFTIndexesResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListFTIndexesResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListFTIndexesResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListFTIndexesResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListFTIndexesResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListFTIndexesResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListFTIndexesResp,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::binary, ::apache::thrift::type_class::structure>,
        std::unordered_map<::std::string,  ::nebula::meta::cpp2::FTIndex>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListFTIndexesResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListFTIndexesResp,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::binary, ::apache::thrift::type_class::structure>,
        std::unordered_map<::std::string,  ::nebula::meta::cpp2::FTIndex>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::QueryDesc>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::QueryDesc>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
QueryDesc::QueryDesc() :
      start_time(0),
      status(static_cast< ::nebula::meta::cpp2::QueryStatus>(0)),
      duration(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


QueryDesc::~QueryDesc() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
QueryDesc::QueryDesc(apache::thrift::FragileConstructor,  ::nebula::cpp2::Timestamp start_time__arg,  ::nebula::meta::cpp2::QueryStatus status__arg, int64_t duration__arg, ::std::string query__arg, nebula::HostAddr graph_addr__arg) :
    start_time(std::move(start_time__arg)),
    status(std::move(status__arg)),
    duration(std::move(duration__arg)),
    query(std::move(query__arg)),
    graph_addr(std::move(graph_addr__arg)) {
  __isset.start_time = true;
  __isset.status = true;
  __isset.duration = true;
  __isset.query = true;
  __isset.graph_addr = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void QueryDesc::__clear() {
  // clear all fields
  start_time = 0;
  status = static_cast< ::nebula::meta::cpp2::QueryStatus>(0);
  duration = 0;
  query = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  graph_addr.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool QueryDesc::operator==(const QueryDesc& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.start_time == rhs.start_time)) {
    return false;
  }
  if (!(lhs.status == rhs.status)) {
    return false;
  }
  if (!(lhs.duration == rhs.duration)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.query, rhs.query)) {
    return false;
  }
  if (!(lhs.graph_addr == rhs.graph_addr)) {
    return false;
  }
  return true;
}

bool QueryDesc::operator<(const QueryDesc& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.start_time == rhs.start_time)) {
    return lhs.start_time < rhs.start_time;
  }
  if (!(lhs.status == rhs.status)) {
    return lhs.status < rhs.status;
  }
  if (!(lhs.duration == rhs.duration)) {
    return lhs.duration < rhs.duration;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.query, rhs.query)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.query, rhs.query);
  }
  if (!(lhs.graph_addr == rhs.graph_addr)) {
    return lhs.graph_addr < rhs.graph_addr;
  }
  return false;
}

const nebula::HostAddr& QueryDesc::get_graph_addr() const& {
  return graph_addr;
}

nebula::HostAddr QueryDesc::get_graph_addr() && {
  return std::move(graph_addr);
}


void swap(QueryDesc& a, QueryDesc& b) {
  using ::std::swap;
  swap(a.start_time_ref().value(), b.start_time_ref().value());
  swap(a.status_ref().value(), b.status_ref().value());
  swap(a.duration_ref().value(), b.duration_ref().value());
  swap(a.query_ref().value(), b.query_ref().value());
  swap(a.graph_addr_ref().value(), b.graph_addr_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void QueryDesc::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t QueryDesc::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t QueryDesc::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t QueryDesc::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void QueryDesc::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t QueryDesc::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t QueryDesc::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t QueryDesc::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        QueryDesc,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        QueryDesc,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::Session>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::Session>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Session::Session() :
      session_id(0),
      create_time(0),
      update_time(0),
      timezone(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


Session::~Session() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Session::Session(apache::thrift::FragileConstructor,  ::nebula::cpp2::SessionID session_id__arg,  ::nebula::cpp2::Timestamp create_time__arg,  ::nebula::cpp2::Timestamp update_time__arg, ::std::string user_name__arg, ::std::string space_name__arg, nebula::HostAddr graph_addr__arg, int32_t timezone__arg, ::std::string client_ip__arg, std::unordered_map<::std::string, nebula::Value> configs__arg, std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc> queries__arg) :
    session_id(std::move(session_id__arg)),
    create_time(std::move(create_time__arg)),
    update_time(std::move(update_time__arg)),
    user_name(std::move(user_name__arg)),
    space_name(std::move(space_name__arg)),
    graph_addr(std::move(graph_addr__arg)),
    timezone(std::move(timezone__arg)),
    client_ip(std::move(client_ip__arg)),
    configs(std::move(configs__arg)),
    queries(std::move(queries__arg)) {
  __isset.session_id = true;
  __isset.create_time = true;
  __isset.update_time = true;
  __isset.user_name = true;
  __isset.space_name = true;
  __isset.graph_addr = true;
  __isset.timezone = true;
  __isset.client_ip = true;
  __isset.configs = true;
  __isset.queries = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Session::__clear() {
  // clear all fields
  session_id = 0;
  create_time = 0;
  update_time = 0;
  user_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  space_name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  graph_addr.__clear();
  timezone = 0;
  client_ip = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  configs.clear();
  queries.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool Session::operator==(const Session& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.session_id == rhs.session_id)) {
    return false;
  }
  if (!(lhs.create_time == rhs.create_time)) {
    return false;
  }
  if (!(lhs.update_time == rhs.update_time)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.user_name, rhs.user_name)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.space_name, rhs.space_name)) {
    return false;
  }
  if (!(lhs.graph_addr == rhs.graph_addr)) {
    return false;
  }
  if (!(lhs.timezone == rhs.timezone)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.client_ip, rhs.client_ip)) {
    return false;
  }
  if (!(lhs.configs == rhs.configs)) {
    return false;
  }
  if (!(lhs.queries == rhs.queries)) {
    return false;
  }
  return true;
}

const nebula::HostAddr& Session::get_graph_addr() const& {
  return graph_addr;
}

nebula::HostAddr Session::get_graph_addr() && {
  return std::move(graph_addr);
}

const std::unordered_map<::std::string, nebula::Value>& Session::get_configs() const& {
  return configs;
}

std::unordered_map<::std::string, nebula::Value> Session::get_configs() && {
  return std::move(configs);
}

const std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>& Session::get_queries() const& {
  return queries;
}

std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc> Session::get_queries() && {
  return std::move(queries);
}


void swap(Session& a, Session& b) {
  using ::std::swap;
  swap(a.session_id_ref().value(), b.session_id_ref().value());
  swap(a.create_time_ref().value(), b.create_time_ref().value());
  swap(a.update_time_ref().value(), b.update_time_ref().value());
  swap(a.user_name_ref().value(), b.user_name_ref().value());
  swap(a.space_name_ref().value(), b.space_name_ref().value());
  swap(a.graph_addr_ref().value(), b.graph_addr_ref().value());
  swap(a.timezone_ref().value(), b.timezone_ref().value());
  swap(a.client_ip_ref().value(), b.client_ip_ref().value());
  swap(a.configs_ref().value(), b.configs_ref().value());
  swap(a.queries_ref().value(), b.queries_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void Session::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Session::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Session::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Session::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Session::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Session::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Session::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Session::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Session,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Session,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::binary, ::apache::thrift::type_class::variant>,
        std::unordered_map<::std::string, nebula::Value>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        Session,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Session,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Session,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::binary, ::apache::thrift::type_class::variant>,
        std::unordered_map<::std::string, nebula::Value>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        Session,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::CreateSessionReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::CreateSessionReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CreateSessionReq::CreateSessionReq(apache::thrift::FragileConstructor, ::std::string user__arg, nebula::HostAddr graph_addr__arg, ::std::string client_ip__arg) :
    user(std::move(user__arg)),
    graph_addr(std::move(graph_addr__arg)),
    client_ip(std::move(client_ip__arg)) {
  __isset.user = true;
  __isset.graph_addr = true;
  __isset.client_ip = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CreateSessionReq::__clear() {
  // clear all fields
  user = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  graph_addr.__clear();
  client_ip = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CreateSessionReq::operator==(const CreateSessionReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.user, rhs.user)) {
    return false;
  }
  if (!(lhs.graph_addr == rhs.graph_addr)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.client_ip, rhs.client_ip)) {
    return false;
  }
  return true;
}

bool CreateSessionReq::operator<(const CreateSessionReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.user, rhs.user)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.user, rhs.user);
  }
  if (!(lhs.graph_addr == rhs.graph_addr)) {
    return lhs.graph_addr < rhs.graph_addr;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.client_ip, rhs.client_ip)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.client_ip, rhs.client_ip);
  }
  return false;
}

const nebula::HostAddr& CreateSessionReq::get_graph_addr() const& {
  return graph_addr;
}

nebula::HostAddr CreateSessionReq::get_graph_addr() && {
  return std::move(graph_addr);
}


void swap(CreateSessionReq& a, CreateSessionReq& b) {
  using ::std::swap;
  swap(a.user_ref().value(), b.user_ref().value());
  swap(a.graph_addr_ref().value(), b.graph_addr_ref().value());
  swap(a.client_ip_ref().value(), b.client_ip_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CreateSessionReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CreateSessionReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CreateSessionReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CreateSessionReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CreateSessionReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CreateSessionReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CreateSessionReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CreateSessionReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CreateSessionReq,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CreateSessionReq,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::CreateSessionResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::CreateSessionResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CreateSessionResp::CreateSessionResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::Session session__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    session(std::move(session__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.session = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CreateSessionResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  session.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CreateSessionResp::operator==(const CreateSessionResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.session == rhs.session)) {
    return false;
  }
  return true;
}

const nebula::HostAddr& CreateSessionResp::get_leader() const& {
  return leader;
}

nebula::HostAddr CreateSessionResp::get_leader() && {
  return std::move(leader);
}

const  ::nebula::meta::cpp2::Session& CreateSessionResp::get_session() const& {
  return session;
}

 ::nebula::meta::cpp2::Session CreateSessionResp::get_session() && {
  return std::move(session);
}


void swap(CreateSessionResp& a, CreateSessionResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.session_ref().value(), b.session_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CreateSessionResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CreateSessionResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CreateSessionResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CreateSessionResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CreateSessionResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CreateSessionResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CreateSessionResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CreateSessionResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CreateSessionResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CreateSessionResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::Session>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CreateSessionResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CreateSessionResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::Session>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::UpdateSessionsReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::UpdateSessionsReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
UpdateSessionsReq::UpdateSessionsReq(apache::thrift::FragileConstructor, ::std::vector< ::nebula::meta::cpp2::Session> sessions__arg) :
    sessions(std::move(sessions__arg)) {
  __isset.sessions = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void UpdateSessionsReq::__clear() {
  // clear all fields
  sessions.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool UpdateSessionsReq::operator==(const UpdateSessionsReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.sessions == rhs.sessions)) {
    return false;
  }
  return true;
}

const ::std::vector< ::nebula::meta::cpp2::Session>& UpdateSessionsReq::get_sessions() const& {
  return sessions;
}

::std::vector< ::nebula::meta::cpp2::Session> UpdateSessionsReq::get_sessions() && {
  return std::move(sessions);
}


void swap(UpdateSessionsReq& a, UpdateSessionsReq& b) {
  using ::std::swap;
  swap(a.sessions_ref().value(), b.sessions_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void UpdateSessionsReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t UpdateSessionsReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t UpdateSessionsReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t UpdateSessionsReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void UpdateSessionsReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t UpdateSessionsReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t UpdateSessionsReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t UpdateSessionsReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        UpdateSessionsReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::Session>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        UpdateSessionsReq,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::Session>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::UpdateSessionsResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::UpdateSessionsResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
UpdateSessionsResp::UpdateSessionsResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>> killed_queries__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    killed_queries(std::move(killed_queries__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.killed_queries = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void UpdateSessionsResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  killed_queries.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool UpdateSessionsResp::operator==(const UpdateSessionsResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.killed_queries == rhs.killed_queries)) {
    return false;
  }
  return true;
}

const nebula::HostAddr& UpdateSessionsResp::get_leader() const& {
  return leader;
}

nebula::HostAddr UpdateSessionsResp::get_leader() && {
  return std::move(leader);
}

const std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>>& UpdateSessionsResp::get_killed_queries() const& {
  return killed_queries;
}

std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>> UpdateSessionsResp::get_killed_queries() && {
  return std::move(killed_queries);
}


void swap(UpdateSessionsResp& a, UpdateSessionsResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.killed_queries_ref().value(), b.killed_queries_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void UpdateSessionsResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t UpdateSessionsResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t UpdateSessionsResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t UpdateSessionsResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void UpdateSessionsResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t UpdateSessionsResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t UpdateSessionsResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t UpdateSessionsResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        UpdateSessionsResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        UpdateSessionsResp,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        UpdateSessionsResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        UpdateSessionsResp,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>>,
        std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_map< ::nebula::cpp2::ExecutionPlanID,  ::nebula::meta::cpp2::QueryDesc>>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListSessionsReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListSessionsReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListSessionsReq::ListSessionsReq(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListSessionsReq::__clear() {
  // clear all fields
}

bool ListSessionsReq::operator==(const ListSessionsReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool ListSessionsReq::operator<(const ListSessionsReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(ListSessionsReq& a, ListSessionsReq& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void ListSessionsReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListSessionsReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListSessionsReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListSessionsReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListSessionsReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListSessionsReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListSessionsReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListSessionsReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListSessionsResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListSessionsResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListSessionsResp::ListSessionsResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector< ::nebula::meta::cpp2::Session> sessions__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    sessions(std::move(sessions__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.sessions = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListSessionsResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  sessions.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListSessionsResp::operator==(const ListSessionsResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.sessions == rhs.sessions)) {
    return false;
  }
  return true;
}

const nebula::HostAddr& ListSessionsResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ListSessionsResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector< ::nebula::meta::cpp2::Session>& ListSessionsResp::get_sessions() const& {
  return sessions;
}

::std::vector< ::nebula::meta::cpp2::Session> ListSessionsResp::get_sessions() && {
  return std::move(sessions);
}


void swap(ListSessionsResp& a, ListSessionsResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.sessions_ref().value(), b.sessions_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListSessionsResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListSessionsResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListSessionsResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListSessionsResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListSessionsResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListSessionsResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListSessionsResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListSessionsResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListSessionsResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListSessionsResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::Session>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListSessionsResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListSessionsResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::meta::cpp2::Session>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetSessionReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetSessionReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetSessionReq::GetSessionReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::SessionID session_id__arg) :
    session_id(std::move(session_id__arg)) {
  __isset.session_id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetSessionReq::__clear() {
  // clear all fields
  session_id = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetSessionReq::operator==(const GetSessionReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.session_id == rhs.session_id)) {
    return false;
  }
  return true;
}

bool GetSessionReq::operator<(const GetSessionReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.session_id == rhs.session_id)) {
    return lhs.session_id < rhs.session_id;
  }
  return false;
}


void swap(GetSessionReq& a, GetSessionReq& b) {
  using ::std::swap;
  swap(a.session_id_ref().value(), b.session_id_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetSessionReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetSessionReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetSessionReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetSessionReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetSessionReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetSessionReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetSessionReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetSessionReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetSessionResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetSessionResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetSessionResp::GetSessionResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg,  ::nebula::meta::cpp2::Session session__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    session(std::move(session__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.session = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetSessionResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  session.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetSessionResp::operator==(const GetSessionResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.session == rhs.session)) {
    return false;
  }
  return true;
}

const nebula::HostAddr& GetSessionResp::get_leader() const& {
  return leader;
}

nebula::HostAddr GetSessionResp::get_leader() && {
  return std::move(leader);
}

const  ::nebula::meta::cpp2::Session& GetSessionResp::get_session() const& {
  return session;
}

 ::nebula::meta::cpp2::Session GetSessionResp::get_session() && {
  return std::move(session);
}


void swap(GetSessionResp& a, GetSessionResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.session_ref().value(), b.session_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetSessionResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetSessionResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetSessionResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetSessionResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetSessionResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetSessionResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetSessionResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetSessionResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetSessionResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetSessionResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::Session>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetSessionResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetSessionResp,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::Session>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::RemoveSessionReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::RemoveSessionReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RemoveSessionReq::RemoveSessionReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::SessionID session_id__arg) :
    session_id(std::move(session_id__arg)) {
  __isset.session_id = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void RemoveSessionReq::__clear() {
  // clear all fields
  session_id = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool RemoveSessionReq::operator==(const RemoveSessionReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.session_id == rhs.session_id)) {
    return false;
  }
  return true;
}

bool RemoveSessionReq::operator<(const RemoveSessionReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.session_id == rhs.session_id)) {
    return lhs.session_id < rhs.session_id;
  }
  return false;
}


void swap(RemoveSessionReq& a, RemoveSessionReq& b) {
  using ::std::swap;
  swap(a.session_id_ref().value(), b.session_id_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void RemoveSessionReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RemoveSessionReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RemoveSessionReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RemoveSessionReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RemoveSessionReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RemoveSessionReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RemoveSessionReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RemoveSessionReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::KillQueryReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::KillQueryReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
KillQueryReq::KillQueryReq(apache::thrift::FragileConstructor, std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_set< ::nebula::cpp2::ExecutionPlanID>> kill_queries__arg) :
    kill_queries(std::move(kill_queries__arg)) {
  __isset.kill_queries = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void KillQueryReq::__clear() {
  // clear all fields
  kill_queries.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool KillQueryReq::operator==(const KillQueryReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.kill_queries == rhs.kill_queries)) {
    return false;
  }
  return true;
}

const std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_set< ::nebula::cpp2::ExecutionPlanID>>& KillQueryReq::get_kill_queries() const& {
  return kill_queries;
}

std::unordered_map< ::nebula::cpp2::SessionID, std::unordered_set< ::nebula::cpp2::ExecutionPlanID>> KillQueryReq::get_kill_queries() && {
  return std::move(kill_queries);
}


void swap(KillQueryReq& a, KillQueryReq& b) {
  using ::std::swap;
  swap(a.kill_queries_ref().value(), b.kill_queries_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void KillQueryReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t KillQueryReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t KillQueryReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t KillQueryReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void KillQueryReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t KillQueryReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t KillQueryReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t KillQueryReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ReportTaskReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ReportTaskReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ReportTaskReq::ReportTaskReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, int32_t job_id__arg, int32_t task_id__arg,  ::nebula::meta::cpp2::StatsItem stats__arg) :
    code(std::move(code__arg)),
    job_id(std::move(job_id__arg)),
    task_id(std::move(task_id__arg)),
    stats(std::move(stats__arg)) {
  __isset.code = true;
  __isset.job_id = true;
  __isset.task_id = true;
  __isset.stats = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ReportTaskReq::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  job_id = 0;
  task_id = 0;
  stats.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ReportTaskReq::operator==(const ReportTaskReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.job_id == rhs.job_id)) {
    return false;
  }
  if (!(lhs.task_id == rhs.task_id)) {
    return false;
  }
  if (lhs.stats_ref() != rhs.stats_ref()) {
    return false;
  }
  return true;
}

const  ::nebula::meta::cpp2::StatsItem* ReportTaskReq::get_stats() const& {
  return stats_ref().has_value() ? std::addressof(stats) : nullptr;
}

 ::nebula::meta::cpp2::StatsItem* ReportTaskReq::get_stats() & {
  return stats_ref().has_value() ? std::addressof(stats) : nullptr;
}


void swap(ReportTaskReq& a, ReportTaskReq& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.job_id_ref().value(), b.job_id_ref().value());
  swap(a.task_id_ref().value(), b.task_id_ref().value());
  swap(a.stats_ref().value_unchecked(), b.stats_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ReportTaskReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ReportTaskReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ReportTaskReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ReportTaskReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ReportTaskReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ReportTaskReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ReportTaskReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ReportTaskReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ReportTaskReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::StatsItem>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ReportTaskReq,
        ::apache::thrift::type_class::structure,
         ::nebula::meta::cpp2::StatsItem>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListClusterInfoResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListClusterInfoResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListClusterInfoResp::ListClusterInfoResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::vector<nebula::HostAddr> meta_servers__arg, ::std::vector< ::nebula::cpp2::NodeInfo> storage_servers__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    meta_servers(std::move(meta_servers__arg)),
    storage_servers(std::move(storage_servers__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.meta_servers = true;
  __isset.storage_servers = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListClusterInfoResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  meta_servers.clear();
  storage_servers.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ListClusterInfoResp::operator==(const ListClusterInfoResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (!(lhs.meta_servers == rhs.meta_servers)) {
    return false;
  }
  if (!(lhs.storage_servers == rhs.storage_servers)) {
    return false;
  }
  return true;
}

bool ListClusterInfoResp::operator<(const ListClusterInfoResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (!(lhs.meta_servers == rhs.meta_servers)) {
    return lhs.meta_servers < rhs.meta_servers;
  }
  if (!(lhs.storage_servers == rhs.storage_servers)) {
    return lhs.storage_servers < rhs.storage_servers;
  }
  return false;
}

const nebula::HostAddr& ListClusterInfoResp::get_leader() const& {
  return leader;
}

nebula::HostAddr ListClusterInfoResp::get_leader() && {
  return std::move(leader);
}

const ::std::vector<nebula::HostAddr>& ListClusterInfoResp::get_meta_servers() const& {
  return meta_servers;
}

::std::vector<nebula::HostAddr> ListClusterInfoResp::get_meta_servers() && {
  return std::move(meta_servers);
}

const ::std::vector< ::nebula::cpp2::NodeInfo>& ListClusterInfoResp::get_storage_servers() const& {
  return storage_servers;
}

::std::vector< ::nebula::cpp2::NodeInfo> ListClusterInfoResp::get_storage_servers() && {
  return std::move(storage_servers);
}


void swap(ListClusterInfoResp& a, ListClusterInfoResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.meta_servers_ref().value(), b.meta_servers_ref().value());
  swap(a.storage_servers_ref().value(), b.storage_servers_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ListClusterInfoResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListClusterInfoResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListClusterInfoResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListClusterInfoResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListClusterInfoResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListClusterInfoResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListClusterInfoResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListClusterInfoResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListClusterInfoResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListClusterInfoResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::HostAddr>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ListClusterInfoResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::cpp2::NodeInfo>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListClusterInfoResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListClusterInfoResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<nebula::HostAddr>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ListClusterInfoResp,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::nebula::cpp2::NodeInfo>>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::ListClusterInfoReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::ListClusterInfoReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ListClusterInfoReq::ListClusterInfoReq(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ListClusterInfoReq::__clear() {
  // clear all fields
}

bool ListClusterInfoReq::operator==(const ListClusterInfoReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool ListClusterInfoReq::operator<(const ListClusterInfoReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(ListClusterInfoReq& a, ListClusterInfoReq& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void ListClusterInfoReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ListClusterInfoReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ListClusterInfoReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ListClusterInfoReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ListClusterInfoReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ListClusterInfoReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ListClusterInfoReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ListClusterInfoReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetMetaDirInfoResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetMetaDirInfoResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetMetaDirInfoResp::GetMetaDirInfoResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg,  ::nebula::cpp2::DirInfo dir__arg) :
    code(std::move(code__arg)),
    dir(std::move(dir__arg)) {
  __isset.code = true;
  __isset.dir = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetMetaDirInfoResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  dir.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool GetMetaDirInfoResp::operator==(const GetMetaDirInfoResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.dir == rhs.dir)) {
    return false;
  }
  return true;
}

bool GetMetaDirInfoResp::operator<(const GetMetaDirInfoResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.dir == rhs.dir)) {
    return lhs.dir < rhs.dir;
  }
  return false;
}

const  ::nebula::cpp2::DirInfo& GetMetaDirInfoResp::get_dir() const& {
  return dir;
}

 ::nebula::cpp2::DirInfo GetMetaDirInfoResp::get_dir() && {
  return std::move(dir);
}


void swap(GetMetaDirInfoResp& a, GetMetaDirInfoResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.dir_ref().value(), b.dir_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void GetMetaDirInfoResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetMetaDirInfoResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetMetaDirInfoResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetMetaDirInfoResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetMetaDirInfoResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetMetaDirInfoResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetMetaDirInfoResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetMetaDirInfoResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetMetaDirInfoResp,
        ::apache::thrift::type_class::structure,
         ::nebula::cpp2::DirInfo>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetMetaDirInfoResp,
        ::apache::thrift::type_class::structure,
         ::nebula::cpp2::DirInfo>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::GetMetaDirInfoReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::GetMetaDirInfoReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
GetMetaDirInfoReq::GetMetaDirInfoReq(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void GetMetaDirInfoReq::__clear() {
  // clear all fields
}

bool GetMetaDirInfoReq::operator==(const GetMetaDirInfoReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool GetMetaDirInfoReq::operator<(const GetMetaDirInfoReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(GetMetaDirInfoReq& a, GetMetaDirInfoReq& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void GetMetaDirInfoReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetMetaDirInfoReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetMetaDirInfoReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetMetaDirInfoReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetMetaDirInfoReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetMetaDirInfoReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetMetaDirInfoReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetMetaDirInfoReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::VerifyClientVersionResp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::VerifyClientVersionResp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
VerifyClientVersionResp::VerifyClientVersionResp(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg, nebula::HostAddr leader__arg, ::std::string error_msg__arg) :
    code(std::move(code__arg)),
    leader(std::move(leader__arg)),
    error_msg(std::move(error_msg__arg)) {
  __isset.code = true;
  __isset.leader = true;
  __isset.error_msg = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void VerifyClientVersionResp::__clear() {
  // clear all fields
  code =  ::nebula::cpp2::ErrorCode::SUCCEEDED;
  leader.__clear();
  error_msg = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool VerifyClientVersionResp::operator==(const VerifyClientVersionResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.leader == rhs.leader)) {
    return false;
  }
  if (lhs.error_msg_ref().has_value() != rhs.error_msg_ref().has_value()) {
    return false;
  }
  if (lhs.error_msg_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.error_msg, rhs.error_msg)) {
      return false;
    }
  }
  return true;
}

bool VerifyClientVersionResp::operator<(const VerifyClientVersionResp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.leader == rhs.leader)) {
    return lhs.leader < rhs.leader;
  }
  if (lhs.error_msg_ref().has_value() != rhs.error_msg_ref().has_value()) {
    return lhs.error_msg_ref().has_value() < rhs.error_msg_ref().has_value();
  }
  if (lhs.error_msg_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.error_msg, rhs.error_msg)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.error_msg, rhs.error_msg);
    }
  }
  return false;
}

const nebula::HostAddr& VerifyClientVersionResp::get_leader() const& {
  return leader;
}

nebula::HostAddr VerifyClientVersionResp::get_leader() && {
  return std::move(leader);
}


void swap(VerifyClientVersionResp& a, VerifyClientVersionResp& b) {
  using ::std::swap;
  swap(a.code_ref().value(), b.code_ref().value());
  swap(a.leader_ref().value(), b.leader_ref().value());
  swap(a.error_msg_ref().value_unchecked(), b.error_msg_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void VerifyClientVersionResp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t VerifyClientVersionResp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t VerifyClientVersionResp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t VerifyClientVersionResp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void VerifyClientVersionResp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t VerifyClientVersionResp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t VerifyClientVersionResp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t VerifyClientVersionResp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        VerifyClientVersionResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        VerifyClientVersionResp,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::nebula::meta::cpp2::VerifyClientVersionReq>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::nebula::meta::cpp2::VerifyClientVersionReq>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace nebula { namespace meta { namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
VerifyClientVersionReq::VerifyClientVersionReq(apache::thrift::FragileConstructor, ::std::string version__arg, nebula::HostAddr host__arg) :
    version(std::move(version__arg)),
    host(std::move(host__arg)) {
  __isset.host = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void VerifyClientVersionReq::__clear() {
  // clear all fields
  version = apache::thrift::StringTraits< std::string>::fromStringLiteral("2.6.0");
  host.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool VerifyClientVersionReq::operator==(const VerifyClientVersionReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.version, rhs.version)) {
    return false;
  }
  if (!(lhs.host == rhs.host)) {
    return false;
  }
  return true;
}

bool VerifyClientVersionReq::operator<(const VerifyClientVersionReq& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.version, rhs.version)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.version, rhs.version);
  }
  if (!(lhs.host == rhs.host)) {
    return lhs.host < rhs.host;
  }
  return false;
}

const nebula::HostAddr& VerifyClientVersionReq::get_host() const& {
  return host;
}

nebula::HostAddr VerifyClientVersionReq::get_host() && {
  return std::move(host);
}


void swap(VerifyClientVersionReq& a, VerifyClientVersionReq& b) {
  using ::std::swap;
  swap(a.version_ref().value(), b.version_ref().value());
  swap(a.host_ref().value(), b.host_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void VerifyClientVersionReq::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t VerifyClientVersionReq::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t VerifyClientVersionReq::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t VerifyClientVersionReq::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void VerifyClientVersionReq::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t VerifyClientVersionReq::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t VerifyClientVersionReq::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t VerifyClientVersionReq::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        VerifyClientVersionReq,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        VerifyClientVersionReq,
        ::apache::thrift::type_class::structure,
        nebula::HostAddr>,
    "inconsistent use of nimble option");

}}} // nebula::meta::cpp2
