/**
 * Autogenerated by Thrift for storage.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>


#include "common_types.h"
#include "meta_types.h"

namespace apache {
namespace thrift {
namespace tag {
struct session_id;
struct plan_id;
struct profile_detail;
struct code;
struct part_id;
struct leader;
struct failed_parts;
struct latency_in_us;
struct latency_detail_us;
struct alias;
struct prop;
struct stat;
struct alias;
struct expr;
struct type;
struct props;
struct tag;
struct props;
struct prop;
struct direction;
struct edge_types;
struct edge_direction;
struct dedup;
struct stat_props;
struct vertex_props;
struct edge_props;
struct expressions;
struct order_by;
struct random;
struct limit;
struct filter;
struct space_id;
struct column_names;
struct parts;
struct traverse_spec;
struct common;
struct result;
struct vertices;
struct result;
struct space_id;
struct parts;
struct vertex_props;
struct edge_props;
struct expressions;
struct dedup;
struct order_by;
struct limit;
struct filter;
struct common;
struct result;
struct props;
struct tag_id;
struct props;
struct id;
struct tags;
struct src;
struct edge_type;
struct ranking;
struct dst;
struct key;
struct props;
struct space_id;
struct parts;
struct prop_names;
struct if_not_exists;
struct ignore_existed_index;
struct common;
struct space_id;
struct parts;
struct prop_names;
struct if_not_exists;
struct ignore_existed_index;
struct common;
struct space_id;
struct parts;
struct common;
struct space_id;
struct parts;
struct common;
struct id;
struct tags;
struct space_id;
struct parts;
struct common;
struct result;
struct props;
struct name;
struct value;
struct space_id;
struct part_id;
struct vertex_id;
struct tag_id;
struct updated_props;
struct insertable;
struct return_props;
struct condition;
struct common;
struct space_id;
struct part_id;
struct edge_key;
struct updated_props;
struct insertable;
struct return_props;
struct condition;
struct common;
struct space_id;
struct part_id;
struct name;
struct common;
struct result;
struct id;
struct result;
struct data;
struct column_name;
struct scan_type;
struct begin_value;
struct end_value;
struct include_begin;
struct include_end;
struct index_id;
struct filter;
struct column_hints;
struct contexts;
struct schema_id;
struct space_id;
struct parts;
struct indices;
struct return_columns;
struct common;
struct limit;
struct order_by;
struct space_id;
struct parts;
struct indices;
struct traverse_spec;
struct common;
struct next_cursor;
struct space_id;
struct parts;
struct return_columns;
struct limit;
struct start_time;
struct end_time;
struct filter;
struct only_latest_version;
struct enable_read_from_follower;
struct common;
struct space_id;
struct parts;
struct return_columns;
struct limit;
struct start_time;
struct end_time;
struct filter;
struct only_latest_version;
struct enable_read_from_follower;
struct common;
struct result;
struct props;
struct cursors;
struct space_id;
struct parts;
struct task_specific_paras;
struct space_id;
struct parts;
struct return_partly;
struct result;
struct key_values;
struct space_id;
struct parts;
struct space_id;
struct parts;
struct result;
struct stats;
struct space_id;
struct part_id;
struct new_leader;
struct space_id;
struct part_id;
struct as_learner;
struct peers;
struct space_id;
struct part_id;
struct learner;
struct space_id;
struct part_id;
struct space_id;
struct part_id;
struct peer;
struct add;
struct space_id;
struct part_id;
struct target;
struct space_ids;
struct name;
struct space_ids;
struct name;
struct space_ids;
struct sign;
struct result;
struct leader_parts;
struct space_id;
struct part_id;
struct peers;
struct space_id;
struct parts;
struct index_id;
struct result;
struct info;
struct result;
struct dir;
struct cmd;
struct job_id;
struct task_id;
struct para;
struct concurrency;
struct job_id;
struct task_id;
struct space_id;
struct parts;
struct prop_names;
struct if_not_exists;
struct term;
struct edge_version;
struct update_edge_request;
struct term;
struct edge_version;
struct space_id;
struct parts;
struct space_id;
struct parts;
struct txn_id;
struct term;
} // namespace tag
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_session_id
#define APACHE_THRIFT_ACCESSOR_session_id
APACHE_THRIFT_DEFINE_ACCESSOR(session_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_plan_id
#define APACHE_THRIFT_ACCESSOR_plan_id
APACHE_THRIFT_DEFINE_ACCESSOR(plan_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_profile_detail
#define APACHE_THRIFT_ACCESSOR_profile_detail
APACHE_THRIFT_DEFINE_ACCESSOR(profile_detail);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_part_id
#define APACHE_THRIFT_ACCESSOR_part_id
APACHE_THRIFT_DEFINE_ACCESSOR(part_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader
#define APACHE_THRIFT_ACCESSOR_leader
APACHE_THRIFT_DEFINE_ACCESSOR(leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_failed_parts
#define APACHE_THRIFT_ACCESSOR_failed_parts
APACHE_THRIFT_DEFINE_ACCESSOR(failed_parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_latency_in_us
#define APACHE_THRIFT_ACCESSOR_latency_in_us
APACHE_THRIFT_DEFINE_ACCESSOR(latency_in_us);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_latency_detail_us
#define APACHE_THRIFT_ACCESSOR_latency_detail_us
APACHE_THRIFT_DEFINE_ACCESSOR(latency_detail_us);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_alias
#define APACHE_THRIFT_ACCESSOR_alias
APACHE_THRIFT_DEFINE_ACCESSOR(alias);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_prop
#define APACHE_THRIFT_ACCESSOR_prop
APACHE_THRIFT_DEFINE_ACCESSOR(prop);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stat
#define APACHE_THRIFT_ACCESSOR_stat
APACHE_THRIFT_DEFINE_ACCESSOR(stat);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_alias
#define APACHE_THRIFT_ACCESSOR_alias
APACHE_THRIFT_DEFINE_ACCESSOR(alias);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_expr
#define APACHE_THRIFT_ACCESSOR_expr
APACHE_THRIFT_DEFINE_ACCESSOR(expr);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_props
#define APACHE_THRIFT_ACCESSOR_props
APACHE_THRIFT_DEFINE_ACCESSOR(props);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tag
#define APACHE_THRIFT_ACCESSOR_tag
APACHE_THRIFT_DEFINE_ACCESSOR(tag);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_props
#define APACHE_THRIFT_ACCESSOR_props
APACHE_THRIFT_DEFINE_ACCESSOR(props);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_prop
#define APACHE_THRIFT_ACCESSOR_prop
APACHE_THRIFT_DEFINE_ACCESSOR(prop);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_direction
#define APACHE_THRIFT_ACCESSOR_direction
APACHE_THRIFT_DEFINE_ACCESSOR(direction);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edge_types
#define APACHE_THRIFT_ACCESSOR_edge_types
APACHE_THRIFT_DEFINE_ACCESSOR(edge_types);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edge_direction
#define APACHE_THRIFT_ACCESSOR_edge_direction
APACHE_THRIFT_DEFINE_ACCESSOR(edge_direction);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_dedup
#define APACHE_THRIFT_ACCESSOR_dedup
APACHE_THRIFT_DEFINE_ACCESSOR(dedup);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stat_props
#define APACHE_THRIFT_ACCESSOR_stat_props
APACHE_THRIFT_DEFINE_ACCESSOR(stat_props);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_vertex_props
#define APACHE_THRIFT_ACCESSOR_vertex_props
APACHE_THRIFT_DEFINE_ACCESSOR(vertex_props);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edge_props
#define APACHE_THRIFT_ACCESSOR_edge_props
APACHE_THRIFT_DEFINE_ACCESSOR(edge_props);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_expressions
#define APACHE_THRIFT_ACCESSOR_expressions
APACHE_THRIFT_DEFINE_ACCESSOR(expressions);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_order_by
#define APACHE_THRIFT_ACCESSOR_order_by
APACHE_THRIFT_DEFINE_ACCESSOR(order_by);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_random
#define APACHE_THRIFT_ACCESSOR_random
APACHE_THRIFT_DEFINE_ACCESSOR(random);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_limit
#define APACHE_THRIFT_ACCESSOR_limit
APACHE_THRIFT_DEFINE_ACCESSOR(limit);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_filter
#define APACHE_THRIFT_ACCESSOR_filter
APACHE_THRIFT_DEFINE_ACCESSOR(filter);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_column_names
#define APACHE_THRIFT_ACCESSOR_column_names
APACHE_THRIFT_DEFINE_ACCESSOR(column_names);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_traverse_spec
#define APACHE_THRIFT_ACCESSOR_traverse_spec
APACHE_THRIFT_DEFINE_ACCESSOR(traverse_spec);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_common
#define APACHE_THRIFT_ACCESSOR_common
APACHE_THRIFT_DEFINE_ACCESSOR(common);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_result
#define APACHE_THRIFT_ACCESSOR_result
APACHE_THRIFT_DEFINE_ACCESSOR(result);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_vertices
#define APACHE_THRIFT_ACCESSOR_vertices
APACHE_THRIFT_DEFINE_ACCESSOR(vertices);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_result
#define APACHE_THRIFT_ACCESSOR_result
APACHE_THRIFT_DEFINE_ACCESSOR(result);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_vertex_props
#define APACHE_THRIFT_ACCESSOR_vertex_props
APACHE_THRIFT_DEFINE_ACCESSOR(vertex_props);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edge_props
#define APACHE_THRIFT_ACCESSOR_edge_props
APACHE_THRIFT_DEFINE_ACCESSOR(edge_props);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_expressions
#define APACHE_THRIFT_ACCESSOR_expressions
APACHE_THRIFT_DEFINE_ACCESSOR(expressions);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_dedup
#define APACHE_THRIFT_ACCESSOR_dedup
APACHE_THRIFT_DEFINE_ACCESSOR(dedup);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_order_by
#define APACHE_THRIFT_ACCESSOR_order_by
APACHE_THRIFT_DEFINE_ACCESSOR(order_by);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_limit
#define APACHE_THRIFT_ACCESSOR_limit
APACHE_THRIFT_DEFINE_ACCESSOR(limit);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_filter
#define APACHE_THRIFT_ACCESSOR_filter
APACHE_THRIFT_DEFINE_ACCESSOR(filter);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_common
#define APACHE_THRIFT_ACCESSOR_common
APACHE_THRIFT_DEFINE_ACCESSOR(common);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_result
#define APACHE_THRIFT_ACCESSOR_result
APACHE_THRIFT_DEFINE_ACCESSOR(result);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_props
#define APACHE_THRIFT_ACCESSOR_props
APACHE_THRIFT_DEFINE_ACCESSOR(props);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tag_id
#define APACHE_THRIFT_ACCESSOR_tag_id
APACHE_THRIFT_DEFINE_ACCESSOR(tag_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_props
#define APACHE_THRIFT_ACCESSOR_props
APACHE_THRIFT_DEFINE_ACCESSOR(props);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_id
#define APACHE_THRIFT_ACCESSOR_id
APACHE_THRIFT_DEFINE_ACCESSOR(id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tags
#define APACHE_THRIFT_ACCESSOR_tags
APACHE_THRIFT_DEFINE_ACCESSOR(tags);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_src
#define APACHE_THRIFT_ACCESSOR_src
APACHE_THRIFT_DEFINE_ACCESSOR(src);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edge_type
#define APACHE_THRIFT_ACCESSOR_edge_type
APACHE_THRIFT_DEFINE_ACCESSOR(edge_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ranking
#define APACHE_THRIFT_ACCESSOR_ranking
APACHE_THRIFT_DEFINE_ACCESSOR(ranking);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_dst
#define APACHE_THRIFT_ACCESSOR_dst
APACHE_THRIFT_DEFINE_ACCESSOR(dst);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_key
#define APACHE_THRIFT_ACCESSOR_key
APACHE_THRIFT_DEFINE_ACCESSOR(key);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_props
#define APACHE_THRIFT_ACCESSOR_props
APACHE_THRIFT_DEFINE_ACCESSOR(props);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_prop_names
#define APACHE_THRIFT_ACCESSOR_prop_names
APACHE_THRIFT_DEFINE_ACCESSOR(prop_names);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_if_not_exists
#define APACHE_THRIFT_ACCESSOR_if_not_exists
APACHE_THRIFT_DEFINE_ACCESSOR(if_not_exists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ignore_existed_index
#define APACHE_THRIFT_ACCESSOR_ignore_existed_index
APACHE_THRIFT_DEFINE_ACCESSOR(ignore_existed_index);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_common
#define APACHE_THRIFT_ACCESSOR_common
APACHE_THRIFT_DEFINE_ACCESSOR(common);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_prop_names
#define APACHE_THRIFT_ACCESSOR_prop_names
APACHE_THRIFT_DEFINE_ACCESSOR(prop_names);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_if_not_exists
#define APACHE_THRIFT_ACCESSOR_if_not_exists
APACHE_THRIFT_DEFINE_ACCESSOR(if_not_exists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ignore_existed_index
#define APACHE_THRIFT_ACCESSOR_ignore_existed_index
APACHE_THRIFT_DEFINE_ACCESSOR(ignore_existed_index);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_common
#define APACHE_THRIFT_ACCESSOR_common
APACHE_THRIFT_DEFINE_ACCESSOR(common);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_common
#define APACHE_THRIFT_ACCESSOR_common
APACHE_THRIFT_DEFINE_ACCESSOR(common);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_common
#define APACHE_THRIFT_ACCESSOR_common
APACHE_THRIFT_DEFINE_ACCESSOR(common);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_id
#define APACHE_THRIFT_ACCESSOR_id
APACHE_THRIFT_DEFINE_ACCESSOR(id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tags
#define APACHE_THRIFT_ACCESSOR_tags
APACHE_THRIFT_DEFINE_ACCESSOR(tags);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_common
#define APACHE_THRIFT_ACCESSOR_common
APACHE_THRIFT_DEFINE_ACCESSOR(common);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_result
#define APACHE_THRIFT_ACCESSOR_result
APACHE_THRIFT_DEFINE_ACCESSOR(result);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_props
#define APACHE_THRIFT_ACCESSOR_props
APACHE_THRIFT_DEFINE_ACCESSOR(props);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_value
#define APACHE_THRIFT_ACCESSOR_value
APACHE_THRIFT_DEFINE_ACCESSOR(value);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_part_id
#define APACHE_THRIFT_ACCESSOR_part_id
APACHE_THRIFT_DEFINE_ACCESSOR(part_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_vertex_id
#define APACHE_THRIFT_ACCESSOR_vertex_id
APACHE_THRIFT_DEFINE_ACCESSOR(vertex_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tag_id
#define APACHE_THRIFT_ACCESSOR_tag_id
APACHE_THRIFT_DEFINE_ACCESSOR(tag_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_updated_props
#define APACHE_THRIFT_ACCESSOR_updated_props
APACHE_THRIFT_DEFINE_ACCESSOR(updated_props);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_insertable
#define APACHE_THRIFT_ACCESSOR_insertable
APACHE_THRIFT_DEFINE_ACCESSOR(insertable);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_return_props
#define APACHE_THRIFT_ACCESSOR_return_props
APACHE_THRIFT_DEFINE_ACCESSOR(return_props);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_condition
#define APACHE_THRIFT_ACCESSOR_condition
APACHE_THRIFT_DEFINE_ACCESSOR(condition);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_common
#define APACHE_THRIFT_ACCESSOR_common
APACHE_THRIFT_DEFINE_ACCESSOR(common);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_part_id
#define APACHE_THRIFT_ACCESSOR_part_id
APACHE_THRIFT_DEFINE_ACCESSOR(part_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edge_key
#define APACHE_THRIFT_ACCESSOR_edge_key
APACHE_THRIFT_DEFINE_ACCESSOR(edge_key);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_updated_props
#define APACHE_THRIFT_ACCESSOR_updated_props
APACHE_THRIFT_DEFINE_ACCESSOR(updated_props);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_insertable
#define APACHE_THRIFT_ACCESSOR_insertable
APACHE_THRIFT_DEFINE_ACCESSOR(insertable);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_return_props
#define APACHE_THRIFT_ACCESSOR_return_props
APACHE_THRIFT_DEFINE_ACCESSOR(return_props);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_condition
#define APACHE_THRIFT_ACCESSOR_condition
APACHE_THRIFT_DEFINE_ACCESSOR(condition);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_common
#define APACHE_THRIFT_ACCESSOR_common
APACHE_THRIFT_DEFINE_ACCESSOR(common);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_part_id
#define APACHE_THRIFT_ACCESSOR_part_id
APACHE_THRIFT_DEFINE_ACCESSOR(part_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_common
#define APACHE_THRIFT_ACCESSOR_common
APACHE_THRIFT_DEFINE_ACCESSOR(common);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_result
#define APACHE_THRIFT_ACCESSOR_result
APACHE_THRIFT_DEFINE_ACCESSOR(result);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_id
#define APACHE_THRIFT_ACCESSOR_id
APACHE_THRIFT_DEFINE_ACCESSOR(id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_result
#define APACHE_THRIFT_ACCESSOR_result
APACHE_THRIFT_DEFINE_ACCESSOR(result);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_data
#define APACHE_THRIFT_ACCESSOR_data
APACHE_THRIFT_DEFINE_ACCESSOR(data);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_column_name
#define APACHE_THRIFT_ACCESSOR_column_name
APACHE_THRIFT_DEFINE_ACCESSOR(column_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_scan_type
#define APACHE_THRIFT_ACCESSOR_scan_type
APACHE_THRIFT_DEFINE_ACCESSOR(scan_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_begin_value
#define APACHE_THRIFT_ACCESSOR_begin_value
APACHE_THRIFT_DEFINE_ACCESSOR(begin_value);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_end_value
#define APACHE_THRIFT_ACCESSOR_end_value
APACHE_THRIFT_DEFINE_ACCESSOR(end_value);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_include_begin
#define APACHE_THRIFT_ACCESSOR_include_begin
APACHE_THRIFT_DEFINE_ACCESSOR(include_begin);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_include_end
#define APACHE_THRIFT_ACCESSOR_include_end
APACHE_THRIFT_DEFINE_ACCESSOR(include_end);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_index_id
#define APACHE_THRIFT_ACCESSOR_index_id
APACHE_THRIFT_DEFINE_ACCESSOR(index_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_filter
#define APACHE_THRIFT_ACCESSOR_filter
APACHE_THRIFT_DEFINE_ACCESSOR(filter);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_column_hints
#define APACHE_THRIFT_ACCESSOR_column_hints
APACHE_THRIFT_DEFINE_ACCESSOR(column_hints);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_contexts
#define APACHE_THRIFT_ACCESSOR_contexts
APACHE_THRIFT_DEFINE_ACCESSOR(contexts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_schema_id
#define APACHE_THRIFT_ACCESSOR_schema_id
APACHE_THRIFT_DEFINE_ACCESSOR(schema_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_indices
#define APACHE_THRIFT_ACCESSOR_indices
APACHE_THRIFT_DEFINE_ACCESSOR(indices);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_return_columns
#define APACHE_THRIFT_ACCESSOR_return_columns
APACHE_THRIFT_DEFINE_ACCESSOR(return_columns);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_common
#define APACHE_THRIFT_ACCESSOR_common
APACHE_THRIFT_DEFINE_ACCESSOR(common);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_limit
#define APACHE_THRIFT_ACCESSOR_limit
APACHE_THRIFT_DEFINE_ACCESSOR(limit);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_order_by
#define APACHE_THRIFT_ACCESSOR_order_by
APACHE_THRIFT_DEFINE_ACCESSOR(order_by);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_indices
#define APACHE_THRIFT_ACCESSOR_indices
APACHE_THRIFT_DEFINE_ACCESSOR(indices);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_traverse_spec
#define APACHE_THRIFT_ACCESSOR_traverse_spec
APACHE_THRIFT_DEFINE_ACCESSOR(traverse_spec);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_common
#define APACHE_THRIFT_ACCESSOR_common
APACHE_THRIFT_DEFINE_ACCESSOR(common);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_next_cursor
#define APACHE_THRIFT_ACCESSOR_next_cursor
APACHE_THRIFT_DEFINE_ACCESSOR(next_cursor);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_return_columns
#define APACHE_THRIFT_ACCESSOR_return_columns
APACHE_THRIFT_DEFINE_ACCESSOR(return_columns);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_limit
#define APACHE_THRIFT_ACCESSOR_limit
APACHE_THRIFT_DEFINE_ACCESSOR(limit);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_start_time
#define APACHE_THRIFT_ACCESSOR_start_time
APACHE_THRIFT_DEFINE_ACCESSOR(start_time);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_end_time
#define APACHE_THRIFT_ACCESSOR_end_time
APACHE_THRIFT_DEFINE_ACCESSOR(end_time);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_filter
#define APACHE_THRIFT_ACCESSOR_filter
APACHE_THRIFT_DEFINE_ACCESSOR(filter);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_only_latest_version
#define APACHE_THRIFT_ACCESSOR_only_latest_version
APACHE_THRIFT_DEFINE_ACCESSOR(only_latest_version);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_enable_read_from_follower
#define APACHE_THRIFT_ACCESSOR_enable_read_from_follower
APACHE_THRIFT_DEFINE_ACCESSOR(enable_read_from_follower);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_common
#define APACHE_THRIFT_ACCESSOR_common
APACHE_THRIFT_DEFINE_ACCESSOR(common);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_return_columns
#define APACHE_THRIFT_ACCESSOR_return_columns
APACHE_THRIFT_DEFINE_ACCESSOR(return_columns);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_limit
#define APACHE_THRIFT_ACCESSOR_limit
APACHE_THRIFT_DEFINE_ACCESSOR(limit);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_start_time
#define APACHE_THRIFT_ACCESSOR_start_time
APACHE_THRIFT_DEFINE_ACCESSOR(start_time);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_end_time
#define APACHE_THRIFT_ACCESSOR_end_time
APACHE_THRIFT_DEFINE_ACCESSOR(end_time);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_filter
#define APACHE_THRIFT_ACCESSOR_filter
APACHE_THRIFT_DEFINE_ACCESSOR(filter);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_only_latest_version
#define APACHE_THRIFT_ACCESSOR_only_latest_version
APACHE_THRIFT_DEFINE_ACCESSOR(only_latest_version);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_enable_read_from_follower
#define APACHE_THRIFT_ACCESSOR_enable_read_from_follower
APACHE_THRIFT_DEFINE_ACCESSOR(enable_read_from_follower);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_common
#define APACHE_THRIFT_ACCESSOR_common
APACHE_THRIFT_DEFINE_ACCESSOR(common);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_result
#define APACHE_THRIFT_ACCESSOR_result
APACHE_THRIFT_DEFINE_ACCESSOR(result);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_props
#define APACHE_THRIFT_ACCESSOR_props
APACHE_THRIFT_DEFINE_ACCESSOR(props);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cursors
#define APACHE_THRIFT_ACCESSOR_cursors
APACHE_THRIFT_DEFINE_ACCESSOR(cursors);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_task_specific_paras
#define APACHE_THRIFT_ACCESSOR_task_specific_paras
APACHE_THRIFT_DEFINE_ACCESSOR(task_specific_paras);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_return_partly
#define APACHE_THRIFT_ACCESSOR_return_partly
APACHE_THRIFT_DEFINE_ACCESSOR(return_partly);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_result
#define APACHE_THRIFT_ACCESSOR_result
APACHE_THRIFT_DEFINE_ACCESSOR(result);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_key_values
#define APACHE_THRIFT_ACCESSOR_key_values
APACHE_THRIFT_DEFINE_ACCESSOR(key_values);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_result
#define APACHE_THRIFT_ACCESSOR_result
APACHE_THRIFT_DEFINE_ACCESSOR(result);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stats
#define APACHE_THRIFT_ACCESSOR_stats
APACHE_THRIFT_DEFINE_ACCESSOR(stats);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_part_id
#define APACHE_THRIFT_ACCESSOR_part_id
APACHE_THRIFT_DEFINE_ACCESSOR(part_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_new_leader
#define APACHE_THRIFT_ACCESSOR_new_leader
APACHE_THRIFT_DEFINE_ACCESSOR(new_leader);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_part_id
#define APACHE_THRIFT_ACCESSOR_part_id
APACHE_THRIFT_DEFINE_ACCESSOR(part_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_as_learner
#define APACHE_THRIFT_ACCESSOR_as_learner
APACHE_THRIFT_DEFINE_ACCESSOR(as_learner);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_peers
#define APACHE_THRIFT_ACCESSOR_peers
APACHE_THRIFT_DEFINE_ACCESSOR(peers);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_part_id
#define APACHE_THRIFT_ACCESSOR_part_id
APACHE_THRIFT_DEFINE_ACCESSOR(part_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_learner
#define APACHE_THRIFT_ACCESSOR_learner
APACHE_THRIFT_DEFINE_ACCESSOR(learner);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_part_id
#define APACHE_THRIFT_ACCESSOR_part_id
APACHE_THRIFT_DEFINE_ACCESSOR(part_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_part_id
#define APACHE_THRIFT_ACCESSOR_part_id
APACHE_THRIFT_DEFINE_ACCESSOR(part_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_peer
#define APACHE_THRIFT_ACCESSOR_peer
APACHE_THRIFT_DEFINE_ACCESSOR(peer);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_add
#define APACHE_THRIFT_ACCESSOR_add
APACHE_THRIFT_DEFINE_ACCESSOR(add);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_part_id
#define APACHE_THRIFT_ACCESSOR_part_id
APACHE_THRIFT_DEFINE_ACCESSOR(part_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_target
#define APACHE_THRIFT_ACCESSOR_target
APACHE_THRIFT_DEFINE_ACCESSOR(target);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_ids
#define APACHE_THRIFT_ACCESSOR_space_ids
APACHE_THRIFT_DEFINE_ACCESSOR(space_ids);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_ids
#define APACHE_THRIFT_ACCESSOR_space_ids
APACHE_THRIFT_DEFINE_ACCESSOR(space_ids);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_ids
#define APACHE_THRIFT_ACCESSOR_space_ids
APACHE_THRIFT_DEFINE_ACCESSOR(space_ids);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_sign
#define APACHE_THRIFT_ACCESSOR_sign
APACHE_THRIFT_DEFINE_ACCESSOR(sign);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_result
#define APACHE_THRIFT_ACCESSOR_result
APACHE_THRIFT_DEFINE_ACCESSOR(result);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leader_parts
#define APACHE_THRIFT_ACCESSOR_leader_parts
APACHE_THRIFT_DEFINE_ACCESSOR(leader_parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_part_id
#define APACHE_THRIFT_ACCESSOR_part_id
APACHE_THRIFT_DEFINE_ACCESSOR(part_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_peers
#define APACHE_THRIFT_ACCESSOR_peers
APACHE_THRIFT_DEFINE_ACCESSOR(peers);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_index_id
#define APACHE_THRIFT_ACCESSOR_index_id
APACHE_THRIFT_DEFINE_ACCESSOR(index_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_result
#define APACHE_THRIFT_ACCESSOR_result
APACHE_THRIFT_DEFINE_ACCESSOR(result);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_info
#define APACHE_THRIFT_ACCESSOR_info
APACHE_THRIFT_DEFINE_ACCESSOR(info);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_result
#define APACHE_THRIFT_ACCESSOR_result
APACHE_THRIFT_DEFINE_ACCESSOR(result);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_dir
#define APACHE_THRIFT_ACCESSOR_dir
APACHE_THRIFT_DEFINE_ACCESSOR(dir);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cmd
#define APACHE_THRIFT_ACCESSOR_cmd
APACHE_THRIFT_DEFINE_ACCESSOR(cmd);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_job_id
#define APACHE_THRIFT_ACCESSOR_job_id
APACHE_THRIFT_DEFINE_ACCESSOR(job_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_task_id
#define APACHE_THRIFT_ACCESSOR_task_id
APACHE_THRIFT_DEFINE_ACCESSOR(task_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_para
#define APACHE_THRIFT_ACCESSOR_para
APACHE_THRIFT_DEFINE_ACCESSOR(para);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_concurrency
#define APACHE_THRIFT_ACCESSOR_concurrency
APACHE_THRIFT_DEFINE_ACCESSOR(concurrency);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_job_id
#define APACHE_THRIFT_ACCESSOR_job_id
APACHE_THRIFT_DEFINE_ACCESSOR(job_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_task_id
#define APACHE_THRIFT_ACCESSOR_task_id
APACHE_THRIFT_DEFINE_ACCESSOR(task_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_prop_names
#define APACHE_THRIFT_ACCESSOR_prop_names
APACHE_THRIFT_DEFINE_ACCESSOR(prop_names);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_if_not_exists
#define APACHE_THRIFT_ACCESSOR_if_not_exists
APACHE_THRIFT_DEFINE_ACCESSOR(if_not_exists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_term
#define APACHE_THRIFT_ACCESSOR_term
APACHE_THRIFT_DEFINE_ACCESSOR(term);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edge_version
#define APACHE_THRIFT_ACCESSOR_edge_version
APACHE_THRIFT_DEFINE_ACCESSOR(edge_version);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_update_edge_request
#define APACHE_THRIFT_ACCESSOR_update_edge_request
APACHE_THRIFT_DEFINE_ACCESSOR(update_edge_request);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_term
#define APACHE_THRIFT_ACCESSOR_term
APACHE_THRIFT_DEFINE_ACCESSOR(term);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_edge_version
#define APACHE_THRIFT_ACCESSOR_edge_version
APACHE_THRIFT_DEFINE_ACCESSOR(edge_version);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_space_id
#define APACHE_THRIFT_ACCESSOR_space_id
APACHE_THRIFT_DEFINE_ACCESSOR(space_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parts
#define APACHE_THRIFT_ACCESSOR_parts
APACHE_THRIFT_DEFINE_ACCESSOR(parts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_txn_id
#define APACHE_THRIFT_ACCESSOR_txn_id
APACHE_THRIFT_DEFINE_ACCESSOR(txn_id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_term
#define APACHE_THRIFT_ACCESSOR_term
APACHE_THRIFT_DEFINE_ACCESSOR(term);
#endif
} // namespace detail
} // namespace thrift
} // namespace apache

// BEGIN declare_enums
namespace nebula { namespace storage { namespace cpp2 {

enum class StatType {
  SUM = 1,
  COUNT = 2,
  AVG = 3,
  MAX = 4,
  MIN = 5,
};




enum class OrderDirection {
  ASCENDING = 1,
  DESCENDING = 2,
};




enum class EdgeDirection {
  BOTH = 1,
  IN_EDGE = 2,
  OUT_EDGE = 3,
};




enum class ScanType {
  PREFIX = 1,
  RANGE = 2,
};




enum class EngineSignType {
  BLOCK_ON = 1,
  BLOCK_OFF = 2,
};




}}} // nebula::storage::cpp2
namespace std {


template<> struct hash<typename ::nebula::storage::cpp2::StatType> : public apache::thrift::detail::enum_hash<typename ::nebula::storage::cpp2::StatType> {};
template<> struct equal_to<typename ::nebula::storage::cpp2::StatType> : public apache::thrift::detail::enum_equal_to<typename ::nebula::storage::cpp2::StatType> {};


template<> struct hash<typename ::nebula::storage::cpp2::OrderDirection> : public apache::thrift::detail::enum_hash<typename ::nebula::storage::cpp2::OrderDirection> {};
template<> struct equal_to<typename ::nebula::storage::cpp2::OrderDirection> : public apache::thrift::detail::enum_equal_to<typename ::nebula::storage::cpp2::OrderDirection> {};


template<> struct hash<typename ::nebula::storage::cpp2::EdgeDirection> : public apache::thrift::detail::enum_hash<typename ::nebula::storage::cpp2::EdgeDirection> {};
template<> struct equal_to<typename ::nebula::storage::cpp2::EdgeDirection> : public apache::thrift::detail::enum_equal_to<typename ::nebula::storage::cpp2::EdgeDirection> {};


template<> struct hash<typename ::nebula::storage::cpp2::ScanType> : public apache::thrift::detail::enum_hash<typename ::nebula::storage::cpp2::ScanType> {};
template<> struct equal_to<typename ::nebula::storage::cpp2::ScanType> : public apache::thrift::detail::enum_equal_to<typename ::nebula::storage::cpp2::ScanType> {};


template<> struct hash<typename ::nebula::storage::cpp2::EngineSignType> : public apache::thrift::detail::enum_hash<typename ::nebula::storage::cpp2::EngineSignType> {};
template<> struct equal_to<typename ::nebula::storage::cpp2::EngineSignType> : public apache::thrift::detail::enum_equal_to<typename ::nebula::storage::cpp2::EngineSignType> {};


} // std

namespace apache { namespace thrift {


template <> struct TEnumDataStorage<::nebula::storage::cpp2::StatType>;

template <> struct TEnumTraits<::nebula::storage::cpp2::StatType> {
  using type = ::nebula::storage::cpp2::StatType;

  static constexpr std::size_t const size = 5;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::SUM; }
  static constexpr type max() { return type::MIN; }
};


template <> struct TEnumDataStorage<::nebula::storage::cpp2::OrderDirection>;

template <> struct TEnumTraits<::nebula::storage::cpp2::OrderDirection> {
  using type = ::nebula::storage::cpp2::OrderDirection;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::ASCENDING; }
  static constexpr type max() { return type::DESCENDING; }
};


template <> struct TEnumDataStorage<::nebula::storage::cpp2::EdgeDirection>;

template <> struct TEnumTraits<::nebula::storage::cpp2::EdgeDirection> {
  using type = ::nebula::storage::cpp2::EdgeDirection;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::BOTH; }
  static constexpr type max() { return type::OUT_EDGE; }
};


template <> struct TEnumDataStorage<::nebula::storage::cpp2::ScanType>;

template <> struct TEnumTraits<::nebula::storage::cpp2::ScanType> {
  using type = ::nebula::storage::cpp2::ScanType;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::PREFIX; }
  static constexpr type max() { return type::RANGE; }
};


template <> struct TEnumDataStorage<::nebula::storage::cpp2::EngineSignType>;

template <> struct TEnumTraits<::nebula::storage::cpp2::EngineSignType> {
  using type = ::nebula::storage::cpp2::EngineSignType;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::BLOCK_ON; }
  static constexpr type max() { return type::BLOCK_OFF; }
};


}} // apache::thrift

namespace nebula { namespace storage { namespace cpp2 {

using _StatType_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<StatType>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _StatType_EnumMapFactory::ValuesToNamesMapType _StatType_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _StatType_EnumMapFactory::NamesToValuesMapType _StatType_NAMES_TO_VALUES;

using _OrderDirection_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<OrderDirection>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _OrderDirection_EnumMapFactory::ValuesToNamesMapType _OrderDirection_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _OrderDirection_EnumMapFactory::NamesToValuesMapType _OrderDirection_NAMES_TO_VALUES;

using _EdgeDirection_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<EdgeDirection>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _EdgeDirection_EnumMapFactory::ValuesToNamesMapType _EdgeDirection_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _EdgeDirection_EnumMapFactory::NamesToValuesMapType _EdgeDirection_NAMES_TO_VALUES;

using _ScanType_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<ScanType>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _ScanType_EnumMapFactory::ValuesToNamesMapType _ScanType_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _ScanType_EnumMapFactory::NamesToValuesMapType _ScanType_NAMES_TO_VALUES;

using _EngineSignType_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<EngineSignType>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _EngineSignType_EnumMapFactory::ValuesToNamesMapType _EngineSignType_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _EngineSignType_EnumMapFactory::NamesToValuesMapType _EngineSignType_NAMES_TO_VALUES;

}}} // nebula::storage::cpp2

// END declare_enums
// BEGIN forward_declare
namespace nebula { namespace storage { namespace cpp2 {
class RequestCommon;
class PartitionResult;
class ResponseCommon;
class StatProp;
class Expr;
class EdgeProp;
class VertexProp;
class OrderBy;
class TraverseSpec;
class GetNeighborsRequest;
class GetNeighborsResponse;
class ExecResponse;
class GetPropRequest;
class GetPropResponse;
class NewTag;
class NewVertex;
class EdgeKey;
class NewEdge;
class AddVerticesRequest;
class AddEdgesRequest;
class DeleteVerticesRequest;
class DeleteEdgesRequest;
class DelTags;
class DeleteTagsRequest;
class UpdateResponse;
class UpdatedProp;
class UpdateVertexRequest;
class UpdateEdgeRequest;
class GetUUIDReq;
class GetUUIDResp;
class LookupIndexResp;
class IndexColumnHint;
class IndexQueryContext;
class IndexSpec;
class LookupIndexRequest;
class LookupAndTraverseRequest;
class ScanCursor;
class ScanVertexRequest;
class ScanEdgeRequest;
class ScanResponse;
class TaskPara;
class KVGetRequest;
class KVGetResponse;
class KVPutRequest;
class KVRemoveRequest;
class AdminExecResp;
class TransLeaderReq;
class AddPartReq;
class AddLearnerReq;
class RemovePartReq;
class MemberChangeReq;
class CatchUpDataReq;
class GetLeaderReq;
class CreateCPRequest;
class DropCPRequest;
class BlockingSignRequest;
class GetLeaderPartsResp;
class CheckPeersReq;
class RebuildIndexRequest;
class CreateCPResp;
class ListClusterInfoResp;
class ListClusterInfoReq;
class AddAdminTaskRequest;
class StopAdminTaskRequest;
class ChainAddEdgesRequest;
class ChainUpdateEdgeRequest;
class ChainDeleteEdgesRequest;
}}} // nebula::storage::cpp2
// END forward_declare
// BEGIN typedefs

// END typedefs
// BEGIN hash_and_equal_to
// END hash_and_equal_to
namespace nebula { namespace storage { namespace cpp2 {
class RequestCommon final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = RequestCommon;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  RequestCommon() :
      session_id(0),
      plan_id(0),
      profile_detail(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RequestCommon(apache::thrift::FragileConstructor,  ::nebula::cpp2::SessionID session_id__arg,  ::nebula::cpp2::ExecutionPlanID plan_id__arg, bool profile_detail__arg);

  RequestCommon(RequestCommon&&) = default;

  RequestCommon(const RequestCommon&) = default;


  RequestCommon& operator=(RequestCommon&&) = default;

  RequestCommon& operator=(const RequestCommon&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::SessionID session_id;
 private:
   ::nebula::cpp2::ExecutionPlanID plan_id;
 private:
  bool profile_detail;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool session_id;
    bool plan_id;
    bool profile_detail;
  } __isset = {};
  bool operator==(const RequestCommon& rhs) const;
#ifndef SWIG
  friend bool operator!=(const RequestCommon& __x, const RequestCommon& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const RequestCommon& rhs) const;
#ifndef SWIG
  friend bool operator>(const RequestCommon& __x, const RequestCommon& __y) {
    return __y < __x;
  }
  friend bool operator<=(const RequestCommon& __x, const RequestCommon& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const RequestCommon& __x, const RequestCommon& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::SessionID>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> session_id_ref() const& {
    return {this->session_id, __isset.session_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::SessionID>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> session_id_ref() const&& {
    return {std::move(this->session_id), __isset.session_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::SessionID>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> session_id_ref() & {
    return {this->session_id, __isset.session_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::SessionID>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> session_id_ref() && {
    return {std::move(this->session_id), __isset.session_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::ExecutionPlanID>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> plan_id_ref() const& {
    return {this->plan_id, __isset.plan_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::ExecutionPlanID>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> plan_id_ref() const&& {
    return {std::move(this->plan_id), __isset.plan_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::ExecutionPlanID>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> plan_id_ref() & {
    return {this->plan_id, __isset.plan_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::ExecutionPlanID>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> plan_id_ref() && {
    return {std::move(this->plan_id), __isset.plan_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> profile_detail_ref() const& {
    return {this->profile_detail, __isset.profile_detail};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> profile_detail_ref() const&& {
    return {std::move(this->profile_detail), __isset.profile_detail};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> profile_detail_ref() & {
    return {this->profile_detail, __isset.profile_detail};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> profile_detail_ref() && {
    return {std::move(this->profile_detail), __isset.profile_detail};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const  ::nebula::cpp2::SessionID* get_session_id() const& {
    return session_id_ref() ? std::addressof(session_id) : nullptr;
  }

   ::nebula::cpp2::SessionID* get_session_id() & {
    return session_id_ref() ? std::addressof(session_id) : nullptr;
  }
   ::nebula::cpp2::SessionID* get_session_id() && = delete;

   ::nebula::cpp2::SessionID& set_session_id( ::nebula::cpp2::SessionID session_id_) {
    session_id = session_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.session_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return session_id;
  }

  const  ::nebula::cpp2::ExecutionPlanID* get_plan_id() const& {
    return plan_id_ref() ? std::addressof(plan_id) : nullptr;
  }

   ::nebula::cpp2::ExecutionPlanID* get_plan_id() & {
    return plan_id_ref() ? std::addressof(plan_id) : nullptr;
  }
   ::nebula::cpp2::ExecutionPlanID* get_plan_id() && = delete;

   ::nebula::cpp2::ExecutionPlanID& set_plan_id( ::nebula::cpp2::ExecutionPlanID plan_id_) {
    plan_id = plan_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.plan_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return plan_id;
  }

  const bool* get_profile_detail() const& {
    return profile_detail_ref() ? std::addressof(profile_detail) : nullptr;
  }

  bool* get_profile_detail() & {
    return profile_detail_ref() ? std::addressof(profile_detail) : nullptr;
  }
  bool* get_profile_detail() && = delete;

  bool& set_profile_detail(bool profile_detail_) {
    profile_detail = profile_detail_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.profile_detail = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return profile_detail;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< RequestCommon >;
  friend void swap(RequestCommon& a, RequestCommon& b);
};

template <class Protocol_>
uint32_t RequestCommon::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class PartitionResult final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = PartitionResult;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  PartitionResult() :
      code( ::nebula::cpp2::ErrorCode::SUCCEEDED),
      part_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  PartitionResult(apache::thrift::FragileConstructor,  ::nebula::cpp2::ErrorCode code__arg,  ::nebula::cpp2::PartitionID part_id__arg, nebula::HostAddr leader__arg);

  PartitionResult(PartitionResult&&) = default;

  PartitionResult(const PartitionResult&) = default;


  PartitionResult& operator=(PartitionResult&&) = default;

  PartitionResult& operator=(const PartitionResult&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
   ::nebula::cpp2::ErrorCode code;
 public:
   ::nebula::cpp2::PartitionID part_id;
 private:
  nebula::HostAddr leader;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool leader;
  } __isset = {};
  bool operator==(const PartitionResult& rhs) const;
#ifndef SWIG
  friend bool operator!=(const PartitionResult& __x, const PartitionResult& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const PartitionResult& rhs) const;
#ifndef SWIG
  friend bool operator>(const PartitionResult& __x, const PartitionResult& __y) {
    return __y < __x;
  }
  friend bool operator<=(const PartitionResult& __x, const PartitionResult& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const PartitionResult& __x, const PartitionResult& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> code_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> code_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->code)};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> code_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->code};
  }

  template <typename..., typename T =  ::nebula::cpp2::ErrorCode>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> code_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->code)};
  }
  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> part_id_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> part_id_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->part_id)};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> part_id_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> part_id_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->part_id)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> leader_ref() const& {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> leader_ref() const&& {
    return {std::move(this->leader), __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> leader_ref() & {
    return {this->leader, __isset.leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> leader_ref() && {
    return {std::move(this->leader), __isset.leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::ErrorCode get_code() const {
    return code;
  }

   ::nebula::cpp2::ErrorCode& set_code( ::nebula::cpp2::ErrorCode code_) {
    code = code_;
    return code;
  }

   ::nebula::cpp2::PartitionID get_part_id() const {
    return part_id;
  }

   ::nebula::cpp2::PartitionID& set_part_id( ::nebula::cpp2::PartitionID part_id_) {
    part_id = part_id_;
    return part_id;
  }
  const nebula::HostAddr* get_leader() const&;
  nebula::HostAddr* get_leader() &;
  nebula::HostAddr* get_leader() && = delete;

  template <typename T_PartitionResult_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_leader(T_PartitionResult_leader_struct_setter&& leader_) {
    leader = std::forward<T_PartitionResult_leader_struct_setter>(leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< PartitionResult >;
  friend void swap(PartitionResult& a, PartitionResult& b);
};

template <class Protocol_>
uint32_t PartitionResult::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class ResponseCommon final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ResponseCommon;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ResponseCommon() :
      latency_in_us(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ResponseCommon(apache::thrift::FragileConstructor, ::std::vector< ::nebula::storage::cpp2::PartitionResult> failed_parts__arg, int64_t latency_in_us__arg, ::std::map<::std::string, int32_t> latency_detail_us__arg);

  ResponseCommon(ResponseCommon&&) = default;

  ResponseCommon(const ResponseCommon&) = default;


  ResponseCommon& operator=(ResponseCommon&&) = default;

  ResponseCommon& operator=(const ResponseCommon&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
  ::std::vector< ::nebula::storage::cpp2::PartitionResult> failed_parts;
 public:
  int64_t latency_in_us;
 private:
  ::std::map<::std::string, int32_t> latency_detail_us;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool latency_detail_us;
  } __isset = {};
  bool operator==(const ResponseCommon& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ResponseCommon& __x, const ResponseCommon& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ResponseCommon& rhs) const;
#ifndef SWIG
  friend bool operator>(const ResponseCommon& __x, const ResponseCommon& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ResponseCommon& __x, const ResponseCommon& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ResponseCommon& __x, const ResponseCommon& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::PartitionResult>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> failed_parts_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->failed_parts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::PartitionResult>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> failed_parts_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->failed_parts)};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::PartitionResult>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> failed_parts_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->failed_parts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::PartitionResult>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> failed_parts_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->failed_parts)};
  }
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> latency_in_us_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->latency_in_us};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> latency_in_us_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->latency_in_us)};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> latency_in_us_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->latency_in_us};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> latency_in_us_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->latency_in_us)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> latency_detail_us_ref() const& {
    return {this->latency_detail_us, __isset.latency_detail_us};
  }

  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> latency_detail_us_ref() const&& {
    return {std::move(this->latency_detail_us), __isset.latency_detail_us};
  }

  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> latency_detail_us_ref() & {
    return {this->latency_detail_us, __isset.latency_detail_us};
  }

  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> latency_detail_us_ref() && {
    return {std::move(this->latency_detail_us), __isset.latency_detail_us};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector< ::nebula::storage::cpp2::PartitionResult>& get_failed_parts() const&;
  ::std::vector< ::nebula::storage::cpp2::PartitionResult> get_failed_parts() &&;

  template <typename T_ResponseCommon_failed_parts_struct_setter = ::std::vector< ::nebula::storage::cpp2::PartitionResult>>
  ::std::vector< ::nebula::storage::cpp2::PartitionResult>& set_failed_parts(T_ResponseCommon_failed_parts_struct_setter&& failed_parts_) {
    failed_parts = std::forward<T_ResponseCommon_failed_parts_struct_setter>(failed_parts_);
    return failed_parts;
  }

  int64_t get_latency_in_us() const {
    return latency_in_us;
  }

  int64_t& set_latency_in_us(int64_t latency_in_us_) {
    latency_in_us = latency_in_us_;
    return latency_in_us;
  }
  const ::std::map<::std::string, int32_t>* get_latency_detail_us() const&;
  ::std::map<::std::string, int32_t>* get_latency_detail_us() &;
  ::std::map<::std::string, int32_t>* get_latency_detail_us() && = delete;

  template <typename T_ResponseCommon_latency_detail_us_struct_setter = ::std::map<::std::string, int32_t>>
  ::std::map<::std::string, int32_t>& set_latency_detail_us(T_ResponseCommon_latency_detail_us_struct_setter&& latency_detail_us_) {
    latency_detail_us = std::forward<T_ResponseCommon_latency_detail_us_struct_setter>(latency_detail_us_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.latency_detail_us = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return latency_detail_us;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ResponseCommon >;
  friend void swap(ResponseCommon& a, ResponseCommon& b);
};

template <class Protocol_>
uint32_t ResponseCommon::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class StatProp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = StatProp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  StatProp() :
      stat(static_cast< ::nebula::storage::cpp2::StatType>(0)) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  StatProp(apache::thrift::FragileConstructor, ::std::string alias__arg, ::std::string prop__arg,  ::nebula::storage::cpp2::StatType stat__arg);

  StatProp(StatProp&&) = default;

  StatProp(const StatProp&) = default;


  StatProp& operator=(StatProp&&) = default;

  StatProp& operator=(const StatProp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string alias;
 private:
  ::std::string prop;
 private:
   ::nebula::storage::cpp2::StatType stat;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool alias;
    bool prop;
    bool stat;
  } __isset = {};
  bool operator==(const StatProp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const StatProp& __x, const StatProp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const StatProp& rhs) const;
#ifndef SWIG
  friend bool operator>(const StatProp& __x, const StatProp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const StatProp& __x, const StatProp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const StatProp& __x, const StatProp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> alias_ref() const& {
    return {this->alias, __isset.alias};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> alias_ref() const&& {
    return {std::move(this->alias), __isset.alias};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> alias_ref() & {
    return {this->alias, __isset.alias};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> alias_ref() && {
    return {std::move(this->alias), __isset.alias};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> prop_ref() const& {
    return {this->prop, __isset.prop};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> prop_ref() const&& {
    return {std::move(this->prop), __isset.prop};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> prop_ref() & {
    return {this->prop, __isset.prop};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> prop_ref() && {
    return {std::move(this->prop), __isset.prop};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::StatType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> stat_ref() const& {
    return {this->stat, __isset.stat};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::StatType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> stat_ref() const&& {
    return {std::move(this->stat), __isset.stat};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::StatType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> stat_ref() & {
    return {this->stat, __isset.stat};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::StatType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> stat_ref() && {
    return {std::move(this->stat), __isset.stat};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_alias() const& {
    return alias;
  }

  ::std::string get_alias() && {
    return std::move(alias);
  }

  template <typename T_StatProp_alias_struct_setter = ::std::string>
  ::std::string& set_alias(T_StatProp_alias_struct_setter&& alias_) {
    alias = std::forward<T_StatProp_alias_struct_setter>(alias_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.alias = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return alias;
  }

  const ::std::string& get_prop() const& {
    return prop;
  }

  ::std::string get_prop() && {
    return std::move(prop);
  }

  template <typename T_StatProp_prop_struct_setter = ::std::string>
  ::std::string& set_prop(T_StatProp_prop_struct_setter&& prop_) {
    prop = std::forward<T_StatProp_prop_struct_setter>(prop_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.prop = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return prop;
  }

   ::nebula::storage::cpp2::StatType get_stat() const {
    return stat;
  }

   ::nebula::storage::cpp2::StatType& set_stat( ::nebula::storage::cpp2::StatType stat_) {
    stat = stat_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.stat = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return stat;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< StatProp >;
  friend void swap(StatProp& a, StatProp& b);
};

template <class Protocol_>
uint32_t StatProp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class Expr final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Expr;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  Expr() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Expr(apache::thrift::FragileConstructor, ::std::string alias__arg, ::std::string expr__arg);

  Expr(Expr&&) = default;

  Expr(const Expr&) = default;


  Expr& operator=(Expr&&) = default;

  Expr& operator=(const Expr&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string alias;
 private:
  ::std::string expr;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool alias;
    bool expr;
  } __isset = {};
  bool operator==(const Expr& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Expr& __x, const Expr& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Expr& rhs) const;
#ifndef SWIG
  friend bool operator>(const Expr& __x, const Expr& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Expr& __x, const Expr& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Expr& __x, const Expr& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> alias_ref() const& {
    return {this->alias, __isset.alias};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> alias_ref() const&& {
    return {std::move(this->alias), __isset.alias};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> alias_ref() & {
    return {this->alias, __isset.alias};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> alias_ref() && {
    return {std::move(this->alias), __isset.alias};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> expr_ref() const& {
    return {this->expr, __isset.expr};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> expr_ref() const&& {
    return {std::move(this->expr), __isset.expr};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> expr_ref() & {
    return {this->expr, __isset.expr};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> expr_ref() && {
    return {std::move(this->expr), __isset.expr};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_alias() const& {
    return alias;
  }

  ::std::string get_alias() && {
    return std::move(alias);
  }

  template <typename T_Expr_alias_struct_setter = ::std::string>
  ::std::string& set_alias(T_Expr_alias_struct_setter&& alias_) {
    alias = std::forward<T_Expr_alias_struct_setter>(alias_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.alias = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return alias;
  }

  const ::std::string& get_expr() const& {
    return expr;
  }

  ::std::string get_expr() && {
    return std::move(expr);
  }

  template <typename T_Expr_expr_struct_setter = ::std::string>
  ::std::string& set_expr(T_Expr_expr_struct_setter&& expr_) {
    expr = std::forward<T_Expr_expr_struct_setter>(expr_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.expr = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return expr;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Expr >;
  friend void swap(Expr& a, Expr& b);
};

template <class Protocol_>
uint32_t Expr::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class EdgeProp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = EdgeProp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  EdgeProp() :
      type(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  EdgeProp(apache::thrift::FragileConstructor,  ::nebula::cpp2::EdgeType type__arg, ::std::vector<::std::string> props__arg);

  EdgeProp(EdgeProp&&) = default;

  EdgeProp(const EdgeProp&) = default;


  EdgeProp& operator=(EdgeProp&&) = default;

  EdgeProp& operator=(const EdgeProp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::EdgeType type;
 private:
  ::std::vector<::std::string> props;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool type;
    bool props;
  } __isset = {};
  bool operator==(const EdgeProp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const EdgeProp& __x, const EdgeProp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const EdgeProp& rhs) const;
#ifndef SWIG
  friend bool operator>(const EdgeProp& __x, const EdgeProp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const EdgeProp& __x, const EdgeProp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const EdgeProp& __x, const EdgeProp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> type_ref() const& {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> type_ref() const&& {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> type_ref() & {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> type_ref() && {
    return {std::move(this->type), __isset.type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> props_ref() const& {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> props_ref() const&& {
    return {std::move(this->props), __isset.props};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> props_ref() & {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> props_ref() && {
    return {std::move(this->props), __isset.props};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::EdgeType get_type() const {
    return type;
  }

   ::nebula::cpp2::EdgeType& set_type( ::nebula::cpp2::EdgeType type_) {
    type = type_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return type;
  }
  const ::std::vector<::std::string>& get_props() const&;
  ::std::vector<::std::string> get_props() &&;

  template <typename T_EdgeProp_props_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_props(T_EdgeProp_props_struct_setter&& props_) {
    props = std::forward<T_EdgeProp_props_struct_setter>(props_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.props = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return props;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< EdgeProp >;
  friend void swap(EdgeProp& a, EdgeProp& b);
};

template <class Protocol_>
uint32_t EdgeProp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class VertexProp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = VertexProp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  VertexProp() :
      tag(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  VertexProp(apache::thrift::FragileConstructor,  ::nebula::cpp2::TagID tag__arg, ::std::vector<::std::string> props__arg);

  VertexProp(VertexProp&&) = default;

  VertexProp(const VertexProp&) = default;


  VertexProp& operator=(VertexProp&&) = default;

  VertexProp& operator=(const VertexProp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::TagID tag;
 private:
  ::std::vector<::std::string> props;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool tag;
    bool props;
  } __isset = {};
  bool operator==(const VertexProp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const VertexProp& __x, const VertexProp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const VertexProp& rhs) const;
#ifndef SWIG
  friend bool operator>(const VertexProp& __x, const VertexProp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const VertexProp& __x, const VertexProp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const VertexProp& __x, const VertexProp& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> tag_ref() const& {
    return {this->tag, __isset.tag};
  }

  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> tag_ref() const&& {
    return {std::move(this->tag), __isset.tag};
  }

  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> tag_ref() & {
    return {this->tag, __isset.tag};
  }

  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> tag_ref() && {
    return {std::move(this->tag), __isset.tag};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> props_ref() const& {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> props_ref() const&& {
    return {std::move(this->props), __isset.props};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> props_ref() & {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> props_ref() && {
    return {std::move(this->props), __isset.props};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::TagID get_tag() const {
    return tag;
  }

   ::nebula::cpp2::TagID& set_tag( ::nebula::cpp2::TagID tag_) {
    tag = tag_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.tag = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return tag;
  }
  const ::std::vector<::std::string>& get_props() const&;
  ::std::vector<::std::string> get_props() &&;

  template <typename T_VertexProp_props_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_props(T_VertexProp_props_struct_setter&& props_) {
    props = std::forward<T_VertexProp_props_struct_setter>(props_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.props = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return props;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< VertexProp >;
  friend void swap(VertexProp& a, VertexProp& b);
};

template <class Protocol_>
uint32_t VertexProp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class OrderBy final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = OrderBy;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  OrderBy() :
      direction(static_cast< ::nebula::storage::cpp2::OrderDirection>(0)) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  OrderBy(apache::thrift::FragileConstructor, ::std::string prop__arg,  ::nebula::storage::cpp2::OrderDirection direction__arg);

  OrderBy(OrderBy&&) = default;

  OrderBy(const OrderBy&) = default;


  OrderBy& operator=(OrderBy&&) = default;

  OrderBy& operator=(const OrderBy&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string prop;
 private:
   ::nebula::storage::cpp2::OrderDirection direction;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool prop;
    bool direction;
  } __isset = {};
  bool operator==(const OrderBy& rhs) const;
#ifndef SWIG
  friend bool operator!=(const OrderBy& __x, const OrderBy& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const OrderBy& rhs) const;
#ifndef SWIG
  friend bool operator>(const OrderBy& __x, const OrderBy& __y) {
    return __y < __x;
  }
  friend bool operator<=(const OrderBy& __x, const OrderBy& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const OrderBy& __x, const OrderBy& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> prop_ref() const& {
    return {this->prop, __isset.prop};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> prop_ref() const&& {
    return {std::move(this->prop), __isset.prop};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> prop_ref() & {
    return {this->prop, __isset.prop};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> prop_ref() && {
    return {std::move(this->prop), __isset.prop};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::OrderDirection>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> direction_ref() const& {
    return {this->direction, __isset.direction};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::OrderDirection>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> direction_ref() const&& {
    return {std::move(this->direction), __isset.direction};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::OrderDirection>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> direction_ref() & {
    return {this->direction, __isset.direction};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::OrderDirection>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> direction_ref() && {
    return {std::move(this->direction), __isset.direction};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_prop() const& {
    return prop;
  }

  ::std::string get_prop() && {
    return std::move(prop);
  }

  template <typename T_OrderBy_prop_struct_setter = ::std::string>
  ::std::string& set_prop(T_OrderBy_prop_struct_setter&& prop_) {
    prop = std::forward<T_OrderBy_prop_struct_setter>(prop_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.prop = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return prop;
  }

   ::nebula::storage::cpp2::OrderDirection get_direction() const {
    return direction;
  }

   ::nebula::storage::cpp2::OrderDirection& set_direction( ::nebula::storage::cpp2::OrderDirection direction_) {
    direction = direction_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.direction = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return direction;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< OrderBy >;
  friend void swap(OrderBy& a, OrderBy& b);
};

template <class Protocol_>
uint32_t OrderBy::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class TraverseSpec final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = TraverseSpec;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  TraverseSpec();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  TraverseSpec(apache::thrift::FragileConstructor, ::std::vector< ::nebula::cpp2::EdgeType> edge_types__arg,  ::nebula::storage::cpp2::EdgeDirection edge_direction__arg, bool dedup__arg, ::std::vector< ::nebula::storage::cpp2::StatProp> stat_props__arg, ::std::vector< ::nebula::storage::cpp2::VertexProp> vertex_props__arg, ::std::vector< ::nebula::storage::cpp2::EdgeProp> edge_props__arg, ::std::vector< ::nebula::storage::cpp2::Expr> expressions__arg, ::std::vector< ::nebula::storage::cpp2::OrderBy> order_by__arg, bool random__arg, int64_t limit__arg, ::std::string filter__arg);

  TraverseSpec(TraverseSpec&&) = default;

  TraverseSpec(const TraverseSpec&) = default;


  TraverseSpec& operator=(TraverseSpec&&) = default;

  TraverseSpec& operator=(const TraverseSpec&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~TraverseSpec();

 private:
  ::std::vector< ::nebula::cpp2::EdgeType> edge_types;
 private:
   ::nebula::storage::cpp2::EdgeDirection edge_direction;
 private:
  bool dedup;
 private:
  ::std::vector< ::nebula::storage::cpp2::StatProp> stat_props;
 private:
  ::std::vector< ::nebula::storage::cpp2::VertexProp> vertex_props;
 private:
  ::std::vector< ::nebula::storage::cpp2::EdgeProp> edge_props;
 private:
  ::std::vector< ::nebula::storage::cpp2::Expr> expressions;
 private:
  ::std::vector< ::nebula::storage::cpp2::OrderBy> order_by;
 private:
  bool random;
 private:
  int64_t limit;
 private:
  ::std::string filter;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool edge_types;
    bool edge_direction;
    bool dedup;
    bool stat_props;
    bool vertex_props;
    bool edge_props;
    bool expressions;
    bool order_by;
    bool random;
    bool limit;
    bool filter;
  } __isset = {};
  bool operator==(const TraverseSpec& rhs) const;
#ifndef SWIG
  friend bool operator!=(const TraverseSpec& __x, const TraverseSpec& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const TraverseSpec& rhs) const;
#ifndef SWIG
  friend bool operator>(const TraverseSpec& __x, const TraverseSpec& __y) {
    return __y < __x;
  }
  friend bool operator<=(const TraverseSpec& __x, const TraverseSpec& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const TraverseSpec& __x, const TraverseSpec& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::cpp2::EdgeType>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> edge_types_ref() const& {
    return {this->edge_types, __isset.edge_types};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::EdgeType>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> edge_types_ref() const&& {
    return {std::move(this->edge_types), __isset.edge_types};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::EdgeType>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> edge_types_ref() & {
    return {this->edge_types, __isset.edge_types};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::EdgeType>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> edge_types_ref() && {
    return {std::move(this->edge_types), __isset.edge_types};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::EdgeDirection>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> edge_direction_ref() const& {
    return {this->edge_direction, __isset.edge_direction};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::EdgeDirection>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> edge_direction_ref() const&& {
    return {std::move(this->edge_direction), __isset.edge_direction};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::EdgeDirection>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> edge_direction_ref() & {
    return {this->edge_direction, __isset.edge_direction};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::EdgeDirection>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> edge_direction_ref() && {
    return {std::move(this->edge_direction), __isset.edge_direction};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> dedup_ref() const& {
    return {this->dedup, __isset.dedup};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> dedup_ref() const&& {
    return {std::move(this->dedup), __isset.dedup};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> dedup_ref() & {
    return {this->dedup, __isset.dedup};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> dedup_ref() && {
    return {std::move(this->dedup), __isset.dedup};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::StatProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> stat_props_ref() const& {
    return {this->stat_props, __isset.stat_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::StatProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> stat_props_ref() const&& {
    return {std::move(this->stat_props), __isset.stat_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::StatProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> stat_props_ref() & {
    return {this->stat_props, __isset.stat_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::StatProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> stat_props_ref() && {
    return {std::move(this->stat_props), __isset.stat_props};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::VertexProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> vertex_props_ref() const& {
    return {this->vertex_props, __isset.vertex_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::VertexProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> vertex_props_ref() const&& {
    return {std::move(this->vertex_props), __isset.vertex_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::VertexProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> vertex_props_ref() & {
    return {this->vertex_props, __isset.vertex_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::VertexProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> vertex_props_ref() && {
    return {std::move(this->vertex_props), __isset.vertex_props};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::EdgeProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> edge_props_ref() const& {
    return {this->edge_props, __isset.edge_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::EdgeProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> edge_props_ref() const&& {
    return {std::move(this->edge_props), __isset.edge_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::EdgeProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> edge_props_ref() & {
    return {this->edge_props, __isset.edge_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::EdgeProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> edge_props_ref() && {
    return {std::move(this->edge_props), __isset.edge_props};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::Expr>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> expressions_ref() const& {
    return {this->expressions, __isset.expressions};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::Expr>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> expressions_ref() const&& {
    return {std::move(this->expressions), __isset.expressions};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::Expr>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> expressions_ref() & {
    return {this->expressions, __isset.expressions};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::Expr>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> expressions_ref() && {
    return {std::move(this->expressions), __isset.expressions};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::OrderBy>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> order_by_ref() const& {
    return {this->order_by, __isset.order_by};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::OrderBy>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> order_by_ref() const&& {
    return {std::move(this->order_by), __isset.order_by};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::OrderBy>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> order_by_ref() & {
    return {this->order_by, __isset.order_by};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::OrderBy>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> order_by_ref() && {
    return {std::move(this->order_by), __isset.order_by};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> random_ref() const& {
    return {this->random, __isset.random};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> random_ref() const&& {
    return {std::move(this->random), __isset.random};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> random_ref() & {
    return {this->random, __isset.random};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> random_ref() && {
    return {std::move(this->random), __isset.random};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> limit_ref() const& {
    return {this->limit, __isset.limit};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> limit_ref() const&& {
    return {std::move(this->limit), __isset.limit};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> limit_ref() & {
    return {this->limit, __isset.limit};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> limit_ref() && {
    return {std::move(this->limit), __isset.limit};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> filter_ref() const& {
    return {this->filter, __isset.filter};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> filter_ref() const&& {
    return {std::move(this->filter), __isset.filter};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> filter_ref() & {
    return {this->filter, __isset.filter};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> filter_ref() && {
    return {std::move(this->filter), __isset.filter};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector< ::nebula::cpp2::EdgeType>& get_edge_types() const&;
  ::std::vector< ::nebula::cpp2::EdgeType> get_edge_types() &&;

  template <typename T_TraverseSpec_edge_types_struct_setter = ::std::vector< ::nebula::cpp2::EdgeType>>
  ::std::vector< ::nebula::cpp2::EdgeType>& set_edge_types(T_TraverseSpec_edge_types_struct_setter&& edge_types_) {
    edge_types = std::forward<T_TraverseSpec_edge_types_struct_setter>(edge_types_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.edge_types = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return edge_types;
  }

   ::nebula::storage::cpp2::EdgeDirection get_edge_direction() const {
    return edge_direction;
  }

   ::nebula::storage::cpp2::EdgeDirection& set_edge_direction( ::nebula::storage::cpp2::EdgeDirection edge_direction_) {
    edge_direction = edge_direction_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.edge_direction = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return edge_direction;
  }

  bool get_dedup() const {
    return dedup;
  }

  bool& set_dedup(bool dedup_) {
    dedup = dedup_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.dedup = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return dedup;
  }
  const ::std::vector< ::nebula::storage::cpp2::StatProp>* get_stat_props() const&;
  ::std::vector< ::nebula::storage::cpp2::StatProp>* get_stat_props() &;
  ::std::vector< ::nebula::storage::cpp2::StatProp>* get_stat_props() && = delete;

  template <typename T_TraverseSpec_stat_props_struct_setter = ::std::vector< ::nebula::storage::cpp2::StatProp>>
  ::std::vector< ::nebula::storage::cpp2::StatProp>& set_stat_props(T_TraverseSpec_stat_props_struct_setter&& stat_props_) {
    stat_props = std::forward<T_TraverseSpec_stat_props_struct_setter>(stat_props_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.stat_props = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return stat_props;
  }
  const ::std::vector< ::nebula::storage::cpp2::VertexProp>* get_vertex_props() const&;
  ::std::vector< ::nebula::storage::cpp2::VertexProp>* get_vertex_props() &;
  ::std::vector< ::nebula::storage::cpp2::VertexProp>* get_vertex_props() && = delete;

  template <typename T_TraverseSpec_vertex_props_struct_setter = ::std::vector< ::nebula::storage::cpp2::VertexProp>>
  ::std::vector< ::nebula::storage::cpp2::VertexProp>& set_vertex_props(T_TraverseSpec_vertex_props_struct_setter&& vertex_props_) {
    vertex_props = std::forward<T_TraverseSpec_vertex_props_struct_setter>(vertex_props_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.vertex_props = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return vertex_props;
  }
  const ::std::vector< ::nebula::storage::cpp2::EdgeProp>* get_edge_props() const&;
  ::std::vector< ::nebula::storage::cpp2::EdgeProp>* get_edge_props() &;
  ::std::vector< ::nebula::storage::cpp2::EdgeProp>* get_edge_props() && = delete;

  template <typename T_TraverseSpec_edge_props_struct_setter = ::std::vector< ::nebula::storage::cpp2::EdgeProp>>
  ::std::vector< ::nebula::storage::cpp2::EdgeProp>& set_edge_props(T_TraverseSpec_edge_props_struct_setter&& edge_props_) {
    edge_props = std::forward<T_TraverseSpec_edge_props_struct_setter>(edge_props_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.edge_props = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return edge_props;
  }
  const ::std::vector< ::nebula::storage::cpp2::Expr>* get_expressions() const&;
  ::std::vector< ::nebula::storage::cpp2::Expr>* get_expressions() &;
  ::std::vector< ::nebula::storage::cpp2::Expr>* get_expressions() && = delete;

  template <typename T_TraverseSpec_expressions_struct_setter = ::std::vector< ::nebula::storage::cpp2::Expr>>
  ::std::vector< ::nebula::storage::cpp2::Expr>& set_expressions(T_TraverseSpec_expressions_struct_setter&& expressions_) {
    expressions = std::forward<T_TraverseSpec_expressions_struct_setter>(expressions_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.expressions = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return expressions;
  }
  const ::std::vector< ::nebula::storage::cpp2::OrderBy>* get_order_by() const&;
  ::std::vector< ::nebula::storage::cpp2::OrderBy>* get_order_by() &;
  ::std::vector< ::nebula::storage::cpp2::OrderBy>* get_order_by() && = delete;

  template <typename T_TraverseSpec_order_by_struct_setter = ::std::vector< ::nebula::storage::cpp2::OrderBy>>
  ::std::vector< ::nebula::storage::cpp2::OrderBy>& set_order_by(T_TraverseSpec_order_by_struct_setter&& order_by_) {
    order_by = std::forward<T_TraverseSpec_order_by_struct_setter>(order_by_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.order_by = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return order_by;
  }

  const bool* get_random() const& {
    return random_ref() ? std::addressof(random) : nullptr;
  }

  bool* get_random() & {
    return random_ref() ? std::addressof(random) : nullptr;
  }
  bool* get_random() && = delete;

  bool& set_random(bool random_) {
    random = random_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.random = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return random;
  }

  const int64_t* get_limit() const& {
    return limit_ref() ? std::addressof(limit) : nullptr;
  }

  int64_t* get_limit() & {
    return limit_ref() ? std::addressof(limit) : nullptr;
  }
  int64_t* get_limit() && = delete;

  int64_t& set_limit(int64_t limit_) {
    limit = limit_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.limit = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return limit;
  }

  const ::std::string* get_filter() const& {
    return filter_ref() ? std::addressof(filter) : nullptr;
  }

  ::std::string* get_filter() & {
    return filter_ref() ? std::addressof(filter) : nullptr;
  }
  ::std::string* get_filter() && = delete;

  template <typename T_TraverseSpec_filter_struct_setter = ::std::string>
  ::std::string& set_filter(T_TraverseSpec_filter_struct_setter&& filter_) {
    filter = std::forward<T_TraverseSpec_filter_struct_setter>(filter_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.filter = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return filter;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< TraverseSpec >;
  friend void swap(TraverseSpec& a, TraverseSpec& b);
};

template <class Protocol_>
uint32_t TraverseSpec::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class GetNeighborsRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetNeighborsRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  GetNeighborsRequest();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetNeighborsRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::vector<::std::string> column_names__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>> parts__arg,  ::nebula::storage::cpp2::TraverseSpec traverse_spec__arg,  ::nebula::storage::cpp2::RequestCommon common__arg);

  GetNeighborsRequest(GetNeighborsRequest&&) = default;

  GetNeighborsRequest(const GetNeighborsRequest&) = default;


  GetNeighborsRequest& operator=(GetNeighborsRequest&&) = default;

  GetNeighborsRequest& operator=(const GetNeighborsRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~GetNeighborsRequest();

 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::vector<::std::string> column_names;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>> parts;
 private:
   ::nebula::storage::cpp2::TraverseSpec traverse_spec;
 private:
   ::nebula::storage::cpp2::RequestCommon common;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool column_names;
    bool parts;
    bool traverse_spec;
    bool common;
  } __isset = {};
  bool operator==(const GetNeighborsRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetNeighborsRequest& __x, const GetNeighborsRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetNeighborsRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetNeighborsRequest& __x, const GetNeighborsRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetNeighborsRequest& __x, const GetNeighborsRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetNeighborsRequest& __x, const GetNeighborsRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> column_names_ref() const& {
    return {this->column_names, __isset.column_names};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> column_names_ref() const&& {
    return {std::move(this->column_names), __isset.column_names};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> column_names_ref() & {
    return {this->column_names, __isset.column_names};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> column_names_ref() && {
    return {std::move(this->column_names), __isset.column_names};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> parts_ref() const& {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> parts_ref() const&& {
    return {std::move(this->parts), __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> parts_ref() & {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> parts_ref() && {
    return {std::move(this->parts), __isset.parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::TraverseSpec>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> traverse_spec_ref() const& {
    return {this->traverse_spec, __isset.traverse_spec};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::TraverseSpec>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> traverse_spec_ref() const&& {
    return {std::move(this->traverse_spec), __isset.traverse_spec};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::TraverseSpec>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> traverse_spec_ref() & {
    return {this->traverse_spec, __isset.traverse_spec};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::TraverseSpec>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> traverse_spec_ref() && {
    return {std::move(this->traverse_spec), __isset.traverse_spec};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> common_ref() const& {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> common_ref() const&& {
    return {std::move(this->common), __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> common_ref() & {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> common_ref() && {
    return {std::move(this->common), __isset.common};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const ::std::vector<::std::string>& get_column_names() const&;
  ::std::vector<::std::string> get_column_names() &&;

  template <typename T_GetNeighborsRequest_column_names_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_column_names(T_GetNeighborsRequest_column_names_struct_setter&& column_names_) {
    column_names = std::forward<T_GetNeighborsRequest_column_names_struct_setter>(column_names_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.column_names = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return column_names;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>& get_parts() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>> get_parts() &&;

  template <typename T_GetNeighborsRequest_parts_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>& set_parts(T_GetNeighborsRequest_parts_struct_setter&& parts_) {
    parts = std::forward<T_GetNeighborsRequest_parts_struct_setter>(parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return parts;
  }
  const  ::nebula::storage::cpp2::TraverseSpec& get_traverse_spec() const&;
   ::nebula::storage::cpp2::TraverseSpec get_traverse_spec() &&;

  template <typename T_GetNeighborsRequest_traverse_spec_struct_setter =  ::nebula::storage::cpp2::TraverseSpec>
   ::nebula::storage::cpp2::TraverseSpec& set_traverse_spec(T_GetNeighborsRequest_traverse_spec_struct_setter&& traverse_spec_) {
    traverse_spec = std::forward<T_GetNeighborsRequest_traverse_spec_struct_setter>(traverse_spec_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.traverse_spec = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return traverse_spec;
  }
  const  ::nebula::storage::cpp2::RequestCommon* get_common() const&;
   ::nebula::storage::cpp2::RequestCommon* get_common() &;
   ::nebula::storage::cpp2::RequestCommon* get_common() && = delete;

  template <typename T_GetNeighborsRequest_common_struct_setter =  ::nebula::storage::cpp2::RequestCommon>
   ::nebula::storage::cpp2::RequestCommon& set_common(T_GetNeighborsRequest_common_struct_setter&& common_) {
    common = std::forward<T_GetNeighborsRequest_common_struct_setter>(common_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.common = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return common;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetNeighborsRequest >;
  friend void swap(GetNeighborsRequest& a, GetNeighborsRequest& b);
};

template <class Protocol_>
uint32_t GetNeighborsRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class GetNeighborsResponse final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetNeighborsResponse;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetNeighborsResponse() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetNeighborsResponse(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg, nebula::DataSet vertices__arg);

  GetNeighborsResponse(GetNeighborsResponse&&) = default;

  GetNeighborsResponse(const GetNeighborsResponse&) = default;


  GetNeighborsResponse& operator=(GetNeighborsResponse&&) = default;

  GetNeighborsResponse& operator=(const GetNeighborsResponse&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
   ::nebula::storage::cpp2::ResponseCommon result;
 private:
  nebula::DataSet vertices;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool vertices;
  } __isset = {};
  bool operator==(const GetNeighborsResponse& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetNeighborsResponse& __x, const GetNeighborsResponse& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetNeighborsResponse& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetNeighborsResponse& __x, const GetNeighborsResponse& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetNeighborsResponse& __x, const GetNeighborsResponse& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetNeighborsResponse& __x, const GetNeighborsResponse& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> result_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> result_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->result)};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> result_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> result_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->result)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> vertices_ref() const& {
    return {this->vertices, __isset.vertices};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> vertices_ref() const&& {
    return {std::move(this->vertices), __isset.vertices};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> vertices_ref() & {
    return {this->vertices, __isset.vertices};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> vertices_ref() && {
    return {std::move(this->vertices), __isset.vertices};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::storage::cpp2::ResponseCommon& get_result() const&;
   ::nebula::storage::cpp2::ResponseCommon get_result() &&;

  template <typename T_GetNeighborsResponse_result_struct_setter =  ::nebula::storage::cpp2::ResponseCommon>
   ::nebula::storage::cpp2::ResponseCommon& set_result(T_GetNeighborsResponse_result_struct_setter&& result_) {
    result = std::forward<T_GetNeighborsResponse_result_struct_setter>(result_);
    return result;
  }
  const nebula::DataSet* get_vertices() const&;
  nebula::DataSet* get_vertices() &;
  nebula::DataSet* get_vertices() && = delete;

  template <typename T_GetNeighborsResponse_vertices_struct_setter = nebula::DataSet>
  nebula::DataSet& set_vertices(T_GetNeighborsResponse_vertices_struct_setter&& vertices_) {
    vertices = std::forward<T_GetNeighborsResponse_vertices_struct_setter>(vertices_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.vertices = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return vertices;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetNeighborsResponse >;
  friend void swap(GetNeighborsResponse& a, GetNeighborsResponse& b);
};

template <class Protocol_>
uint32_t GetNeighborsResponse::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class ExecResponse final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ExecResponse;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ExecResponse() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ExecResponse(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg);

  ExecResponse(ExecResponse&&) = default;

  ExecResponse(const ExecResponse&) = default;


  ExecResponse& operator=(ExecResponse&&) = default;

  ExecResponse& operator=(const ExecResponse&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
   ::nebula::storage::cpp2::ResponseCommon result;

 public:
  bool operator==(const ExecResponse& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ExecResponse& __x, const ExecResponse& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ExecResponse& rhs) const;
#ifndef SWIG
  friend bool operator>(const ExecResponse& __x, const ExecResponse& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ExecResponse& __x, const ExecResponse& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ExecResponse& __x, const ExecResponse& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> result_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> result_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->result)};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> result_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> result_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->result)};
  }
  const  ::nebula::storage::cpp2::ResponseCommon& get_result() const&;
   ::nebula::storage::cpp2::ResponseCommon get_result() &&;

  template <typename T_ExecResponse_result_struct_setter =  ::nebula::storage::cpp2::ResponseCommon>
   ::nebula::storage::cpp2::ResponseCommon& set_result(T_ExecResponse_result_struct_setter&& result_) {
    result = std::forward<T_ExecResponse_result_struct_setter>(result_);
    return result;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ExecResponse >;
  friend void swap(ExecResponse& a, ExecResponse& b);
};

template <class Protocol_>
uint32_t ExecResponse::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class GetPropRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetPropRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  GetPropRequest();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetPropRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>> parts__arg, ::std::vector< ::nebula::storage::cpp2::VertexProp> vertex_props__arg, ::std::vector< ::nebula::storage::cpp2::EdgeProp> edge_props__arg, ::std::vector< ::nebula::storage::cpp2::Expr> expressions__arg, bool dedup__arg, ::std::vector< ::nebula::storage::cpp2::OrderBy> order_by__arg, int64_t limit__arg, ::std::string filter__arg,  ::nebula::storage::cpp2::RequestCommon common__arg);

  GetPropRequest(GetPropRequest&&) = default;

  GetPropRequest(const GetPropRequest&) = default;


  GetPropRequest& operator=(GetPropRequest&&) = default;

  GetPropRequest& operator=(const GetPropRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~GetPropRequest();

 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>> parts;
 private:
  ::std::vector< ::nebula::storage::cpp2::VertexProp> vertex_props;
 private:
  ::std::vector< ::nebula::storage::cpp2::EdgeProp> edge_props;
 private:
  ::std::vector< ::nebula::storage::cpp2::Expr> expressions;
 private:
  bool dedup;
 private:
  ::std::vector< ::nebula::storage::cpp2::OrderBy> order_by;
 private:
  int64_t limit;
 private:
  ::std::string filter;
 private:
   ::nebula::storage::cpp2::RequestCommon common;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool parts;
    bool vertex_props;
    bool edge_props;
    bool expressions;
    bool dedup;
    bool order_by;
    bool limit;
    bool filter;
    bool common;
  } __isset = {};
  bool operator==(const GetPropRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetPropRequest& __x, const GetPropRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetPropRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetPropRequest& __x, const GetPropRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetPropRequest& __x, const GetPropRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetPropRequest& __x, const GetPropRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> parts_ref() const& {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> parts_ref() const&& {
    return {std::move(this->parts), __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> parts_ref() & {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> parts_ref() && {
    return {std::move(this->parts), __isset.parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::VertexProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> vertex_props_ref() const& {
    return {this->vertex_props, __isset.vertex_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::VertexProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> vertex_props_ref() const&& {
    return {std::move(this->vertex_props), __isset.vertex_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::VertexProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> vertex_props_ref() & {
    return {this->vertex_props, __isset.vertex_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::VertexProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> vertex_props_ref() && {
    return {std::move(this->vertex_props), __isset.vertex_props};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::EdgeProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> edge_props_ref() const& {
    return {this->edge_props, __isset.edge_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::EdgeProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> edge_props_ref() const&& {
    return {std::move(this->edge_props), __isset.edge_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::EdgeProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> edge_props_ref() & {
    return {this->edge_props, __isset.edge_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::EdgeProp>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> edge_props_ref() && {
    return {std::move(this->edge_props), __isset.edge_props};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::Expr>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> expressions_ref() const& {
    return {this->expressions, __isset.expressions};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::Expr>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> expressions_ref() const&& {
    return {std::move(this->expressions), __isset.expressions};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::Expr>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> expressions_ref() & {
    return {this->expressions, __isset.expressions};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::Expr>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> expressions_ref() && {
    return {std::move(this->expressions), __isset.expressions};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> dedup_ref() const& {
    return {this->dedup, __isset.dedup};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> dedup_ref() const&& {
    return {std::move(this->dedup), __isset.dedup};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> dedup_ref() & {
    return {this->dedup, __isset.dedup};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> dedup_ref() && {
    return {std::move(this->dedup), __isset.dedup};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::OrderBy>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> order_by_ref() const& {
    return {this->order_by, __isset.order_by};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::OrderBy>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> order_by_ref() const&& {
    return {std::move(this->order_by), __isset.order_by};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::OrderBy>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> order_by_ref() & {
    return {this->order_by, __isset.order_by};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::OrderBy>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> order_by_ref() && {
    return {std::move(this->order_by), __isset.order_by};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> limit_ref() const& {
    return {this->limit, __isset.limit};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> limit_ref() const&& {
    return {std::move(this->limit), __isset.limit};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> limit_ref() & {
    return {this->limit, __isset.limit};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> limit_ref() && {
    return {std::move(this->limit), __isset.limit};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> filter_ref() const& {
    return {this->filter, __isset.filter};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> filter_ref() const&& {
    return {std::move(this->filter), __isset.filter};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> filter_ref() & {
    return {this->filter, __isset.filter};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> filter_ref() && {
    return {std::move(this->filter), __isset.filter};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> common_ref() const& {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> common_ref() const&& {
    return {std::move(this->common), __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> common_ref() & {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> common_ref() && {
    return {std::move(this->common), __isset.common};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>& get_parts() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>> get_parts() &&;

  template <typename T_GetPropRequest_parts_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>>
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Row>>& set_parts(T_GetPropRequest_parts_struct_setter&& parts_) {
    parts = std::forward<T_GetPropRequest_parts_struct_setter>(parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return parts;
  }
  const ::std::vector< ::nebula::storage::cpp2::VertexProp>* get_vertex_props() const&;
  ::std::vector< ::nebula::storage::cpp2::VertexProp>* get_vertex_props() &;
  ::std::vector< ::nebula::storage::cpp2::VertexProp>* get_vertex_props() && = delete;

  template <typename T_GetPropRequest_vertex_props_struct_setter = ::std::vector< ::nebula::storage::cpp2::VertexProp>>
  ::std::vector< ::nebula::storage::cpp2::VertexProp>& set_vertex_props(T_GetPropRequest_vertex_props_struct_setter&& vertex_props_) {
    vertex_props = std::forward<T_GetPropRequest_vertex_props_struct_setter>(vertex_props_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.vertex_props = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return vertex_props;
  }
  const ::std::vector< ::nebula::storage::cpp2::EdgeProp>* get_edge_props() const&;
  ::std::vector< ::nebula::storage::cpp2::EdgeProp>* get_edge_props() &;
  ::std::vector< ::nebula::storage::cpp2::EdgeProp>* get_edge_props() && = delete;

  template <typename T_GetPropRequest_edge_props_struct_setter = ::std::vector< ::nebula::storage::cpp2::EdgeProp>>
  ::std::vector< ::nebula::storage::cpp2::EdgeProp>& set_edge_props(T_GetPropRequest_edge_props_struct_setter&& edge_props_) {
    edge_props = std::forward<T_GetPropRequest_edge_props_struct_setter>(edge_props_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.edge_props = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return edge_props;
  }
  const ::std::vector< ::nebula::storage::cpp2::Expr>* get_expressions() const&;
  ::std::vector< ::nebula::storage::cpp2::Expr>* get_expressions() &;
  ::std::vector< ::nebula::storage::cpp2::Expr>* get_expressions() && = delete;

  template <typename T_GetPropRequest_expressions_struct_setter = ::std::vector< ::nebula::storage::cpp2::Expr>>
  ::std::vector< ::nebula::storage::cpp2::Expr>& set_expressions(T_GetPropRequest_expressions_struct_setter&& expressions_) {
    expressions = std::forward<T_GetPropRequest_expressions_struct_setter>(expressions_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.expressions = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return expressions;
  }

  bool get_dedup() const {
    return dedup;
  }

  bool& set_dedup(bool dedup_) {
    dedup = dedup_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.dedup = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return dedup;
  }
  const ::std::vector< ::nebula::storage::cpp2::OrderBy>* get_order_by() const&;
  ::std::vector< ::nebula::storage::cpp2::OrderBy>* get_order_by() &;
  ::std::vector< ::nebula::storage::cpp2::OrderBy>* get_order_by() && = delete;

  template <typename T_GetPropRequest_order_by_struct_setter = ::std::vector< ::nebula::storage::cpp2::OrderBy>>
  ::std::vector< ::nebula::storage::cpp2::OrderBy>& set_order_by(T_GetPropRequest_order_by_struct_setter&& order_by_) {
    order_by = std::forward<T_GetPropRequest_order_by_struct_setter>(order_by_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.order_by = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return order_by;
  }

  const int64_t* get_limit() const& {
    return limit_ref() ? std::addressof(limit) : nullptr;
  }

  int64_t* get_limit() & {
    return limit_ref() ? std::addressof(limit) : nullptr;
  }
  int64_t* get_limit() && = delete;

  int64_t& set_limit(int64_t limit_) {
    limit = limit_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.limit = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return limit;
  }

  const ::std::string* get_filter() const& {
    return filter_ref() ? std::addressof(filter) : nullptr;
  }

  ::std::string* get_filter() & {
    return filter_ref() ? std::addressof(filter) : nullptr;
  }
  ::std::string* get_filter() && = delete;

  template <typename T_GetPropRequest_filter_struct_setter = ::std::string>
  ::std::string& set_filter(T_GetPropRequest_filter_struct_setter&& filter_) {
    filter = std::forward<T_GetPropRequest_filter_struct_setter>(filter_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.filter = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return filter;
  }
  const  ::nebula::storage::cpp2::RequestCommon* get_common() const&;
   ::nebula::storage::cpp2::RequestCommon* get_common() &;
   ::nebula::storage::cpp2::RequestCommon* get_common() && = delete;

  template <typename T_GetPropRequest_common_struct_setter =  ::nebula::storage::cpp2::RequestCommon>
   ::nebula::storage::cpp2::RequestCommon& set_common(T_GetPropRequest_common_struct_setter&& common_) {
    common = std::forward<T_GetPropRequest_common_struct_setter>(common_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.common = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return common;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetPropRequest >;
  friend void swap(GetPropRequest& a, GetPropRequest& b);
};

template <class Protocol_>
uint32_t GetPropRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class GetPropResponse final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetPropResponse;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetPropResponse() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetPropResponse(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg, nebula::DataSet props__arg);

  GetPropResponse(GetPropResponse&&) = default;

  GetPropResponse(const GetPropResponse&) = default;


  GetPropResponse& operator=(GetPropResponse&&) = default;

  GetPropResponse& operator=(const GetPropResponse&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::storage::cpp2::ResponseCommon result;
 private:
  nebula::DataSet props;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool result;
    bool props;
  } __isset = {};
  bool operator==(const GetPropResponse& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetPropResponse& __x, const GetPropResponse& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetPropResponse& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetPropResponse& __x, const GetPropResponse& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetPropResponse& __x, const GetPropResponse& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetPropResponse& __x, const GetPropResponse& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> result_ref() const& {
    return {this->result, __isset.result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> result_ref() const&& {
    return {std::move(this->result), __isset.result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> result_ref() & {
    return {this->result, __isset.result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> result_ref() && {
    return {std::move(this->result), __isset.result};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> props_ref() const& {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> props_ref() const&& {
    return {std::move(this->props), __isset.props};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> props_ref() & {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> props_ref() && {
    return {std::move(this->props), __isset.props};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::storage::cpp2::ResponseCommon& get_result() const&;
   ::nebula::storage::cpp2::ResponseCommon get_result() &&;

  template <typename T_GetPropResponse_result_struct_setter =  ::nebula::storage::cpp2::ResponseCommon>
   ::nebula::storage::cpp2::ResponseCommon& set_result(T_GetPropResponse_result_struct_setter&& result_) {
    result = std::forward<T_GetPropResponse_result_struct_setter>(result_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.result = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return result;
  }
  const nebula::DataSet* get_props() const&;
  nebula::DataSet* get_props() &;
  nebula::DataSet* get_props() && = delete;

  template <typename T_GetPropResponse_props_struct_setter = nebula::DataSet>
  nebula::DataSet& set_props(T_GetPropResponse_props_struct_setter&& props_) {
    props = std::forward<T_GetPropResponse_props_struct_setter>(props_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.props = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return props;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetPropResponse >;
  friend void swap(GetPropResponse& a, GetPropResponse& b);
};

template <class Protocol_>
uint32_t GetPropResponse::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class NewTag final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = NewTag;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  NewTag() :
      tag_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  NewTag(apache::thrift::FragileConstructor,  ::nebula::cpp2::TagID tag_id__arg, ::std::vector<nebula::Value> props__arg);

  NewTag(NewTag&&) = default;

  NewTag(const NewTag&) = default;


  NewTag& operator=(NewTag&&) = default;

  NewTag& operator=(const NewTag&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::TagID tag_id;
 private:
  ::std::vector<nebula::Value> props;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool tag_id;
    bool props;
  } __isset = {};
  bool operator==(const NewTag& rhs) const;
#ifndef SWIG
  friend bool operator!=(const NewTag& __x, const NewTag& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const NewTag& rhs) const;
#ifndef SWIG
  friend bool operator>(const NewTag& __x, const NewTag& __y) {
    return __y < __x;
  }
  friend bool operator<=(const NewTag& __x, const NewTag& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const NewTag& __x, const NewTag& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> tag_id_ref() const& {
    return {this->tag_id, __isset.tag_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> tag_id_ref() const&& {
    return {std::move(this->tag_id), __isset.tag_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> tag_id_ref() & {
    return {this->tag_id, __isset.tag_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> tag_id_ref() && {
    return {std::move(this->tag_id), __isset.tag_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> props_ref() const& {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = ::std::vector<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> props_ref() const&& {
    return {std::move(this->props), __isset.props};
  }

  template <typename..., typename T = ::std::vector<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> props_ref() & {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = ::std::vector<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> props_ref() && {
    return {std::move(this->props), __isset.props};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::TagID get_tag_id() const {
    return tag_id;
  }

   ::nebula::cpp2::TagID& set_tag_id( ::nebula::cpp2::TagID tag_id_) {
    tag_id = tag_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.tag_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return tag_id;
  }
  const ::std::vector<nebula::Value>& get_props() const&;
  ::std::vector<nebula::Value> get_props() &&;

  template <typename T_NewTag_props_struct_setter = ::std::vector<nebula::Value>>
  ::std::vector<nebula::Value>& set_props(T_NewTag_props_struct_setter&& props_) {
    props = std::forward<T_NewTag_props_struct_setter>(props_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.props = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return props;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< NewTag >;
  friend void swap(NewTag& a, NewTag& b);
};

template <class Protocol_>
uint32_t NewTag::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class NewVertex final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = NewVertex;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  NewVertex() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  NewVertex(apache::thrift::FragileConstructor, nebula::Value id__arg, ::std::vector< ::nebula::storage::cpp2::NewTag> tags__arg);

  NewVertex(NewVertex&&) = default;

  NewVertex(const NewVertex&) = default;


  NewVertex& operator=(NewVertex&&) = default;

  NewVertex& operator=(const NewVertex&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  nebula::Value id;
 private:
  ::std::vector< ::nebula::storage::cpp2::NewTag> tags;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool id;
    bool tags;
  } __isset = {};
  bool operator==(const NewVertex& rhs) const;
#ifndef SWIG
  friend bool operator!=(const NewVertex& __x, const NewVertex& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const NewVertex& rhs) const;
#ifndef SWIG
  friend bool operator>(const NewVertex& __x, const NewVertex& __y) {
    return __y < __x;
  }
  friend bool operator<=(const NewVertex& __x, const NewVertex& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const NewVertex& __x, const NewVertex& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> id_ref() const& {
    return {this->id, __isset.id};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> id_ref() const&& {
    return {std::move(this->id), __isset.id};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> id_ref() & {
    return {this->id, __isset.id};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> id_ref() && {
    return {std::move(this->id), __isset.id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::NewTag>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> tags_ref() const& {
    return {this->tags, __isset.tags};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::NewTag>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> tags_ref() const&& {
    return {std::move(this->tags), __isset.tags};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::NewTag>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> tags_ref() & {
    return {this->tags, __isset.tags};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::NewTag>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> tags_ref() && {
    return {std::move(this->tags), __isset.tags};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const nebula::Value& get_id() const&;
  nebula::Value get_id() &&;

  template <typename T_NewVertex_id_struct_setter = nebula::Value>
  nebula::Value& set_id(T_NewVertex_id_struct_setter&& id_) {
    id = std::forward<T_NewVertex_id_struct_setter>(id_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return id;
  }
  const ::std::vector< ::nebula::storage::cpp2::NewTag>& get_tags() const&;
  ::std::vector< ::nebula::storage::cpp2::NewTag> get_tags() &&;

  template <typename T_NewVertex_tags_struct_setter = ::std::vector< ::nebula::storage::cpp2::NewTag>>
  ::std::vector< ::nebula::storage::cpp2::NewTag>& set_tags(T_NewVertex_tags_struct_setter&& tags_) {
    tags = std::forward<T_NewVertex_tags_struct_setter>(tags_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.tags = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return tags;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< NewVertex >;
  friend void swap(NewVertex& a, NewVertex& b);
};

template <class Protocol_>
uint32_t NewVertex::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class EdgeKey final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = EdgeKey;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  EdgeKey() :
      edge_type(0),
      ranking(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  EdgeKey(apache::thrift::FragileConstructor, nebula::Value src__arg,  ::nebula::cpp2::EdgeType edge_type__arg,  ::nebula::cpp2::EdgeRanking ranking__arg, nebula::Value dst__arg);

  EdgeKey(EdgeKey&&) = default;

  EdgeKey(const EdgeKey&) = default;


  EdgeKey& operator=(EdgeKey&&) = default;

  EdgeKey& operator=(const EdgeKey&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  nebula::Value src;
 private:
   ::nebula::cpp2::EdgeType edge_type;
 private:
   ::nebula::cpp2::EdgeRanking ranking;
 private:
  nebula::Value dst;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool src;
    bool edge_type;
    bool ranking;
    bool dst;
  } __isset = {};
  bool operator==(const EdgeKey& rhs) const;
#ifndef SWIG
  friend bool operator!=(const EdgeKey& __x, const EdgeKey& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const EdgeKey& rhs) const;
#ifndef SWIG
  friend bool operator>(const EdgeKey& __x, const EdgeKey& __y) {
    return __y < __x;
  }
  friend bool operator<=(const EdgeKey& __x, const EdgeKey& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const EdgeKey& __x, const EdgeKey& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> src_ref() const& {
    return {this->src, __isset.src};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> src_ref() const&& {
    return {std::move(this->src), __isset.src};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> src_ref() & {
    return {this->src, __isset.src};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> src_ref() && {
    return {std::move(this->src), __isset.src};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> edge_type_ref() const& {
    return {this->edge_type, __isset.edge_type};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> edge_type_ref() const&& {
    return {std::move(this->edge_type), __isset.edge_type};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> edge_type_ref() & {
    return {this->edge_type, __isset.edge_type};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> edge_type_ref() && {
    return {std::move(this->edge_type), __isset.edge_type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::EdgeRanking>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> ranking_ref() const& {
    return {this->ranking, __isset.ranking};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeRanking>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> ranking_ref() const&& {
    return {std::move(this->ranking), __isset.ranking};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeRanking>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> ranking_ref() & {
    return {this->ranking, __isset.ranking};
  }

  template <typename..., typename T =  ::nebula::cpp2::EdgeRanking>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> ranking_ref() && {
    return {std::move(this->ranking), __isset.ranking};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> dst_ref() const& {
    return {this->dst, __isset.dst};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> dst_ref() const&& {
    return {std::move(this->dst), __isset.dst};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> dst_ref() & {
    return {this->dst, __isset.dst};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> dst_ref() && {
    return {std::move(this->dst), __isset.dst};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const nebula::Value& get_src() const&;
  nebula::Value get_src() &&;

  template <typename T_EdgeKey_src_struct_setter = nebula::Value>
  nebula::Value& set_src(T_EdgeKey_src_struct_setter&& src_) {
    src = std::forward<T_EdgeKey_src_struct_setter>(src_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.src = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return src;
  }

   ::nebula::cpp2::EdgeType get_edge_type() const {
    return edge_type;
  }

   ::nebula::cpp2::EdgeType& set_edge_type( ::nebula::cpp2::EdgeType edge_type_) {
    edge_type = edge_type_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.edge_type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return edge_type;
  }

   ::nebula::cpp2::EdgeRanking get_ranking() const {
    return ranking;
  }

   ::nebula::cpp2::EdgeRanking& set_ranking( ::nebula::cpp2::EdgeRanking ranking_) {
    ranking = ranking_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.ranking = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return ranking;
  }
  const nebula::Value& get_dst() const&;
  nebula::Value get_dst() &&;

  template <typename T_EdgeKey_dst_struct_setter = nebula::Value>
  nebula::Value& set_dst(T_EdgeKey_dst_struct_setter&& dst_) {
    dst = std::forward<T_EdgeKey_dst_struct_setter>(dst_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.dst = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return dst;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< EdgeKey >;
  friend void swap(EdgeKey& a, EdgeKey& b);
};

template <class Protocol_>
uint32_t EdgeKey::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class NewEdge final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = NewEdge;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  NewEdge() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  NewEdge(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::EdgeKey key__arg, ::std::vector<nebula::Value> props__arg);

  NewEdge(NewEdge&&) = default;

  NewEdge(const NewEdge&) = default;


  NewEdge& operator=(NewEdge&&) = default;

  NewEdge& operator=(const NewEdge&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::storage::cpp2::EdgeKey key;
 private:
  ::std::vector<nebula::Value> props;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool key;
    bool props;
  } __isset = {};
  bool operator==(const NewEdge& rhs) const;
#ifndef SWIG
  friend bool operator!=(const NewEdge& __x, const NewEdge& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const NewEdge& rhs) const;
#ifndef SWIG
  friend bool operator>(const NewEdge& __x, const NewEdge& __y) {
    return __y < __x;
  }
  friend bool operator<=(const NewEdge& __x, const NewEdge& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const NewEdge& __x, const NewEdge& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::EdgeKey>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> key_ref() const& {
    return {this->key, __isset.key};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::EdgeKey>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> key_ref() const&& {
    return {std::move(this->key), __isset.key};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::EdgeKey>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> key_ref() & {
    return {this->key, __isset.key};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::EdgeKey>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> key_ref() && {
    return {std::move(this->key), __isset.key};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> props_ref() const& {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = ::std::vector<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> props_ref() const&& {
    return {std::move(this->props), __isset.props};
  }

  template <typename..., typename T = ::std::vector<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> props_ref() & {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = ::std::vector<nebula::Value>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> props_ref() && {
    return {std::move(this->props), __isset.props};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::storage::cpp2::EdgeKey& get_key() const&;
   ::nebula::storage::cpp2::EdgeKey get_key() &&;

  template <typename T_NewEdge_key_struct_setter =  ::nebula::storage::cpp2::EdgeKey>
   ::nebula::storage::cpp2::EdgeKey& set_key(T_NewEdge_key_struct_setter&& key_) {
    key = std::forward<T_NewEdge_key_struct_setter>(key_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.key = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return key;
  }
  const ::std::vector<nebula::Value>& get_props() const&;
  ::std::vector<nebula::Value> get_props() &&;

  template <typename T_NewEdge_props_struct_setter = ::std::vector<nebula::Value>>
  ::std::vector<nebula::Value>& set_props(T_NewEdge_props_struct_setter&& props_) {
    props = std::forward<T_NewEdge_props_struct_setter>(props_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.props = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return props;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< NewEdge >;
  friend void swap(NewEdge& a, NewEdge& b);
};

template <class Protocol_>
uint32_t NewEdge::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class AddVerticesRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AddVerticesRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  AddVerticesRequest();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AddVerticesRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>> parts__arg, std::unordered_map< ::nebula::cpp2::TagID, ::std::vector<::std::string>> prop_names__arg, bool if_not_exists__arg, bool ignore_existed_index__arg,  ::nebula::storage::cpp2::RequestCommon common__arg);

  AddVerticesRequest(AddVerticesRequest&&) = default;

  AddVerticesRequest(const AddVerticesRequest&) = default;


  AddVerticesRequest& operator=(AddVerticesRequest&&) = default;

  AddVerticesRequest& operator=(const AddVerticesRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~AddVerticesRequest();

 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>> parts;
 private:
  std::unordered_map< ::nebula::cpp2::TagID, ::std::vector<::std::string>> prop_names;
 private:
  bool if_not_exists;
 private:
  bool ignore_existed_index;
 private:
   ::nebula::storage::cpp2::RequestCommon common;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool parts;
    bool prop_names;
    bool if_not_exists;
    bool ignore_existed_index;
    bool common;
  } __isset = {};
  bool operator==(const AddVerticesRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AddVerticesRequest& __x, const AddVerticesRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AddVerticesRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const AddVerticesRequest& __x, const AddVerticesRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AddVerticesRequest& __x, const AddVerticesRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AddVerticesRequest& __x, const AddVerticesRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> parts_ref() const& {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> parts_ref() const&& {
    return {std::move(this->parts), __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> parts_ref() & {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> parts_ref() && {
    return {std::move(this->parts), __isset.parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::TagID, ::std::vector<::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> prop_names_ref() const& {
    return {this->prop_names, __isset.prop_names};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::TagID, ::std::vector<::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> prop_names_ref() const&& {
    return {std::move(this->prop_names), __isset.prop_names};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::TagID, ::std::vector<::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> prop_names_ref() & {
    return {this->prop_names, __isset.prop_names};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::TagID, ::std::vector<::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> prop_names_ref() && {
    return {std::move(this->prop_names), __isset.prop_names};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> if_not_exists_ref() const& {
    return {this->if_not_exists, __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> if_not_exists_ref() const&& {
    return {std::move(this->if_not_exists), __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> if_not_exists_ref() & {
    return {this->if_not_exists, __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> if_not_exists_ref() && {
    return {std::move(this->if_not_exists), __isset.if_not_exists};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> ignore_existed_index_ref() const& {
    return {this->ignore_existed_index, __isset.ignore_existed_index};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> ignore_existed_index_ref() const&& {
    return {std::move(this->ignore_existed_index), __isset.ignore_existed_index};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> ignore_existed_index_ref() & {
    return {this->ignore_existed_index, __isset.ignore_existed_index};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> ignore_existed_index_ref() && {
    return {std::move(this->ignore_existed_index), __isset.ignore_existed_index};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> common_ref() const& {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> common_ref() const&& {
    return {std::move(this->common), __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> common_ref() & {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> common_ref() && {
    return {std::move(this->common), __isset.common};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>>& get_parts() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>> get_parts() &&;

  template <typename T_AddVerticesRequest_parts_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>>>
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewVertex>>& set_parts(T_AddVerticesRequest_parts_struct_setter&& parts_) {
    parts = std::forward<T_AddVerticesRequest_parts_struct_setter>(parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return parts;
  }
  const std::unordered_map< ::nebula::cpp2::TagID, ::std::vector<::std::string>>& get_prop_names() const&;
  std::unordered_map< ::nebula::cpp2::TagID, ::std::vector<::std::string>> get_prop_names() &&;

  template <typename T_AddVerticesRequest_prop_names_struct_setter = std::unordered_map< ::nebula::cpp2::TagID, ::std::vector<::std::string>>>
  std::unordered_map< ::nebula::cpp2::TagID, ::std::vector<::std::string>>& set_prop_names(T_AddVerticesRequest_prop_names_struct_setter&& prop_names_) {
    prop_names = std::forward<T_AddVerticesRequest_prop_names_struct_setter>(prop_names_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.prop_names = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return prop_names;
  }

  bool get_if_not_exists() const {
    return if_not_exists;
  }

  bool& set_if_not_exists(bool if_not_exists_) {
    if_not_exists = if_not_exists_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.if_not_exists = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return if_not_exists;
  }

  bool get_ignore_existed_index() const {
    return ignore_existed_index;
  }

  bool& set_ignore_existed_index(bool ignore_existed_index_) {
    ignore_existed_index = ignore_existed_index_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.ignore_existed_index = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return ignore_existed_index;
  }
  const  ::nebula::storage::cpp2::RequestCommon* get_common() const&;
   ::nebula::storage::cpp2::RequestCommon* get_common() &;
   ::nebula::storage::cpp2::RequestCommon* get_common() && = delete;

  template <typename T_AddVerticesRequest_common_struct_setter =  ::nebula::storage::cpp2::RequestCommon>
   ::nebula::storage::cpp2::RequestCommon& set_common(T_AddVerticesRequest_common_struct_setter&& common_) {
    common = std::forward<T_AddVerticesRequest_common_struct_setter>(common_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.common = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return common;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AddVerticesRequest >;
  friend void swap(AddVerticesRequest& a, AddVerticesRequest& b);
};

template <class Protocol_>
uint32_t AddVerticesRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class AddEdgesRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AddEdgesRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  AddEdgesRequest();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AddEdgesRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>> parts__arg, ::std::vector<::std::string> prop_names__arg, bool if_not_exists__arg, bool ignore_existed_index__arg,  ::nebula::storage::cpp2::RequestCommon common__arg);

  AddEdgesRequest(AddEdgesRequest&&) = default;

  AddEdgesRequest(const AddEdgesRequest&) = default;


  AddEdgesRequest& operator=(AddEdgesRequest&&) = default;

  AddEdgesRequest& operator=(const AddEdgesRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~AddEdgesRequest();

 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>> parts;
 private:
  ::std::vector<::std::string> prop_names;
 private:
  bool if_not_exists;
 private:
  bool ignore_existed_index;
 private:
   ::nebula::storage::cpp2::RequestCommon common;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool parts;
    bool prop_names;
    bool if_not_exists;
    bool ignore_existed_index;
    bool common;
  } __isset = {};
  bool operator==(const AddEdgesRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AddEdgesRequest& __x, const AddEdgesRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AddEdgesRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const AddEdgesRequest& __x, const AddEdgesRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AddEdgesRequest& __x, const AddEdgesRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AddEdgesRequest& __x, const AddEdgesRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> parts_ref() const& {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> parts_ref() const&& {
    return {std::move(this->parts), __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> parts_ref() & {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> parts_ref() && {
    return {std::move(this->parts), __isset.parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> prop_names_ref() const& {
    return {this->prop_names, __isset.prop_names};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> prop_names_ref() const&& {
    return {std::move(this->prop_names), __isset.prop_names};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> prop_names_ref() & {
    return {this->prop_names, __isset.prop_names};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> prop_names_ref() && {
    return {std::move(this->prop_names), __isset.prop_names};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> if_not_exists_ref() const& {
    return {this->if_not_exists, __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> if_not_exists_ref() const&& {
    return {std::move(this->if_not_exists), __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> if_not_exists_ref() & {
    return {this->if_not_exists, __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> if_not_exists_ref() && {
    return {std::move(this->if_not_exists), __isset.if_not_exists};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> ignore_existed_index_ref() const& {
    return {this->ignore_existed_index, __isset.ignore_existed_index};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> ignore_existed_index_ref() const&& {
    return {std::move(this->ignore_existed_index), __isset.ignore_existed_index};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> ignore_existed_index_ref() & {
    return {this->ignore_existed_index, __isset.ignore_existed_index};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> ignore_existed_index_ref() && {
    return {std::move(this->ignore_existed_index), __isset.ignore_existed_index};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> common_ref() const& {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> common_ref() const&& {
    return {std::move(this->common), __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> common_ref() & {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> common_ref() && {
    return {std::move(this->common), __isset.common};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>& get_parts() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>> get_parts() &&;

  template <typename T_AddEdgesRequest_parts_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>& set_parts(T_AddEdgesRequest_parts_struct_setter&& parts_) {
    parts = std::forward<T_AddEdgesRequest_parts_struct_setter>(parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return parts;
  }
  const ::std::vector<::std::string>& get_prop_names() const&;
  ::std::vector<::std::string> get_prop_names() &&;

  template <typename T_AddEdgesRequest_prop_names_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_prop_names(T_AddEdgesRequest_prop_names_struct_setter&& prop_names_) {
    prop_names = std::forward<T_AddEdgesRequest_prop_names_struct_setter>(prop_names_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.prop_names = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return prop_names;
  }

  bool get_if_not_exists() const {
    return if_not_exists;
  }

  bool& set_if_not_exists(bool if_not_exists_) {
    if_not_exists = if_not_exists_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.if_not_exists = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return if_not_exists;
  }

  bool get_ignore_existed_index() const {
    return ignore_existed_index;
  }

  bool& set_ignore_existed_index(bool ignore_existed_index_) {
    ignore_existed_index = ignore_existed_index_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.ignore_existed_index = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return ignore_existed_index;
  }
  const  ::nebula::storage::cpp2::RequestCommon* get_common() const&;
   ::nebula::storage::cpp2::RequestCommon* get_common() &;
   ::nebula::storage::cpp2::RequestCommon* get_common() && = delete;

  template <typename T_AddEdgesRequest_common_struct_setter =  ::nebula::storage::cpp2::RequestCommon>
   ::nebula::storage::cpp2::RequestCommon& set_common(T_AddEdgesRequest_common_struct_setter&& common_) {
    common = std::forward<T_AddEdgesRequest_common_struct_setter>(common_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.common = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return common;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AddEdgesRequest >;
  friend void swap(AddEdgesRequest& a, AddEdgesRequest& b);
};

template <class Protocol_>
uint32_t AddEdgesRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class DeleteVerticesRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = DeleteVerticesRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  DeleteVerticesRequest() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  DeleteVerticesRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>> parts__arg,  ::nebula::storage::cpp2::RequestCommon common__arg);

  DeleteVerticesRequest(DeleteVerticesRequest&&) = default;

  DeleteVerticesRequest(const DeleteVerticesRequest&) = default;


  DeleteVerticesRequest& operator=(DeleteVerticesRequest&&) = default;

  DeleteVerticesRequest& operator=(const DeleteVerticesRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>> parts;
 private:
   ::nebula::storage::cpp2::RequestCommon common;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool parts;
    bool common;
  } __isset = {};
  bool operator==(const DeleteVerticesRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const DeleteVerticesRequest& __x, const DeleteVerticesRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const DeleteVerticesRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const DeleteVerticesRequest& __x, const DeleteVerticesRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const DeleteVerticesRequest& __x, const DeleteVerticesRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const DeleteVerticesRequest& __x, const DeleteVerticesRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> parts_ref() const& {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> parts_ref() const&& {
    return {std::move(this->parts), __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> parts_ref() & {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> parts_ref() && {
    return {std::move(this->parts), __isset.parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> common_ref() const& {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> common_ref() const&& {
    return {std::move(this->common), __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> common_ref() & {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> common_ref() && {
    return {std::move(this->common), __isset.common};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>& get_parts() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>> get_parts() &&;

  template <typename T_DeleteVerticesRequest_parts_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>>
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::Value>>& set_parts(T_DeleteVerticesRequest_parts_struct_setter&& parts_) {
    parts = std::forward<T_DeleteVerticesRequest_parts_struct_setter>(parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return parts;
  }
  const  ::nebula::storage::cpp2::RequestCommon* get_common() const&;
   ::nebula::storage::cpp2::RequestCommon* get_common() &;
   ::nebula::storage::cpp2::RequestCommon* get_common() && = delete;

  template <typename T_DeleteVerticesRequest_common_struct_setter =  ::nebula::storage::cpp2::RequestCommon>
   ::nebula::storage::cpp2::RequestCommon& set_common(T_DeleteVerticesRequest_common_struct_setter&& common_) {
    common = std::forward<T_DeleteVerticesRequest_common_struct_setter>(common_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.common = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return common;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< DeleteVerticesRequest >;
  friend void swap(DeleteVerticesRequest& a, DeleteVerticesRequest& b);
};

template <class Protocol_>
uint32_t DeleteVerticesRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class DeleteEdgesRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = DeleteEdgesRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  DeleteEdgesRequest() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  DeleteEdgesRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>> parts__arg,  ::nebula::storage::cpp2::RequestCommon common__arg);

  DeleteEdgesRequest(DeleteEdgesRequest&&) = default;

  DeleteEdgesRequest(const DeleteEdgesRequest&) = default;


  DeleteEdgesRequest& operator=(DeleteEdgesRequest&&) = default;

  DeleteEdgesRequest& operator=(const DeleteEdgesRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>> parts;
 private:
   ::nebula::storage::cpp2::RequestCommon common;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool parts;
    bool common;
  } __isset = {};
  bool operator==(const DeleteEdgesRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const DeleteEdgesRequest& __x, const DeleteEdgesRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const DeleteEdgesRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const DeleteEdgesRequest& __x, const DeleteEdgesRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const DeleteEdgesRequest& __x, const DeleteEdgesRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const DeleteEdgesRequest& __x, const DeleteEdgesRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> parts_ref() const& {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> parts_ref() const&& {
    return {std::move(this->parts), __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> parts_ref() & {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> parts_ref() && {
    return {std::move(this->parts), __isset.parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> common_ref() const& {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> common_ref() const&& {
    return {std::move(this->common), __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> common_ref() & {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> common_ref() && {
    return {std::move(this->common), __isset.common};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>& get_parts() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>> get_parts() &&;

  template <typename T_DeleteEdgesRequest_parts_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>& set_parts(T_DeleteEdgesRequest_parts_struct_setter&& parts_) {
    parts = std::forward<T_DeleteEdgesRequest_parts_struct_setter>(parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return parts;
  }
  const  ::nebula::storage::cpp2::RequestCommon* get_common() const&;
   ::nebula::storage::cpp2::RequestCommon* get_common() &;
   ::nebula::storage::cpp2::RequestCommon* get_common() && = delete;

  template <typename T_DeleteEdgesRequest_common_struct_setter =  ::nebula::storage::cpp2::RequestCommon>
   ::nebula::storage::cpp2::RequestCommon& set_common(T_DeleteEdgesRequest_common_struct_setter&& common_) {
    common = std::forward<T_DeleteEdgesRequest_common_struct_setter>(common_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.common = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return common;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< DeleteEdgesRequest >;
  friend void swap(DeleteEdgesRequest& a, DeleteEdgesRequest& b);
};

template <class Protocol_>
uint32_t DeleteEdgesRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class DelTags final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = DelTags;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  DelTags() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  DelTags(apache::thrift::FragileConstructor, nebula::Value id__arg, ::std::vector< ::nebula::cpp2::TagID> tags__arg);

  DelTags(DelTags&&) = default;

  DelTags(const DelTags&) = default;


  DelTags& operator=(DelTags&&) = default;

  DelTags& operator=(const DelTags&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  nebula::Value id;
 private:
  ::std::vector< ::nebula::cpp2::TagID> tags;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool id;
    bool tags;
  } __isset = {};
  bool operator==(const DelTags& rhs) const;
#ifndef SWIG
  friend bool operator!=(const DelTags& __x, const DelTags& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const DelTags& rhs) const;
#ifndef SWIG
  friend bool operator>(const DelTags& __x, const DelTags& __y) {
    return __y < __x;
  }
  friend bool operator<=(const DelTags& __x, const DelTags& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const DelTags& __x, const DelTags& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> id_ref() const& {
    return {this->id, __isset.id};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> id_ref() const&& {
    return {std::move(this->id), __isset.id};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> id_ref() & {
    return {this->id, __isset.id};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> id_ref() && {
    return {std::move(this->id), __isset.id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::cpp2::TagID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> tags_ref() const& {
    return {this->tags, __isset.tags};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::TagID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> tags_ref() const&& {
    return {std::move(this->tags), __isset.tags};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::TagID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> tags_ref() & {
    return {this->tags, __isset.tags};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::TagID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> tags_ref() && {
    return {std::move(this->tags), __isset.tags};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const nebula::Value& get_id() const&;
  nebula::Value get_id() &&;

  template <typename T_DelTags_id_struct_setter = nebula::Value>
  nebula::Value& set_id(T_DelTags_id_struct_setter&& id_) {
    id = std::forward<T_DelTags_id_struct_setter>(id_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return id;
  }
  const ::std::vector< ::nebula::cpp2::TagID>& get_tags() const&;
  ::std::vector< ::nebula::cpp2::TagID> get_tags() &&;

  template <typename T_DelTags_tags_struct_setter = ::std::vector< ::nebula::cpp2::TagID>>
  ::std::vector< ::nebula::cpp2::TagID>& set_tags(T_DelTags_tags_struct_setter&& tags_) {
    tags = std::forward<T_DelTags_tags_struct_setter>(tags_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.tags = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return tags;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< DelTags >;
  friend void swap(DelTags& a, DelTags& b);
};

template <class Protocol_>
uint32_t DelTags::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class DeleteTagsRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = DeleteTagsRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  DeleteTagsRequest() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  DeleteTagsRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>> parts__arg,  ::nebula::storage::cpp2::RequestCommon common__arg);

  DeleteTagsRequest(DeleteTagsRequest&&) = default;

  DeleteTagsRequest(const DeleteTagsRequest&) = default;


  DeleteTagsRequest& operator=(DeleteTagsRequest&&) = default;

  DeleteTagsRequest& operator=(const DeleteTagsRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>> parts;
 private:
   ::nebula::storage::cpp2::RequestCommon common;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool parts;
    bool common;
  } __isset = {};
  bool operator==(const DeleteTagsRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const DeleteTagsRequest& __x, const DeleteTagsRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const DeleteTagsRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const DeleteTagsRequest& __x, const DeleteTagsRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const DeleteTagsRequest& __x, const DeleteTagsRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const DeleteTagsRequest& __x, const DeleteTagsRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> parts_ref() const& {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> parts_ref() const&& {
    return {std::move(this->parts), __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> parts_ref() & {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> parts_ref() && {
    return {std::move(this->parts), __isset.parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> common_ref() const& {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> common_ref() const&& {
    return {std::move(this->common), __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> common_ref() & {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> common_ref() && {
    return {std::move(this->common), __isset.common};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>>& get_parts() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>> get_parts() &&;

  template <typename T_DeleteTagsRequest_parts_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>>>
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::DelTags>>& set_parts(T_DeleteTagsRequest_parts_struct_setter&& parts_) {
    parts = std::forward<T_DeleteTagsRequest_parts_struct_setter>(parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return parts;
  }
  const  ::nebula::storage::cpp2::RequestCommon* get_common() const&;
   ::nebula::storage::cpp2::RequestCommon* get_common() &;
   ::nebula::storage::cpp2::RequestCommon* get_common() && = delete;

  template <typename T_DeleteTagsRequest_common_struct_setter =  ::nebula::storage::cpp2::RequestCommon>
   ::nebula::storage::cpp2::RequestCommon& set_common(T_DeleteTagsRequest_common_struct_setter&& common_) {
    common = std::forward<T_DeleteTagsRequest_common_struct_setter>(common_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.common = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return common;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< DeleteTagsRequest >;
  friend void swap(DeleteTagsRequest& a, DeleteTagsRequest& b);
};

template <class Protocol_>
uint32_t DeleteTagsRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class UpdateResponse final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = UpdateResponse;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  UpdateResponse() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  UpdateResponse(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg, nebula::DataSet props__arg);

  UpdateResponse(UpdateResponse&&) = default;

  UpdateResponse(const UpdateResponse&) = default;


  UpdateResponse& operator=(UpdateResponse&&) = default;

  UpdateResponse& operator=(const UpdateResponse&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
   ::nebula::storage::cpp2::ResponseCommon result;
 private:
  nebula::DataSet props;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool props;
  } __isset = {};
  bool operator==(const UpdateResponse& rhs) const;
#ifndef SWIG
  friend bool operator!=(const UpdateResponse& __x, const UpdateResponse& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const UpdateResponse& rhs) const;
#ifndef SWIG
  friend bool operator>(const UpdateResponse& __x, const UpdateResponse& __y) {
    return __y < __x;
  }
  friend bool operator<=(const UpdateResponse& __x, const UpdateResponse& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const UpdateResponse& __x, const UpdateResponse& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> result_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> result_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->result)};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> result_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> result_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->result)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> props_ref() const& {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> props_ref() const&& {
    return {std::move(this->props), __isset.props};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> props_ref() & {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> props_ref() && {
    return {std::move(this->props), __isset.props};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::storage::cpp2::ResponseCommon& get_result() const&;
   ::nebula::storage::cpp2::ResponseCommon get_result() &&;

  template <typename T_UpdateResponse_result_struct_setter =  ::nebula::storage::cpp2::ResponseCommon>
   ::nebula::storage::cpp2::ResponseCommon& set_result(T_UpdateResponse_result_struct_setter&& result_) {
    result = std::forward<T_UpdateResponse_result_struct_setter>(result_);
    return result;
  }
  const nebula::DataSet* get_props() const&;
  nebula::DataSet* get_props() &;
  nebula::DataSet* get_props() && = delete;

  template <typename T_UpdateResponse_props_struct_setter = nebula::DataSet>
  nebula::DataSet& set_props(T_UpdateResponse_props_struct_setter&& props_) {
    props = std::forward<T_UpdateResponse_props_struct_setter>(props_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.props = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return props;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< UpdateResponse >;
  friend void swap(UpdateResponse& a, UpdateResponse& b);
};

template <class Protocol_>
uint32_t UpdateResponse::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class UpdatedProp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = UpdatedProp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  UpdatedProp() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  UpdatedProp(apache::thrift::FragileConstructor, ::std::string name__arg, ::std::string value__arg);

  UpdatedProp(UpdatedProp&&) = default;

  UpdatedProp(const UpdatedProp&) = default;


  UpdatedProp& operator=(UpdatedProp&&) = default;

  UpdatedProp& operator=(const UpdatedProp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
  ::std::string name;
 public:
  ::std::string value;

 public:
  bool operator==(const UpdatedProp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const UpdatedProp& __x, const UpdatedProp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const UpdatedProp& rhs) const;
#ifndef SWIG
  friend bool operator>(const UpdatedProp& __x, const UpdatedProp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const UpdatedProp& __x, const UpdatedProp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const UpdatedProp& __x, const UpdatedProp& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> name_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> name_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->name)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> name_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> name_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->name)};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> value_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->value};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> value_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->value)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> value_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->value};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> value_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->value)};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_UpdatedProp_name_struct_setter = ::std::string>
  ::std::string& set_name(T_UpdatedProp_name_struct_setter&& name_) {
    name = std::forward<T_UpdatedProp_name_struct_setter>(name_);
    return name;
  }

  const ::std::string& get_value() const& {
    return value;
  }

  ::std::string get_value() && {
    return std::move(value);
  }

  template <typename T_UpdatedProp_value_struct_setter = ::std::string>
  ::std::string& set_value(T_UpdatedProp_value_struct_setter&& value_) {
    value = std::forward<T_UpdatedProp_value_struct_setter>(value_);
    return value;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< UpdatedProp >;
  friend void swap(UpdatedProp& a, UpdatedProp& b);
};

template <class Protocol_>
uint32_t UpdatedProp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class UpdateVertexRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = UpdateVertexRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  UpdateVertexRequest();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  UpdateVertexRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg, nebula::Value vertex_id__arg,  ::nebula::cpp2::TagID tag_id__arg, ::std::vector< ::nebula::storage::cpp2::UpdatedProp> updated_props__arg, bool insertable__arg, ::std::vector<::std::string> return_props__arg, ::std::string condition__arg,  ::nebula::storage::cpp2::RequestCommon common__arg);

  UpdateVertexRequest(UpdateVertexRequest&&) = default;

  UpdateVertexRequest(const UpdateVertexRequest&) = default;


  UpdateVertexRequest& operator=(UpdateVertexRequest&&) = default;

  UpdateVertexRequest& operator=(const UpdateVertexRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~UpdateVertexRequest();

 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
   ::nebula::cpp2::PartitionID part_id;
 private:
  nebula::Value vertex_id;
 public:
   ::nebula::cpp2::TagID tag_id;
 private:
  ::std::vector< ::nebula::storage::cpp2::UpdatedProp> updated_props;
 private:
  bool insertable;
 private:
  ::std::vector<::std::string> return_props;
 private:
  ::std::string condition;
 private:
   ::nebula::storage::cpp2::RequestCommon common;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool part_id;
    bool vertex_id;
    bool updated_props;
    bool insertable;
    bool return_props;
    bool condition;
    bool common;
  } __isset = {};
  bool operator==(const UpdateVertexRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const UpdateVertexRequest& __x, const UpdateVertexRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const UpdateVertexRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const UpdateVertexRequest& __x, const UpdateVertexRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const UpdateVertexRequest& __x, const UpdateVertexRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const UpdateVertexRequest& __x, const UpdateVertexRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> part_id_ref() const& {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> part_id_ref() const&& {
    return {std::move(this->part_id), __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> part_id_ref() & {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> part_id_ref() && {
    return {std::move(this->part_id), __isset.part_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> vertex_id_ref() const& {
    return {this->vertex_id, __isset.vertex_id};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> vertex_id_ref() const&& {
    return {std::move(this->vertex_id), __isset.vertex_id};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> vertex_id_ref() & {
    return {this->vertex_id, __isset.vertex_id};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> vertex_id_ref() && {
    return {std::move(this->vertex_id), __isset.vertex_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> tag_id_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->tag_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> tag_id_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->tag_id)};
  }

  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> tag_id_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->tag_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::TagID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> tag_id_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->tag_id)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> updated_props_ref() const& {
    return {this->updated_props, __isset.updated_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> updated_props_ref() const&& {
    return {std::move(this->updated_props), __isset.updated_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> updated_props_ref() & {
    return {this->updated_props, __isset.updated_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> updated_props_ref() && {
    return {std::move(this->updated_props), __isset.updated_props};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> insertable_ref() const& {
    return {this->insertable, __isset.insertable};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> insertable_ref() const&& {
    return {std::move(this->insertable), __isset.insertable};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> insertable_ref() & {
    return {this->insertable, __isset.insertable};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> insertable_ref() && {
    return {std::move(this->insertable), __isset.insertable};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> return_props_ref() const& {
    return {this->return_props, __isset.return_props};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> return_props_ref() const&& {
    return {std::move(this->return_props), __isset.return_props};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> return_props_ref() & {
    return {this->return_props, __isset.return_props};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> return_props_ref() && {
    return {std::move(this->return_props), __isset.return_props};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> condition_ref() const& {
    return {this->condition, __isset.condition};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> condition_ref() const&& {
    return {std::move(this->condition), __isset.condition};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> condition_ref() & {
    return {this->condition, __isset.condition};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> condition_ref() && {
    return {std::move(this->condition), __isset.condition};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> common_ref() const& {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> common_ref() const&& {
    return {std::move(this->common), __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> common_ref() & {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> common_ref() && {
    return {std::move(this->common), __isset.common};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

   ::nebula::cpp2::PartitionID get_part_id() const {
    return part_id;
  }

   ::nebula::cpp2::PartitionID& set_part_id( ::nebula::cpp2::PartitionID part_id_) {
    part_id = part_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.part_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return part_id;
  }
  const nebula::Value& get_vertex_id() const&;
  nebula::Value get_vertex_id() &&;

  template <typename T_UpdateVertexRequest_vertex_id_struct_setter = nebula::Value>
  nebula::Value& set_vertex_id(T_UpdateVertexRequest_vertex_id_struct_setter&& vertex_id_) {
    vertex_id = std::forward<T_UpdateVertexRequest_vertex_id_struct_setter>(vertex_id_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.vertex_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return vertex_id;
  }

   ::nebula::cpp2::TagID get_tag_id() const {
    return tag_id;
  }

   ::nebula::cpp2::TagID& set_tag_id( ::nebula::cpp2::TagID tag_id_) {
    tag_id = tag_id_;
    return tag_id;
  }
  const ::std::vector< ::nebula::storage::cpp2::UpdatedProp>& get_updated_props() const&;
  ::std::vector< ::nebula::storage::cpp2::UpdatedProp> get_updated_props() &&;

  template <typename T_UpdateVertexRequest_updated_props_struct_setter = ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>
  ::std::vector< ::nebula::storage::cpp2::UpdatedProp>& set_updated_props(T_UpdateVertexRequest_updated_props_struct_setter&& updated_props_) {
    updated_props = std::forward<T_UpdateVertexRequest_updated_props_struct_setter>(updated_props_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.updated_props = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return updated_props;
  }

  const bool* get_insertable() const& {
    return insertable_ref() ? std::addressof(insertable) : nullptr;
  }

  bool* get_insertable() & {
    return insertable_ref() ? std::addressof(insertable) : nullptr;
  }
  bool* get_insertable() && = delete;

  bool& set_insertable(bool insertable_) {
    insertable = insertable_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.insertable = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return insertable;
  }
  const ::std::vector<::std::string>* get_return_props() const&;
  ::std::vector<::std::string>* get_return_props() &;
  ::std::vector<::std::string>* get_return_props() && = delete;

  template <typename T_UpdateVertexRequest_return_props_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_return_props(T_UpdateVertexRequest_return_props_struct_setter&& return_props_) {
    return_props = std::forward<T_UpdateVertexRequest_return_props_struct_setter>(return_props_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.return_props = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return return_props;
  }

  const ::std::string* get_condition() const& {
    return condition_ref() ? std::addressof(condition) : nullptr;
  }

  ::std::string* get_condition() & {
    return condition_ref() ? std::addressof(condition) : nullptr;
  }
  ::std::string* get_condition() && = delete;

  template <typename T_UpdateVertexRequest_condition_struct_setter = ::std::string>
  ::std::string& set_condition(T_UpdateVertexRequest_condition_struct_setter&& condition_) {
    condition = std::forward<T_UpdateVertexRequest_condition_struct_setter>(condition_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.condition = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return condition;
  }
  const  ::nebula::storage::cpp2::RequestCommon* get_common() const&;
   ::nebula::storage::cpp2::RequestCommon* get_common() &;
   ::nebula::storage::cpp2::RequestCommon* get_common() && = delete;

  template <typename T_UpdateVertexRequest_common_struct_setter =  ::nebula::storage::cpp2::RequestCommon>
   ::nebula::storage::cpp2::RequestCommon& set_common(T_UpdateVertexRequest_common_struct_setter&& common_) {
    common = std::forward<T_UpdateVertexRequest_common_struct_setter>(common_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.common = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return common;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< UpdateVertexRequest >;
  friend void swap(UpdateVertexRequest& a, UpdateVertexRequest& b);
};

template <class Protocol_>
uint32_t UpdateVertexRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class UpdateEdgeRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = UpdateEdgeRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  UpdateEdgeRequest();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  UpdateEdgeRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg,  ::nebula::storage::cpp2::EdgeKey edge_key__arg, ::std::vector< ::nebula::storage::cpp2::UpdatedProp> updated_props__arg, bool insertable__arg, ::std::vector<::std::string> return_props__arg, ::std::string condition__arg,  ::nebula::storage::cpp2::RequestCommon common__arg);

  UpdateEdgeRequest(UpdateEdgeRequest&&) = default;

  UpdateEdgeRequest(const UpdateEdgeRequest&) = default;


  UpdateEdgeRequest& operator=(UpdateEdgeRequest&&) = default;

  UpdateEdgeRequest& operator=(const UpdateEdgeRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~UpdateEdgeRequest();

 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
   ::nebula::cpp2::PartitionID part_id;
 private:
   ::nebula::storage::cpp2::EdgeKey edge_key;
 private:
  ::std::vector< ::nebula::storage::cpp2::UpdatedProp> updated_props;
 private:
  bool insertable;
 private:
  ::std::vector<::std::string> return_props;
 private:
  ::std::string condition;
 private:
   ::nebula::storage::cpp2::RequestCommon common;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool part_id;
    bool edge_key;
    bool updated_props;
    bool insertable;
    bool return_props;
    bool condition;
    bool common;
  } __isset = {};
  bool operator==(const UpdateEdgeRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const UpdateEdgeRequest& __x, const UpdateEdgeRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const UpdateEdgeRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const UpdateEdgeRequest& __x, const UpdateEdgeRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const UpdateEdgeRequest& __x, const UpdateEdgeRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const UpdateEdgeRequest& __x, const UpdateEdgeRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> part_id_ref() const& {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> part_id_ref() const&& {
    return {std::move(this->part_id), __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> part_id_ref() & {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> part_id_ref() && {
    return {std::move(this->part_id), __isset.part_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::EdgeKey>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> edge_key_ref() const& {
    return {this->edge_key, __isset.edge_key};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::EdgeKey>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> edge_key_ref() const&& {
    return {std::move(this->edge_key), __isset.edge_key};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::EdgeKey>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> edge_key_ref() & {
    return {this->edge_key, __isset.edge_key};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::EdgeKey>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> edge_key_ref() && {
    return {std::move(this->edge_key), __isset.edge_key};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> updated_props_ref() const& {
    return {this->updated_props, __isset.updated_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> updated_props_ref() const&& {
    return {std::move(this->updated_props), __isset.updated_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> updated_props_ref() & {
    return {this->updated_props, __isset.updated_props};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> updated_props_ref() && {
    return {std::move(this->updated_props), __isset.updated_props};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> insertable_ref() const& {
    return {this->insertable, __isset.insertable};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> insertable_ref() const&& {
    return {std::move(this->insertable), __isset.insertable};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> insertable_ref() & {
    return {this->insertable, __isset.insertable};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> insertable_ref() && {
    return {std::move(this->insertable), __isset.insertable};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> return_props_ref() const& {
    return {this->return_props, __isset.return_props};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> return_props_ref() const&& {
    return {std::move(this->return_props), __isset.return_props};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> return_props_ref() & {
    return {this->return_props, __isset.return_props};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> return_props_ref() && {
    return {std::move(this->return_props), __isset.return_props};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> condition_ref() const& {
    return {this->condition, __isset.condition};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> condition_ref() const&& {
    return {std::move(this->condition), __isset.condition};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> condition_ref() & {
    return {this->condition, __isset.condition};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> condition_ref() && {
    return {std::move(this->condition), __isset.condition};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> common_ref() const& {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> common_ref() const&& {
    return {std::move(this->common), __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> common_ref() & {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> common_ref() && {
    return {std::move(this->common), __isset.common};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

   ::nebula::cpp2::PartitionID get_part_id() const {
    return part_id;
  }

   ::nebula::cpp2::PartitionID& set_part_id( ::nebula::cpp2::PartitionID part_id_) {
    part_id = part_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.part_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return part_id;
  }
  const  ::nebula::storage::cpp2::EdgeKey& get_edge_key() const&;
   ::nebula::storage::cpp2::EdgeKey get_edge_key() &&;

  template <typename T_UpdateEdgeRequest_edge_key_struct_setter =  ::nebula::storage::cpp2::EdgeKey>
   ::nebula::storage::cpp2::EdgeKey& set_edge_key(T_UpdateEdgeRequest_edge_key_struct_setter&& edge_key_) {
    edge_key = std::forward<T_UpdateEdgeRequest_edge_key_struct_setter>(edge_key_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.edge_key = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return edge_key;
  }
  const ::std::vector< ::nebula::storage::cpp2::UpdatedProp>& get_updated_props() const&;
  ::std::vector< ::nebula::storage::cpp2::UpdatedProp> get_updated_props() &&;

  template <typename T_UpdateEdgeRequest_updated_props_struct_setter = ::std::vector< ::nebula::storage::cpp2::UpdatedProp>>
  ::std::vector< ::nebula::storage::cpp2::UpdatedProp>& set_updated_props(T_UpdateEdgeRequest_updated_props_struct_setter&& updated_props_) {
    updated_props = std::forward<T_UpdateEdgeRequest_updated_props_struct_setter>(updated_props_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.updated_props = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return updated_props;
  }

  const bool* get_insertable() const& {
    return insertable_ref() ? std::addressof(insertable) : nullptr;
  }

  bool* get_insertable() & {
    return insertable_ref() ? std::addressof(insertable) : nullptr;
  }
  bool* get_insertable() && = delete;

  bool& set_insertable(bool insertable_) {
    insertable = insertable_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.insertable = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return insertable;
  }
  const ::std::vector<::std::string>* get_return_props() const&;
  ::std::vector<::std::string>* get_return_props() &;
  ::std::vector<::std::string>* get_return_props() && = delete;

  template <typename T_UpdateEdgeRequest_return_props_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_return_props(T_UpdateEdgeRequest_return_props_struct_setter&& return_props_) {
    return_props = std::forward<T_UpdateEdgeRequest_return_props_struct_setter>(return_props_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.return_props = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return return_props;
  }

  const ::std::string* get_condition() const& {
    return condition_ref() ? std::addressof(condition) : nullptr;
  }

  ::std::string* get_condition() & {
    return condition_ref() ? std::addressof(condition) : nullptr;
  }
  ::std::string* get_condition() && = delete;

  template <typename T_UpdateEdgeRequest_condition_struct_setter = ::std::string>
  ::std::string& set_condition(T_UpdateEdgeRequest_condition_struct_setter&& condition_) {
    condition = std::forward<T_UpdateEdgeRequest_condition_struct_setter>(condition_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.condition = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return condition;
  }
  const  ::nebula::storage::cpp2::RequestCommon* get_common() const&;
   ::nebula::storage::cpp2::RequestCommon* get_common() &;
   ::nebula::storage::cpp2::RequestCommon* get_common() && = delete;

  template <typename T_UpdateEdgeRequest_common_struct_setter =  ::nebula::storage::cpp2::RequestCommon>
   ::nebula::storage::cpp2::RequestCommon& set_common(T_UpdateEdgeRequest_common_struct_setter&& common_) {
    common = std::forward<T_UpdateEdgeRequest_common_struct_setter>(common_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.common = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return common;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< UpdateEdgeRequest >;
  friend void swap(UpdateEdgeRequest& a, UpdateEdgeRequest& b);
};

template <class Protocol_>
uint32_t UpdateEdgeRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class GetUUIDReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetUUIDReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetUUIDReq() :
      space_id(0),
      part_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetUUIDReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg, ::std::string name__arg,  ::nebula::storage::cpp2::RequestCommon common__arg);

  GetUUIDReq(GetUUIDReq&&) = default;

  GetUUIDReq(const GetUUIDReq&) = default;


  GetUUIDReq& operator=(GetUUIDReq&&) = default;

  GetUUIDReq& operator=(const GetUUIDReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
   ::nebula::cpp2::PartitionID part_id;
 private:
  ::std::string name;
 private:
   ::nebula::storage::cpp2::RequestCommon common;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool part_id;
    bool name;
    bool common;
  } __isset = {};
  bool operator==(const GetUUIDReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetUUIDReq& __x, const GetUUIDReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetUUIDReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetUUIDReq& __x, const GetUUIDReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetUUIDReq& __x, const GetUUIDReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetUUIDReq& __x, const GetUUIDReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> part_id_ref() const& {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> part_id_ref() const&& {
    return {std::move(this->part_id), __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> part_id_ref() & {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> part_id_ref() && {
    return {std::move(this->part_id), __isset.part_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> common_ref() const& {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> common_ref() const&& {
    return {std::move(this->common), __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> common_ref() & {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> common_ref() && {
    return {std::move(this->common), __isset.common};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

   ::nebula::cpp2::PartitionID get_part_id() const {
    return part_id;
  }

   ::nebula::cpp2::PartitionID& set_part_id( ::nebula::cpp2::PartitionID part_id_) {
    part_id = part_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.part_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return part_id;
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_GetUUIDReq_name_struct_setter = ::std::string>
  ::std::string& set_name(T_GetUUIDReq_name_struct_setter&& name_) {
    name = std::forward<T_GetUUIDReq_name_struct_setter>(name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return name;
  }
  const  ::nebula::storage::cpp2::RequestCommon* get_common() const&;
   ::nebula::storage::cpp2::RequestCommon* get_common() &;
   ::nebula::storage::cpp2::RequestCommon* get_common() && = delete;

  template <typename T_GetUUIDReq_common_struct_setter =  ::nebula::storage::cpp2::RequestCommon>
   ::nebula::storage::cpp2::RequestCommon& set_common(T_GetUUIDReq_common_struct_setter&& common_) {
    common = std::forward<T_GetUUIDReq_common_struct_setter>(common_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.common = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return common;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetUUIDReq >;
  friend void swap(GetUUIDReq& a, GetUUIDReq& b);
};

template <class Protocol_>
uint32_t GetUUIDReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class GetUUIDResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetUUIDResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetUUIDResp() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetUUIDResp(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg, nebula::Value id__arg);

  GetUUIDResp(GetUUIDResp&&) = default;

  GetUUIDResp(const GetUUIDResp&) = default;


  GetUUIDResp& operator=(GetUUIDResp&&) = default;

  GetUUIDResp& operator=(const GetUUIDResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
   ::nebula::storage::cpp2::ResponseCommon result;
 private:
  nebula::Value id;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool id;
  } __isset = {};
  bool operator==(const GetUUIDResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetUUIDResp& __x, const GetUUIDResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetUUIDResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetUUIDResp& __x, const GetUUIDResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetUUIDResp& __x, const GetUUIDResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetUUIDResp& __x, const GetUUIDResp& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> result_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> result_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->result)};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> result_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> result_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->result)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> id_ref() const& {
    return {this->id, __isset.id};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> id_ref() const&& {
    return {std::move(this->id), __isset.id};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> id_ref() & {
    return {this->id, __isset.id};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> id_ref() && {
    return {std::move(this->id), __isset.id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::storage::cpp2::ResponseCommon& get_result() const&;
   ::nebula::storage::cpp2::ResponseCommon get_result() &&;

  template <typename T_GetUUIDResp_result_struct_setter =  ::nebula::storage::cpp2::ResponseCommon>
   ::nebula::storage::cpp2::ResponseCommon& set_result(T_GetUUIDResp_result_struct_setter&& result_) {
    result = std::forward<T_GetUUIDResp_result_struct_setter>(result_);
    return result;
  }
  const nebula::Value& get_id() const&;
  nebula::Value get_id() &&;

  template <typename T_GetUUIDResp_id_struct_setter = nebula::Value>
  nebula::Value& set_id(T_GetUUIDResp_id_struct_setter&& id_) {
    id = std::forward<T_GetUUIDResp_id_struct_setter>(id_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return id;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetUUIDResp >;
  friend void swap(GetUUIDResp& a, GetUUIDResp& b);
};

template <class Protocol_>
uint32_t GetUUIDResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class LookupIndexResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = LookupIndexResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  LookupIndexResp() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  LookupIndexResp(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg, nebula::DataSet data__arg);

  LookupIndexResp(LookupIndexResp&&) = default;

  LookupIndexResp(const LookupIndexResp&) = default;


  LookupIndexResp& operator=(LookupIndexResp&&) = default;

  LookupIndexResp& operator=(const LookupIndexResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
   ::nebula::storage::cpp2::ResponseCommon result;
 private:
  nebula::DataSet data;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool data;
  } __isset = {};
  bool operator==(const LookupIndexResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const LookupIndexResp& __x, const LookupIndexResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const LookupIndexResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const LookupIndexResp& __x, const LookupIndexResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const LookupIndexResp& __x, const LookupIndexResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const LookupIndexResp& __x, const LookupIndexResp& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> result_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> result_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->result)};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> result_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> result_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->result)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> data_ref() const& {
    return {this->data, __isset.data};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> data_ref() const&& {
    return {std::move(this->data), __isset.data};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> data_ref() & {
    return {this->data, __isset.data};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> data_ref() && {
    return {std::move(this->data), __isset.data};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::storage::cpp2::ResponseCommon& get_result() const&;
   ::nebula::storage::cpp2::ResponseCommon get_result() &&;

  template <typename T_LookupIndexResp_result_struct_setter =  ::nebula::storage::cpp2::ResponseCommon>
   ::nebula::storage::cpp2::ResponseCommon& set_result(T_LookupIndexResp_result_struct_setter&& result_) {
    result = std::forward<T_LookupIndexResp_result_struct_setter>(result_);
    return result;
  }
  const nebula::DataSet* get_data() const&;
  nebula::DataSet* get_data() &;
  nebula::DataSet* get_data() && = delete;

  template <typename T_LookupIndexResp_data_struct_setter = nebula::DataSet>
  nebula::DataSet& set_data(T_LookupIndexResp_data_struct_setter&& data_) {
    data = std::forward<T_LookupIndexResp_data_struct_setter>(data_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.data = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return data;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< LookupIndexResp >;
  friend void swap(LookupIndexResp& a, LookupIndexResp& b);
};

template <class Protocol_>
uint32_t LookupIndexResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class IndexColumnHint final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = IndexColumnHint;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  IndexColumnHint();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  IndexColumnHint(apache::thrift::FragileConstructor, ::std::string column_name__arg,  ::nebula::storage::cpp2::ScanType scan_type__arg, nebula::Value begin_value__arg, nebula::Value end_value__arg, bool include_begin__arg, bool include_end__arg);

  IndexColumnHint(IndexColumnHint&&) = default;

  IndexColumnHint(const IndexColumnHint&) = default;


  IndexColumnHint& operator=(IndexColumnHint&&) = default;

  IndexColumnHint& operator=(const IndexColumnHint&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~IndexColumnHint();

 private:
  ::std::string column_name;
 private:
   ::nebula::storage::cpp2::ScanType scan_type;
 private:
  nebula::Value begin_value;
 private:
  nebula::Value end_value;
 private:
  bool include_begin;
 private:
  bool include_end;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool column_name;
    bool scan_type;
    bool begin_value;
    bool end_value;
    bool include_begin;
    bool include_end;
  } __isset = {};
  bool operator==(const IndexColumnHint& rhs) const;
#ifndef SWIG
  friend bool operator!=(const IndexColumnHint& __x, const IndexColumnHint& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const IndexColumnHint& rhs) const;
#ifndef SWIG
  friend bool operator>(const IndexColumnHint& __x, const IndexColumnHint& __y) {
    return __y < __x;
  }
  friend bool operator<=(const IndexColumnHint& __x, const IndexColumnHint& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const IndexColumnHint& __x, const IndexColumnHint& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> column_name_ref() const& {
    return {this->column_name, __isset.column_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> column_name_ref() const&& {
    return {std::move(this->column_name), __isset.column_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> column_name_ref() & {
    return {this->column_name, __isset.column_name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> column_name_ref() && {
    return {std::move(this->column_name), __isset.column_name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::ScanType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> scan_type_ref() const& {
    return {this->scan_type, __isset.scan_type};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ScanType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> scan_type_ref() const&& {
    return {std::move(this->scan_type), __isset.scan_type};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ScanType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> scan_type_ref() & {
    return {this->scan_type, __isset.scan_type};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ScanType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> scan_type_ref() && {
    return {std::move(this->scan_type), __isset.scan_type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> begin_value_ref() const& {
    return {this->begin_value, __isset.begin_value};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> begin_value_ref() const&& {
    return {std::move(this->begin_value), __isset.begin_value};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> begin_value_ref() & {
    return {this->begin_value, __isset.begin_value};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> begin_value_ref() && {
    return {std::move(this->begin_value), __isset.begin_value};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> end_value_ref() const& {
    return {this->end_value, __isset.end_value};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> end_value_ref() const&& {
    return {std::move(this->end_value), __isset.end_value};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> end_value_ref() & {
    return {this->end_value, __isset.end_value};
  }

  template <typename..., typename T = nebula::Value>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> end_value_ref() && {
    return {std::move(this->end_value), __isset.end_value};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> include_begin_ref() const& {
    return {this->include_begin, __isset.include_begin};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> include_begin_ref() const&& {
    return {std::move(this->include_begin), __isset.include_begin};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> include_begin_ref() & {
    return {this->include_begin, __isset.include_begin};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> include_begin_ref() && {
    return {std::move(this->include_begin), __isset.include_begin};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> include_end_ref() const& {
    return {this->include_end, __isset.include_end};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> include_end_ref() const&& {
    return {std::move(this->include_end), __isset.include_end};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> include_end_ref() & {
    return {this->include_end, __isset.include_end};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> include_end_ref() && {
    return {std::move(this->include_end), __isset.include_end};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string& get_column_name() const& {
    return column_name;
  }

  ::std::string get_column_name() && {
    return std::move(column_name);
  }

  template <typename T_IndexColumnHint_column_name_struct_setter = ::std::string>
  ::std::string& set_column_name(T_IndexColumnHint_column_name_struct_setter&& column_name_) {
    column_name = std::forward<T_IndexColumnHint_column_name_struct_setter>(column_name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.column_name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return column_name;
  }

   ::nebula::storage::cpp2::ScanType get_scan_type() const {
    return scan_type;
  }

   ::nebula::storage::cpp2::ScanType& set_scan_type( ::nebula::storage::cpp2::ScanType scan_type_) {
    scan_type = scan_type_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.scan_type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return scan_type;
  }
  const nebula::Value& get_begin_value() const&;
  nebula::Value get_begin_value() &&;

  template <typename T_IndexColumnHint_begin_value_struct_setter = nebula::Value>
  nebula::Value& set_begin_value(T_IndexColumnHint_begin_value_struct_setter&& begin_value_) {
    begin_value = std::forward<T_IndexColumnHint_begin_value_struct_setter>(begin_value_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.begin_value = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return begin_value;
  }
  const nebula::Value& get_end_value() const&;
  nebula::Value get_end_value() &&;

  template <typename T_IndexColumnHint_end_value_struct_setter = nebula::Value>
  nebula::Value& set_end_value(T_IndexColumnHint_end_value_struct_setter&& end_value_) {
    end_value = std::forward<T_IndexColumnHint_end_value_struct_setter>(end_value_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.end_value = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return end_value;
  }

  bool get_include_begin() const {
    return include_begin;
  }

  bool& set_include_begin(bool include_begin_) {
    include_begin = include_begin_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.include_begin = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return include_begin;
  }

  bool get_include_end() const {
    return include_end;
  }

  bool& set_include_end(bool include_end_) {
    include_end = include_end_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.include_end = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return include_end;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< IndexColumnHint >;
  friend void swap(IndexColumnHint& a, IndexColumnHint& b);
};

template <class Protocol_>
uint32_t IndexColumnHint::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class IndexQueryContext final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = IndexQueryContext;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  IndexQueryContext() :
      index_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  IndexQueryContext(apache::thrift::FragileConstructor,  ::nebula::cpp2::IndexID index_id__arg, ::std::string filter__arg, ::std::vector< ::nebula::storage::cpp2::IndexColumnHint> column_hints__arg);

  IndexQueryContext(IndexQueryContext&&) = default;

  IndexQueryContext(const IndexQueryContext&) = default;


  IndexQueryContext& operator=(IndexQueryContext&&) = default;

  IndexQueryContext& operator=(const IndexQueryContext&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::IndexID index_id;
 private:
  ::std::string filter;
 private:
  ::std::vector< ::nebula::storage::cpp2::IndexColumnHint> column_hints;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool index_id;
    bool filter;
    bool column_hints;
  } __isset = {};
  bool operator==(const IndexQueryContext& rhs) const;
#ifndef SWIG
  friend bool operator!=(const IndexQueryContext& __x, const IndexQueryContext& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const IndexQueryContext& rhs) const;
#ifndef SWIG
  friend bool operator>(const IndexQueryContext& __x, const IndexQueryContext& __y) {
    return __y < __x;
  }
  friend bool operator<=(const IndexQueryContext& __x, const IndexQueryContext& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const IndexQueryContext& __x, const IndexQueryContext& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::IndexID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> index_id_ref() const& {
    return {this->index_id, __isset.index_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::IndexID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> index_id_ref() const&& {
    return {std::move(this->index_id), __isset.index_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::IndexID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> index_id_ref() & {
    return {this->index_id, __isset.index_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::IndexID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> index_id_ref() && {
    return {std::move(this->index_id), __isset.index_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> filter_ref() const& {
    return {this->filter, __isset.filter};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> filter_ref() const&& {
    return {std::move(this->filter), __isset.filter};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> filter_ref() & {
    return {this->filter, __isset.filter};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> filter_ref() && {
    return {std::move(this->filter), __isset.filter};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::IndexColumnHint>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> column_hints_ref() const& {
    return {this->column_hints, __isset.column_hints};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::IndexColumnHint>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> column_hints_ref() const&& {
    return {std::move(this->column_hints), __isset.column_hints};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::IndexColumnHint>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> column_hints_ref() & {
    return {this->column_hints, __isset.column_hints};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::IndexColumnHint>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> column_hints_ref() && {
    return {std::move(this->column_hints), __isset.column_hints};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::IndexID get_index_id() const {
    return index_id;
  }

   ::nebula::cpp2::IndexID& set_index_id( ::nebula::cpp2::IndexID index_id_) {
    index_id = index_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.index_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return index_id;
  }

  const ::std::string& get_filter() const& {
    return filter;
  }

  ::std::string get_filter() && {
    return std::move(filter);
  }

  template <typename T_IndexQueryContext_filter_struct_setter = ::std::string>
  ::std::string& set_filter(T_IndexQueryContext_filter_struct_setter&& filter_) {
    filter = std::forward<T_IndexQueryContext_filter_struct_setter>(filter_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.filter = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return filter;
  }
  const ::std::vector< ::nebula::storage::cpp2::IndexColumnHint>& get_column_hints() const&;
  ::std::vector< ::nebula::storage::cpp2::IndexColumnHint> get_column_hints() &&;

  template <typename T_IndexQueryContext_column_hints_struct_setter = ::std::vector< ::nebula::storage::cpp2::IndexColumnHint>>
  ::std::vector< ::nebula::storage::cpp2::IndexColumnHint>& set_column_hints(T_IndexQueryContext_column_hints_struct_setter&& column_hints_) {
    column_hints = std::forward<T_IndexQueryContext_column_hints_struct_setter>(column_hints_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.column_hints = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return column_hints;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< IndexQueryContext >;
  friend void swap(IndexQueryContext& a, IndexQueryContext& b);
};

template <class Protocol_>
uint32_t IndexQueryContext::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class IndexSpec final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = IndexSpec;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  IndexSpec() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  IndexSpec(apache::thrift::FragileConstructor, ::std::vector< ::nebula::storage::cpp2::IndexQueryContext> contexts__arg,  ::nebula::cpp2::SchemaID schema_id__arg);

  IndexSpec(IndexSpec&&) = default;

  IndexSpec(const IndexSpec&) = default;


  IndexSpec& operator=(IndexSpec&&) = default;

  IndexSpec& operator=(const IndexSpec&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
  ::std::vector< ::nebula::storage::cpp2::IndexQueryContext> contexts;
 private:
   ::nebula::cpp2::SchemaID schema_id;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool schema_id;
  } __isset = {};
  bool operator==(const IndexSpec& rhs) const;
#ifndef SWIG
  friend bool operator!=(const IndexSpec& __x, const IndexSpec& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const IndexSpec& rhs) const;
#ifndef SWIG
  friend bool operator>(const IndexSpec& __x, const IndexSpec& __y) {
    return __y < __x;
  }
  friend bool operator<=(const IndexSpec& __x, const IndexSpec& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const IndexSpec& __x, const IndexSpec& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::IndexQueryContext>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> contexts_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->contexts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::IndexQueryContext>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> contexts_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->contexts)};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::IndexQueryContext>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> contexts_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->contexts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::IndexQueryContext>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> contexts_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->contexts)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::SchemaID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> schema_id_ref() const& {
    return {this->schema_id, __isset.schema_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::SchemaID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> schema_id_ref() const&& {
    return {std::move(this->schema_id), __isset.schema_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::SchemaID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> schema_id_ref() & {
    return {this->schema_id, __isset.schema_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::SchemaID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> schema_id_ref() && {
    return {std::move(this->schema_id), __isset.schema_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector< ::nebula::storage::cpp2::IndexQueryContext>& get_contexts() const&;
  ::std::vector< ::nebula::storage::cpp2::IndexQueryContext> get_contexts() &&;

  template <typename T_IndexSpec_contexts_struct_setter = ::std::vector< ::nebula::storage::cpp2::IndexQueryContext>>
  ::std::vector< ::nebula::storage::cpp2::IndexQueryContext>& set_contexts(T_IndexSpec_contexts_struct_setter&& contexts_) {
    contexts = std::forward<T_IndexSpec_contexts_struct_setter>(contexts_);
    return contexts;
  }
  const  ::nebula::cpp2::SchemaID& get_schema_id() const&;
   ::nebula::cpp2::SchemaID get_schema_id() &&;

  template <typename T_IndexSpec_schema_id_struct_setter =  ::nebula::cpp2::SchemaID>
   ::nebula::cpp2::SchemaID& set_schema_id(T_IndexSpec_schema_id_struct_setter&& schema_id_) {
    schema_id = std::forward<T_IndexSpec_schema_id_struct_setter>(schema_id_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.schema_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return schema_id;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< IndexSpec >;
  friend void swap(IndexSpec& a, IndexSpec& b);
};

template <class Protocol_>
uint32_t IndexSpec::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class LookupIndexRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = LookupIndexRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  LookupIndexRequest();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  LookupIndexRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::vector< ::nebula::cpp2::PartitionID> parts__arg,  ::nebula::storage::cpp2::IndexSpec indices__arg, ::std::vector<::std::string> return_columns__arg,  ::nebula::storage::cpp2::RequestCommon common__arg, int64_t limit__arg, ::std::vector< ::nebula::storage::cpp2::OrderBy> order_by__arg);

  LookupIndexRequest(LookupIndexRequest&&) = default;

  LookupIndexRequest(const LookupIndexRequest&) = default;


  LookupIndexRequest& operator=(LookupIndexRequest&&) = default;

  LookupIndexRequest& operator=(const LookupIndexRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~LookupIndexRequest();

 public:
   ::nebula::cpp2::GraphSpaceID space_id;
 public:
  ::std::vector< ::nebula::cpp2::PartitionID> parts;
 private:
   ::nebula::storage::cpp2::IndexSpec indices;
 private:
  ::std::vector<::std::string> return_columns;
 private:
   ::nebula::storage::cpp2::RequestCommon common;
 private:
  int64_t limit;
 private:
  ::std::vector< ::nebula::storage::cpp2::OrderBy> order_by;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool indices;
    bool return_columns;
    bool common;
    bool limit;
    bool order_by;
  } __isset = {};
  bool operator==(const LookupIndexRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const LookupIndexRequest& __x, const LookupIndexRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const LookupIndexRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const LookupIndexRequest& __x, const LookupIndexRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const LookupIndexRequest& __x, const LookupIndexRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const LookupIndexRequest& __x, const LookupIndexRequest& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> space_id_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> space_id_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->space_id)};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> space_id_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> space_id_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->space_id)};
  }
  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> parts_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->parts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> parts_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->parts)};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> parts_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->parts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> parts_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->parts)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::IndexSpec>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> indices_ref() const& {
    return {this->indices, __isset.indices};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::IndexSpec>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> indices_ref() const&& {
    return {std::move(this->indices), __isset.indices};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::IndexSpec>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> indices_ref() & {
    return {this->indices, __isset.indices};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::IndexSpec>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> indices_ref() && {
    return {std::move(this->indices), __isset.indices};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> return_columns_ref() const& {
    return {this->return_columns, __isset.return_columns};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> return_columns_ref() const&& {
    return {std::move(this->return_columns), __isset.return_columns};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> return_columns_ref() & {
    return {this->return_columns, __isset.return_columns};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> return_columns_ref() && {
    return {std::move(this->return_columns), __isset.return_columns};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> common_ref() const& {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> common_ref() const&& {
    return {std::move(this->common), __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> common_ref() & {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> common_ref() && {
    return {std::move(this->common), __isset.common};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> limit_ref() const& {
    return {this->limit, __isset.limit};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> limit_ref() const&& {
    return {std::move(this->limit), __isset.limit};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> limit_ref() & {
    return {this->limit, __isset.limit};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> limit_ref() && {
    return {std::move(this->limit), __isset.limit};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::OrderBy>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> order_by_ref() const& {
    return {this->order_by, __isset.order_by};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::OrderBy>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> order_by_ref() const&& {
    return {std::move(this->order_by), __isset.order_by};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::OrderBy>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> order_by_ref() & {
    return {this->order_by, __isset.order_by};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::OrderBy>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> order_by_ref() && {
    return {std::move(this->order_by), __isset.order_by};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
    return space_id;
  }
  const ::std::vector< ::nebula::cpp2::PartitionID>& get_parts() const&;
  ::std::vector< ::nebula::cpp2::PartitionID> get_parts() &&;

  template <typename T_LookupIndexRequest_parts_struct_setter = ::std::vector< ::nebula::cpp2::PartitionID>>
  ::std::vector< ::nebula::cpp2::PartitionID>& set_parts(T_LookupIndexRequest_parts_struct_setter&& parts_) {
    parts = std::forward<T_LookupIndexRequest_parts_struct_setter>(parts_);
    return parts;
  }
  const  ::nebula::storage::cpp2::IndexSpec& get_indices() const&;
   ::nebula::storage::cpp2::IndexSpec get_indices() &&;

  template <typename T_LookupIndexRequest_indices_struct_setter =  ::nebula::storage::cpp2::IndexSpec>
   ::nebula::storage::cpp2::IndexSpec& set_indices(T_LookupIndexRequest_indices_struct_setter&& indices_) {
    indices = std::forward<T_LookupIndexRequest_indices_struct_setter>(indices_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.indices = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return indices;
  }
  const ::std::vector<::std::string>* get_return_columns() const&;
  ::std::vector<::std::string>* get_return_columns() &;
  ::std::vector<::std::string>* get_return_columns() && = delete;

  template <typename T_LookupIndexRequest_return_columns_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_return_columns(T_LookupIndexRequest_return_columns_struct_setter&& return_columns_) {
    return_columns = std::forward<T_LookupIndexRequest_return_columns_struct_setter>(return_columns_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.return_columns = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return return_columns;
  }
  const  ::nebula::storage::cpp2::RequestCommon* get_common() const&;
   ::nebula::storage::cpp2::RequestCommon* get_common() &;
   ::nebula::storage::cpp2::RequestCommon* get_common() && = delete;

  template <typename T_LookupIndexRequest_common_struct_setter =  ::nebula::storage::cpp2::RequestCommon>
   ::nebula::storage::cpp2::RequestCommon& set_common(T_LookupIndexRequest_common_struct_setter&& common_) {
    common = std::forward<T_LookupIndexRequest_common_struct_setter>(common_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.common = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return common;
  }

  const int64_t* get_limit() const& {
    return limit_ref() ? std::addressof(limit) : nullptr;
  }

  int64_t* get_limit() & {
    return limit_ref() ? std::addressof(limit) : nullptr;
  }
  int64_t* get_limit() && = delete;

  int64_t& set_limit(int64_t limit_) {
    limit = limit_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.limit = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return limit;
  }
  const ::std::vector< ::nebula::storage::cpp2::OrderBy>* get_order_by() const&;
  ::std::vector< ::nebula::storage::cpp2::OrderBy>* get_order_by() &;
  ::std::vector< ::nebula::storage::cpp2::OrderBy>* get_order_by() && = delete;

  template <typename T_LookupIndexRequest_order_by_struct_setter = ::std::vector< ::nebula::storage::cpp2::OrderBy>>
  ::std::vector< ::nebula::storage::cpp2::OrderBy>& set_order_by(T_LookupIndexRequest_order_by_struct_setter&& order_by_) {
    order_by = std::forward<T_LookupIndexRequest_order_by_struct_setter>(order_by_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.order_by = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return order_by;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< LookupIndexRequest >;
  friend void swap(LookupIndexRequest& a, LookupIndexRequest& b);
};

template <class Protocol_>
uint32_t LookupIndexRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class LookupAndTraverseRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = LookupAndTraverseRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  LookupAndTraverseRequest();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  LookupAndTraverseRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::vector< ::nebula::cpp2::PartitionID> parts__arg,  ::nebula::storage::cpp2::IndexSpec indices__arg,  ::nebula::storage::cpp2::TraverseSpec traverse_spec__arg,  ::nebula::storage::cpp2::RequestCommon common__arg);

  LookupAndTraverseRequest(LookupAndTraverseRequest&&) = default;

  LookupAndTraverseRequest(const LookupAndTraverseRequest&) = default;


  LookupAndTraverseRequest& operator=(LookupAndTraverseRequest&&) = default;

  LookupAndTraverseRequest& operator=(const LookupAndTraverseRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~LookupAndTraverseRequest();

 public:
   ::nebula::cpp2::GraphSpaceID space_id;
 public:
  ::std::vector< ::nebula::cpp2::PartitionID> parts;
 private:
   ::nebula::storage::cpp2::IndexSpec indices;
 private:
   ::nebula::storage::cpp2::TraverseSpec traverse_spec;
 private:
   ::nebula::storage::cpp2::RequestCommon common;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool indices;
    bool traverse_spec;
    bool common;
  } __isset = {};
  bool operator==(const LookupAndTraverseRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const LookupAndTraverseRequest& __x, const LookupAndTraverseRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const LookupAndTraverseRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const LookupAndTraverseRequest& __x, const LookupAndTraverseRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const LookupAndTraverseRequest& __x, const LookupAndTraverseRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const LookupAndTraverseRequest& __x, const LookupAndTraverseRequest& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> space_id_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> space_id_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->space_id)};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> space_id_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> space_id_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->space_id)};
  }
  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> parts_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->parts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> parts_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->parts)};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> parts_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->parts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> parts_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->parts)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::IndexSpec>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> indices_ref() const& {
    return {this->indices, __isset.indices};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::IndexSpec>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> indices_ref() const&& {
    return {std::move(this->indices), __isset.indices};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::IndexSpec>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> indices_ref() & {
    return {this->indices, __isset.indices};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::IndexSpec>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> indices_ref() && {
    return {std::move(this->indices), __isset.indices};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::TraverseSpec>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> traverse_spec_ref() const& {
    return {this->traverse_spec, __isset.traverse_spec};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::TraverseSpec>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> traverse_spec_ref() const&& {
    return {std::move(this->traverse_spec), __isset.traverse_spec};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::TraverseSpec>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> traverse_spec_ref() & {
    return {this->traverse_spec, __isset.traverse_spec};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::TraverseSpec>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> traverse_spec_ref() && {
    return {std::move(this->traverse_spec), __isset.traverse_spec};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> common_ref() const& {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> common_ref() const&& {
    return {std::move(this->common), __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> common_ref() & {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> common_ref() && {
    return {std::move(this->common), __isset.common};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
    return space_id;
  }
  const ::std::vector< ::nebula::cpp2::PartitionID>& get_parts() const&;
  ::std::vector< ::nebula::cpp2::PartitionID> get_parts() &&;

  template <typename T_LookupAndTraverseRequest_parts_struct_setter = ::std::vector< ::nebula::cpp2::PartitionID>>
  ::std::vector< ::nebula::cpp2::PartitionID>& set_parts(T_LookupAndTraverseRequest_parts_struct_setter&& parts_) {
    parts = std::forward<T_LookupAndTraverseRequest_parts_struct_setter>(parts_);
    return parts;
  }
  const  ::nebula::storage::cpp2::IndexSpec& get_indices() const&;
   ::nebula::storage::cpp2::IndexSpec get_indices() &&;

  template <typename T_LookupAndTraverseRequest_indices_struct_setter =  ::nebula::storage::cpp2::IndexSpec>
   ::nebula::storage::cpp2::IndexSpec& set_indices(T_LookupAndTraverseRequest_indices_struct_setter&& indices_) {
    indices = std::forward<T_LookupAndTraverseRequest_indices_struct_setter>(indices_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.indices = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return indices;
  }
  const  ::nebula::storage::cpp2::TraverseSpec& get_traverse_spec() const&;
   ::nebula::storage::cpp2::TraverseSpec get_traverse_spec() &&;

  template <typename T_LookupAndTraverseRequest_traverse_spec_struct_setter =  ::nebula::storage::cpp2::TraverseSpec>
   ::nebula::storage::cpp2::TraverseSpec& set_traverse_spec(T_LookupAndTraverseRequest_traverse_spec_struct_setter&& traverse_spec_) {
    traverse_spec = std::forward<T_LookupAndTraverseRequest_traverse_spec_struct_setter>(traverse_spec_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.traverse_spec = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return traverse_spec;
  }
  const  ::nebula::storage::cpp2::RequestCommon* get_common() const&;
   ::nebula::storage::cpp2::RequestCommon* get_common() &;
   ::nebula::storage::cpp2::RequestCommon* get_common() && = delete;

  template <typename T_LookupAndTraverseRequest_common_struct_setter =  ::nebula::storage::cpp2::RequestCommon>
   ::nebula::storage::cpp2::RequestCommon& set_common(T_LookupAndTraverseRequest_common_struct_setter&& common_) {
    common = std::forward<T_LookupAndTraverseRequest_common_struct_setter>(common_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.common = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return common;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< LookupAndTraverseRequest >;
  friend void swap(LookupAndTraverseRequest& a, LookupAndTraverseRequest& b);
};

template <class Protocol_>
uint32_t LookupAndTraverseRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class ScanCursor final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ScanCursor;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ScanCursor() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ScanCursor(apache::thrift::FragileConstructor, ::std::string next_cursor__arg);

  ScanCursor(ScanCursor&&) = default;

  ScanCursor(const ScanCursor&) = default;


  ScanCursor& operator=(ScanCursor&&) = default;

  ScanCursor& operator=(const ScanCursor&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::string next_cursor;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool next_cursor;
  } __isset = {};
  bool operator==(const ScanCursor& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ScanCursor& __x, const ScanCursor& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ScanCursor& rhs) const;
#ifndef SWIG
  friend bool operator>(const ScanCursor& __x, const ScanCursor& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ScanCursor& __x, const ScanCursor& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ScanCursor& __x, const ScanCursor& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> next_cursor_ref() const& {
    return {this->next_cursor, __isset.next_cursor};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> next_cursor_ref() const&& {
    return {std::move(this->next_cursor), __isset.next_cursor};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> next_cursor_ref() & {
    return {this->next_cursor, __isset.next_cursor};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> next_cursor_ref() && {
    return {std::move(this->next_cursor), __isset.next_cursor};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  const ::std::string* get_next_cursor() const& {
    return next_cursor_ref() ? std::addressof(next_cursor) : nullptr;
  }

  ::std::string* get_next_cursor() & {
    return next_cursor_ref() ? std::addressof(next_cursor) : nullptr;
  }
  ::std::string* get_next_cursor() && = delete;

  template <typename T_ScanCursor_next_cursor_struct_setter = ::std::string>
  ::std::string& set_next_cursor(T_ScanCursor_next_cursor_struct_setter&& next_cursor_) {
    next_cursor = std::forward<T_ScanCursor_next_cursor_struct_setter>(next_cursor_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.next_cursor = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return next_cursor;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ScanCursor >;
  friend void swap(ScanCursor& a, ScanCursor& b);
};

template <class Protocol_>
uint32_t ScanCursor::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class ScanVertexRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ScanVertexRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ScanVertexRequest();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ScanVertexRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor> parts__arg, ::std::vector< ::nebula::storage::cpp2::VertexProp> return_columns__arg, int64_t limit__arg, int64_t start_time__arg, int64_t end_time__arg, ::std::string filter__arg, bool only_latest_version__arg, bool enable_read_from_follower__arg,  ::nebula::storage::cpp2::RequestCommon common__arg);

  ScanVertexRequest(ScanVertexRequest&&) = default;

  ScanVertexRequest(const ScanVertexRequest&) = default;


  ScanVertexRequest& operator=(ScanVertexRequest&&) = default;

  ScanVertexRequest& operator=(const ScanVertexRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~ScanVertexRequest();

 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor> parts;
 private:
  ::std::vector< ::nebula::storage::cpp2::VertexProp> return_columns;
 private:
  int64_t limit;
 private:
  int64_t start_time;
 private:
  int64_t end_time;
 private:
  ::std::string filter;
 private:
  bool only_latest_version;
 private:
  bool enable_read_from_follower;
 private:
   ::nebula::storage::cpp2::RequestCommon common;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool parts;
    bool return_columns;
    bool limit;
    bool start_time;
    bool end_time;
    bool filter;
    bool only_latest_version;
    bool enable_read_from_follower;
    bool common;
  } __isset = {};
  bool operator==(const ScanVertexRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ScanVertexRequest& __x, const ScanVertexRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ScanVertexRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const ScanVertexRequest& __x, const ScanVertexRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ScanVertexRequest& __x, const ScanVertexRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ScanVertexRequest& __x, const ScanVertexRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> parts_ref() const& {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> parts_ref() const&& {
    return {std::move(this->parts), __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> parts_ref() & {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> parts_ref() && {
    return {std::move(this->parts), __isset.parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::VertexProp>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> return_columns_ref() const& {
    return {this->return_columns, __isset.return_columns};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::VertexProp>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> return_columns_ref() const&& {
    return {std::move(this->return_columns), __isset.return_columns};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::VertexProp>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> return_columns_ref() & {
    return {this->return_columns, __isset.return_columns};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::VertexProp>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> return_columns_ref() && {
    return {std::move(this->return_columns), __isset.return_columns};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> limit_ref() const& {
    return {this->limit, __isset.limit};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> limit_ref() const&& {
    return {std::move(this->limit), __isset.limit};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> limit_ref() & {
    return {this->limit, __isset.limit};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> limit_ref() && {
    return {std::move(this->limit), __isset.limit};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> start_time_ref() const& {
    return {this->start_time, __isset.start_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> start_time_ref() const&& {
    return {std::move(this->start_time), __isset.start_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> start_time_ref() & {
    return {this->start_time, __isset.start_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> start_time_ref() && {
    return {std::move(this->start_time), __isset.start_time};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> end_time_ref() const& {
    return {this->end_time, __isset.end_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> end_time_ref() const&& {
    return {std::move(this->end_time), __isset.end_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> end_time_ref() & {
    return {this->end_time, __isset.end_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> end_time_ref() && {
    return {std::move(this->end_time), __isset.end_time};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> filter_ref() const& {
    return {this->filter, __isset.filter};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> filter_ref() const&& {
    return {std::move(this->filter), __isset.filter};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> filter_ref() & {
    return {this->filter, __isset.filter};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> filter_ref() && {
    return {std::move(this->filter), __isset.filter};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> only_latest_version_ref() const& {
    return {this->only_latest_version, __isset.only_latest_version};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> only_latest_version_ref() const&& {
    return {std::move(this->only_latest_version), __isset.only_latest_version};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> only_latest_version_ref() & {
    return {this->only_latest_version, __isset.only_latest_version};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> only_latest_version_ref() && {
    return {std::move(this->only_latest_version), __isset.only_latest_version};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> enable_read_from_follower_ref() const& {
    return {this->enable_read_from_follower, __isset.enable_read_from_follower};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> enable_read_from_follower_ref() const&& {
    return {std::move(this->enable_read_from_follower), __isset.enable_read_from_follower};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> enable_read_from_follower_ref() & {
    return {this->enable_read_from_follower, __isset.enable_read_from_follower};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> enable_read_from_follower_ref() && {
    return {std::move(this->enable_read_from_follower), __isset.enable_read_from_follower};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> common_ref() const& {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> common_ref() const&& {
    return {std::move(this->common), __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> common_ref() & {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> common_ref() && {
    return {std::move(this->common), __isset.common};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>& get_parts() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor> get_parts() &&;

  template <typename T_ScanVertexRequest_parts_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>
  std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>& set_parts(T_ScanVertexRequest_parts_struct_setter&& parts_) {
    parts = std::forward<T_ScanVertexRequest_parts_struct_setter>(parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return parts;
  }
  const ::std::vector< ::nebula::storage::cpp2::VertexProp>& get_return_columns() const&;
  ::std::vector< ::nebula::storage::cpp2::VertexProp> get_return_columns() &&;

  template <typename T_ScanVertexRequest_return_columns_struct_setter = ::std::vector< ::nebula::storage::cpp2::VertexProp>>
  ::std::vector< ::nebula::storage::cpp2::VertexProp>& set_return_columns(T_ScanVertexRequest_return_columns_struct_setter&& return_columns_) {
    return_columns = std::forward<T_ScanVertexRequest_return_columns_struct_setter>(return_columns_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.return_columns = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return return_columns;
  }

  int64_t get_limit() const {
    return limit;
  }

  int64_t& set_limit(int64_t limit_) {
    limit = limit_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.limit = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return limit;
  }

  const int64_t* get_start_time() const& {
    return start_time_ref() ? std::addressof(start_time) : nullptr;
  }

  int64_t* get_start_time() & {
    return start_time_ref() ? std::addressof(start_time) : nullptr;
  }
  int64_t* get_start_time() && = delete;

  int64_t& set_start_time(int64_t start_time_) {
    start_time = start_time_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.start_time = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return start_time;
  }

  const int64_t* get_end_time() const& {
    return end_time_ref() ? std::addressof(end_time) : nullptr;
  }

  int64_t* get_end_time() & {
    return end_time_ref() ? std::addressof(end_time) : nullptr;
  }
  int64_t* get_end_time() && = delete;

  int64_t& set_end_time(int64_t end_time_) {
    end_time = end_time_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.end_time = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return end_time;
  }

  const ::std::string* get_filter() const& {
    return filter_ref() ? std::addressof(filter) : nullptr;
  }

  ::std::string* get_filter() & {
    return filter_ref() ? std::addressof(filter) : nullptr;
  }
  ::std::string* get_filter() && = delete;

  template <typename T_ScanVertexRequest_filter_struct_setter = ::std::string>
  ::std::string& set_filter(T_ScanVertexRequest_filter_struct_setter&& filter_) {
    filter = std::forward<T_ScanVertexRequest_filter_struct_setter>(filter_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.filter = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return filter;
  }

  bool get_only_latest_version() const {
    return only_latest_version;
  }

  bool& set_only_latest_version(bool only_latest_version_) {
    only_latest_version = only_latest_version_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.only_latest_version = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return only_latest_version;
  }

  bool get_enable_read_from_follower() const {
    return enable_read_from_follower;
  }

  bool& set_enable_read_from_follower(bool enable_read_from_follower_) {
    enable_read_from_follower = enable_read_from_follower_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.enable_read_from_follower = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return enable_read_from_follower;
  }
  const  ::nebula::storage::cpp2::RequestCommon* get_common() const&;
   ::nebula::storage::cpp2::RequestCommon* get_common() &;
   ::nebula::storage::cpp2::RequestCommon* get_common() && = delete;

  template <typename T_ScanVertexRequest_common_struct_setter =  ::nebula::storage::cpp2::RequestCommon>
   ::nebula::storage::cpp2::RequestCommon& set_common(T_ScanVertexRequest_common_struct_setter&& common_) {
    common = std::forward<T_ScanVertexRequest_common_struct_setter>(common_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.common = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return common;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ScanVertexRequest >;
  friend void swap(ScanVertexRequest& a, ScanVertexRequest& b);
};

template <class Protocol_>
uint32_t ScanVertexRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class ScanEdgeRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ScanEdgeRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ScanEdgeRequest();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ScanEdgeRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor> parts__arg, ::std::vector< ::nebula::storage::cpp2::EdgeProp> return_columns__arg, int64_t limit__arg, int64_t start_time__arg, int64_t end_time__arg, ::std::string filter__arg, bool only_latest_version__arg, bool enable_read_from_follower__arg,  ::nebula::storage::cpp2::RequestCommon common__arg);

  ScanEdgeRequest(ScanEdgeRequest&&) = default;

  ScanEdgeRequest(const ScanEdgeRequest&) = default;


  ScanEdgeRequest& operator=(ScanEdgeRequest&&) = default;

  ScanEdgeRequest& operator=(const ScanEdgeRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~ScanEdgeRequest();

 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor> parts;
 private:
  ::std::vector< ::nebula::storage::cpp2::EdgeProp> return_columns;
 private:
  int64_t limit;
 private:
  int64_t start_time;
 private:
  int64_t end_time;
 private:
  ::std::string filter;
 private:
  bool only_latest_version;
 private:
  bool enable_read_from_follower;
 private:
   ::nebula::storage::cpp2::RequestCommon common;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool parts;
    bool return_columns;
    bool limit;
    bool start_time;
    bool end_time;
    bool filter;
    bool only_latest_version;
    bool enable_read_from_follower;
    bool common;
  } __isset = {};
  bool operator==(const ScanEdgeRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ScanEdgeRequest& __x, const ScanEdgeRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ScanEdgeRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const ScanEdgeRequest& __x, const ScanEdgeRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ScanEdgeRequest& __x, const ScanEdgeRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ScanEdgeRequest& __x, const ScanEdgeRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> parts_ref() const& {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> parts_ref() const&& {
    return {std::move(this->parts), __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> parts_ref() & {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> parts_ref() && {
    return {std::move(this->parts), __isset.parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::EdgeProp>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> return_columns_ref() const& {
    return {this->return_columns, __isset.return_columns};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::EdgeProp>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> return_columns_ref() const&& {
    return {std::move(this->return_columns), __isset.return_columns};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::EdgeProp>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> return_columns_ref() & {
    return {this->return_columns, __isset.return_columns};
  }

  template <typename..., typename T = ::std::vector< ::nebula::storage::cpp2::EdgeProp>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> return_columns_ref() && {
    return {std::move(this->return_columns), __isset.return_columns};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> limit_ref() const& {
    return {this->limit, __isset.limit};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> limit_ref() const&& {
    return {std::move(this->limit), __isset.limit};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> limit_ref() & {
    return {this->limit, __isset.limit};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> limit_ref() && {
    return {std::move(this->limit), __isset.limit};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> start_time_ref() const& {
    return {this->start_time, __isset.start_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> start_time_ref() const&& {
    return {std::move(this->start_time), __isset.start_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> start_time_ref() & {
    return {this->start_time, __isset.start_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> start_time_ref() && {
    return {std::move(this->start_time), __isset.start_time};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> end_time_ref() const& {
    return {this->end_time, __isset.end_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> end_time_ref() const&& {
    return {std::move(this->end_time), __isset.end_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> end_time_ref() & {
    return {this->end_time, __isset.end_time};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> end_time_ref() && {
    return {std::move(this->end_time), __isset.end_time};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> filter_ref() const& {
    return {this->filter, __isset.filter};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> filter_ref() const&& {
    return {std::move(this->filter), __isset.filter};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> filter_ref() & {
    return {this->filter, __isset.filter};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> filter_ref() && {
    return {std::move(this->filter), __isset.filter};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> only_latest_version_ref() const& {
    return {this->only_latest_version, __isset.only_latest_version};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> only_latest_version_ref() const&& {
    return {std::move(this->only_latest_version), __isset.only_latest_version};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> only_latest_version_ref() & {
    return {this->only_latest_version, __isset.only_latest_version};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> only_latest_version_ref() && {
    return {std::move(this->only_latest_version), __isset.only_latest_version};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> enable_read_from_follower_ref() const& {
    return {this->enable_read_from_follower, __isset.enable_read_from_follower};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> enable_read_from_follower_ref() const&& {
    return {std::move(this->enable_read_from_follower), __isset.enable_read_from_follower};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> enable_read_from_follower_ref() & {
    return {this->enable_read_from_follower, __isset.enable_read_from_follower};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> enable_read_from_follower_ref() && {
    return {std::move(this->enable_read_from_follower), __isset.enable_read_from_follower};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> common_ref() const& {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> common_ref() const&& {
    return {std::move(this->common), __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> common_ref() & {
    return {this->common, __isset.common};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::RequestCommon>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> common_ref() && {
    return {std::move(this->common), __isset.common};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>& get_parts() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor> get_parts() &&;

  template <typename T_ScanEdgeRequest_parts_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>
  std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>& set_parts(T_ScanEdgeRequest_parts_struct_setter&& parts_) {
    parts = std::forward<T_ScanEdgeRequest_parts_struct_setter>(parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return parts;
  }
  const ::std::vector< ::nebula::storage::cpp2::EdgeProp>& get_return_columns() const&;
  ::std::vector< ::nebula::storage::cpp2::EdgeProp> get_return_columns() &&;

  template <typename T_ScanEdgeRequest_return_columns_struct_setter = ::std::vector< ::nebula::storage::cpp2::EdgeProp>>
  ::std::vector< ::nebula::storage::cpp2::EdgeProp>& set_return_columns(T_ScanEdgeRequest_return_columns_struct_setter&& return_columns_) {
    return_columns = std::forward<T_ScanEdgeRequest_return_columns_struct_setter>(return_columns_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.return_columns = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return return_columns;
  }

  int64_t get_limit() const {
    return limit;
  }

  int64_t& set_limit(int64_t limit_) {
    limit = limit_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.limit = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return limit;
  }

  const int64_t* get_start_time() const& {
    return start_time_ref() ? std::addressof(start_time) : nullptr;
  }

  int64_t* get_start_time() & {
    return start_time_ref() ? std::addressof(start_time) : nullptr;
  }
  int64_t* get_start_time() && = delete;

  int64_t& set_start_time(int64_t start_time_) {
    start_time = start_time_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.start_time = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return start_time;
  }

  const int64_t* get_end_time() const& {
    return end_time_ref() ? std::addressof(end_time) : nullptr;
  }

  int64_t* get_end_time() & {
    return end_time_ref() ? std::addressof(end_time) : nullptr;
  }
  int64_t* get_end_time() && = delete;

  int64_t& set_end_time(int64_t end_time_) {
    end_time = end_time_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.end_time = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return end_time;
  }

  const ::std::string* get_filter() const& {
    return filter_ref() ? std::addressof(filter) : nullptr;
  }

  ::std::string* get_filter() & {
    return filter_ref() ? std::addressof(filter) : nullptr;
  }
  ::std::string* get_filter() && = delete;

  template <typename T_ScanEdgeRequest_filter_struct_setter = ::std::string>
  ::std::string& set_filter(T_ScanEdgeRequest_filter_struct_setter&& filter_) {
    filter = std::forward<T_ScanEdgeRequest_filter_struct_setter>(filter_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.filter = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return filter;
  }

  bool get_only_latest_version() const {
    return only_latest_version;
  }

  bool& set_only_latest_version(bool only_latest_version_) {
    only_latest_version = only_latest_version_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.only_latest_version = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return only_latest_version;
  }

  bool get_enable_read_from_follower() const {
    return enable_read_from_follower;
  }

  bool& set_enable_read_from_follower(bool enable_read_from_follower_) {
    enable_read_from_follower = enable_read_from_follower_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.enable_read_from_follower = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return enable_read_from_follower;
  }
  const  ::nebula::storage::cpp2::RequestCommon* get_common() const&;
   ::nebula::storage::cpp2::RequestCommon* get_common() &;
   ::nebula::storage::cpp2::RequestCommon* get_common() && = delete;

  template <typename T_ScanEdgeRequest_common_struct_setter =  ::nebula::storage::cpp2::RequestCommon>
   ::nebula::storage::cpp2::RequestCommon& set_common(T_ScanEdgeRequest_common_struct_setter&& common_) {
    common = std::forward<T_ScanEdgeRequest_common_struct_setter>(common_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.common = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return common;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ScanEdgeRequest >;
  friend void swap(ScanEdgeRequest& a, ScanEdgeRequest& b);
};

template <class Protocol_>
uint32_t ScanEdgeRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class ScanResponse final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ScanResponse;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ScanResponse() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ScanResponse(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg, nebula::DataSet props__arg, std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor> cursors__arg);

  ScanResponse(ScanResponse&&) = default;

  ScanResponse(const ScanResponse&) = default;


  ScanResponse& operator=(ScanResponse&&) = default;

  ScanResponse& operator=(const ScanResponse&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
   ::nebula::storage::cpp2::ResponseCommon result;
 private:
  nebula::DataSet props;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor> cursors;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool props;
    bool cursors;
  } __isset = {};
  bool operator==(const ScanResponse& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ScanResponse& __x, const ScanResponse& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ScanResponse& rhs) const;
#ifndef SWIG
  friend bool operator>(const ScanResponse& __x, const ScanResponse& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ScanResponse& __x, const ScanResponse& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ScanResponse& __x, const ScanResponse& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> result_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> result_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->result)};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> result_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> result_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->result)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> props_ref() const& {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> props_ref() const&& {
    return {std::move(this->props), __isset.props};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> props_ref() & {
    return {this->props, __isset.props};
  }

  template <typename..., typename T = nebula::DataSet>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> props_ref() && {
    return {std::move(this->props), __isset.props};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> cursors_ref() const& {
    return {this->cursors, __isset.cursors};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> cursors_ref() const&& {
    return {std::move(this->cursors), __isset.cursors};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> cursors_ref() & {
    return {this->cursors, __isset.cursors};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> cursors_ref() && {
    return {std::move(this->cursors), __isset.cursors};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::storage::cpp2::ResponseCommon& get_result() const&;
   ::nebula::storage::cpp2::ResponseCommon get_result() &&;

  template <typename T_ScanResponse_result_struct_setter =  ::nebula::storage::cpp2::ResponseCommon>
   ::nebula::storage::cpp2::ResponseCommon& set_result(T_ScanResponse_result_struct_setter&& result_) {
    result = std::forward<T_ScanResponse_result_struct_setter>(result_);
    return result;
  }
  const nebula::DataSet* get_props() const&;
  nebula::DataSet* get_props() &;
  nebula::DataSet* get_props() && = delete;

  template <typename T_ScanResponse_props_struct_setter = nebula::DataSet>
  nebula::DataSet& set_props(T_ScanResponse_props_struct_setter&& props_) {
    props = std::forward<T_ScanResponse_props_struct_setter>(props_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.props = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return props;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>& get_cursors() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor> get_cursors() &&;

  template <typename T_ScanResponse_cursors_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>>
  std::unordered_map< ::nebula::cpp2::PartitionID,  ::nebula::storage::cpp2::ScanCursor>& set_cursors(T_ScanResponse_cursors_struct_setter&& cursors_) {
    cursors = std::forward<T_ScanResponse_cursors_struct_setter>(cursors_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.cursors = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return cursors;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ScanResponse >;
  friend void swap(ScanResponse& a, ScanResponse& b);
};

template <class Protocol_>
uint32_t ScanResponse::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class TaskPara final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = TaskPara;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  TaskPara() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  TaskPara(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::vector< ::nebula::cpp2::PartitionID> parts__arg, ::std::vector<::std::string> task_specific_paras__arg);

  TaskPara(TaskPara&&) = default;

  TaskPara(const TaskPara&) = default;


  TaskPara& operator=(TaskPara&&) = default;

  TaskPara& operator=(const TaskPara&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::vector< ::nebula::cpp2::PartitionID> parts;
 private:
  ::std::vector<::std::string> task_specific_paras;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool parts;
    bool task_specific_paras;
  } __isset = {};
  bool operator==(const TaskPara& rhs) const;
#ifndef SWIG
  friend bool operator!=(const TaskPara& __x, const TaskPara& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const TaskPara& rhs) const;
#ifndef SWIG
  friend bool operator>(const TaskPara& __x, const TaskPara& __y) {
    return __y < __x;
  }
  friend bool operator<=(const TaskPara& __x, const TaskPara& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const TaskPara& __x, const TaskPara& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> parts_ref() const& {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> parts_ref() const&& {
    return {std::move(this->parts), __isset.parts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> parts_ref() & {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> parts_ref() && {
    return {std::move(this->parts), __isset.parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> task_specific_paras_ref() const& {
    return {this->task_specific_paras, __isset.task_specific_paras};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> task_specific_paras_ref() const&& {
    return {std::move(this->task_specific_paras), __isset.task_specific_paras};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> task_specific_paras_ref() & {
    return {this->task_specific_paras, __isset.task_specific_paras};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> task_specific_paras_ref() && {
    return {std::move(this->task_specific_paras), __isset.task_specific_paras};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const ::std::vector< ::nebula::cpp2::PartitionID>* get_parts() const&;
  ::std::vector< ::nebula::cpp2::PartitionID>* get_parts() &;
  ::std::vector< ::nebula::cpp2::PartitionID>* get_parts() && = delete;

  template <typename T_TaskPara_parts_struct_setter = ::std::vector< ::nebula::cpp2::PartitionID>>
  ::std::vector< ::nebula::cpp2::PartitionID>& set_parts(T_TaskPara_parts_struct_setter&& parts_) {
    parts = std::forward<T_TaskPara_parts_struct_setter>(parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return parts;
  }
  const ::std::vector<::std::string>* get_task_specific_paras() const&;
  ::std::vector<::std::string>* get_task_specific_paras() &;
  ::std::vector<::std::string>* get_task_specific_paras() && = delete;

  template <typename T_TaskPara_task_specific_paras_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_task_specific_paras(T_TaskPara_task_specific_paras_struct_setter&& task_specific_paras_) {
    task_specific_paras = std::forward<T_TaskPara_task_specific_paras_struct_setter>(task_specific_paras_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.task_specific_paras = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return task_specific_paras;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< TaskPara >;
  friend void swap(TaskPara& a, TaskPara& b);
};

template <class Protocol_>
uint32_t TaskPara::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class KVGetRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = KVGetRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  KVGetRequest() :
      space_id(0),
      return_partly(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  KVGetRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>> parts__arg, bool return_partly__arg);

  KVGetRequest(KVGetRequest&&) = default;

  KVGetRequest(const KVGetRequest&) = default;


  KVGetRequest& operator=(KVGetRequest&&) = default;

  KVGetRequest& operator=(const KVGetRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>> parts;
 private:
  bool return_partly;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool parts;
    bool return_partly;
  } __isset = {};
  bool operator==(const KVGetRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const KVGetRequest& __x, const KVGetRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const KVGetRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const KVGetRequest& __x, const KVGetRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const KVGetRequest& __x, const KVGetRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const KVGetRequest& __x, const KVGetRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> parts_ref() const& {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> parts_ref() const&& {
    return {std::move(this->parts), __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> parts_ref() & {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> parts_ref() && {
    return {std::move(this->parts), __isset.parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> return_partly_ref() const& {
    return {this->return_partly, __isset.return_partly};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> return_partly_ref() const&& {
    return {std::move(this->return_partly), __isset.return_partly};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> return_partly_ref() & {
    return {this->return_partly, __isset.return_partly};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> return_partly_ref() && {
    return {std::move(this->return_partly), __isset.return_partly};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>& get_parts() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>> get_parts() &&;

  template <typename T_KVGetRequest_parts_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>>
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>& set_parts(T_KVGetRequest_parts_struct_setter&& parts_) {
    parts = std::forward<T_KVGetRequest_parts_struct_setter>(parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return parts;
  }

  bool get_return_partly() const {
    return return_partly;
  }

  bool& set_return_partly(bool return_partly_) {
    return_partly = return_partly_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.return_partly = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return return_partly;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< KVGetRequest >;
  friend void swap(KVGetRequest& a, KVGetRequest& b);
};

template <class Protocol_>
uint32_t KVGetRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class KVGetResponse final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = KVGetResponse;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  KVGetResponse() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  KVGetResponse(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg, std::unordered_map<::std::string, ::std::string> key_values__arg);

  KVGetResponse(KVGetResponse&&) = default;

  KVGetResponse(const KVGetResponse&) = default;


  KVGetResponse& operator=(KVGetResponse&&) = default;

  KVGetResponse& operator=(const KVGetResponse&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
   ::nebula::storage::cpp2::ResponseCommon result;
 private:
  std::unordered_map<::std::string, ::std::string> key_values;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool key_values;
  } __isset = {};
  bool operator==(const KVGetResponse& rhs) const;
#ifndef SWIG
  friend bool operator!=(const KVGetResponse& __x, const KVGetResponse& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const KVGetResponse& rhs) const;
#ifndef SWIG
  friend bool operator>(const KVGetResponse& __x, const KVGetResponse& __y) {
    return __y < __x;
  }
  friend bool operator<=(const KVGetResponse& __x, const KVGetResponse& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const KVGetResponse& __x, const KVGetResponse& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> result_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> result_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->result)};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> result_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> result_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->result)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> key_values_ref() const& {
    return {this->key_values, __isset.key_values};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> key_values_ref() const&& {
    return {std::move(this->key_values), __isset.key_values};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> key_values_ref() & {
    return {this->key_values, __isset.key_values};
  }

  template <typename..., typename T = std::unordered_map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> key_values_ref() && {
    return {std::move(this->key_values), __isset.key_values};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::storage::cpp2::ResponseCommon& get_result() const&;
   ::nebula::storage::cpp2::ResponseCommon get_result() &&;

  template <typename T_KVGetResponse_result_struct_setter =  ::nebula::storage::cpp2::ResponseCommon>
   ::nebula::storage::cpp2::ResponseCommon& set_result(T_KVGetResponse_result_struct_setter&& result_) {
    result = std::forward<T_KVGetResponse_result_struct_setter>(result_);
    return result;
  }
  const std::unordered_map<::std::string, ::std::string>& get_key_values() const&;
  std::unordered_map<::std::string, ::std::string> get_key_values() &&;

  template <typename T_KVGetResponse_key_values_struct_setter = std::unordered_map<::std::string, ::std::string>>
  std::unordered_map<::std::string, ::std::string>& set_key_values(T_KVGetResponse_key_values_struct_setter&& key_values_) {
    key_values = std::forward<T_KVGetResponse_key_values_struct_setter>(key_values_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.key_values = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return key_values;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< KVGetResponse >;
  friend void swap(KVGetResponse& a, KVGetResponse& b);
};

template <class Protocol_>
uint32_t KVGetResponse::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class KVPutRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = KVPutRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  KVPutRequest() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  KVPutRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>> parts__arg);

  KVPutRequest(KVPutRequest&&) = default;

  KVPutRequest(const KVPutRequest&) = default;


  KVPutRequest& operator=(KVPutRequest&&) = default;

  KVPutRequest& operator=(const KVPutRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>> parts;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool parts;
  } __isset = {};
  bool operator==(const KVPutRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const KVPutRequest& __x, const KVPutRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const KVPutRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const KVPutRequest& __x, const KVPutRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const KVPutRequest& __x, const KVPutRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const KVPutRequest& __x, const KVPutRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> parts_ref() const& {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> parts_ref() const&& {
    return {std::move(this->parts), __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> parts_ref() & {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> parts_ref() && {
    return {std::move(this->parts), __isset.parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>>& get_parts() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>> get_parts() &&;

  template <typename T_KVPutRequest_parts_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>>>
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<nebula::KeyValue>>& set_parts(T_KVPutRequest_parts_struct_setter&& parts_) {
    parts = std::forward<T_KVPutRequest_parts_struct_setter>(parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return parts;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< KVPutRequest >;
  friend void swap(KVPutRequest& a, KVPutRequest& b);
};

template <class Protocol_>
uint32_t KVPutRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class KVRemoveRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = KVRemoveRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  KVRemoveRequest() :
      space_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  KVRemoveRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>> parts__arg);

  KVRemoveRequest(KVRemoveRequest&&) = default;

  KVRemoveRequest(const KVRemoveRequest&) = default;


  KVRemoveRequest& operator=(KVRemoveRequest&&) = default;

  KVRemoveRequest& operator=(const KVRemoveRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>> parts;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool parts;
  } __isset = {};
  bool operator==(const KVRemoveRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const KVRemoveRequest& __x, const KVRemoveRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const KVRemoveRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const KVRemoveRequest& __x, const KVRemoveRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const KVRemoveRequest& __x, const KVRemoveRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const KVRemoveRequest& __x, const KVRemoveRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> parts_ref() const& {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> parts_ref() const&& {
    return {std::move(this->parts), __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> parts_ref() & {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> parts_ref() && {
    return {std::move(this->parts), __isset.parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>& get_parts() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>> get_parts() &&;

  template <typename T_KVRemoveRequest_parts_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>>
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector<::std::string>>& set_parts(T_KVRemoveRequest_parts_struct_setter&& parts_) {
    parts = std::forward<T_KVRemoveRequest_parts_struct_setter>(parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return parts;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< KVRemoveRequest >;
  friend void swap(KVRemoveRequest& a, KVRemoveRequest& b);
};

template <class Protocol_>
uint32_t KVRemoveRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class AdminExecResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AdminExecResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  AdminExecResp() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AdminExecResp(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg,  ::nebula::meta::cpp2::StatsItem stats__arg);

  AdminExecResp(AdminExecResp&&) = default;

  AdminExecResp(const AdminExecResp&) = default;


  AdminExecResp& operator=(AdminExecResp&&) = default;

  AdminExecResp& operator=(const AdminExecResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
   ::nebula::storage::cpp2::ResponseCommon result;
 private:
   ::nebula::meta::cpp2::StatsItem stats;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool stats;
  } __isset = {};
  bool operator==(const AdminExecResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AdminExecResp& __x, const AdminExecResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AdminExecResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const AdminExecResp& __x, const AdminExecResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AdminExecResp& __x, const AdminExecResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AdminExecResp& __x, const AdminExecResp& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> result_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> result_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->result)};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> result_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> result_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->result)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::StatsItem>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> stats_ref() const& {
    return {this->stats, __isset.stats};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::StatsItem>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> stats_ref() const&& {
    return {std::move(this->stats), __isset.stats};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::StatsItem>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> stats_ref() & {
    return {this->stats, __isset.stats};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::StatsItem>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> stats_ref() && {
    return {std::move(this->stats), __isset.stats};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::storage::cpp2::ResponseCommon& get_result() const&;
   ::nebula::storage::cpp2::ResponseCommon get_result() &&;

  template <typename T_AdminExecResp_result_struct_setter =  ::nebula::storage::cpp2::ResponseCommon>
   ::nebula::storage::cpp2::ResponseCommon& set_result(T_AdminExecResp_result_struct_setter&& result_) {
    result = std::forward<T_AdminExecResp_result_struct_setter>(result_);
    return result;
  }
  const  ::nebula::meta::cpp2::StatsItem* get_stats() const&;
   ::nebula::meta::cpp2::StatsItem* get_stats() &;
   ::nebula::meta::cpp2::StatsItem* get_stats() && = delete;

  template <typename T_AdminExecResp_stats_struct_setter =  ::nebula::meta::cpp2::StatsItem>
   ::nebula::meta::cpp2::StatsItem& set_stats(T_AdminExecResp_stats_struct_setter&& stats_) {
    stats = std::forward<T_AdminExecResp_stats_struct_setter>(stats_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.stats = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return stats;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AdminExecResp >;
  friend void swap(AdminExecResp& a, AdminExecResp& b);
};

template <class Protocol_>
uint32_t AdminExecResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class TransLeaderReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = TransLeaderReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  TransLeaderReq() :
      space_id(0),
      part_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  TransLeaderReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg, nebula::HostAddr new_leader__arg);

  TransLeaderReq(TransLeaderReq&&) = default;

  TransLeaderReq(const TransLeaderReq&) = default;


  TransLeaderReq& operator=(TransLeaderReq&&) = default;

  TransLeaderReq& operator=(const TransLeaderReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
   ::nebula::cpp2::PartitionID part_id;
 private:
  nebula::HostAddr new_leader;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool part_id;
    bool new_leader;
  } __isset = {};
  bool operator==(const TransLeaderReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const TransLeaderReq& __x, const TransLeaderReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const TransLeaderReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const TransLeaderReq& __x, const TransLeaderReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const TransLeaderReq& __x, const TransLeaderReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const TransLeaderReq& __x, const TransLeaderReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> part_id_ref() const& {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> part_id_ref() const&& {
    return {std::move(this->part_id), __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> part_id_ref() & {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> part_id_ref() && {
    return {std::move(this->part_id), __isset.part_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> new_leader_ref() const& {
    return {this->new_leader, __isset.new_leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> new_leader_ref() const&& {
    return {std::move(this->new_leader), __isset.new_leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> new_leader_ref() & {
    return {this->new_leader, __isset.new_leader};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> new_leader_ref() && {
    return {std::move(this->new_leader), __isset.new_leader};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

   ::nebula::cpp2::PartitionID get_part_id() const {
    return part_id;
  }

   ::nebula::cpp2::PartitionID& set_part_id( ::nebula::cpp2::PartitionID part_id_) {
    part_id = part_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.part_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return part_id;
  }
  const nebula::HostAddr& get_new_leader() const&;
  nebula::HostAddr get_new_leader() &&;

  template <typename T_TransLeaderReq_new_leader_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_new_leader(T_TransLeaderReq_new_leader_struct_setter&& new_leader_) {
    new_leader = std::forward<T_TransLeaderReq_new_leader_struct_setter>(new_leader_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.new_leader = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return new_leader;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< TransLeaderReq >;
  friend void swap(TransLeaderReq& a, TransLeaderReq& b);
};

template <class Protocol_>
uint32_t TransLeaderReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class AddPartReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AddPartReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  AddPartReq() :
      space_id(0),
      part_id(0),
      as_learner(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AddPartReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg, bool as_learner__arg, ::std::vector<nebula::HostAddr> peers__arg);

  AddPartReq(AddPartReq&&) = default;

  AddPartReq(const AddPartReq&) = default;


  AddPartReq& operator=(AddPartReq&&) = default;

  AddPartReq& operator=(const AddPartReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
   ::nebula::cpp2::PartitionID part_id;
 private:
  bool as_learner;
 private:
  ::std::vector<nebula::HostAddr> peers;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool part_id;
    bool as_learner;
    bool peers;
  } __isset = {};
  bool operator==(const AddPartReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AddPartReq& __x, const AddPartReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AddPartReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const AddPartReq& __x, const AddPartReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AddPartReq& __x, const AddPartReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AddPartReq& __x, const AddPartReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> part_id_ref() const& {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> part_id_ref() const&& {
    return {std::move(this->part_id), __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> part_id_ref() & {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> part_id_ref() && {
    return {std::move(this->part_id), __isset.part_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> as_learner_ref() const& {
    return {this->as_learner, __isset.as_learner};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> as_learner_ref() const&& {
    return {std::move(this->as_learner), __isset.as_learner};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> as_learner_ref() & {
    return {this->as_learner, __isset.as_learner};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> as_learner_ref() && {
    return {std::move(this->as_learner), __isset.as_learner};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> peers_ref() const& {
    return {this->peers, __isset.peers};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> peers_ref() const&& {
    return {std::move(this->peers), __isset.peers};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> peers_ref() & {
    return {this->peers, __isset.peers};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> peers_ref() && {
    return {std::move(this->peers), __isset.peers};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

   ::nebula::cpp2::PartitionID get_part_id() const {
    return part_id;
  }

   ::nebula::cpp2::PartitionID& set_part_id( ::nebula::cpp2::PartitionID part_id_) {
    part_id = part_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.part_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return part_id;
  }

  bool get_as_learner() const {
    return as_learner;
  }

  bool& set_as_learner(bool as_learner_) {
    as_learner = as_learner_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.as_learner = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return as_learner;
  }
  const ::std::vector<nebula::HostAddr>& get_peers() const&;
  ::std::vector<nebula::HostAddr> get_peers() &&;

  template <typename T_AddPartReq_peers_struct_setter = ::std::vector<nebula::HostAddr>>
  ::std::vector<nebula::HostAddr>& set_peers(T_AddPartReq_peers_struct_setter&& peers_) {
    peers = std::forward<T_AddPartReq_peers_struct_setter>(peers_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.peers = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return peers;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AddPartReq >;
  friend void swap(AddPartReq& a, AddPartReq& b);
};

template <class Protocol_>
uint32_t AddPartReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class AddLearnerReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AddLearnerReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  AddLearnerReq() :
      space_id(0),
      part_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AddLearnerReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg, nebula::HostAddr learner__arg);

  AddLearnerReq(AddLearnerReq&&) = default;

  AddLearnerReq(const AddLearnerReq&) = default;


  AddLearnerReq& operator=(AddLearnerReq&&) = default;

  AddLearnerReq& operator=(const AddLearnerReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
   ::nebula::cpp2::PartitionID part_id;
 private:
  nebula::HostAddr learner;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool part_id;
    bool learner;
  } __isset = {};
  bool operator==(const AddLearnerReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AddLearnerReq& __x, const AddLearnerReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AddLearnerReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const AddLearnerReq& __x, const AddLearnerReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AddLearnerReq& __x, const AddLearnerReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AddLearnerReq& __x, const AddLearnerReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> part_id_ref() const& {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> part_id_ref() const&& {
    return {std::move(this->part_id), __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> part_id_ref() & {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> part_id_ref() && {
    return {std::move(this->part_id), __isset.part_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> learner_ref() const& {
    return {this->learner, __isset.learner};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> learner_ref() const&& {
    return {std::move(this->learner), __isset.learner};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> learner_ref() & {
    return {this->learner, __isset.learner};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> learner_ref() && {
    return {std::move(this->learner), __isset.learner};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

   ::nebula::cpp2::PartitionID get_part_id() const {
    return part_id;
  }

   ::nebula::cpp2::PartitionID& set_part_id( ::nebula::cpp2::PartitionID part_id_) {
    part_id = part_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.part_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return part_id;
  }
  const nebula::HostAddr& get_learner() const&;
  nebula::HostAddr get_learner() &&;

  template <typename T_AddLearnerReq_learner_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_learner(T_AddLearnerReq_learner_struct_setter&& learner_) {
    learner = std::forward<T_AddLearnerReq_learner_struct_setter>(learner_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.learner = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return learner;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AddLearnerReq >;
  friend void swap(AddLearnerReq& a, AddLearnerReq& b);
};

template <class Protocol_>
uint32_t AddLearnerReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class RemovePartReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = RemovePartReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  RemovePartReq() :
      space_id(0),
      part_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RemovePartReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg);

  RemovePartReq(RemovePartReq&&) = default;

  RemovePartReq(const RemovePartReq&) = default;


  RemovePartReq& operator=(RemovePartReq&&) = default;

  RemovePartReq& operator=(const RemovePartReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
   ::nebula::cpp2::PartitionID part_id;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool part_id;
  } __isset = {};
  bool operator==(const RemovePartReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const RemovePartReq& __x, const RemovePartReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const RemovePartReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const RemovePartReq& __x, const RemovePartReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const RemovePartReq& __x, const RemovePartReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const RemovePartReq& __x, const RemovePartReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> part_id_ref() const& {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> part_id_ref() const&& {
    return {std::move(this->part_id), __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> part_id_ref() & {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> part_id_ref() && {
    return {std::move(this->part_id), __isset.part_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

   ::nebula::cpp2::PartitionID get_part_id() const {
    return part_id;
  }

   ::nebula::cpp2::PartitionID& set_part_id( ::nebula::cpp2::PartitionID part_id_) {
    part_id = part_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.part_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return part_id;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< RemovePartReq >;
  friend void swap(RemovePartReq& a, RemovePartReq& b);
};

template <class Protocol_>
uint32_t RemovePartReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class MemberChangeReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = MemberChangeReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  MemberChangeReq() :
      space_id(0),
      part_id(0),
      add(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  MemberChangeReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg, nebula::HostAddr peer__arg, bool add__arg);

  MemberChangeReq(MemberChangeReq&&) = default;

  MemberChangeReq(const MemberChangeReq&) = default;


  MemberChangeReq& operator=(MemberChangeReq&&) = default;

  MemberChangeReq& operator=(const MemberChangeReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
   ::nebula::cpp2::PartitionID part_id;
 private:
  nebula::HostAddr peer;
 private:
  bool add;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool part_id;
    bool peer;
    bool add;
  } __isset = {};
  bool operator==(const MemberChangeReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const MemberChangeReq& __x, const MemberChangeReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const MemberChangeReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const MemberChangeReq& __x, const MemberChangeReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const MemberChangeReq& __x, const MemberChangeReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const MemberChangeReq& __x, const MemberChangeReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> part_id_ref() const& {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> part_id_ref() const&& {
    return {std::move(this->part_id), __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> part_id_ref() & {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> part_id_ref() && {
    return {std::move(this->part_id), __isset.part_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> peer_ref() const& {
    return {this->peer, __isset.peer};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> peer_ref() const&& {
    return {std::move(this->peer), __isset.peer};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> peer_ref() & {
    return {this->peer, __isset.peer};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> peer_ref() && {
    return {std::move(this->peer), __isset.peer};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> add_ref() const& {
    return {this->add, __isset.add};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> add_ref() const&& {
    return {std::move(this->add), __isset.add};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> add_ref() & {
    return {this->add, __isset.add};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> add_ref() && {
    return {std::move(this->add), __isset.add};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

   ::nebula::cpp2::PartitionID get_part_id() const {
    return part_id;
  }

   ::nebula::cpp2::PartitionID& set_part_id( ::nebula::cpp2::PartitionID part_id_) {
    part_id = part_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.part_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return part_id;
  }
  const nebula::HostAddr& get_peer() const&;
  nebula::HostAddr get_peer() &&;

  template <typename T_MemberChangeReq_peer_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_peer(T_MemberChangeReq_peer_struct_setter&& peer_) {
    peer = std::forward<T_MemberChangeReq_peer_struct_setter>(peer_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.peer = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return peer;
  }

  bool get_add() const {
    return add;
  }

  bool& set_add(bool add_) {
    add = add_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.add = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return add;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< MemberChangeReq >;
  friend void swap(MemberChangeReq& a, MemberChangeReq& b);
};

template <class Protocol_>
uint32_t MemberChangeReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class CatchUpDataReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CatchUpDataReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  CatchUpDataReq() :
      space_id(0),
      part_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CatchUpDataReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg, nebula::HostAddr target__arg);

  CatchUpDataReq(CatchUpDataReq&&) = default;

  CatchUpDataReq(const CatchUpDataReq&) = default;


  CatchUpDataReq& operator=(CatchUpDataReq&&) = default;

  CatchUpDataReq& operator=(const CatchUpDataReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
   ::nebula::cpp2::PartitionID part_id;
 private:
  nebula::HostAddr target;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool part_id;
    bool target;
  } __isset = {};
  bool operator==(const CatchUpDataReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CatchUpDataReq& __x, const CatchUpDataReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CatchUpDataReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const CatchUpDataReq& __x, const CatchUpDataReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CatchUpDataReq& __x, const CatchUpDataReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CatchUpDataReq& __x, const CatchUpDataReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> part_id_ref() const& {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> part_id_ref() const&& {
    return {std::move(this->part_id), __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> part_id_ref() & {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> part_id_ref() && {
    return {std::move(this->part_id), __isset.part_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> target_ref() const& {
    return {this->target, __isset.target};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> target_ref() const&& {
    return {std::move(this->target), __isset.target};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> target_ref() & {
    return {this->target, __isset.target};
  }

  template <typename..., typename T = nebula::HostAddr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> target_ref() && {
    return {std::move(this->target), __isset.target};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

   ::nebula::cpp2::PartitionID get_part_id() const {
    return part_id;
  }

   ::nebula::cpp2::PartitionID& set_part_id( ::nebula::cpp2::PartitionID part_id_) {
    part_id = part_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.part_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return part_id;
  }
  const nebula::HostAddr& get_target() const&;
  nebula::HostAddr get_target() &&;

  template <typename T_CatchUpDataReq_target_struct_setter = nebula::HostAddr>
  nebula::HostAddr& set_target(T_CatchUpDataReq_target_struct_setter&& target_) {
    target = std::forward<T_CatchUpDataReq_target_struct_setter>(target_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.target = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return target;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CatchUpDataReq >;
  friend void swap(CatchUpDataReq& a, CatchUpDataReq& b);
};

template <class Protocol_>
uint32_t CatchUpDataReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class GetLeaderReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetLeaderReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetLeaderReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetLeaderReq(apache::thrift::FragileConstructor);

  GetLeaderReq(GetLeaderReq&&) = default;

  GetLeaderReq(const GetLeaderReq&) = default;


  GetLeaderReq& operator=(GetLeaderReq&&) = default;

  GetLeaderReq& operator=(const GetLeaderReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
  bool operator==(const GetLeaderReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetLeaderReq& __x, const GetLeaderReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetLeaderReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetLeaderReq& __x, const GetLeaderReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetLeaderReq& __x, const GetLeaderReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetLeaderReq& __x, const GetLeaderReq& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetLeaderReq >;
  friend void swap(GetLeaderReq& a, GetLeaderReq& b);
};

template <class Protocol_>
uint32_t GetLeaderReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class CreateCPRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CreateCPRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  CreateCPRequest() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CreateCPRequest(apache::thrift::FragileConstructor, ::std::vector< ::nebula::cpp2::GraphSpaceID> space_ids__arg, ::std::string name__arg);

  CreateCPRequest(CreateCPRequest&&) = default;

  CreateCPRequest(const CreateCPRequest&) = default;


  CreateCPRequest& operator=(CreateCPRequest&&) = default;

  CreateCPRequest& operator=(const CreateCPRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector< ::nebula::cpp2::GraphSpaceID> space_ids;
 private:
  ::std::string name;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_ids;
    bool name;
  } __isset = {};
  bool operator==(const CreateCPRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CreateCPRequest& __x, const CreateCPRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CreateCPRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const CreateCPRequest& __x, const CreateCPRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CreateCPRequest& __x, const CreateCPRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CreateCPRequest& __x, const CreateCPRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::cpp2::GraphSpaceID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_ids_ref() const& {
    return {this->space_ids, __isset.space_ids};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::GraphSpaceID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_ids_ref() const&& {
    return {std::move(this->space_ids), __isset.space_ids};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::GraphSpaceID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_ids_ref() & {
    return {this->space_ids, __isset.space_ids};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::GraphSpaceID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_ids_ref() && {
    return {std::move(this->space_ids), __isset.space_ids};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector< ::nebula::cpp2::GraphSpaceID>& get_space_ids() const&;
  ::std::vector< ::nebula::cpp2::GraphSpaceID> get_space_ids() &&;

  template <typename T_CreateCPRequest_space_ids_struct_setter = ::std::vector< ::nebula::cpp2::GraphSpaceID>>
  ::std::vector< ::nebula::cpp2::GraphSpaceID>& set_space_ids(T_CreateCPRequest_space_ids_struct_setter&& space_ids_) {
    space_ids = std::forward<T_CreateCPRequest_space_ids_struct_setter>(space_ids_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_ids = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_ids;
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_CreateCPRequest_name_struct_setter = ::std::string>
  ::std::string& set_name(T_CreateCPRequest_name_struct_setter&& name_) {
    name = std::forward<T_CreateCPRequest_name_struct_setter>(name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CreateCPRequest >;
  friend void swap(CreateCPRequest& a, CreateCPRequest& b);
};

template <class Protocol_>
uint32_t CreateCPRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class DropCPRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = DropCPRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  DropCPRequest() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  DropCPRequest(apache::thrift::FragileConstructor, ::std::vector< ::nebula::cpp2::GraphSpaceID> space_ids__arg, ::std::string name__arg);

  DropCPRequest(DropCPRequest&&) = default;

  DropCPRequest(const DropCPRequest&) = default;


  DropCPRequest& operator=(DropCPRequest&&) = default;

  DropCPRequest& operator=(const DropCPRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector< ::nebula::cpp2::GraphSpaceID> space_ids;
 private:
  ::std::string name;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_ids;
    bool name;
  } __isset = {};
  bool operator==(const DropCPRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const DropCPRequest& __x, const DropCPRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const DropCPRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const DropCPRequest& __x, const DropCPRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const DropCPRequest& __x, const DropCPRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const DropCPRequest& __x, const DropCPRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::cpp2::GraphSpaceID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_ids_ref() const& {
    return {this->space_ids, __isset.space_ids};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::GraphSpaceID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_ids_ref() const&& {
    return {std::move(this->space_ids), __isset.space_ids};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::GraphSpaceID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_ids_ref() & {
    return {this->space_ids, __isset.space_ids};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::GraphSpaceID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_ids_ref() && {
    return {std::move(this->space_ids), __isset.space_ids};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::vector< ::nebula::cpp2::GraphSpaceID>& get_space_ids() const&;
  ::std::vector< ::nebula::cpp2::GraphSpaceID> get_space_ids() &&;

  template <typename T_DropCPRequest_space_ids_struct_setter = ::std::vector< ::nebula::cpp2::GraphSpaceID>>
  ::std::vector< ::nebula::cpp2::GraphSpaceID>& set_space_ids(T_DropCPRequest_space_ids_struct_setter&& space_ids_) {
    space_ids = std::forward<T_DropCPRequest_space_ids_struct_setter>(space_ids_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_ids = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_ids;
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_DropCPRequest_name_struct_setter = ::std::string>
  ::std::string& set_name(T_DropCPRequest_name_struct_setter&& name_) {
    name = std::forward<T_DropCPRequest_name_struct_setter>(name_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.name = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< DropCPRequest >;
  friend void swap(DropCPRequest& a, DropCPRequest& b);
};

template <class Protocol_>
uint32_t DropCPRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class BlockingSignRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = BlockingSignRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  BlockingSignRequest() :
      sign(static_cast< ::nebula::storage::cpp2::EngineSignType>(0)) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  BlockingSignRequest(apache::thrift::FragileConstructor, ::std::vector< ::nebula::cpp2::GraphSpaceID> space_ids__arg,  ::nebula::storage::cpp2::EngineSignType sign__arg);

  BlockingSignRequest(BlockingSignRequest&&) = default;

  BlockingSignRequest(const BlockingSignRequest&) = default;


  BlockingSignRequest& operator=(BlockingSignRequest&&) = default;

  BlockingSignRequest& operator=(const BlockingSignRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  ::std::vector< ::nebula::cpp2::GraphSpaceID> space_ids;
 public:
   ::nebula::storage::cpp2::EngineSignType sign;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_ids;
  } __isset = {};
  bool operator==(const BlockingSignRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const BlockingSignRequest& __x, const BlockingSignRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const BlockingSignRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const BlockingSignRequest& __x, const BlockingSignRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const BlockingSignRequest& __x, const BlockingSignRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const BlockingSignRequest& __x, const BlockingSignRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::cpp2::GraphSpaceID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_ids_ref() const& {
    return {this->space_ids, __isset.space_ids};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::GraphSpaceID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_ids_ref() const&& {
    return {std::move(this->space_ids), __isset.space_ids};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::GraphSpaceID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_ids_ref() & {
    return {this->space_ids, __isset.space_ids};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::GraphSpaceID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_ids_ref() && {
    return {std::move(this->space_ids), __isset.space_ids};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  template <typename..., typename T =  ::nebula::storage::cpp2::EngineSignType>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> sign_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->sign};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::EngineSignType>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> sign_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->sign)};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::EngineSignType>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> sign_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->sign};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::EngineSignType>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> sign_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->sign)};
  }
  const ::std::vector< ::nebula::cpp2::GraphSpaceID>& get_space_ids() const&;
  ::std::vector< ::nebula::cpp2::GraphSpaceID> get_space_ids() &&;

  template <typename T_BlockingSignRequest_space_ids_struct_setter = ::std::vector< ::nebula::cpp2::GraphSpaceID>>
  ::std::vector< ::nebula::cpp2::GraphSpaceID>& set_space_ids(T_BlockingSignRequest_space_ids_struct_setter&& space_ids_) {
    space_ids = std::forward<T_BlockingSignRequest_space_ids_struct_setter>(space_ids_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_ids = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_ids;
  }

   ::nebula::storage::cpp2::EngineSignType get_sign() const {
    return sign;
  }

   ::nebula::storage::cpp2::EngineSignType& set_sign( ::nebula::storage::cpp2::EngineSignType sign_) {
    sign = sign_;
    return sign;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< BlockingSignRequest >;
  friend void swap(BlockingSignRequest& a, BlockingSignRequest& b);
};

template <class Protocol_>
uint32_t BlockingSignRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class GetLeaderPartsResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = GetLeaderPartsResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  GetLeaderPartsResp() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  GetLeaderPartsResp(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg, std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::cpp2::PartitionID>> leader_parts__arg);

  GetLeaderPartsResp(GetLeaderPartsResp&&) = default;

  GetLeaderPartsResp(const GetLeaderPartsResp&) = default;


  GetLeaderPartsResp& operator=(GetLeaderPartsResp&&) = default;

  GetLeaderPartsResp& operator=(const GetLeaderPartsResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
   ::nebula::storage::cpp2::ResponseCommon result;
 private:
  std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::cpp2::PartitionID>> leader_parts;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool leader_parts;
  } __isset = {};
  bool operator==(const GetLeaderPartsResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const GetLeaderPartsResp& __x, const GetLeaderPartsResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const GetLeaderPartsResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const GetLeaderPartsResp& __x, const GetLeaderPartsResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const GetLeaderPartsResp& __x, const GetLeaderPartsResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const GetLeaderPartsResp& __x, const GetLeaderPartsResp& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> result_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> result_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->result)};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> result_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> result_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->result)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::cpp2::PartitionID>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leader_parts_ref() const& {
    return {this->leader_parts, __isset.leader_parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::cpp2::PartitionID>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leader_parts_ref() const&& {
    return {std::move(this->leader_parts), __isset.leader_parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::cpp2::PartitionID>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leader_parts_ref() & {
    return {this->leader_parts, __isset.leader_parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::cpp2::PartitionID>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leader_parts_ref() && {
    return {std::move(this->leader_parts), __isset.leader_parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::storage::cpp2::ResponseCommon& get_result() const&;
   ::nebula::storage::cpp2::ResponseCommon get_result() &&;

  template <typename T_GetLeaderPartsResp_result_struct_setter =  ::nebula::storage::cpp2::ResponseCommon>
   ::nebula::storage::cpp2::ResponseCommon& set_result(T_GetLeaderPartsResp_result_struct_setter&& result_) {
    result = std::forward<T_GetLeaderPartsResp_result_struct_setter>(result_);
    return result;
  }
  const std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::cpp2::PartitionID>>& get_leader_parts() const&;
  std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::cpp2::PartitionID>> get_leader_parts() &&;

  template <typename T_GetLeaderPartsResp_leader_parts_struct_setter = std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::cpp2::PartitionID>>>
  std::unordered_map< ::nebula::cpp2::GraphSpaceID, ::std::vector< ::nebula::cpp2::PartitionID>>& set_leader_parts(T_GetLeaderPartsResp_leader_parts_struct_setter&& leader_parts_) {
    leader_parts = std::forward<T_GetLeaderPartsResp_leader_parts_struct_setter>(leader_parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.leader_parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return leader_parts;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetLeaderPartsResp >;
  friend void swap(GetLeaderPartsResp& a, GetLeaderPartsResp& b);
};

template <class Protocol_>
uint32_t GetLeaderPartsResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class CheckPeersReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CheckPeersReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  CheckPeersReq() :
      space_id(0),
      part_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CheckPeersReq(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg,  ::nebula::cpp2::PartitionID part_id__arg, ::std::vector<nebula::HostAddr> peers__arg);

  CheckPeersReq(CheckPeersReq&&) = default;

  CheckPeersReq(const CheckPeersReq&) = default;


  CheckPeersReq& operator=(CheckPeersReq&&) = default;

  CheckPeersReq& operator=(const CheckPeersReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
   ::nebula::cpp2::PartitionID part_id;
 private:
  ::std::vector<nebula::HostAddr> peers;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool part_id;
    bool peers;
  } __isset = {};
  bool operator==(const CheckPeersReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CheckPeersReq& __x, const CheckPeersReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CheckPeersReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const CheckPeersReq& __x, const CheckPeersReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CheckPeersReq& __x, const CheckPeersReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CheckPeersReq& __x, const CheckPeersReq& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> part_id_ref() const& {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> part_id_ref() const&& {
    return {std::move(this->part_id), __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> part_id_ref() & {
    return {this->part_id, __isset.part_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::PartitionID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> part_id_ref() && {
    return {std::move(this->part_id), __isset.part_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> peers_ref() const& {
    return {this->peers, __isset.peers};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> peers_ref() const&& {
    return {std::move(this->peers), __isset.peers};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> peers_ref() & {
    return {this->peers, __isset.peers};
  }

  template <typename..., typename T = ::std::vector<nebula::HostAddr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> peers_ref() && {
    return {std::move(this->peers), __isset.peers};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }

   ::nebula::cpp2::PartitionID get_part_id() const {
    return part_id;
  }

   ::nebula::cpp2::PartitionID& set_part_id( ::nebula::cpp2::PartitionID part_id_) {
    part_id = part_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.part_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return part_id;
  }
  const ::std::vector<nebula::HostAddr>& get_peers() const&;
  ::std::vector<nebula::HostAddr> get_peers() &&;

  template <typename T_CheckPeersReq_peers_struct_setter = ::std::vector<nebula::HostAddr>>
  ::std::vector<nebula::HostAddr>& set_peers(T_CheckPeersReq_peers_struct_setter&& peers_) {
    peers = std::forward<T_CheckPeersReq_peers_struct_setter>(peers_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.peers = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return peers;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CheckPeersReq >;
  friend void swap(CheckPeersReq& a, CheckPeersReq& b);
};

template <class Protocol_>
uint32_t CheckPeersReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class RebuildIndexRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = RebuildIndexRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  RebuildIndexRequest() :
      space_id(0),
      index_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RebuildIndexRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::vector< ::nebula::cpp2::PartitionID> parts__arg,  ::nebula::cpp2::IndexID index_id__arg);

  RebuildIndexRequest(RebuildIndexRequest&&) = default;

  RebuildIndexRequest(const RebuildIndexRequest&) = default;


  RebuildIndexRequest& operator=(RebuildIndexRequest&&) = default;

  RebuildIndexRequest& operator=(const RebuildIndexRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  ::std::vector< ::nebula::cpp2::PartitionID> parts;
 private:
   ::nebula::cpp2::IndexID index_id;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool parts;
    bool index_id;
  } __isset = {};
  bool operator==(const RebuildIndexRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const RebuildIndexRequest& __x, const RebuildIndexRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const RebuildIndexRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const RebuildIndexRequest& __x, const RebuildIndexRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const RebuildIndexRequest& __x, const RebuildIndexRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const RebuildIndexRequest& __x, const RebuildIndexRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> parts_ref() const& {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> parts_ref() const&& {
    return {std::move(this->parts), __isset.parts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> parts_ref() & {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> parts_ref() && {
    return {std::move(this->parts), __isset.parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::IndexID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> index_id_ref() const& {
    return {this->index_id, __isset.index_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::IndexID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> index_id_ref() const&& {
    return {std::move(this->index_id), __isset.index_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::IndexID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> index_id_ref() & {
    return {this->index_id, __isset.index_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::IndexID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> index_id_ref() && {
    return {std::move(this->index_id), __isset.index_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const ::std::vector< ::nebula::cpp2::PartitionID>& get_parts() const&;
  ::std::vector< ::nebula::cpp2::PartitionID> get_parts() &&;

  template <typename T_RebuildIndexRequest_parts_struct_setter = ::std::vector< ::nebula::cpp2::PartitionID>>
  ::std::vector< ::nebula::cpp2::PartitionID>& set_parts(T_RebuildIndexRequest_parts_struct_setter&& parts_) {
    parts = std::forward<T_RebuildIndexRequest_parts_struct_setter>(parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return parts;
  }

   ::nebula::cpp2::IndexID get_index_id() const {
    return index_id;
  }

   ::nebula::cpp2::IndexID& set_index_id( ::nebula::cpp2::IndexID index_id_) {
    index_id = index_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.index_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return index_id;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< RebuildIndexRequest >;
  friend void swap(RebuildIndexRequest& a, RebuildIndexRequest& b);
};

template <class Protocol_>
uint32_t RebuildIndexRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class CreateCPResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CreateCPResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  CreateCPResp() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CreateCPResp(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg, ::std::vector< ::nebula::cpp2::CheckpointInfo> info__arg);

  CreateCPResp(CreateCPResp&&) = default;

  CreateCPResp(const CreateCPResp&) = default;


  CreateCPResp& operator=(CreateCPResp&&) = default;

  CreateCPResp& operator=(const CreateCPResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
   ::nebula::storage::cpp2::ResponseCommon result;
 private:
  ::std::vector< ::nebula::cpp2::CheckpointInfo> info;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool info;
  } __isset = {};
  bool operator==(const CreateCPResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CreateCPResp& __x, const CreateCPResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CreateCPResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const CreateCPResp& __x, const CreateCPResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CreateCPResp& __x, const CreateCPResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CreateCPResp& __x, const CreateCPResp& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> result_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> result_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->result)};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> result_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> result_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->result)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::nebula::cpp2::CheckpointInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> info_ref() const& {
    return {this->info, __isset.info};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::CheckpointInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> info_ref() const&& {
    return {std::move(this->info), __isset.info};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::CheckpointInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> info_ref() & {
    return {this->info, __isset.info};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::CheckpointInfo>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> info_ref() && {
    return {std::move(this->info), __isset.info};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::storage::cpp2::ResponseCommon& get_result() const&;
   ::nebula::storage::cpp2::ResponseCommon get_result() &&;

  template <typename T_CreateCPResp_result_struct_setter =  ::nebula::storage::cpp2::ResponseCommon>
   ::nebula::storage::cpp2::ResponseCommon& set_result(T_CreateCPResp_result_struct_setter&& result_) {
    result = std::forward<T_CreateCPResp_result_struct_setter>(result_);
    return result;
  }
  const ::std::vector< ::nebula::cpp2::CheckpointInfo>& get_info() const&;
  ::std::vector< ::nebula::cpp2::CheckpointInfo> get_info() &&;

  template <typename T_CreateCPResp_info_struct_setter = ::std::vector< ::nebula::cpp2::CheckpointInfo>>
  ::std::vector< ::nebula::cpp2::CheckpointInfo>& set_info(T_CreateCPResp_info_struct_setter&& info_) {
    info = std::forward<T_CreateCPResp_info_struct_setter>(info_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.info = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return info;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CreateCPResp >;
  friend void swap(CreateCPResp& a, CreateCPResp& b);
};

template <class Protocol_>
uint32_t CreateCPResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class ListClusterInfoResp final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListClusterInfoResp;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListClusterInfoResp() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListClusterInfoResp(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::ResponseCommon result__arg,  ::nebula::cpp2::DirInfo dir__arg);

  ListClusterInfoResp(ListClusterInfoResp&&) = default;

  ListClusterInfoResp(const ListClusterInfoResp&) = default;


  ListClusterInfoResp& operator=(ListClusterInfoResp&&) = default;

  ListClusterInfoResp& operator=(const ListClusterInfoResp&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
   ::nebula::storage::cpp2::ResponseCommon result;
 private:
   ::nebula::cpp2::DirInfo dir;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool dir;
  } __isset = {};
  bool operator==(const ListClusterInfoResp& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListClusterInfoResp& __x, const ListClusterInfoResp& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListClusterInfoResp& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListClusterInfoResp& __x, const ListClusterInfoResp& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListClusterInfoResp& __x, const ListClusterInfoResp& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListClusterInfoResp& __x, const ListClusterInfoResp& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> result_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> result_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->result)};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> result_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->result};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::ResponseCommon>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> result_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->result)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::DirInfo>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> dir_ref() const& {
    return {this->dir, __isset.dir};
  }

  template <typename..., typename T =  ::nebula::cpp2::DirInfo>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> dir_ref() const&& {
    return {std::move(this->dir), __isset.dir};
  }

  template <typename..., typename T =  ::nebula::cpp2::DirInfo>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> dir_ref() & {
    return {this->dir, __isset.dir};
  }

  template <typename..., typename T =  ::nebula::cpp2::DirInfo>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> dir_ref() && {
    return {std::move(this->dir), __isset.dir};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::nebula::storage::cpp2::ResponseCommon& get_result() const&;
   ::nebula::storage::cpp2::ResponseCommon get_result() &&;

  template <typename T_ListClusterInfoResp_result_struct_setter =  ::nebula::storage::cpp2::ResponseCommon>
   ::nebula::storage::cpp2::ResponseCommon& set_result(T_ListClusterInfoResp_result_struct_setter&& result_) {
    result = std::forward<T_ListClusterInfoResp_result_struct_setter>(result_);
    return result;
  }
  const  ::nebula::cpp2::DirInfo& get_dir() const&;
   ::nebula::cpp2::DirInfo get_dir() &&;

  template <typename T_ListClusterInfoResp_dir_struct_setter =  ::nebula::cpp2::DirInfo>
   ::nebula::cpp2::DirInfo& set_dir(T_ListClusterInfoResp_dir_struct_setter&& dir_) {
    dir = std::forward<T_ListClusterInfoResp_dir_struct_setter>(dir_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.dir = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return dir;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListClusterInfoResp >;
  friend void swap(ListClusterInfoResp& a, ListClusterInfoResp& b);
};

template <class Protocol_>
uint32_t ListClusterInfoResp::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class ListClusterInfoReq final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ListClusterInfoReq;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ListClusterInfoReq() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ListClusterInfoReq(apache::thrift::FragileConstructor);

  ListClusterInfoReq(ListClusterInfoReq&&) = default;

  ListClusterInfoReq(const ListClusterInfoReq&) = default;


  ListClusterInfoReq& operator=(ListClusterInfoReq&&) = default;

  ListClusterInfoReq& operator=(const ListClusterInfoReq&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
  bool operator==(const ListClusterInfoReq& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ListClusterInfoReq& __x, const ListClusterInfoReq& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ListClusterInfoReq& rhs) const;
#ifndef SWIG
  friend bool operator>(const ListClusterInfoReq& __x, const ListClusterInfoReq& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ListClusterInfoReq& __x, const ListClusterInfoReq& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ListClusterInfoReq& __x, const ListClusterInfoReq& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ListClusterInfoReq >;
  friend void swap(ListClusterInfoReq& a, ListClusterInfoReq& b);
};

template <class Protocol_>
uint32_t ListClusterInfoReq::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class AddAdminTaskRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AddAdminTaskRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  AddAdminTaskRequest() :
      cmd( ::nebula::meta::cpp2::AdminCmd::COMPACT),
      job_id(0),
      task_id(0),
      concurrency(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AddAdminTaskRequest(apache::thrift::FragileConstructor,  ::nebula::meta::cpp2::AdminCmd cmd__arg, int32_t job_id__arg, int32_t task_id__arg,  ::nebula::storage::cpp2::TaskPara para__arg, int32_t concurrency__arg);

  AddAdminTaskRequest(AddAdminTaskRequest&&) = default;

  AddAdminTaskRequest(const AddAdminTaskRequest&) = default;


  AddAdminTaskRequest& operator=(AddAdminTaskRequest&&) = default;

  AddAdminTaskRequest& operator=(const AddAdminTaskRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::meta::cpp2::AdminCmd cmd;
 private:
  int32_t job_id;
 private:
  int32_t task_id;
 private:
   ::nebula::storage::cpp2::TaskPara para;
 private:
  int32_t concurrency;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool cmd;
    bool job_id;
    bool task_id;
    bool para;
    bool concurrency;
  } __isset = {};
  bool operator==(const AddAdminTaskRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AddAdminTaskRequest& __x, const AddAdminTaskRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AddAdminTaskRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const AddAdminTaskRequest& __x, const AddAdminTaskRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AddAdminTaskRequest& __x, const AddAdminTaskRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AddAdminTaskRequest& __x, const AddAdminTaskRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::meta::cpp2::AdminCmd>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> cmd_ref() const& {
    return {this->cmd, __isset.cmd};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::AdminCmd>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> cmd_ref() const&& {
    return {std::move(this->cmd), __isset.cmd};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::AdminCmd>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> cmd_ref() & {
    return {this->cmd, __isset.cmd};
  }

  template <typename..., typename T =  ::nebula::meta::cpp2::AdminCmd>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> cmd_ref() && {
    return {std::move(this->cmd), __isset.cmd};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> job_id_ref() const& {
    return {this->job_id, __isset.job_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> job_id_ref() const&& {
    return {std::move(this->job_id), __isset.job_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> job_id_ref() & {
    return {this->job_id, __isset.job_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> job_id_ref() && {
    return {std::move(this->job_id), __isset.job_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> task_id_ref() const& {
    return {this->task_id, __isset.task_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> task_id_ref() const&& {
    return {std::move(this->task_id), __isset.task_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> task_id_ref() & {
    return {this->task_id, __isset.task_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> task_id_ref() && {
    return {std::move(this->task_id), __isset.task_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::TaskPara>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> para_ref() const& {
    return {this->para, __isset.para};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::TaskPara>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> para_ref() const&& {
    return {std::move(this->para), __isset.para};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::TaskPara>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> para_ref() & {
    return {this->para, __isset.para};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::TaskPara>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> para_ref() && {
    return {std::move(this->para), __isset.para};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> concurrency_ref() const& {
    return {this->concurrency, __isset.concurrency};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> concurrency_ref() const&& {
    return {std::move(this->concurrency), __isset.concurrency};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> concurrency_ref() & {
    return {this->concurrency, __isset.concurrency};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> concurrency_ref() && {
    return {std::move(this->concurrency), __isset.concurrency};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::meta::cpp2::AdminCmd get_cmd() const {
    return cmd;
  }

   ::nebula::meta::cpp2::AdminCmd& set_cmd( ::nebula::meta::cpp2::AdminCmd cmd_) {
    cmd = cmd_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.cmd = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return cmd;
  }

  int32_t get_job_id() const {
    return job_id;
  }

  int32_t& set_job_id(int32_t job_id_) {
    job_id = job_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.job_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return job_id;
  }

  int32_t get_task_id() const {
    return task_id;
  }

  int32_t& set_task_id(int32_t task_id_) {
    task_id = task_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.task_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return task_id;
  }
  const  ::nebula::storage::cpp2::TaskPara& get_para() const&;
   ::nebula::storage::cpp2::TaskPara get_para() &&;

  template <typename T_AddAdminTaskRequest_para_struct_setter =  ::nebula::storage::cpp2::TaskPara>
   ::nebula::storage::cpp2::TaskPara& set_para(T_AddAdminTaskRequest_para_struct_setter&& para_) {
    para = std::forward<T_AddAdminTaskRequest_para_struct_setter>(para_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.para = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return para;
  }

  const int32_t* get_concurrency() const& {
    return concurrency_ref() ? std::addressof(concurrency) : nullptr;
  }

  int32_t* get_concurrency() & {
    return concurrency_ref() ? std::addressof(concurrency) : nullptr;
  }
  int32_t* get_concurrency() && = delete;

  int32_t& set_concurrency(int32_t concurrency_) {
    concurrency = concurrency_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.concurrency = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return concurrency;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AddAdminTaskRequest >;
  friend void swap(AddAdminTaskRequest& a, AddAdminTaskRequest& b);
};

template <class Protocol_>
uint32_t AddAdminTaskRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class StopAdminTaskRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = StopAdminTaskRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  StopAdminTaskRequest() :
      job_id(0),
      task_id(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  StopAdminTaskRequest(apache::thrift::FragileConstructor, int32_t job_id__arg, int32_t task_id__arg);

  StopAdminTaskRequest(StopAdminTaskRequest&&) = default;

  StopAdminTaskRequest(const StopAdminTaskRequest&) = default;


  StopAdminTaskRequest& operator=(StopAdminTaskRequest&&) = default;

  StopAdminTaskRequest& operator=(const StopAdminTaskRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
  int32_t job_id;
 private:
  int32_t task_id;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool job_id;
    bool task_id;
  } __isset = {};
  bool operator==(const StopAdminTaskRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const StopAdminTaskRequest& __x, const StopAdminTaskRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const StopAdminTaskRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const StopAdminTaskRequest& __x, const StopAdminTaskRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const StopAdminTaskRequest& __x, const StopAdminTaskRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const StopAdminTaskRequest& __x, const StopAdminTaskRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> job_id_ref() const& {
    return {this->job_id, __isset.job_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> job_id_ref() const&& {
    return {std::move(this->job_id), __isset.job_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> job_id_ref() & {
    return {this->job_id, __isset.job_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> job_id_ref() && {
    return {std::move(this->job_id), __isset.job_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> task_id_ref() const& {
    return {this->task_id, __isset.task_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> task_id_ref() const&& {
    return {std::move(this->task_id), __isset.task_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> task_id_ref() & {
    return {this->task_id, __isset.task_id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> task_id_ref() && {
    return {std::move(this->task_id), __isset.task_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  int32_t get_job_id() const {
    return job_id;
  }

  int32_t& set_job_id(int32_t job_id_) {
    job_id = job_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.job_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return job_id;
  }

  int32_t get_task_id() const {
    return task_id;
  }

  int32_t& set_task_id(int32_t task_id_) {
    task_id = task_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.task_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return task_id;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< StopAdminTaskRequest >;
  friend void swap(StopAdminTaskRequest& a, StopAdminTaskRequest& b);
};

template <class Protocol_>
uint32_t StopAdminTaskRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class ChainAddEdgesRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ChainAddEdgesRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ChainAddEdgesRequest();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ChainAddEdgesRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>> parts__arg, ::std::vector<::std::string> prop_names__arg, bool if_not_exists__arg, int64_t term__arg, int64_t edge_version__arg);

  ChainAddEdgesRequest(ChainAddEdgesRequest&&) = default;

  ChainAddEdgesRequest(const ChainAddEdgesRequest&) = default;


  ChainAddEdgesRequest& operator=(ChainAddEdgesRequest&&) = default;

  ChainAddEdgesRequest& operator=(const ChainAddEdgesRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~ChainAddEdgesRequest();

 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>> parts;
 private:
  ::std::vector<::std::string> prop_names;
 private:
  bool if_not_exists;
 private:
  int64_t term;
 private:
  int64_t edge_version;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool parts;
    bool prop_names;
    bool if_not_exists;
    bool term;
    bool edge_version;
  } __isset = {};
  bool operator==(const ChainAddEdgesRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ChainAddEdgesRequest& __x, const ChainAddEdgesRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ChainAddEdgesRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const ChainAddEdgesRequest& __x, const ChainAddEdgesRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ChainAddEdgesRequest& __x, const ChainAddEdgesRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ChainAddEdgesRequest& __x, const ChainAddEdgesRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> parts_ref() const& {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> parts_ref() const&& {
    return {std::move(this->parts), __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> parts_ref() & {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> parts_ref() && {
    return {std::move(this->parts), __isset.parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> prop_names_ref() const& {
    return {this->prop_names, __isset.prop_names};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> prop_names_ref() const&& {
    return {std::move(this->prop_names), __isset.prop_names};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> prop_names_ref() & {
    return {this->prop_names, __isset.prop_names};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> prop_names_ref() && {
    return {std::move(this->prop_names), __isset.prop_names};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> if_not_exists_ref() const& {
    return {this->if_not_exists, __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> if_not_exists_ref() const&& {
    return {std::move(this->if_not_exists), __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> if_not_exists_ref() & {
    return {this->if_not_exists, __isset.if_not_exists};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> if_not_exists_ref() && {
    return {std::move(this->if_not_exists), __isset.if_not_exists};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> term_ref() const& {
    return {this->term, __isset.term};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> term_ref() const&& {
    return {std::move(this->term), __isset.term};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> term_ref() & {
    return {this->term, __isset.term};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> term_ref() && {
    return {std::move(this->term), __isset.term};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> edge_version_ref() const& {
    return {this->edge_version, __isset.edge_version};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> edge_version_ref() const&& {
    return {std::move(this->edge_version), __isset.edge_version};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> edge_version_ref() & {
    return {this->edge_version, __isset.edge_version};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> edge_version_ref() && {
    return {std::move(this->edge_version), __isset.edge_version};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>& get_parts() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>> get_parts() &&;

  template <typename T_ChainAddEdgesRequest_parts_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>>
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::NewEdge>>& set_parts(T_ChainAddEdgesRequest_parts_struct_setter&& parts_) {
    parts = std::forward<T_ChainAddEdgesRequest_parts_struct_setter>(parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return parts;
  }
  const ::std::vector<::std::string>& get_prop_names() const&;
  ::std::vector<::std::string> get_prop_names() &&;

  template <typename T_ChainAddEdgesRequest_prop_names_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_prop_names(T_ChainAddEdgesRequest_prop_names_struct_setter&& prop_names_) {
    prop_names = std::forward<T_ChainAddEdgesRequest_prop_names_struct_setter>(prop_names_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.prop_names = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return prop_names;
  }

  bool get_if_not_exists() const {
    return if_not_exists;
  }

  bool& set_if_not_exists(bool if_not_exists_) {
    if_not_exists = if_not_exists_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.if_not_exists = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return if_not_exists;
  }

  int64_t get_term() const {
    return term;
  }

  int64_t& set_term(int64_t term_) {
    term = term_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.term = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return term;
  }

  const int64_t* get_edge_version() const& {
    return edge_version_ref() ? std::addressof(edge_version) : nullptr;
  }

  int64_t* get_edge_version() & {
    return edge_version_ref() ? std::addressof(edge_version) : nullptr;
  }
  int64_t* get_edge_version() && = delete;

  int64_t& set_edge_version(int64_t edge_version_) {
    edge_version = edge_version_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.edge_version = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return edge_version;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ChainAddEdgesRequest >;
  friend void swap(ChainAddEdgesRequest& a, ChainAddEdgesRequest& b);
};

template <class Protocol_>
uint32_t ChainAddEdgesRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class ChainUpdateEdgeRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ChainUpdateEdgeRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ChainUpdateEdgeRequest();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ChainUpdateEdgeRequest(apache::thrift::FragileConstructor,  ::nebula::storage::cpp2::UpdateEdgeRequest update_edge_request__arg, int64_t term__arg, int64_t edge_version__arg,  ::nebula::cpp2::GraphSpaceID space_id__arg, ::std::vector< ::nebula::cpp2::PartitionID> parts__arg);

  ChainUpdateEdgeRequest(ChainUpdateEdgeRequest&&) = default;

  ChainUpdateEdgeRequest(const ChainUpdateEdgeRequest&) = default;


  ChainUpdateEdgeRequest& operator=(ChainUpdateEdgeRequest&&) = default;

  ChainUpdateEdgeRequest& operator=(const ChainUpdateEdgeRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~ChainUpdateEdgeRequest();

 private:
   ::nebula::storage::cpp2::UpdateEdgeRequest update_edge_request;
 private:
  int64_t term;
 private:
  int64_t edge_version;
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 public:
  ::std::vector< ::nebula::cpp2::PartitionID> parts;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool update_edge_request;
    bool term;
    bool edge_version;
    bool space_id;
  } __isset = {};
  bool operator==(const ChainUpdateEdgeRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ChainUpdateEdgeRequest& __x, const ChainUpdateEdgeRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ChainUpdateEdgeRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const ChainUpdateEdgeRequest& __x, const ChainUpdateEdgeRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ChainUpdateEdgeRequest& __x, const ChainUpdateEdgeRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ChainUpdateEdgeRequest& __x, const ChainUpdateEdgeRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::storage::cpp2::UpdateEdgeRequest>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> update_edge_request_ref() const& {
    return {this->update_edge_request, __isset.update_edge_request};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::UpdateEdgeRequest>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> update_edge_request_ref() const&& {
    return {std::move(this->update_edge_request), __isset.update_edge_request};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::UpdateEdgeRequest>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> update_edge_request_ref() & {
    return {this->update_edge_request, __isset.update_edge_request};
  }

  template <typename..., typename T =  ::nebula::storage::cpp2::UpdateEdgeRequest>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> update_edge_request_ref() && {
    return {std::move(this->update_edge_request), __isset.update_edge_request};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> term_ref() const& {
    return {this->term, __isset.term};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> term_ref() const&& {
    return {std::move(this->term), __isset.term};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> term_ref() & {
    return {this->term, __isset.term};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> term_ref() && {
    return {std::move(this->term), __isset.term};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> edge_version_ref() const& {
    return {this->edge_version, __isset.edge_version};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> edge_version_ref() const&& {
    return {std::move(this->edge_version), __isset.edge_version};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> edge_version_ref() & {
    return {this->edge_version, __isset.edge_version};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> edge_version_ref() && {
    return {std::move(this->edge_version), __isset.edge_version};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> parts_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->parts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> parts_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->parts)};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> parts_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->parts};
  }

  template <typename..., typename T = ::std::vector< ::nebula::cpp2::PartitionID>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> parts_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->parts)};
  }
  const  ::nebula::storage::cpp2::UpdateEdgeRequest& get_update_edge_request() const&;
   ::nebula::storage::cpp2::UpdateEdgeRequest get_update_edge_request() &&;

  template <typename T_ChainUpdateEdgeRequest_update_edge_request_struct_setter =  ::nebula::storage::cpp2::UpdateEdgeRequest>
   ::nebula::storage::cpp2::UpdateEdgeRequest& set_update_edge_request(T_ChainUpdateEdgeRequest_update_edge_request_struct_setter&& update_edge_request_) {
    update_edge_request = std::forward<T_ChainUpdateEdgeRequest_update_edge_request_struct_setter>(update_edge_request_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.update_edge_request = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return update_edge_request;
  }

  int64_t get_term() const {
    return term;
  }

  int64_t& set_term(int64_t term_) {
    term = term_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.term = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return term;
  }

  const int64_t* get_edge_version() const& {
    return edge_version_ref() ? std::addressof(edge_version) : nullptr;
  }

  int64_t* get_edge_version() & {
    return edge_version_ref() ? std::addressof(edge_version) : nullptr;
  }
  int64_t* get_edge_version() && = delete;

  int64_t& set_edge_version(int64_t edge_version_) {
    edge_version = edge_version_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.edge_version = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return edge_version;
  }

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const ::std::vector< ::nebula::cpp2::PartitionID>& get_parts() const&;
  ::std::vector< ::nebula::cpp2::PartitionID> get_parts() &&;

  template <typename T_ChainUpdateEdgeRequest_parts_struct_setter = ::std::vector< ::nebula::cpp2::PartitionID>>
  ::std::vector< ::nebula::cpp2::PartitionID>& set_parts(T_ChainUpdateEdgeRequest_parts_struct_setter&& parts_) {
    parts = std::forward<T_ChainUpdateEdgeRequest_parts_struct_setter>(parts_);
    return parts;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ChainUpdateEdgeRequest >;
  friend void swap(ChainUpdateEdgeRequest& a, ChainUpdateEdgeRequest& b);
};

template <class Protocol_>
uint32_t ChainUpdateEdgeRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
namespace nebula { namespace storage { namespace cpp2 {
class ChainDeleteEdgesRequest final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ChainDeleteEdgesRequest;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ChainDeleteEdgesRequest() :
      space_id(0),
      term(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ChainDeleteEdgesRequest(apache::thrift::FragileConstructor,  ::nebula::cpp2::GraphSpaceID space_id__arg, std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>> parts__arg, ::std::string txn_id__arg, int64_t term__arg);

  ChainDeleteEdgesRequest(ChainDeleteEdgesRequest&&) = default;

  ChainDeleteEdgesRequest(const ChainDeleteEdgesRequest&) = default;


  ChainDeleteEdgesRequest& operator=(ChainDeleteEdgesRequest&&) = default;

  ChainDeleteEdgesRequest& operator=(const ChainDeleteEdgesRequest&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 private:
   ::nebula::cpp2::GraphSpaceID space_id;
 private:
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>> parts;
 private:
  ::std::string txn_id;
 private:
  int64_t term;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool space_id;
    bool parts;
    bool txn_id;
    bool term;
  } __isset = {};
  bool operator==(const ChainDeleteEdgesRequest& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ChainDeleteEdgesRequest& __x, const ChainDeleteEdgesRequest& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ChainDeleteEdgesRequest& rhs) const;
#ifndef SWIG
  friend bool operator>(const ChainDeleteEdgesRequest& __x, const ChainDeleteEdgesRequest& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ChainDeleteEdgesRequest& __x, const ChainDeleteEdgesRequest& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ChainDeleteEdgesRequest& __x, const ChainDeleteEdgesRequest& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> space_id_ref() const& {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> space_id_ref() const&& {
    return {std::move(this->space_id), __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> space_id_ref() & {
    return {this->space_id, __isset.space_id};
  }

  template <typename..., typename T =  ::nebula::cpp2::GraphSpaceID>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> space_id_ref() && {
    return {std::move(this->space_id), __isset.space_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> parts_ref() const& {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> parts_ref() const&& {
    return {std::move(this->parts), __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> parts_ref() & {
    return {this->parts, __isset.parts};
  }

  template <typename..., typename T = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> parts_ref() && {
    return {std::move(this->parts), __isset.parts};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> txn_id_ref() const& {
    return {this->txn_id, __isset.txn_id};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> txn_id_ref() const&& {
    return {std::move(this->txn_id), __isset.txn_id};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> txn_id_ref() & {
    return {this->txn_id, __isset.txn_id};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> txn_id_ref() && {
    return {std::move(this->txn_id), __isset.txn_id};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> term_ref() const& {
    return {this->term, __isset.term};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> term_ref() const&& {
    return {std::move(this->term), __isset.term};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> term_ref() & {
    return {this->term, __isset.term};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> term_ref() && {
    return {std::move(this->term), __isset.term};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

   ::nebula::cpp2::GraphSpaceID get_space_id() const {
    return space_id;
  }

   ::nebula::cpp2::GraphSpaceID& set_space_id( ::nebula::cpp2::GraphSpaceID space_id_) {
    space_id = space_id_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.space_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return space_id;
  }
  const std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>& get_parts() const&;
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>> get_parts() &&;

  template <typename T_ChainDeleteEdgesRequest_parts_struct_setter = std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>>
  std::unordered_map< ::nebula::cpp2::PartitionID, ::std::vector< ::nebula::storage::cpp2::EdgeKey>>& set_parts(T_ChainDeleteEdgesRequest_parts_struct_setter&& parts_) {
    parts = std::forward<T_ChainDeleteEdgesRequest_parts_struct_setter>(parts_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.parts = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return parts;
  }

  const ::std::string& get_txn_id() const& {
    return txn_id;
  }

  ::std::string get_txn_id() && {
    return std::move(txn_id);
  }

  template <typename T_ChainDeleteEdgesRequest_txn_id_struct_setter = ::std::string>
  ::std::string& set_txn_id(T_ChainDeleteEdgesRequest_txn_id_struct_setter&& txn_id_) {
    txn_id = std::forward<T_ChainDeleteEdgesRequest_txn_id_struct_setter>(txn_id_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.txn_id = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return txn_id;
  }

  int64_t get_term() const {
    return term;
  }

  int64_t& set_term(int64_t term_) {
    term = term_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.term = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return term;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ChainDeleteEdgesRequest >;
  friend void swap(ChainDeleteEdgesRequest& a, ChainDeleteEdgesRequest& b);
};

template <class Protocol_>
uint32_t ChainDeleteEdgesRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // nebula::storage::cpp2
